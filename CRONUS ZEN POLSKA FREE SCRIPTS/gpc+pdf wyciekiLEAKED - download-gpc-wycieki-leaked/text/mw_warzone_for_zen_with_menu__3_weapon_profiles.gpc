// GPC Online Library
// mw_warzone_for_zen_with_menu_+_3_weapon_profiles.gpc

// GPC Online Library
// modern_warfare_for_zen_with_menu_+_3_weapon_profiles.gpc

   
/* 
BIG SHOUT OUT TO NoozBar , Batts , Sweet Evil , Swizzy, ItzSnackz & many more who work hard at making us these scripts!!

I AM NOT TAKING OWNERSHIP OF THIS SCRIPT, all I have done is incorperated sections of other scripts and put them into this one! 

I hope you enjoy it as well as I do. I have been using Sweet Evil's Aim Assist for a long time and I personally find it to work great for me
hence why I added it to this script. Please let me know if you have any issuee or tweaks I can add in to this amazing script. 

This script is perfect for Modern Warfare - Warzone . Are you ready to dominate your opponent? 

I will be adding more features to this script in due course! ENJOY!

Added Features - Autoping + Autoplates 

You can now ping an enemy while aiming down sight by double tapping UP. 
You can now put plates on by holding triangle to place one plate will automatically hold triangle until all plates are full, cancel by firing, ads or tapping reload

 # # # # # # # # # # # # # # # #
 # /\/\/\/\/\/\/\/\/\/\/\/\/\/ #
 # /\/\/\/\ Edited By /\/\/\/\ #
 # /\/\/\ Taylordrift21 \/\/\/ #  
 # /\/\/\/\/\/\/\/\/\/\/\/\/\/ #  
 # # # # # # # # # # # # # # # #
 
    You can easily change the button combinations
    3 Profiles with:
            Antirecoil with editable values and toggle for each profile (save all)
                    Antirecoil Start
                    Antirecoil End
                    Antirecoil Time
                    Antirecoil Horizontal
            RapidFire with editable values and toggle for each profile (save all) OR BurstFire with editable values and toggle for each profile (save all)(can't be enable at the same time)
            AIM Assist with editable values and toggle for each profile (values not saved)  Strafe Shot with editable values and toggle for each profile (values not saved)        
            AutoRun with one toggle for the entier script (not saved)   Swap Trigger/bumper with one toggle for the entier script (not saved) Inverted Y with one toggle for the entier script (not saved)     
    Enter in Mod Menu
        - Hold L2/LT and tap OPTIONS/MENU 
        
        Navigate between every mods and toogles
            - Tap LEFT or RIGHT on the D-PAD
            
        Enable or disable the displayed mod
            - Tap UP to turn ON
            - Tap DOWN to turn OFF
            
        Switch Profiles
            - Tap TRIANGLE/Y
            
    Enter in Mod Edit
            - Tap CROSS/A to enter ModEdit on the current/displayed mod
            - Tap CIRCLE/B to exit ModEdit
            
        Navigate between every values available for this mod
            - Tap LEFT or RIGHT 
            
        Edit values
            - Hold L2/LT   + Tap RIGHT for +1
                           + Tap LEFT for -1
                           + Tap UP for +10
                           + Tap DOWN for -10
                           
    Save and exit ModMenu or ModEdit        
        - Hold L2/LT and tap OPTIONS/MENU to close ModEdit and ModMenu and save all
        
    Speed toggles (outside Mod Menu/Edit)
        - Hold L2/LT and hold 300ms UP, DOWN, RIGHT or LEFT
    
    Switch profiles (not in ModMenu)
        - Tap TRIANGLE to switch profile 1 and 2
        - Double tap to switch to profile 3 (tap again to go back to the previous profile)
        
    Kill Switch (disable everything)
        - Hold L2/LT and tap SHARE/VIEW   
*/

define Sampling_Time = 10;//10*; //10 //8 //16
define Aim_Boost = 8;//7;* //8 //6
define Aim_Correction = 6//11//12;* //5//6//11 //3
define Aim_Perfection_Limit = 30;//30; //20 //25* //26
//operating aim perfection interval
define POS_Aim_Limit = 70;//70; //75
define NEG_Aim_Limit = -70;//-70; //75
define POS_Micro_MVT_Limit = 25;
define NEG_Micro_MVT_Limit = -25;
//Button Layout
define PS = 0;
define SHARE = 1;
define OPTIONS = 2;
define R1 = 3;
define R2 = 4;
define R3 = 5;
define L1 = 6;
define L2 = 7;
define L3 = 8;
define RX = 9;
define RY = 10;
define LX = 11;
define LY = 12;
define UP = 13;
define DOWN = 14;
define LEFT = 15;
define RIGHT = 16;
define TRIANGLE = 17;
define CIRCLE = 18;
define CROSS = 19;
define SQUARE = 20
define TOUCHPAD = 27;
// Sweet Evil's Aim Assist 
int X_Last_Value     = 0;
int Y_Last_Value     = 0;
int X_Current_Value  = 0;
int Y_Current_Value  = 0;
int Sampling_Done = FALSE;
int spiroide_pulse = 0;
int fine_pulse = 0;
int Joystick_calibration = FALSE;
int RX_Axis_Joystick_calibrate = 0; 
int RY_Axis_Joystick_calibrate = 0;
//Custom Sensitivity
int GEN_SENS = 100;
int ADS_SENS = 100;
int FIRE_SENS = 100;
int ADS_FIRE_SENS = 100;
int GRENADE_SENS = 100;
int CS = TRUE;
int USE_SENS;
/*NOTE:
Default = 100
Ranges from 0 to 327*/
int easy_plate=TRUE; //[TRUE = on / FALSE = off] holding triangle to place one plate will automatically hold triangle until all plates are full, cancel by firing, ads or tapping reload
int autoping=TRUE;	 //[TRUE = on / FALSE = off] while holding ADS if you FIRE you will automatically place a danger marker			
// Text to display 
   const string TITLE = "MW DOUBLE"; // 11 char max
   const string OFF = "OFF"; 
   const string ON = "ON"; 
   const string SAVE= "SAVED";
   const string PROFILE_1 = "Profile 1": // or primary weapon
   const string PROFILE_2 = "Profile 2": // or secondary weapon
   const string PROFILE_3 = "Profile 3": // or handgun
// Mod Name
    const string ANTIRECOIL = "AntiRecoil*";         // modName_idx = 0
    const string RAPIDFIRE = "RapidFire*";           // modName_idx = 1
    const string BURSTFIRE = "BurstFire'";           // modName_idx = 2
    const string AIMASSIST = "AIM Assist'"           // modName_idx = 3         
    const string STRAFE_SHOT = "StrafeShot'";        // modName_idx = 4
    const string AUTORUN = "AutoRun";
    const string SWAP = "Swap Tr/Bu";
    const string INVERTED = "Inverted Y";   // modName_idx = 7 
// Index to find Mod Name string - switchable in game with left/right in ModMenu 
    int modName_idx; 
// modName # of the last Mod Name string - Used for cycle modName_idx
    define LAST_MODNAME_STRING = 7;
// # of the last modName_idx that has a value that can be edited
    define LAST_EDITABLE_STRING = 4;
// Value Name
    // modName_idx = 0 = ANTIRECOIL string
    const string ANTIRECOIL_START = "AR Start";         // valName_idx = 0  
    const string ANTIRECOIL_END = "AR End";                // valName_idx = 1
    const string ANTIRECOIL_TIME = "AR Time";            // valName_idx = 2
    const string ANTIRECOIL_HORIZONTAL = "AR Horiz";    // valName_idx = 3
    // modName_idx = 1
    const string RATE_OF_FIRE = "Rounds/sec";            // valName_idx = 4
    // modName_idx = 
    const string BURSTFIRE_HOLD = "BF Hold";            // valName_idx = 5
    const string BURSTFIRE_RELEASE = "BF Release";        // valName_idx = 6
    // modName_idx = 3 = AA string
    const string AIMASSIST_SIZE = "AA Size";            // valName_idx = 7
    const string AIMASSIST_TIME = "AA Time";            // valName_idx = 8
    // modName_idx = 4
    const string STRAFESHOT_TIME = "S.Shot Time";        // valName_idx = 9 
// Index to find Value Name string - switchable in game with left/right in ModEdit 
    int valName_idx;
    define AMOUNT_OF_VALNAME_IDX = 9;
// /!\ DO NOT CHANGE RATE OF FIRE VALUE IN THE ARRAY
// Constant bytes - VALUES array (mods with value and toggle) - VALUES[line][column]
    const byte VALUES[][] = {         
/* Profile 1 */    {    20,                31,               22,                   0,                  13      },        // profile_idx = 0 
/* Profile 2 */    {    20,                31,               22,                   0,                  13      },         // profile_idx = 1 
/* Profile 3 */ {    12,                32,               22,                   0,                  1       }};        // profile_idx = 2 
/*             antirecoil_start[]  antirecoil_end[]  antirecoil_time[]  antirecoil_horizontal[]  rate_of_fire[]           
                 AntiRecoil          AntiRecoil       AntiRecoil            AntiRecoil          RapidFire  
val_col_idx          = 0               = 1               = 2                  = 3                 = 4       */
// VALUES array column number - Buffer to add or substract edited value to corresponding value in VALUES array
    int antirecoil_start[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
    int antirecoil_end[3];
    int antirecoil_time[3];
    int antirecoil_horizontal[3];
    int rate_of_fire[3];
/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
    int profile_idx; 
// Index to find VALUES array column - Follow valName_idx to edit the right value (that is in VALUES array or not like Strafe_t value)
    int val_col_idx;
// # of the last column - used in display_edit() function 
    define LAST_EDITABLE_COLUMN = 4;
// Multi toggles
    int toggle_antirecoil[3]; // for 3 Profiles: profile_idx = 0, 1 and 2
    int toggle_rapidfire[3];  
    int toggle_burstfire[3];
    int toggle_aimassist[3];
    int toggle_strafeShot[3]; 
// Amount of profiles - Used for switch profiles cycle
    define AMOUNT_OF_PROFILES = 3;  
// Amount of multi toggle - Used for display profiles
    define AMOUNT_OF_MULTI_TOGGLE = 5;
// Mods (with values) that activates for all profiles at the same time (if toggled ON)
// BurstFire
    int burstfire_hold;
    int burstfire_release;
// AIM Assist
    int aimassist_size;
    int aimassist_time;
// Strafe Shot
    int strafeShot_time;
// Toggles
    int autorun_on;
    int swap_on;
    int inverted_on;
    
// Constant bytes - Convert numbers array - ASCII_NUM[column number]
    const byte ASCII_NUM[] = 
//      0  1  2  3  4  5  6  7  8  9  (column numbers)
      {48,49,50,51,52,53,54,55,56,57};
// Variables for function number_to_string() 
    int i;
    int c,c_val;
 
data(
//    Blue      Pink    SkyBlue    Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//   Yellow    White      Red       OFF        
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
// Refresh OLED
    int display_title = TRUE;
    int display_new; 
    int display_black;
// ModMenu / ModEdit / KillSwitch
    int ModMenu;    
    int ModEdit;
    int KillSwitch;
// Anti Recoil values                                                 
    int i_val;                                                        
    int i_pnt;                                                        
    int i_num;                                                        
    int i_cnt;                                                        
    int v,ar_y;
    int ar_x;
    int x_ref;
    int invert; // -1 for inverted, 1 for standard
// RapidFire / BurstFire
    int hold_time;                                                    
    int rest_time;
    int led_on;
    int led_off;
// Counter
    int count_black; // for screen saver
// Double Tap
    int double_tap;
// Profiles
    int profile_1or2; // Profile 1 and 2
    int profile_3;   // Profile 3
// Double tap 
int q;											
int double__tap[30];
init {
while(q < 30) 
{double__tap[q] = -1;       
q++;}}
 
init{
// Profile 1
    // Toggles                                                  // Values
    toggle_antirecoil[0] = get_pvar(SPVAR_1, 0, 1, 0 );         antirecoil_start[0]      = get_pvar(SPVAR_6, -99, 99, 0);         
    toggle_rapidfire[0]  = get_pvar(SPVAR_2, 0, 1, 0 );         antirecoil_end[0]        = get_pvar(SPVAR_7, -99, 99, 0);         
    toggle_burstfire[0]  = get_pvar(SPVAR_3, 0, 1, 0 );         antirecoil_time[0]       = get_pvar(SPVAR_8, -99, 99, 0);      
    toggle_aimassist[0]  = get_pvar(SPVAR_4, 0, 1, 0 );         antirecoil_horizontal[0] = get_pvar(SPVAR_9, -99, 99, 0);
    toggle_strafeShot[0] = get_pvar(SPVAR_5, 0, 1, 0 );         rate_of_fire[0]          = get_pvar(SPVAR_10,  0, 25, 0);
// Profile 2
    // Toggles                                                  // Values
    toggle_antirecoil[1] = get_pvar(SPVAR_11, 0, 1, 0 );        antirecoil_start[1]      = get_pvar(SPVAR_16, -99, 99, 0);         
    toggle_rapidfire[1]  = get_pvar(SPVAR_12, 0, 1, 0 );        antirecoil_end[1]        = get_pvar(SPVAR_17, -99, 99, 0);         
    toggle_burstfire[1]  = get_pvar(SPVAR_13, 0, 1, 0 );        antirecoil_time[1]       = get_pvar(SPVAR_18, -99, 99, 0);        
    toggle_aimassist[1]  = get_pvar(SPVAR_14, 0, 1, 0 );        antirecoil_horizontal[1] = get_pvar(SPVAR_19, -99, 99, 0);
    toggle_strafeShot[1] = get_pvar(SPVAR_15, 0, 1, 0 );        rate_of_fire[1]          = get_pvar(SPVAR_20,   0, 25, 0);
// Profile 3
    // Toggles                                                  // Values
    toggle_antirecoil[2] = get_pvar(SPVAR_21, 0, 1, 0 );        antirecoil_start[2]      = get_pvar(SPVAR_26, -99, 99, 0);         
    toggle_rapidfire[2]  = get_pvar(SPVAR_22, 0, 1, 0 );        antirecoil_end[2]        = get_pvar(SPVAR_27, -99, 99, 0);         
    toggle_burstfire[2]  = get_pvar(SPVAR_23, 0, 1, 0 );        antirecoil_time[2]       = get_pvar(SPVAR_28, -99, 99, 0);         
    toggle_aimassist[2]  = get_pvar(SPVAR_24, 0, 1, 0 );        antirecoil_horizontal[2] = get_pvar(SPVAR_29, -99, 99, 0);
    toggle_strafeShot[2] = get_pvar(SPVAR_25, 0, 1, 0 );        rate_of_fire[2]          = get_pvar(SPVAR_30,   0, 25, 0);
// Misc    
// Toggles only                                                    // Values
    autorun_on   = get_pvar(SPVAR_31, 0, 1, 0);                    burstfire_hold    = get_pvar(SPVAR_34, 1, 999, 150); 
    swap_on      = get_pvar(SPVAR_32, 0, 1, 0);                    burstfire_release = get_pvar(SPVAR_35, 1, 999, 150); 
    inverted_on  = get_pvar(SPVAR_33, 0, 1, 0);                    aimassist_size    = get_pvar(SPVAR_36, 1, 50 , 25 ); 
                                                                aimassist_time    = get_pvar(SPVAR_37, 1, 999, 20 ); 
                                                                strafeShot_time   = get_pvar(SPVAR_38, 1, 999, 500); 
}
// MAIN SECTION                             
main{
 //update main every 8ms --> only for PS4
    //vm_tctrl(-2); 
        if (Joystick_calibration == FALSE)
            {
                RX_Axis_Joystick_calibrate = get_val(9); 
                RY_Axis_Joystick_calibrate = get_val(10); 
                Joystick_calibration = TRUE;     
            }
        X_Last_Value = X_Current_Value;
        Y_Last_Value = Y_Current_Value;
        X_Current_Value = get_lval(9)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(10)- RY_Axis_Joystick_calibrate;
            //--LT pulled 
        if(get_val(7)) 
            {
            //--current & last value less than limit   
                if(abs(X_Current_Value) <= POS_Micro_MVT_Limit && abs(Y_Current_Value) <= POS_Micro_MVT_Limit) 
                {
                    //--both have a value        
                    //if(X_Last_Value && X_Current_Value) 
                        //{
                        //--difference between the 2 values less than 15         
                        if(abs(X_Last_Value - X_Current_Value) < 15) 
                            {
                                combo_stop(Aim_Assist_Perfection);
                                Sampling_Done = FALSE;
 
                                //--RT pulled more than 95%
                                if(get_val(4) > 95) 
                                    {
                                        combo_stop(Fine_Tune_Aim);
                                        fine_pulse = 0;
                                        combo_run(spiroide_Aim_Assit);
                                    }
                                else
                                    {
                                        combo_stop(spiroide_Aim_Assit);
                                        spiroide_pulse = 0;
                                        combo_run(Fine_Tune_Aim);
                                    }    
                            }
                    //}
                }
                //--current and last greater than limit             
                else if(abs(X_Current_Value) <= POS_Aim_Limit && abs(Y_Current_Value) <= POS_Aim_Limit) 
                    {
                        combo_stop(Fine_Tune_Aim);
                        combo_stop(spiroide_Aim_Assit);
                        spiroide_pulse = 0;
                        fine_pulse = 0;
                        combo_run(Aim_Assist_Perfection);
                    }
        }
        else //--LT not pulled
            {
                combo_stop(Fine_Tune_Aim);
                combo_stop(spiroide_Aim_Assit);
                combo_stop(Aim_Assist_Perfection);
                spiroide_pulse = 0;
                fine_pulse = 0;
                Sampling_Done = FALSE;    
            }
//-- auto ping
	if(autoping)
		{
		if(get_val(L2)&&double_click(UP))
		combo_run(auto_ping);
		if(!get_val(L2))
		combo_stop(auto_ping);
		}
		
	//-- easy plate
	if(easy_plate)
		{
		if(get_val(TRIANGLE)&&get_ptime(TRIANGLE)>350)// change to double click if you want to put 3 plates after double pressing triangle
		combo_run(easy_plate);
		if(get_val(L2)>10)
		combo_stop(easy_plate);
		if(get_val(R2)>10)
		combo_stop(easy_plate);
		if(get_val(SQUARE))
		combo_stop(easy_plate);
		}	

if(CS)
    if(!get_val(L2) && !get_val(R2)) { 
    USE_SENS=GEN_SENS;}
    else if(get_val(L2) && !get_val(R2)) { 
    USE_SENS=ADS_SENS;}    
    else if(!get_val(L2) && get_val(R2)) { 
    USE_SENS=FIRE_SENS;}
    else if(get_val(L2) && get_val(R2)) { 
    USE_SENS=ADS_FIRE_SENS;}
    else if(get_val(R1)) { 
    USE_SENS=GRENADE_SENS;}
    sensitivity(RY,NOT_USE,USE_SENS);
    sensitivity(RX,NOT_USE,USE_SENS);
    
 
    set_val(TRACE_4, toggle_burstfire[0]); // BurstFire toggle Profile 1
    set_val(TRACE_5, toggle_burstfire[1]); // BurstFire toggle Profile 2
    set_val(TRACE_6, toggle_burstfire[2]); // BurstFire toggle Profile 3
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
        if(get_console() == PIO_PS4) // If PS4 console:
        {
            swap(PS4_SHARE,PS4_TOUCH); // View = TouchPad
 
                if(get_val(PS4_R3) && event_press(PS4_TOUCH)) //  RS + View = ScreenShot
                {
                    set_val(PS4_SHARE,100);
                    set_val(PS4_TOUCH,0);
                    set_val(PS4_R3,0);
                }
        }
    }    
 //DISPLAY TITLE
// Display Script Title    
    if(display_title)
    {
        cls_oled(0);    // clear OLED screen
        count_black = 0;// reset screen saver counter
 
        if(KillSwitch)
        {
            printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),8,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);    // display OFF centered in X 
            
        }
        else
        {
            printf(center_x(sizeof(TITLE) - 1, OLED_FONT_MEDIUM_WIDTH),13,OLED_FONT_MEDIUM,OLED_WHITE,TITLE[0]);    // display TITLE centered in X 
 
        // Display profile name
            if(profile_idx == 0)
                printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_1[0]); 
            if(profile_idx == 1)
                printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_2[0]);
            if(profile_idx == 2)
                printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_3[0]);
 
            display_black = TRUE;    // screen saver
            display_title = FALSE;
        }
    }
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
        count_black += get_rtime();
        if(count_black >= 5000)
        {
            cls_oled(0);
            count_black = 0;
            display_black = FALSE;
        }
    }
// KILL SWITCH
    if(get_val(PS4_L2))
    {
    // Kill Switch    
        if(event_release(PS4_SHARE))
        {
            KillSwitch = !KillSwitch;
 
            if(KillSwitch)        
                combo_run(RUMBLE_OFF);    // rumble and LED blink
            else
                combo_run(RUMBLE_ON);    // rumble and LED blink
 
            //display_black = FALSE;
            display_title = TRUE;
        }
// MOD MENU
    // toggle ModMenu ON/OFF
        if(event_release(PS4_OPTIONS) && !KillSwitch)
        {
            ModMenu = !ModMenu;
 
            if(!ModMenu)
            {
                ModEdit = FALSE;         // close ModEdit too
                //save ();                // save function
                //combo_run(EXIT_SAVE);    // rumble, blink and display SAVED then display TITLE
                combo_run(RUMBLE_OFF);  // rumble and LED blink
                display_title = TRUE;   // display Title
            }
 
            if(ModMenu)
            {
                modName_idx = 0;        // start to the first adjustable value
                combo_run(RUMBLE_ON);    // rumble and LED blink
                display_new = TRUE;        // display mod name, profile, ON/OFF and value
            }
        }
        set_val(PS4_SHARE, 0);            // block
        set_val(PS4_OPTIONS, 0);        // block
    } // L2 end
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
if(!KillSwitch)
{
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
// ModMenu
    if(ModMenu)
    {
//MOD EDIT           
    // toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
        if(modName_idx <= LAST_EDITABLE_STRING)    // if ANTIRECOIL (so modName_idx = 0) or AA or RAPIDFIRE or BURSTFIRE or StrafeShot is diplayed 
        {
            if(event_press(PS4_CROSS) && !ModEdit) // Turn ModEdit ON
            {
                valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
                ModEdit = TRUE;
                combo_run(RUMBLE_ON);
                display_new = TRUE;
            }
 
            if(event_press(PS4_CIRCLE) && ModEdit) // Turn ModEdit OFF
            {
                ModEdit = FALSE;
                combo_run(RUMBLE_OFF);
                display_new = TRUE;
            }
        }
//EDIT VALUES        
    // ModEdit ON
        if(ModEdit)
        {
            if(get_val(PS4_L2)) // Edit value: hold L2 + UP (+1) or DOWN (-1) or RIGHT (+10) or LEFT (-10)
            {
            // Mods that can have different values depending the active Profile
 
              //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], abs(range min) , range max );     
                antirecoil_start[profile_idx]      = edit_val( 0 , antirecoil_start[profile_idx]     , 0 , 99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
                antirecoil_end[profile_idx]        = edit_val( 1 , antirecoil_end[profile_idx]       , 0 , 99 , 1 , 10   ); // the 2 last numbers are range min and range max
                antirecoil_time[profile_idx]       = edit_val( 2 , antirecoil_time[profile_idx]      , 0 , 99 , 1 , 10   ); // only ar_t display value x100 (real time in ms) - so 99 display 9,900 so 9.9 seconds 
                antirecoil_horizontal[profile_idx] = edit_val( 3 , antirecoil_horizontal[profile_idx], 99, 99 , 1 , 10   );
                rate_of_fire[profile_idx]          = edit_val( 4 , rate_of_fire[profile_idx]         , 0 , 25 , 1 , 10   );  // 25 rounds/s max
 
            // Mods that have same value on every Profiles
 
              //val_I_want_to_edit = edit_val( corresponding valName_idx , val_I_want_to_edit, range min , range max );
                burstfire_hold    = edit_val( 5 , burstfire_hold    , 0 , 990  , 10 , 100  );
                burstfire_release = edit_val( 6 , burstfire_release , 0 , 990  , 10 , 100  );
                aimassist_size    = edit_val( 7 , aimassist_size    , 0,  50   , 1  , 10   );
                aimassist_time    = edit_val( 8 , aimassist_time    , 0,  990  , 1  , 10   ); 
                strafeShot_time   = edit_val( 9 , strafeShot_time   , 0,  9990 , 10 , 100  );
            }
 //AVAILABLE VALUES
            else // NOT L2 (if not editing value)
            {
            // Navigate value name
                if(event_press(PS4_RIGHT))
                {
                    valName_idx += 1;
                    display_new = TRUE; // Display value name and value
                }
                if(event_press(PS4_LEFT))
                {
                    valName_idx -= 1;
                    display_new = TRUE;
                }
 
            // Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
             // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
                if(modName_idx == 0) vals_available( 0 , 3  );// Anti-Recoil        
                if(modName_idx == 1) vals_available( 4 , 4  );// RapidFire                            
                if(modName_idx == 2) vals_available( 5 , 6  );// If BurstFire was displayed before I enter ModEdit, I can only edit all BurstFire values            
                if(modName_idx == 3) vals_available( 7 , 8  );// AIM Assist                
                if(modName_idx == 4) vals_available( 9 , 9  );// StrafeShot    
            } // NOT SQUARE (if not editing value) end
        } // ModEdit end
//TOGGLES
        else // if NOT ModEdit BUT if ModMenu
        {
        // Navigate mods name
            if(event_press(PS4_RIGHT))
            {
                modName_idx += 1;
                display_new = TRUE;
            }
            if(event_press(PS4_LEFT))
            {
                modName_idx -= 1;
                display_new = TRUE;
            }
        // Cycle mods name
            if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
                modName_idx = 0;
            if(modName_idx < 0)
                modName_idx = LAST_MODNAME_STRING;
        // Switch profiles    
            if(event_press(PS4_TRIANGLE))
            {
                profile_idx += 1;
                display_new = TRUE;
            }
        // Cycle profiles    
            if(profile_idx > (AMOUNT_OF_PROFILES - 1))
                profile_idx = 0;
        // Toggles (UP to turn ON, DOWN to turn OFF)
            // Mods that can have different ON/OFF status depending the active Profile
          //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
            toggle_antirecoil[profile_idx] = toggle( 0, toggle_antirecoil[profile_idx] );
            toggle_rapidfire[profile_idx]  = toggle( 1, toggle_rapidfire[profile_idx]  );
            toggle_burstfire[profile_idx]  = toggle( 2, toggle_burstfire[profile_idx]  );
            toggle_aimassist[profile_idx]  = toggle( 3, toggle_aimassist[profile_idx]  );
            toggle_strafeShot[profile_idx] = toggle( 4, toggle_strafeShot[profile_idx] );
            // Mods that have same ON/OFF status on every Profiles
          //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
            autorun_on  = toggle( 5 , autorun_on  );
            swap_on     = toggle( 6 , swap_on     );
            inverted_on = toggle( 7 , inverted_on );
        } // if NOT ModEdit BUT if ModMenu end
    // If ModMenu AND ModEdit
        if(event_press(PS4_PS))
            save ();
        //block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
        block_all_inputs();
    } // ModMenu ON end
//MOD MENU MOD EDIT  
    if(!ModMenu)
    {
    // Speed Toggles
      //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2 300ms   , toggle_I_want_to_edit[profile] , corresponding modName_idx );
        toggle_rapidfire[profile_idx]  = speed_toggle( PS4_L2, PS4_UP   , toggle_rapidfire[profile_idx] , 1 );
        toggle_burstfire[profile_idx]  = speed_toggle( PS4_L2, PS4_DOWN , toggle_burstfire[profile_idx] , 2 );
        toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT, toggle_aimassist[profile_idx] , 3 );
        toggle_strafeShot[profile_idx] = speed_toggle( PS4_L2, PS4_LEFT , toggle_strafeShot[profile_idx], 4 );
        // We can add as many speed toogle as we need
    // Double Tap
        if(double_tap) 
            double_tap -= get_rtime();
    // Hair Trigger
            deadzone(PS4_L2,PS4_R2,99,99);
//AIM ASSIST
    // If AIM Assist is enable for the curent profile
        if(toggle_aimassist[profile_idx] == 1)
        {
            if(get_val(PS4_L2))
                combo_run(AIM_ASSIST);
            else 
                combo_stop(AIM_ASSIST); 
        }
// STRAFE SHOT
   // If Strafe Shot is enable for the curent profile
        if(toggle_strafeShot[profile_idx] == 1)
        {
        // Run combo
            if(get_val(PS4_R2))
                combo_run(STRAFESHOT);
            else
                combo_stop(STRAFESHOT);
        }
// OTHER MODS
    /* AutoRun press sensitive (Work better when in game option "Press to Sprint" is turned OFF)
         Push your stick to more than 60% to run automatically
    */    
        if(autorun_on) // (5)
        {
            if(get_val(PS4_LY) < -60)
            {
                set_val(PS4_LY, -100);
                set_val(PS4_L3, 100);
            }
        }
    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?    
        if(swap_on) // (6)
        {
            swap(PS4_R1, PS4_R2);
            swap(PS4_L1, PS4_L2);
        }
    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
        if(inverted_on) // (7)
            invert = -1;
        else
            invert = 1;
// SWITCH PROFILE
    // Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold R3/RS + tap for sync color
        if(event_press(PS4_TRIANGLE) || (get_val(PS4_L3) && event_press(PS4_TRIANGLE)))
        {
            profile_1or2=!profile_1or2; 
            profile_3 = FALSE;
 
            if(double_tap) 
            { 
                 profile_3 = TRUE ; 
                profile_1or2 = !profile_1or2;
            }
            else
                double_tap = 200;
 
            if(ModMenu)
                display_new = TRUE;
            else
                display_title = TRUE;
        }
        if(get_val(PS4_L3))
            set_val(PS4_TRIANGLE, 0);
    // If Profile 3
        if(profile_3)
            profile_idx = 2;
 
        else
        {    
        // If Profile 2
            if(profile_1or2)
                profile_idx = 1;
 
        // If Profile 1
            else    
                profile_idx = 0;
        }
    } // ModMenu OFF end
//ANTI RECOIL
// If Anti-Recoil is enable for the active profile
    if(toggle_antirecoil[profile_idx] == 1)
    {    
        ar_x = (VALUES[profile_idx][3] + antirecoil_horizontal[profile_idx]);
 
    // Antirecoil vertical by Batts        
        if((VALUES[profile_idx][0] + antirecoil_start[profile_idx]) < (VALUES[profile_idx][1] + antirecoil_end[profile_idx]))
            i_val = 1; 
        else
            i_val = -1;
 
        i_pnt = ((VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10) / (abs((VALUES[profile_idx][0] + antirecoil_start[profile_idx]) - (VALUES[profile_idx][1] + antirecoil_end[profile_idx]))); 
 
        if(!get_ival(PS4_R2)) 
           {
              ar_y = VALUES[profile_idx][0] + antirecoil_start[profile_idx];
              i_cnt = 0;
              i_num = 0;
           }   
 
        if(toggle_burstfire[profile_idx] != 1 && get_val(PS4_L2) && get_val(PS4_R2) || toggle_burstfire[profile_idx] == 1 && get_val(PS4_R2) && get_ptime(PS4_R2) <= hold_time)
        {
            combo_run(X_VAL);
 
               if(!p_complete())  
                   ar_y = p_val();
               else
                   ar_y = VALUES[profile_idx][1] + antirecoil_end[profile_idx];
 
            if(y_val() < 100)
                   set_val(PS4_RY,y_val());     
           }
 
           if(abs(get_val(PS4_RX)) > abs(ar_x) + 5)
              combo_stop(X_VAL);
    }
// RAPID FIRE
// If RapidFire is enable for the active profile
    if(toggle_rapidfire[profile_idx] == 1)
    {
    // Rate of Fire Calculation
        hold_time = 500 / (VALUES[profile_idx][4] + rate_of_fire[profile_idx]); 
           rest_time = hold_time - 20;
        if(rest_time < 0) rest_time = 0;
 
    // Run combo
        if(get_ival(PS4_R2))
            combo_run(RAPIDFIRE);
        else
            combo_stop(RAPIDFIRE);
 
        led_on = 150;
        led_off = 300;
        combo_run(BLINK);
    }
// BURST FIRE
// If BurstFire is enable for the active profile
    if(toggle_burstfire[profile_idx] == 1)
    {
    // Hold and Release
        hold_time = burstfire_hold;
        rest_time = burstfire_release;
 
    // Run combo
        if(get_ival(PS4_R2))    
            combo_run(BURSTFIRE);
        else
            combo_stop(BURSTFIRE);
 
        led_on = 200;
        led_off = 1000;
        combo_run(BLINK);
    }  
// REFRESH DISPLAY   
    if(display_new) 
    {
    // Clear OLED screen    
        cls_oled(0);
        count_black = 0;// reset screen saver counter
 
        if(ModEdit)
        {
        // Display Value Name and value
            // Mods that can have different values depending the active Profile
          //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
            display_edit( 0 , center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH)      , ANTIRECOIL_START[0]      , antirecoil_start[profile_idx]      );
            display_edit( 1 , center_x(sizeof(ANTIRECOIL_END) - 1, OLED_FONT_MEDIUM_WIDTH)        , ANTIRECOIL_END[0]        , antirecoil_end[profile_idx]        );
            display_edit( 2 , center_x(sizeof(ANTIRECOIL_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)       , ANTIRECOIL_TIME[0]       , antirecoil_time[profile_idx]       );
            display_edit( 3 , center_x(sizeof(ANTIRECOIL_HORIZONTAL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_HORIZONTAL[0] , antirecoil_horizontal[profile_idx] );
            display_edit( 4 , center_x(sizeof(RATE_OF_FIRE) - 1 , OLED_FONT_MEDIUM_WIDTH)         , RATE_OF_FIRE[0]          , rate_of_fire[profile_idx]          );
            // Mods that have same value on every Profile
            display_edit( 5 , center_x(sizeof(BURSTFIRE_HOLD) - 1, OLED_FONT_MEDIUM_WIDTH)    , BURSTFIRE_HOLD[0]    , burstfire_hold    );
            display_edit( 6 , center_x(sizeof(BURSTFIRE_RELEASE) - 1, OLED_FONT_MEDIUM_WIDTH) , BURSTFIRE_RELEASE[0] , burstfire_release );
            display_edit( 7 , center_x(sizeof(AIMASSIST_SIZE) - 1, OLED_FONT_MEDIUM_WIDTH)    , AIMASSIST_SIZE[0]    , aimassist_size    );
            display_edit( 8 , center_x(sizeof(AIMASSIST_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)    , AIMASSIST_TIME[0]    , aimassist_time    );
            display_edit( 9 , center_x(sizeof(STRAFESHOT_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)   , STRAFESHOT_TIME[0]   , strafeShot_time   );
        }
        else
        {
        // Display Mod Name and ON/OFF
            // Mods that can have different ON/OFF status depending the active Profile
          //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
            display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , toggle_antirecoil[profile_idx]);
            display_mod( 1 ,  center_x(sizeof(RAPIDFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)  , RAPIDFIRE[0]  , toggle_rapidfire[profile_idx]);
            display_mod( 2 ,  center_x(sizeof(BURSTFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)  , BURSTFIRE[0]  , toggle_burstfire[profile_idx]);
            display_mod( 3 ,  center_x(sizeof(AIMASSIST) - 1, OLED_FONT_MEDIUM_WIDTH)  , AIMASSIST[0]  , toggle_aimassist[profile_idx]);
            display_mod( 4 ,  center_x(sizeof(STRAFE_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH), STRAFE_SHOT[0], toggle_strafeShot[profile_idx]);
            // Mods that have same ON/OFF status on every Profile
            display_mod( 5 ,  center_x(sizeof(AUTORUN) - 1, OLED_FONT_MEDIUM_WIDTH) , AUTORUN[0] , autorun_on);
            display_mod( 6 ,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)    , SWAP[0]    , swap_on);
            display_mod( 7 ,  center_x(sizeof(INVERTED) - 1, OLED_FONT_MEDIUM_WIDTH), INVERTED[0], inverted_on);
        }
    // Display Profile only on mods that may have a different value depending on the Profile
        if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
        {
            if(profile_idx == 0) // profile_idx = profile_idx = Profile
                //printf(center_x(sizeof(PROFILE_1) - 1, SMALL),23,SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
                line_oled(0, 26, 39, 26, 5, 1); // print a line to the left to say profile 1
            else if(profile_idx == 1)
                //printf(center_x(sizeof(PROFILE_2) - 1, SMALL),23,SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
                line_oled(44, 26, 83, 26, 5, 1); // print a line in the middle to say Profile 2
            else if(profile_idx == 2)
                //printf(center_x(sizeof(PROFILE_3) - 1, SMALL),23,SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
                line_oled(88, 26, 127, 26, 5, 1); // print a line to the right to say Profile 3
        }
        else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
        {
            line_oled(0, 26, 39, 26, 5, 1);
            line_oled(44, 26, 83, 26, 5, 1);
            line_oled(88, 26, 127, 26, 5, 1);
        }
 
        display_black = TRUE;
        display_new = FALSE;
    } // display_new end
 
} // NOT KillSwitch end
 
    led(profile_idx);
 
} // main end
// AIM ASSIST COMBO
combo Aim_Assist_Perfection 
       {
        // Save the first joystick position 
        X_Last_Value = X_Current_Value
        Y_Last_Value = Y_Current_Value
 
        // Sampling frequency 
        wait(Sampling_Time);
 
        // Save the second joystick position 
        X_Current_Value = get_lval(9)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(10)- RY_Axis_Joystick_calibrate; 
 
     if (Sampling_Done == TRUE )
        {
            //Applying BOOST
            //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
            Aim_Perfection(X_Last_Value, X_Current_Value, 1, 0, 1, 0 ); 
            Aim_Perfection(Y_Last_Value, Y_Current_Value, 1, 0, 0, 1 ); 
        }
 
        X_Last_Value = X_Current_Value;
        Y_Last_Value = Y_Current_Value;
 
        // Sampling frequency 
        wait(Sampling_Time);
 
        // Save the second joystick position 
        X_Current_Value = get_lval(9)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(10)- RX_Axis_Joystick_calibrate; 
 
   if (Sampling_Done == TRUE )
        {
            //Applying CORRECTION
            //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS )
            Aim_Perfection(X_Last_Value, X_Current_Value, 0, 1, 1, 0 ); 
            Aim_Perfection(Y_Last_Value, Y_Current_Value, 0, 1, 0, 1 ); 
        }
 
        Sampling_Done = TRUE; 
        wait(Sampling_Time);
    }
 
combo Fine_Tune_Aim {
 
    set_val(9,(15 - fine_pulse));//right
    set_val(11,(-15 + fine_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(9,(15 - fine_pulse));//right+down
    set_val(10,(10 - fine_pulse));
    set_val(11,(-5 + fine_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
 
    set_val(10,(10 - fine_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(9,(-15 + fine_pulse));//left+down
    set_val(10,(10 - fine_pulse));
    set_val(11,(5 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time)
    wait(Sampling_Time)
 
    set_val(9,(-15 + fine_pulse));// left
    set_val(11,(15 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(9,(-15 + fine_pulse)); //left + up
    set_val(10,(-10 + fine_pulse));
    set_val(11,(5 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(10,(-10 + fine_pulse)); //up
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(9,(15 - fine_pulse));//right+up
    set_val(10,(-10 + fine_pulse));
    set_val(11,(-5 + fine_pulse))//move 	left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
 
    fine_pulse = fine_pulse + 2;
 
 
    if ( fine_pulse >10)
       {
            fine_pulse = 0;   
        }
   }
 
combo spiroide_Aim_Assit {
 
    set_val(9,(4 + spiroide_pulse));//right
    set_val(11,(-15+ spiroide_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
 
 
    set_val(10,(5 + spiroide_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(9,(-4 - spiroide_pulse));//left
    set_val(11,15 - spiroide_pulse );//move right
    wait(Sampling_Time);
 
    wait(Sampling_Time)
 
    set_val(10,(5 + spiroide_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
 
    spiroide_pulse = spiroide_pulse + 2;
 
 
    if ( spiroide_pulse >10)
       {
            spiroide_pulse = 0;   
        }
   } 
// COMBO SECTION

combo auto_ping
	{set_val(UP,100);
	wait(20)
	set_val(UP,0);
	wait(20)
	set_val(UP,100);
	wait(20)
	set_val(UP,0);
	}
combo easy_plate
	{set_val(TRIANGLE,100);
	wait(6000)}//time triangle is held for adjust higher or lower 500 if you only get 2 plates or cant switch weapons after replating
 
combo RUMBLE_ON {                        // 2 high rumbles + green blink 2 times
    set_ledx(2, 2);
    set_rumble(RUMBLE_B, 50);
    wait(150);
    reset_rumble();
    wait(100);
    set_rumble(RUMBLE_B, 50);
    wait(150);
    reset_rumble();
}
 
combo RUMBLE_OFF {                        // 1 high rumble + red blink 1 time
    set_ledx(1, 1);
    set_rumble(RUMBLE_A, 50);
    wait(300);
    reset_rumble();
    wait(400);
}
 
combo SAVE { 
    cls_oled(0);                        // clear OLED screen 
    printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]);     // display SAVED... centered in X Y 
    wait(10)
    call(RUMBLE_ON);                    // 2 high rumbles + green blink 2 times                                
    wait(150);
    call(RUMBLE_ON);                    // 2 high rumbles + green blink 2 times    
    wait(1000);
    display_new = TRUE;                   // display mods
}

combo BURSTFIRE { 
    wait(hold_time);
    call(RAPIDFIRE);
    call(RAPIDFIRE);
    call(RAPIDFIRE);
    call(RAPIDFIRE);
    }
 
combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time);
    }
 
combo AIM_ASSIST { // AIM Assist
    set_val(PS4_RY,aa(PS4_RY, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RX,aa(PS4_RX, aimassist_size));
    set_val(PS4_LX,aa(PS4_LX, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RY,aa(PS4_RY,inv(aimassist_size))); 
    wait(aimassist_time);
    set_val(PS4_RX,aa(PS4_RX,inv(aimassist_size)));
    set_val(PS4_LX,aa(PS4_LX,inv(aimassist_size)));
    wait(aimassist_time);
}
 
combo STRAFESHOT { // StrafeShot
    set_val(PS4_LX, 100);
    wait(strafeShot_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafeShot_time);
    wait(50);
}
 
combo BLINK {
    led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}
 
combo X_VAL { // Antirecoil Horizontal
    x_ref = get_val(PS4_RX) + ar_x;
    if(x_ref > 100) x_ref = 100;
    set_val(PS4_RX, x_ref);
}
// FUNCTIONS 
function Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
    { 
 
 
       if(abs(Last_Value - Current_Value) < Aim_Perfection_Limit) 
            {
                //--moving right
                if(Last_Value < Current_Value)
                    {           
                        if (Boost)
                            { 
                                if (X_AXIS)
                                    set_val(9, (Current_Value + Aim_Boost)); 
 
                                if (Y_AXIS)
                                        set_val(10, (Current_Value + Aim_Boost));
                            }
 
 
                        else if(Correction)
                            {
                                if (X_AXIS)
                                    set_val(9, (Current_Value - Aim_Correction)); 
 
                                if (Y_AXIS)
                                set_val(10, (Current_Value - Aim_Correction));            
                            }
                    }
                else //--moving left
                    {
 
                        if (Boost)
                            { 
                                if (X_AXIS)
                                    set_val(9, (Current_Value - Aim_Boost)); 
 
                                if (Y_AXIS)
                                        set_val(10, (Current_Value - Aim_Boost));
                            }
 
 
                        else if(Correction)
                            {
                                if (X_AXIS)
                                    set_val(9, (Current_Value + Aim_Correction)); 
 
                                if (Y_AXIS)
                                set_val(10, (Current_Value + Aim_Correction));            
                            }
                    }
            }
    } 
function double_click(button) {        
    if (double__tap[button] >= 0) {                    
        double__tap[button] += get_rtime(); 
        if (double__tap[button] > 450)
            double__tap[button] = -1;                                                                                       
    }           
    if (event_release(button) && get_ptime(button) <= 200) { 
        if (double__tap[button] < 0) {                    
            double__tap[button] = 0;                        
        } else {             
            double__tap[button] = -1;                       
            return 1;                                   
        }                                                     
    }                                                  
    return 0;
    }





function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods
 
    if(valName_idx < f_min)
        valName_idx = f_max;
    if(valName_idx > f_max)
        valName_idx = f_min;
 
// Match the # of value names index with the right column in VALUES array
    val_col_idx = valName_idx;    
}
 
function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
 
    if(valName_idx == f_idx)
    {
    // +1 or -1                                                             // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
        f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
        f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
        // +10 or -10
              f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
           f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2
 
    // We can also add (f_ref)
    // Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_start[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;    
    }
    // Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
    if(rate_of_fire[profile_idx] < 0)
        rate_of_fire[profile_idx] = 0;
 
    //return f_ref;
 
    return f_val;
}
 
function speed_toggle(f_hold, f_press, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
 
    if(get_val(f_hold))
    {
        if(get_val(f_press) && get_ptime(f_press) == 300) // Hold second button 300ms or more
        {
            modName_idx = f_string;
 
            if(f_val == 0)
            {
                if(f_string == 1) // If RapidFire is enable, 
                    toggle_burstfire[profile_idx] = 0; // disable BurstFire
                else if(f_string == 2) // If BurstFire is enable, 
                    toggle_rapidfire[profile_idx] = 0; // disable RapidFire
 
                f_val = 1;
                combo_run(RUMBLE_ON);
            }
            else
            {
                f_val = 0;
                combo_run(RUMBLE_OFF);
            }
            display_new = TRUE;
        } 
    set_val(f_press, 0)
    }
 
    return f_val;
}
 
function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
 
    if(event_press(PS4_UP))
    {
        if(modName_idx == f_idx)
        {
            if(f_idx == 1) // If RapidFire is enable, 
                toggle_burstfire[profile_idx] = 0; // disable BurstFire
            else if(f_idx == 2) // If BurstFire is enable, 
                toggle_rapidfire[profile_idx] = 0; // disable RapidFire
 
            f_val = 1;
            combo_run(RUMBLE_ON);
        }
 
        display_new = TRUE;
    }
 
    if(event_press(PS4_DOWN))
    {
        if(modName_idx == f_idx)
        {
            f_val = 0;
            combo_run(RUMBLE_OFF);
        }        
        display_new = TRUE;
    }
    return f_val;
}
 
function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);
 
        if(valName_idx == f_idx)
        {
        // Display value name and value
            printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
 
        // Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
            if(f_idx == 2) 
                number_to_string((VALUES[profile_idx][val_col_idx] + f_val) * 100, find_digits((VALUES[profile_idx][val_col_idx] + f_val) * 100));
 
        // Display all editable values in VALUES array
            else if(f_idx <= LAST_EDITABLE_COLUMN) 
                number_to_string(VALUES[profile_idx][val_col_idx] + f_val, find_digits(VALUES[profile_idx][val_col_idx] + f_val));
 
        // Display editable values that are not in the array (burstfire_hold for exemple)
            else 
                number_to_string(f_val, find_digits(f_val));
        }
}
 
function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
        if(modName_idx == f_idx)
        {
        // Display MOD_NAME
            printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
 
        // Display ON OFF
            if(f_toggle == 1)
                printf(center_x(sizeof(ON) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,ON[0]);
            else
                printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);
        }
}
 
function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 
 
    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
 
    // Values that are not in the array (aimassist_time for exemple)
        if(valName_idx > LAST_EDITABLE_COLUMN)
        {
        // Substract    
            if(f_val < inv(f_rng_min)) 
                f_val = inv(f_rng_min); 
           // Add   
               if(f_val > f_rng_max) 
                f_val = f_rng_max;
        }
 
    // Values that are in the array 
        else
        {
    // Substract    
        if((f_val + VALUES[profile_idx][val_col_idx]) < inv(f_rng_min)) 
            f_val = inv(f_rng_min + VALUES[profile_idx][val_col_idx]); 
    // Add   
        if((f_val + VALUES[profile_idx][val_col_idx]) > f_rng_max) 
            f_val = f_rng_max - VALUES[profile_idx][val_col_idx]; 
        }
        display_new = TRUE;
    }
    return f_val; 
} 
 
function p_complete() { // Antirecoil
 
    i_cnt++;
    if(i_cnt > (VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10) 
    {
        i_cnt = (VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10;
        return 1;
    }    
    return 0;
}  

 
function p_val() { // Antirecoil
 
    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
}  
 
function y_val() { // Antirecoil
 
    v = get_val(10);
 
    if(abs(v) < 10)
        v = 0;
 
    if(abs(v) > ar_y + 5)
        return v;
 
    return v + (ar_y * invert);           
}
 
function aa(f_axis,f_val) { // AIM Assist
 
    if(abs(get_val(f_axis)) < aimassist_size + 1) // + 1 is release
        return f_val;
 
    return get_val(f_axis); 
}
 
function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
 
    if(f_val < 0) //--neg numbers
    {          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
    } 
 
    for(c = 5; c >= 1; c--) 
    {
        if(f_digits >= c) 
        {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function find_digits(f_num) {
//  find_digits(value)  
//        return Number of Digits in Value Passed  
 
    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//        return X for Centering String Horizontally
 
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function center_y(f_size) {
//  center_y(font size);  
//        return Y for Centering String Vertically
 
    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function press_hold(f_btn) { 
//  return TRUE - event_press()   
//                - every 250ms when button is held
 
    return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
           && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,dbyte((f_color * 4) + i));
   }
}
 
function save () {
    combo_run(SAVE);
 
// Profile 1
    // Toggles                                      // Values
    set_pvar(SPVAR_1,toggle_antirecoil[0]);         set_pvar(SPVAR_6 ,antirecoil_start[0]     );         
    set_pvar(SPVAR_2,toggle_rapidfire[0] );         set_pvar(SPVAR_7 ,antirecoil_end[0]       );        
    set_pvar(SPVAR_3,toggle_burstfire[0] );         set_pvar(SPVAR_8 ,antirecoil_time[0]      );     
    set_pvar(SPVAR_4,toggle_aimassist[0] );         set_pvar(SPVAR_9 ,antirecoil_horizontal[0]);
    set_pvar(SPVAR_5,toggle_strafeShot[0]);         set_pvar(SPVAR_10,rate_of_fire[0]         );
// Profile 2
    // Toggles                                       // Values
    set_pvar(SPVAR_11,toggle_antirecoil[1]);         set_pvar(SPVAR_16,antirecoil_start[1]     );       
    set_pvar(SPVAR_12,toggle_rapidfire[1] );         set_pvar(SPVAR_17,antirecoil_end[1]       );      
    set_pvar(SPVAR_13,toggle_burstfire[1] );         set_pvar(SPVAR_18,antirecoil_time[1]      );     
    set_pvar(SPVAR_14,toggle_aimassist[1] );         set_pvar(SPVAR_19,antirecoil_horizontal[1]);
    set_pvar(SPVAR_15,toggle_strafeShot[1]);         set_pvar(SPVAR_20,rate_of_fire[1]         );
// Profile 3
    // Toggles                                       // Values
    set_pvar(SPVAR_21,toggle_antirecoil[2]);         set_pvar(SPVAR_26,antirecoil_start[2]     );       
    set_pvar(SPVAR_22,toggle_rapidfire[2] );         set_pvar(SPVAR_27,antirecoil_end[2]       );      
    set_pvar(SPVAR_23,toggle_burstfire[2] );         set_pvar(SPVAR_28,antirecoil_time[2]      );      
    set_pvar(SPVAR_24,toggle_aimassist[2] );         set_pvar(SPVAR_29,antirecoil_horizontal[2]);
    set_pvar(SPVAR_25,toggle_strafeShot[2]);         set_pvar(SPVAR_30,rate_of_fire[2]         );
// Misc
    // Toggles only                                      // Values
    set_pvar(SPVAR_31, autorun_on  );                  set_pvar(SPVAR_34, burstfire_hold    );
    set_pvar(SPVAR_32, swap_on     );                 set_pvar(SPVAR_35, burstfire_release );
    set_pvar(SPVAR_33, inverted_on );                 set_pvar(SPVAR_36, aimassist_size    );
                                                     set_pvar(SPVAR_37, aimassist_time    );
                                                     set_pvar(SPVAR_38, strafeShot_time   );
 
}
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
/*
function block_btn() {
 
set_val(PS4_UP     , 0 );     set_val(PS4_DOWN  , 0 );     set_val(PS4_LEFT  , 0 );    set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 );     set_val(PS4_CIRCLE, 0 );     set_val(PS4_SQUARE, 0 );     set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 );     set_val(PS4_R1    , 0 );     set_val(PS4_L3    , 0 );     set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 );     set_val(PS4_SHARE , 0 );    set_val(PS4_TOUCH , 0 );    set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 );     set_val(XB1_PL2   , 0 );    set_val(XB1_PR1   , 0 );    set_val(XB1_PR2     , 0);
//set_val(PS4_LX, 0);         set_val(PS4_LY, 0);         set_val(PS4_RX, 0);         set_val(PS4_RY, 0);
//set_val(PS4_L2, 0);         set_val(PS4_R2, 0);
}   */