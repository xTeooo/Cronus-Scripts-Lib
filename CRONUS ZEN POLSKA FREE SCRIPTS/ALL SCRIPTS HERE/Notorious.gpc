// GPC Online Library
// notorious_exodus_v_2.0_-_all_scripts_are_free.gpc

/* 
                                   ,----,                                                                      
         ,--.    ,----..         ,/   .`|  ,----..                         ,----..                             
       ,--.'|   /   /   \      ,`   .'  : /   /   \  ,-.----.     ,---,   /   /   \                 .--.--.    
   ,--,:  : |  /   .     :   ;    ;     //   .     : \    /  \ ,`--.' |  /   .     :          ,--, /  /    '.  
,`--.'`|  ' : .   /   ;.  \.'___,/    ,'.   /   ;.  \;   :    \|   :  : .   /   ;.  \       ,'_ /||  :  /`. /  
|   :  :  | |.   ;   /  ` ;|    :     |.   ;   /  ` ;|   | .\ ::   |  '.   ;   /  ` ;  .--. |  | :;  |  |--`   
:   |   \ | :;   |  ; \ ; |;    |.';  ;;   |  ; \ ; |.   : |: ||   :  |;   |  ; \ ; |,'_ /| :  . ||  :  ;_     
|   : '  '; ||   :  | ; | '`----'  |  ||   :  | ; | '|   |  \ :'   '  ;|   :  | ; | '|  ' | |  . . \  \    `.  
'   ' ;.    ;.   |  ' ' ' :    '   :  ;.   |  ' ' ' :|   : .  /|   |  |.   |  ' ' ' :|  | ' |  | |  `----.   \ 
|   | | \   |'   ;  \; /  |    |   |  ''   ;  \; /  |;   | |  \'   :  ;'   ;  \; /  |:  | | :  ' ;  __ \  \  | 
'   : |  ; .' \   \  ',  /     '   :  | \   \  ',  / |   | ;\  \   |  ' \   \  ',  / |  ; ' |  | ' /  /`--'  / 
|   | '`--'    ;   :    /      ;   |.'   ;   :    /  :   ' | \.'   :  |  ;   :    /  :  | : ;  ; |'--'.     /  
'   : |         \   \ .'       '---'      \   \ .'   :   : :-' ;   |.'    \   \ .'   '  :  `--'   \ `--'---'   
;   |.'          `---`                     `---`     |   |.'   '---'       `---`     :  ,      .-./           
'---'                                                `---'                            `--`----'              
 
 
 
 
 All Scripts Are Free.
 Anyone trying to sell a script is simply a scammer.
 If you have paid for a script, you have been scammed.
 
 NOTORIOUS Exodus V 2.0 
 CALL OF DUTY COLD WAR AIMBOT
 
 Lazer V 1.0
 MODERN WARAFRE Version 

   
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                                          INSTRUCTIONS ON HOW TO ACTIVATE MODS   
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Open modMenu                                           ===== Hold L2/LT and tap OPTIONS/MENU                        ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== To edit the mods in the modMenu                        ===== Press CROSS/A to EDIT                                  ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Navigate between all mods                              ===== Tap LEFT or RIGHT on the D-PAD                         ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Enable or Disable the diplayed mod                     ===== Tap UP for ON == Tap DOWN for OFF                      ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Switch Loadouts In Mod Menu                            ===== Tap Y/Triangle                                         ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Switch Loadouts In Game                                ===== USER DEFINED BUTTONS                                   ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Edit availble Mods                                     ===== Press CROSS/A OR Press CIRCLE/B to Exit Mod            ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Edit Values In available Mods                          ===== Hold L2/LT & Tap RIGHT to increase + 1                 ===
                                                            =====              Tap LEFT to decrease  - 1                 ===
                                                            =====              Tap UP   to increase  + 10                ===
                                                            =====              Tap DOWN to decrease  - 10                ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★ 
==== Navigate between values available in the editable mods ===== Tap LEFT Or RIGHT                                      ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== To SAVE all mods that have been edited & enabled       ===== Press XBOX/PS Button == Screen Will diplay "SAVED"     ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== To exit Mod Menu once you have saved it                ===== Hold L2/LT and Tap OPTIONS/MENU                        ===
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
==== Kill Switch (Disable Everything)                       ===== Hold LT/L2 & Double Tap SHARE/VIEW                     ===


*/  define one_button_press = FALSE; /* ==
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
*/  define two_button_press = TRUE;  /* ==
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
OPTION 1 = 1 BUTTON PRESS FOR SWITCH PROFILE */  define profile_switch_button1 = PS4_TRIANGLE;                            /*
OPEN ZEN MENU TO ENABLE THIS 1 BUTTON TO CHANGE PROFILE!!!! IF YOU WANT TO CHANGE WHICH BUTTON TO PRESS REPLACE PS4_TRIANGLE
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
OPTION 2 = 2 BUTTON PRESS FOR SWITCH PROFILE */  define profile_switch_button2 = PS4_L2; // ★★★★★★★★★★★★★★★★★★★★★★★
/*========================================== */  define profile_switch_button3 = PS4_DOWN;                                /*
OPEN ZEN MENU TO ENABLE THIS BUTTON TO CHANGE PROFILE!! IF YOU WANT TO CHANGE THE BUTTONS REPLACE THE ABOVE!!! 
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
=== Slide Cancel Buttons, If you DO NOT use Default Button Layout In Game, you DO NOT need to change buttons ==============
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
===   FOR SLIDE CANCEL ====> THIS IS YOUR CROUCH/PRONE BUTTON   |*/   define user_defined_crouch_button = PS4_CIRCLE; /* == 
===   FOR SLIDE CANCEL ====> THIS IS YOUR JUMP BUTTON            |*/   define user_defined_jump_button  = PS4_CROSS;  /* ==
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                               

*/
// Text to display
	const string TITLE = "NOTORIOUS";
	const string MW = "COD ColdWar";
	const string COLDWAR = "ExOdUs V2.0" 
	const string PRESS_A_TO_CONTINUE = "Press A to Edit";
	const string DEFAULT = "Default 5";
	const string DEFAULT1 = "Default -5"; 
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE= "SAVED";
	const string PROFILE_1 = "Primary": // or primary weapon
	const string PROFILE_2 = "Secondary": // or secondary weapon
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

//  Tap up on the D-pad to enable these mods! Down on the D-pad disables
	const string ANTIRECOIL        = "Recoil V1";		  // modName_idx = 0
	const string ANTIRECOILH       = "AntiRecoilH"        // modName_idx = 1
	const string RAPIDFIRE         = "RapidFire";         // modName_idx = 2
    const string NOTORIOUSAIM      = "Lock on";           // modName_idx = 3
    const string EXTREME_AIMABUSE  = "Aim Abuse";         // modName_idx = 4
    const string POLARAIM          = "Polar Aim";         // modName_idx = 5
    const string STICKYAIM         = "Sticky Aim";        // modName_idx = 6
	const string TRACKING          = "Tracking";          // modName_idx = 7
	const string QUICKSCOPE        = "QuickScope"         // modName_idx = 8
    const string HOLD_BREATH       = "Hold Breath";       // modName_idx = 9
	const string EASY_PLATE        = "Easy Plates";       // modName_idx = 10
    const string CANCELSLIDE       = "CancelSlide";       // modName_idx = 11
    const string PRONESHOT         = "Prone Shot";        // modName_idx = 12
	const string BOUNCE_SHOT       = "Bounce shot";       // modName_idx = 13
 	const string BUNNYHOP          = "Bunny Hop";         // modName_idx = 14
	const string AUTORUN           = "AutoRun";           // modName_idx = 15
	const string SWAP              = "Swap Tr/Bu";        // modName_idx - 16
	const string INVERTED          = "Inverted Y";        // modName_idx = 17
	
// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;

// modName # of the last Mod Name string - Used for cycle modName_idx
	define LAST_MODNAME_STRING = 17;

// # of the last modName_idx that has a value that can be edited
	define LAST_EDITABLE_STRING = 8;
	
// Value Name
	// modName_idx = 0 = ANTIRECOIL string
	const string ANTIRECOIL_VERTICAL      = "Vertical"; 		 // valName_idx = 0  
	const string ANTIRECOIL_HORIZONTAL    = "Horizontal";          // valName_idx = 1
	// modName_idx = 1
   	const string ANTIRECOIL_START         = "ARV Start"; 		 // valName_idx = 2  
	const string ANTIRECOIL_END           = "ARV End";			 // valName_idx = 3
	const string ANTIRECOIL_TIME          = "ARV Time";			 // valName_idx = 4
    const string ANTIRECOILH_START        = "ARH Start"; 	     // valName_idx = 5 
	const string ANTIRECOILH_END          = "ARH End";			 // valName_idx = 6
	const string ANTIRECOILH_TIME         = "ARH Time";			 // valName_idx = 7
    // modName_idx = 2
    const string RATE_OF_FIRE             = "Rounds/sec";	     // valName_idx = 8
	// modName_idx = 3
	const string NOTORIOUSPOLAR   = "HeadShot";                      // valName_idx = 9
	const string NOTORIOUSASSIST  = "AimAbuse";                      // valName_idx = 10
	const string NOTORIOUSPROG    = "Flickspeed"                    // valName_idx = 11
	// modName_idx = 4
	const string AIMBOOST                 = "Aim Speed";         // valName_idx = 12
    const string AIMCORRECT               = "Correction";        // valName_idx = 13
    const string AIMPERFECT               = "Perfection" ;       // valName_idx = 14
    // modName_idx = 5
    const string POLAR_RADIUS1             = "Radius";            // valName_idx = 15
    const string POLAR_TIME                = "Steps";             // valName_idx = 16
    // modName_idx = 6
    const string STICKYAIM_SIZE           = "Size";              // valName_idx = 17
    const string STICKYAIM_TIME           = "Time";              // valName_idx = 18
    // modName_idx = 7
	const string ENEMYPINGBYFIRE          = "TrackTime";        // valName_idx = 19 
	// modName_idx = 8
	const string QUICKSCOPESPEED          = "QScopeDelay";       // valName_idx = 20
// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
	define AMOUNT_OF_VALNAME_IDX = 20;
	
	/// ====== MODEDIT 2 === VALNAME2_IDX 
 
   const string RADIUS1    = "Radius";                          // valName2_idx = 0
   const string ANGLE1     = "Angle";                           // valName2_idx = 1
   const string BOOST     = "Boost";                            // valName2_idx = 2
   const string SHAKE     = "Shake";                            // valName2_idx = 3
   const string INPUT     = "Input";                            // valName2_idx = 4
   const string RELEASE   = "Release";                          // valName2_idx = 5
   const string KILLPLUS  = "NOTORIOUS + ";                     // valName2_idx = 6
   const string KILLMIN   = "NOTORIOUS - ";                     // valName2_idx = 7
   const string RELEASE1  = "Release";                          // valName2_idx = 8
   const string POS       = "Pos +";                            // valName2_idx = 9
   const string NEG       = "Neg -";                            // valName2_idx = 10
   const string WAIT      = "Wait";                             // valName2_idx = 11          
   const string PRELEASE  = "Release";                          // valName2_idx = 12
   int valName2_idx; 
  
   define AMOUNT_OF_VALNAME2_IDX = 12;  /// Amount of valName2_idx  
   
    int antirecoil_vertical[2]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
	int antirecoil_horizontal[2];
	int antirecoil_start[2]; 
	int antirecoil_end[2];
	int antirecoil_time[2];
	int antirecoilH_start[2];
	int antirecoilH_end[2];
	int antirecoilH_time[2];
	int rate_of_fire[2];


/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
	int profile_idx; 
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Multi toggles
	int toggle_legacyar[2];  //NoozBar Standard Anti-recoil 
	int toggle_antirecoilh[2] // Batts Vertical Antirecoil - NoozBar Veritcal & Horizontal Progressive Anti-Recoil
	int toggle_rapidfire[2];  // NoozBar Rapid Fire
	
// Amount of profiles - Used for switch profiles cycle
	define AMOUNT_OF_PROFILES = 2;  
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 3;
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Anti-Recoil Variables
    int i_val;                                                        
	int i_pnt;                                                        
	int i_num;                                                        
	int i_cnt;                                                        
	int v,ar_y;
	int invert; // -1 for inverted, 1 for standard
	// Horizontal
    int i_val_h;
    int i_pnt_h;
    int i_num_h;
    int i_cnt_h;
    int v_x,ar_x;                                                                                                                                                                                
 // EnemyPing & Easy Plates // Credit to who done these codes :) 
    int enemy_ping;
    int pingonfire;
    int easy_plate;
    int toggle_BOUNCE_SHOT;
    int toggle_proneshot;
    int toggle_bunnyhop; 
    int Prone_Speed = 80; //Prone On Shot - How long before you prone
	int DS_Speed = 60; //Drop Shot
// Toggles
    int autorun_on;
    int swap_on;
    int inverted_on;
    int cancel_slide; 
// NOTORIOUS Triple Aim
    define PRX		  = POLAR_RX;
    define PRY		  = POLAR_RY;
    define RS         = POLAR_RS;
    define VIB_A      = RUMBLE_A;
    define X          = PS4_RX;                                    
    define Y          = PS4_RY;
    int NOTORIOUS_AIM_ASSIST;   
    int PROGRESSION_ASSIST;
    int POLAR_ASSIST;  
 //PROGRESSION ASSIST SETTINGS
    define AAMIN  = -6;// MINIMUM VALUE  
    define AAMAX  =  6;// MAXIMUM VALUE  
    define AAVAL  =  6;// STEPS   
    define AAWMIN =  1;// MIN WAIT   
    define AAWMAX =  2;// MAXIMUM WAIT   
    define AAWVAL =  1;// STEPS
// DON'T TOUCH THESE BELOW
    int D_AS;
    int AS = AAMIN;  
    int AW = AAWMIN;
    int PROG;
    int AAS = 1;   
    int AAD = 1;
//POLAR ASSIST SETTINGS
    int RADIUS;
    int ANGLE;
    int POLAR_BOOST;
    int POLAR_SHAKE;
    int A_B_S;
    int POLAR_RELEASE;
    int POLAR_RADIUS,POLAR_ANGLE,SPEED;
//NOTORIOUS ASSIST VALUES
    int NOTORIOUS_ASSIST_RELEASE;
    define VMCR   =  0;// DEFAULT VM SPEED
    int D__AS;  
    int D__AS1    =  4; // INVERT DIRECTION VALUE
    int D___AS;
    int D_AS1;  
//POLAR CONDITIONS
    define ACTIVE_WHEN_ADS    =  TRUE;// POLAR ASSSIT PRESSING AIM
    define ACTIVE_WHEN_FIRING =  TRUE;// POLAR ASSSIT ACTIVE BY ONLY PRESSING FIRE OR AIM & FIRE                    
    define POLAR_BOOST_FIRE      =  TRUE;   
    define POLAR_SHAKE_FIRE      =  TRUE;
    int VM                    =  TRUE;// VM SPEED CONTROL ( CHANGES PATTERN AND SPEED )   
    int POSI          =   0;    
    int NEGI          =   0;        
    int WA            =   0;          
    int PROG_RELEASE  =   15;   
// AIM ABUSE NEW      
   int EXTREME_AIMABUSE_on;
   define Sampling_Time = 10;
   int Aim_Boost;
   int Aim_Correction;
   int Aim_Perfection_Limit;
   define POS_Aim_Limit = 70;//70; //75
   define NEG_Aim_Limit = -70;//-70; //75
   define POS_Micro_MVT_Limit = 25;
   define NEG_Micro_MVT_Limit = -25;
   int X_Last_Value     = 0;
   int Y_Last_Value     = 0;
   int X_Current_Value  = 0;
   int Y_Current_Value  = 0;
   int Sampling_Done = FALSE;
   int spiroide_pulse = 0;
   int fine_pulse = 0;
   int Joystick_calibration = FALSE;
   int RX_Axis_Joystick_calibrate = 0; 
   int RY_Axis_Joystick_calibrate = 0;
// NOTORIOUS Polar Aim
   int RADIUS2; 
   int STEPS;          
   define STEP_INTERVAL =  1;                            
   define VM_INTERVAL   = -2; 
   int time;                                             
   int angle, cos_angle, sin_angle;                      
   int actual_X, actual_Y, actual_Magnitude, max_Magnitude;
   int polar_aim;
   const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,    
   80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7, 
   6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,  
   -60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95, 
   -96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,   
   -96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61, 
   -59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,
   9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,
   82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; 
// Sticky Aim 
   int sticky_aim;
   int stickyaim_size;
   int stickyaim_time;
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for function number_to_string() 
	int i;
	int c,c_val;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//    Blue      Pink    SkyBlue    Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//   Yellow    White      Red       OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_black;
    
// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int ModEdit2; 
	int KillSwitch;
	int toggle_holdbreath; // NOTORIOUS Hold Breath
	int toggle_quickscope;
	int quickscopedelay;
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil values                                                 
	int AntirecoilVertical; 
	int AntirecoilHorizontal;
	//int invert; // -1 for inverted, 1 for standard

// RapidFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
// Counter
	int count_black; // for screen saver
// Profiles
	int profile_1or2; // Profile 1 and 2
// Double tap 
    int q;											
    int double__tap[30];
    init {
    while(q < 30) 
    {double__tap[q] = -1;       
    q++;}}
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
init{
// Profile 1
	// Toggles 
	// Values
	toggle_legacyar[0]       = get_pvar(SPVAR_1, 0, 1, 0 );     antirecoil_vertical[0]   = get_pvar(SPVAR_4, -99, 99, 0);
	toggle_antirecoilh[0]    = get_pvar(SPVAR_2, 0, 1, 0 );     antirecoil_horizontal[0] = get_pvar(SPVAR_5, -99, 99, 0);
    toggle_rapidfire[0]      = get_pvar(SPVAR_3, 0, 1, 0 );     antirecoil_start[0]      = get_pvar(SPVAR_6,  -99, 99, 0);         
                                                                antirecoil_end[0]        = get_pvar(SPVAR_7,  -99, 99, 0);         
                                                                antirecoil_time[0]       = get_pvar(SPVAR_8,  -99, 99, 0);
                                                                antirecoilH_start[0]     = get_pvar(SPVAR_9,  -99, 99, 0);
	                                                            antirecoilH_end[0]       = get_pvar(SPVAR_10, -99, 99, 0);
	                                                            antirecoilH_time[0]      = get_pvar(SPVAR_11, -99, 99, 0);	
	                                                            rate_of_fire[0]          = get_pvar(SPVAR_12,  1, 25, 1);
// Profile 2 ===================================================================================================================
	// Toggles                                                  // Values
    toggle_legacyar[1]       = get_pvar(SPVAR_13, 0, 1, 0 );    antirecoil_vertical[1]   = get_pvar(SPVAR_16, -99, 99, 0);
	toggle_antirecoilh[1]    = get_pvar(SPVAR_14, 0, 1, 0 );    antirecoil_horizontal[1] = get_pvar(SPVAR_17, -99, 99, 0);
    toggle_rapidfire[1]      = get_pvar(SPVAR_15, 0, 1, 0 );    antirecoil_start[1]      = get_pvar(SPVAR_18,  -99, 99, 0);         
	                                                            antirecoil_end[1]        = get_pvar(SPVAR_19,  -99, 99, 0);         
                                                                antirecoil_time[1]       = get_pvar(SPVAR_20,  -99, 99, 0);
                                                                antirecoilH_start[1]     = get_pvar(SPVAR_21,  -99, 99, 0);
	                                                            antirecoilH_end[1]       = get_pvar(SPVAR_22, -99, 99, 0);
	                                                            antirecoilH_time[1]      = get_pvar(SPVAR_23, -99, 99, 0);	
	                                                            rate_of_fire[1]          = get_pvar(SPVAR_24,  1, 25, 1);
	
                                                              
// Misc	
											// Values
                                                                Aim_Boost                = get_pvar(SPVAR_49,  1, 15, 10 ); 
                                                                Aim_Correction           = get_pvar(SPVAR_50,  1, 15, 5  );
    POLAR_ASSIST        = get_pvar(SPVAR_25, 0, 1, 0    );      Aim_Perfection_Limit     = get_pvar(SPVAR_51,  1, 60, 30 );
    NOTORIOUS_AIM_ASSIST     = get_pvar(SPVAR_26, 0, 1, 0    );      RADIUS2                  = get_pvar(SPVAR_52,  1, 99, 20 );
                                                                STEPS                    = get_pvar(SPVAR_53,  1, 99, 15 );
    PROGRESSION_ASSIST  = get_pvar(SPVAR_27, 0, 1, 0    );      stickyaim_size           = get_pvar(SPVAR_54,  1, 50, 20 );
    RADIUS              = get_pvar(SPVAR_28, 1, 100, 8  );      stickyaim_time           = get_pvar(SPVAR_55,  1, 99, 20 );
    ANGLE               = get_pvar(SPVAR_29, 1, 50, 20  );      quickscopedelay          = get_pvar(SPVAR_56,  50,600,350);
    POLAR_BOOST         = get_pvar(SPVAR_30, 1, 30, 5   );      toggle_BOUNCE_SHOT          = get_pvar(SPVAR_57,  0, 1, 0   );
    POLAR_SHAKE         = get_pvar(SPVAR_31, 1, 50, 20  ); 
    A_B_S               = get_pvar(SPVAR_32, 1, 5, 2    );
    POLAR_RELEASE       = get_pvar(SPVAR_33, 1, 50, 15  ); 
    D___AS              = get_pvar(SPVAR_34, -35, 35, 5 ); 
    D_AS1               = get_pvar(SPVAR_35, -35, 35, -5): 
    NOTORIOUS_ASSIST_RELEASE = get_pvar(SPVAR_36, 1, 100, 50 ); 
    EXTREME_AIMABUSE_on        = get_pvar(SPVAR_37, 0, 1, 0    );
    polar_aim           = get_pvar(SPVAR_38, 0, 1, 0    );
    sticky_aim          = get_pvar(SPVAR_39, 0, 1, 0    ); 
    enemy_ping          = get_pvar(SPVAR_40, 0, 1, 0    );
    pingonfire          = get_pvar(SPVAR_41, 0, 1, 0    ); 
    easy_plate          = get_pvar(SPVAR_42, 0, 1, 0    );
    cancel_slide        = get_pvar(SPVAR_43, 0, 1, 0    );  
    autorun_on          = get_pvar(SPVAR_44, 0, 1, 0    ); 
    swap_on             = get_pvar(SPVAR_45, 0, 1, 0    );
    inverted_on         = get_pvar(SPVAR_46, 0, 1, 0    );
    toggle_quickscope   = get_pvar(SPVAR_47, 0, 1, 0    );
    toggle_holdbreath   = get_pvar(SPVAR_48, 0, 1, 0    ); 
    toggle_proneshot    = get_pvar(SPVAR_58, 0, 1, 0    );         
	toggle_bunnyhop     = get_pvar(SPVAR_59, 0, 1, 0    ); 
   
}

main {
// Debug - Device Monitor
	set_val(TRACE_3,   D___AS); 
	set_val(TRACE_4, D_AS1); 
	//set_val(TRACE_3, profile_idx);
	//set_val(TRACE_4, valName2_idx);
	//set_val(TRACE_5, RADIUS);
	//set_val(TRACE_6, DG_AS);
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
        if(get_console() == PIO_PS4) // If PS4 console:
        {
            swap(PS4_SHARE,PS4_TOUCH); // View = TouchPad
        
                if(get_val(PS4_R3) && event_press(PS4_TOUCH)) //  RS + View = ScreenShot
                {
                    set_val(PS4_SHARE,100);
                    set_val(PS4_TOUCH,0);
                    set_val(PS4_R3,0);
                }
        }
	}

// Display Script Title    
    if(display_title)
    {
    	cls_oled(0);	// clear OLED screen
    	count_black = 0;// reset screen saver counter
    	
    	if(KillSwitch)
    	{
    		printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),8,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);	// display OFF centered in X 
			                                     // display Battery
		}
    	else
    	{
    	   printf(5, 5, 1, 1, TITLE[0]);
   
           printf(16, 27, 0 , 1, MW[0]);

           printf(40, 38, 0, 1, COLDWAR[0]);
          
    	// Display profile name
    		if(profile_idx == 0)
    		   printf(25, 47, 1, 1, PROFILE_1[0]);
    		if(profile_idx == 1)
    		   printf(16, 47, 1, 1, PROFILE_2[0]);
    	
    	
    		display_black = TRUE;	// screen saver
    		display_title = FALSE;
    	}
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
    	count_black += get_rtime();
    	if(count_black >= 5000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    	}
    }

  
	if(get_val(PS4_L2))
	{
	// Kill Switch	
		if(event_release(PS4_SHARE))
		{
			KillSwitch = !KillSwitch;
			
			if(KillSwitch)        
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			else
				combo_run(RUMBLE_ON);	// rumble and LED blink
			
    		//display_black = FALSE;
			display_title = TRUE;
		}


	// toggle ModMenu ON/OFF
		if(event_release(PS4_OPTIONS) && !KillSwitch)
		{
			ModMenu = !ModMenu;
			
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				ModEdit2 = FALSE; //save ();				// save function
				//combo_run(EXIT_SAVE);	// rumble, blink and display SAVED then display TITLE
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
		}
		set_val(PS4_SHARE, 0);		    // block
		set_val(PS4_OPTIONS, 0);		// block
	} // L2 end

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
if(!KillSwitch)
{
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
if(ModMenu)
	{
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            MOD EDIT                                               |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 


		if(modName_idx <= LAST_EDITABLE_STRING)	// if ANTIRECOIL 
		{		   
			if(event_press(PS4_CROSS) && !ModEdit && !ModEdit2) // Turn ModEdit2 ONif(ModEdit &&
			{
				
				valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // I don't verify if it's true
				ModEdit = TRUE; // you are in mod edit 2
				combo_run(RUMBLE_ON);
				display_new = TRUE;
			}
			
			if(event_press(PS4_CIRCLE) && ModEdit && !ModEdit2) // Turn ModEdit2 OFF
			{
				ModEdit = FALSE; // you leave mod edit2 and return mod edit
				combo_run(RUMBLE_OFF);
				display_new = TRUE;
			}
		}
        /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                          EDIT VALUES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
       if(ModEdit) 
       { 
       
       		if(valName_idx>=9 && valName_idx<=11)  // // if ver 5.3 or ver 7.0 is displayed
       		//if(modName_idx == 1)
        	{
         		if(event_press(PS4_CROSS) && !ModEdit2) // Turn ModEdit2 ON
				{
					valName2_idx = AMOUNT_OF_VALNAME2_IDX + 1; 
					ModEdit2 = TRUE; // you are in mod edit 2
					combo_run(RUMBLE_ON);
					display_new = TRUE;
				}
			
				if(event_press(PS4_CIRCLE) && ModEdit2) // Turn ModEdit2 OFF
				{
					ModEdit2 = FALSE; // you leave mod edit2 and return mod edit
					combo_run(RUMBLE_OFF);
					display_new = TRUE;
				}
			}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                          EDIT VALUES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
            
	// ModEdit ON
		if(ModEdit2)
		{
			if(get_val(PS4_L2))
				{ 
					
					 RADIUS               = edit_val(valName2_idx,0 , RADIUS                  , 0 , 99 , 1 , 10   );       // valName2_idx 0
					 ANGLE                = edit_val(valName2_idx,1 , ANGLE                   , 0 , 99 , 1 , 10   );     // valName2_idx 1
					 POLAR_BOOST          = edit_val(valName2_idx,2 , POLAR_BOOST             , 30  ,30,  1 , 10   );       // valName2_ idx 2
					 POLAR_SHAKE          = edit_val(valName2_idx,3 , POLAR_SHAKE             , 0 , 50 , 1 , 10   );       // valName2_ idx 2
					 A_B_S                = edit_val(valName2_idx,4 , A_B_S                   , 0 , 5 , 1 , 10   );       // valName2_ idx 2
					 POLAR_RELEASE        = edit_val(valName2_idx,5, POLAR_RELEASE          , 0 , 50 , 1 , 10   );       // valName2_ idx 2
					 D___AS               = edit_val(valName2_idx,6 , D___AS                  , 35 , 35 , 1 , 10   );       // valName2_ idx 2
					 D_AS1                = edit_val(valName2_idx,7 , D_AS1                   , 35 , 35 , 1 , 10   );       // valName2_ idx 2
					 NOTORIOUS_ASSIST_RELEASE  =	edit_val(valName2_idx,8, NOTORIOUS_ASSIST_RELEASE     , 0  , 100, 1 , 10 ); 
					 POSI               = edit_val(valName2_idx,9, POSI                    , 30 , 30 , 1 , 10 ); 
					 NEGI               = edit_val(valName2_idx,10, NEGI                    , 30 , 30 , 1 , 10 ); 
					 WA                 = edit_val(valName2_idx,11, WA                      , 2  , 100, 1 , 10 ); 
				     PROG_RELEASE       = edit_val(valName2_idx,12, PROG_RELEASE            , 8  , 90 , 1 , 10 ); 
					 
					 
					 
				} 
				else
				{
				     
				
	     			if(event_press(PS4_RIGHT))
					{
						valName2_idx += 1;
						display_new = TRUE; // Display value name and value
					}
					
					if(event_press(PS4_LEFT))
					{
						valName2_idx -= 1;
						display_new = TRUE;
					}	
				
	         		if(valName_idx == 9)vals_available1( 0, 5);     // valName = 6 == press CROSS/A to enter ModEdit2 = 2 valName2_idx to edit
		    		if(valName_idx == 10)vals_available1(6, 8); 
		    		if(valName_idx == 11)vals_available1(9, 12); // valName = 7 == press CROSS/A to enter ModEdit2 = 1 valName2_idx to edit
			       
				}
    		} // mod edit 2 end
			else // if not modedit 2
			{
		
			if(get_val(PS4_L2)) // Edit value: hold L2 + UP (+1) or DOWN (-1) or RIGHT (+10) or LEFT (-10)
			{
			// Mods that can have different values depending the active Profile
			
    		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], abs(range min) , range max ); 	
			    antirecoil_vertical[profile_idx]   = edit_val(valName_idx, 0 , antirecoil_vertical[profile_idx]  , 0  ,   99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
				antirecoil_horizontal[profile_idx] = edit_val(valName_idx, 1 , antirecoil_horizontal[profile_idx], 99 ,   99 , 1 , 10   );
				antirecoil_start[profile_idx]      = edit_val(valName_idx, 2 , antirecoil_start[profile_idx]     , 0 , 99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
				antirecoil_end[profile_idx]        = edit_val(valName_idx, 3 , antirecoil_end[profile_idx]       , 0 , 99 , 1 , 10   ); // the 2 last numbers are range min and range max
				antirecoil_time[profile_idx]       = edit_val(valName_idx, 4 , antirecoil_time[profile_idx]      , 0 , 99 , 1 , 10   ); // only ar_t display value x100 (real time in ms) - so 99 display 9,900 so 9.9 seconds 
			    antirecoilH_start[profile_idx]     = edit_val(valName_idx, 5 , antirecoilH_start[profile_idx]    ,99 , 99 , 1 , 10   ); 
				antirecoilH_end[profile_idx]       = edit_val(valName_idx, 6 , antirecoilH_end[profile_idx]      ,99 , 99 , 1 , 10   ); 
				antirecoilH_time[profile_idx]      = edit_val(valName_idx, 7 , antirecoilH_time[profile_idx]     , 0 , 99 , 1 , 10   );
			    rate_of_fire[profile_idx]          = edit_val(valName_idx, 8 , rate_of_fire[profile_idx]         ,  1 ,   25 , 1 , 10   );
			    Aim_Boost                          = edit_val(valName_idx, 12 , Aim_Boost                        , 0 , 10   , 1  , 10   ); 
                Aim_Correction                     = edit_val(valName_idx, 13, Aim_Correction                    , 0 , 10   , 1  , 10   ); 
                Aim_Perfection_Limit               = edit_val(valName_idx, 14, Aim_Perfection_Limit              , 0 , 60   , 1  , 10   );
			    RADIUS2                             = edit_val(valName_idx, 15 , RADIUS2                , 0 , 99   , 1  , 10   );
                STEPS                              = edit_val(valName_idx, 16 , STEPS                 , 0 , 99   , 1  , 10   ); 
			    stickyaim_size                     = edit_val(valName_idx, 17 , stickyaim_size        , 0 , 50   , 1  , 10   );
                stickyaim_time                     = edit_val(valName_idx, 18 , stickyaim_time        , 0 , 990  , 1  , 10   );
                quickscopedelay                    = edit_val(valName_idx, 20 , quickscopedelay      , 0 , 600  , 1  , 10   ); 
			}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        VALUES AVAILABLE                                           |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

			else // NOT L2 (if not editing value)
			{
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
					display_new = TRUE; // Display value name and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
					display_new = TRUE;
				}
				    POLAR_ASSIST = toggle(valName_idx , 9, POLAR_ASSIST );
					NOTORIOUS_AIM_ASSIST = toggle(valName_idx , 10, NOTORIOUS_AIM_ASSIST );
                    PROGRESSION_ASSIST = toggle(valName_idx, 11, PROGRESSION_ASSIST); 
                    pingonfire             = toggle(valName_idx, 19, pingonfire );
			// Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
			 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
				if(modName_idx == 0) vals_available( 0 , 1  );// Anti-Recoil		
				if(modName_idx == 1) vals_available( 2 , 7  );// Noozbar/Batts Progressive Antirecoil            				
				if(modName_idx == 2) vals_available( 8 , 8 );// Rapid Fire			
				if(modName_idx == 3) vals_available( 9, 11 ); 
				if(modName_idx == 4) vals_available(12, 14 ); 
				if(modName_idx == 5) vals_available(15, 16 );
				if(modName_idx == 6) vals_available(17, 18 ); 
				if(modName_idx == 7) vals_available(19, 19 ); 
				if(modName_idx == 8) vals_available(20, 20 ); 
				
			
			} // NOT SQUARE (if not editing value) end
		} // ModEdit end
    } 
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            TOGGLES                                                |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

		else // if NOT ModEdit BUT if ModMenu
		{
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx += 1;
				display_new = TRUE;
			}
			if(event_press(PS4_LEFT))
			{
				modName_idx -= 1;
				display_new = TRUE;
			}
			
		// Cycle mods name
			if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
				modName_idx = 0;
			if(modName_idx < 0)
				modName_idx = LAST_MODNAME_STRING;
				
		// Switch profiles	
			if(event_press(PS4_TRIANGLE))
			{
				profile_idx += 1;
				display_new = TRUE;
			}
		// Cycle profiles	
			if(profile_idx > (AMOUNT_OF_PROFILES - 1))
				profile_idx = 0;
			
		// Toggles (UP to turn ON, DOWN to turn OFF)
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			toggle_legacyar  [profile_idx] = toggle(modName_idx, 0, toggle_legacyar[profile_idx] );
			toggle_antirecoilh[profile_idx]= toggle(modName_idx, 1, toggle_antirecoilh[profile_idx] ); 
			toggle_rapidfire[profile_idx]  = toggle(modName_idx, 2, toggle_rapidfire[profile_idx]  );
			EXTREME_AIMABUSE_on                   = toggle(modName_idx, 4, EXTREME_AIMABUSE_on                   );
			polar_aim                      = toggle(modName_idx, 5, polar_aim                      );
			sticky_aim                     = toggle(modName_idx, 6, sticky_aim                     );
            enemy_ping                     = toggle(modName_idx, 7, enemy_ping                    ); 
            toggle_quickscope              = toggle(modName_idx, 8, toggle_quickscope             ); 
            toggle_holdbreath              = toggle(modName_idx, 9, toggle_holdbreath             ); 
            easy_plate                     = toggle(modName_idx, 10, easy_plate                    )
            cancel_slide                   = toggle(modName_idx, 11, cancel_slide ); 
            toggle_proneshot               = toggle(modName_idx, 12, toggle_proneshot ) ;
            toggle_BOUNCE_SHOT                = toggle(modName_idx, 13, toggle_BOUNCE_SHOT ); 
            toggle_bunnyhop                = toggle(modName_idx, 14, toggle_bunnyhop );  
		  //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
			autorun_on  = toggle(modName_idx, 15 , autorun_on  );
			swap_on     = toggle(modName_idx, 16 , swap_on     );
			inverted_on = toggle(modName_idx, 17 , inverted_on );
		} // if NOT ModEdit BUT if ModMenu end
		
	// If ModMenu AND ModEdit
		if(event_press(PS4_PS))
			save ();
			
		//block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
		block_all_inputs();
		
	} // ModMenu ON end


							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                              NOT MOD MENU AND NOT MOD EDIT                                             |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — */	 
	if(!ModMenu)
	{
	
		if(swap_on) // (6)
		{
			swap(PS4_R1, PS4_R2);
			swap(PS4_L1, PS4_L2);
		}
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        SPEED TOGGLES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	// Speed Toggles
	
	    //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2 300ms   , toggle_I_want_to_edit[profile] , corresponding modName_idx );
		  toggle_rapidfire[profile_idx]  = speed_toggle( PS4_L2, PS4_UP   , toggle_rapidfire[profile_idx] , 2 );
		//toggle_burstfire[profile_idx]  = speed_toggle( PS4_L2, PS4_DOWN , toggle_burstfire[profile_idx] , 2 );
		//toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT, toggle_aimassist[profile_idx] , 3 );
		//toggle_strafeShot[profile_idx] = speed_toggle( PS4_L2, PS4_LEFT , toggle_strafeShot[profile_idx], 4 );
		// We can add as many speed toogle as we need

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	
	// Hair Trigger
   	deadzone(PS4_L2,PS4_R2,99,99);
    

	POLAR_RADIUS = RADIUS;
	POLAR_ANGLE  = ANGLE;
	
if (PROGRESSION_ASSIST && get_val(PS4_L2) >= 80) {
if (!combo_running(AAS)) {
	AS = PROGRESSION(AS,AAMIN + NEGI,AAMAX + POSI,AAVAL,AAS,1);
    AW = PROGRESSION(AW,AAWMIN,AAWMAX,AAWVAL,AAD,2);
    combo_run(AAS);
    	}
if (abs(get_val(PS4_RY))> PROG_RELEASE || abs(get_val(PS4_RX)) > PROG_RELEASE) {
	combo_stop(AAS);
	}
}
if (POLAR_ASSIST && get_val(PS4_L2) && abs(get_ival(PS4_RX)) <= POLAR_RELEASE && abs(get_ival(PS4_RY)) <= POLAR_RELEASE) {
if (POLAR_BOOST_FIRE && get_val(PS4_R2)) {
	POLAR_RADIUS = POLAR_RADIUS + POLAR_BOOST;
	}
	else {
	POLAR_RADIUS = POLAR_RADIUS;
	}
if (POLAR_SHAKE_FIRE && get_val(PS4_R2)) {
	POLAR_ANGLE = POLAR_ANGLE + POLAR_SHAKE;
	}
	else {
	POLAR_ANGLE = POLAR_ANGLE;
	}    
    set_polar(POLAR_RS,SPEED = (SPEED + POLAR_ANGLE) % 360,abs(get_ival(POLAR_RX)) / A_B_S + POLAR_RADIUS * 328);
}



if (NOTORIOUS_AIM_ASSIST && abs(get_val(PS4_RX)) < NOTORIOUS_ASSIST_RELEASE && abs(get_val(PS4_RY)) < NOTORIOUS_ASSIST_RELEASE) {
if (get_val(PS4_L2) > 80) {
	D_AS = TRUE;
	AIM();
}
if (event_release(PS4_L2) || event_release(PS4_R2)){
	D_AS = FALSE;
	vm_tctrl(VMCR); 
	}
}

 if (EXTREME_AIMABUSE_on) 
 {
          if (Joystick_calibration == FALSE)
          {
                RX_Axis_Joystick_calibrate = get_val(PS4_RX); 
                RY_Axis_Joystick_calibrate = get_val(PS4_RY); 
                Joystick_calibration = TRUE;     
          }
        X_Last_Value = X_Current_Value;
        Y_Last_Value = Y_Current_Value;
        X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(PS4_RY)- RY_Axis_Joystick_calibrate;
            //--LT pulled 
        if(get_val(PS4_L2)) 
        {
            //--current & last value less than limit   
                if(abs(X_Current_Value) <= POS_Micro_MVT_Limit && abs(Y_Current_Value) <= POS_Micro_MVT_Limit) 
                {
                    //--both have a value        
                    //if(X_Last_Value && X_Current_Value) 
                        //{
                        //--difference between the 2 values less than 15         
                        if(abs(X_Last_Value - X_Current_Value) < 15) 
                        {
                                combo_stop(Aim_Assist_Perfection);
                                Sampling_Done = FALSE;
 
                                //--RT pulled more than 95%
                                if(get_val(PS4_R2) > 95) 
                                {
                                        combo_stop(Fine_Tune_Aim);
                                        fine_pulse = 0;
                                        combo_run(spiroide_Aim_Assit);
                                }
                                else
                                {
                                        combo_stop(spiroide_Aim_Assit);
                                        spiroide_pulse = 0;
                                        combo_run(Fine_Tune_Aim);
                                }    
                       }
                    //}
                }
                //--current and last greater than limit             
                else if(abs(X_Current_Value) <= POS_Aim_Limit && abs(Y_Current_Value) <= POS_Aim_Limit) 
                {
                        combo_stop(Fine_Tune_Aim);
                        combo_stop(spiroide_Aim_Assit);
                        spiroide_pulse = 0;
                        fine_pulse = 0;
                        combo_run(Aim_Assist_Perfection);
               }
        }
        else //--LT not pulled
        {
                combo_stop(Fine_Tune_Aim);
                combo_stop(spiroide_Aim_Assit);
                combo_stop(Aim_Assist_Perfection);
                spiroide_pulse = 0;
                fine_pulse = 0;
                Sampling_Done = FALSE;    
              }
           
     
 	  } 	
 	  if(polar_aim){
    
      vm_tctrl(VM_INTERVAL); 
                         
      actual_X = get_val(X);   
      actual_Y = get_val(Y);           
      actual_Magnitude = isqrt(pow(actual_X, 2) + pow(actual_Y, 2));  
      max_Magnitude = (actual_Magnitude < 100);                      
                                                                  
      if(!(time++ % STEP_INTERVAL)){                                  
	         angle += STEPS;                                                 
      }                                                               
      angle = angle % 360;                                            
      sin_angle = Polar_Array[angle % 360];                           
      cos_angle = Polar_Array[(angle + 270) % 360];                  
      cos_angle = (cos_angle * RADIUS2) / 100;                         
      sin_angle = (sin_angle * RADIUS2) / 100;                          
                                                                         
      if((ACTIVE_WHEN_ADS && get_val(PS4_L2)) || (ACTIVE_WHEN_FIRING && get_val(PS4_R2))){ 
           if(actual_Magnitude <= RADIUS2){                                                      
                sin_angle -= actual_Y;                                                              
                cos_angle -= actual_X;                                                                 
           }else {                                                                                       
                sin_angle = (sin_angle * (200 - ((abs(actual_Y) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude; 
                cos_angle = (cos_angle * (200 - ((abs(actual_X) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude; 
           }                                                  
           set_val(X, calculate(actual_X + cos_angle, -100, 100));
           set_val(Y, calculate(actual_Y + sin_angle, -100, 100)); 
      }
      else
       vm_tctrl(0); 
  } 
    if(sticky_aim)
    {
    if(get_val(PS4_L2))
    combo_run(STICKY_AIM);
    else 
    combo_stop(STICKY_AIM); 
    } 
 	 
    if(enemy_ping)
    {
	  if(get_ival(PS4_L2)&&double_click(PS4_UP))
	      combo_run(TRACKING);        
      
    }
    if(enemy_ping && pingonfire)
    { 
     if(event_press(PS4_R2))
        combo_run(TRACKING); 
    }  
    
    if(toggle_quickscope)
    {
      if(event_release(PS4_L2) && get_ptime(PS4_L2) < 140)
          combo_run(Quick_Scope);
    }
    
    if(toggle_holdbreath)
   {
          if(get_val(PS4_L2))
               set_val(PS4_L3,100);
                      
          if(get_val(PS4_LY) <-90 && get_val(PS4_L2) && get_ptime(PS4_L2) > 200)
              combo_stop(CH);       
                    
          if(event_press(PS4_L2)) 
              combo_run(CH);
  
          if(get_val(PS4_L2) && get_lval(PS4_L3)) 
              set_val(PS4_L3,0);       
   }
    
    if(easy_plate)
    {
	if(get_val(PS4_TRIANGLE)&&get_ptime(PS4_TRIANGLE)>350)
		  combo_run(easy_plate);
		    
	if(get_val(PS4_L2)>10 || get_val(PS4_R2)>10 || get_val(PS4_SQUARE))
		  combo_stop(easy_plate);	
    }
    
	if(cancel_slide)  
    {                                                                                                  
    	if((get_val(PS4_LY) < -60) || (get_val(PS4_LY) > 60) || (get_val(PS4_LX) < -60) || (get_val(PS4_LX) > 60))
    	{
		      if(event_release (user_defined_crouch_button))
		         combo_run(CANCEL_SLIDE)                                            
	    }                                               
                                               
	} 		
if(toggle_proneshot) 
 { 
     if(get_val(PS4_R2) && get_ptime(PS4_R2) > Prone_Speed)
          set_val(user_defined_crouch_button,100);
          
 }
 
 if(toggle_BOUNCE_SHOT) 
 { 
     if(get_val(PS4_R2))
            combo_run(DS);
 }
 
 if(toggle_bunnyhop) 
 { 
     if (get_ival(user_defined_jump_button) && get_ptime(user_defined_jump_button) > 200) {
             combo_run(BUNNYHOP); 
     }        
             
 }  	
	
	if(inverted_on) // (7)
			invert = -1;
		else
			invert = 1;
			
			if(autorun_on) // (5)
		{
    		if(get_val(PS4_LY) < -60)
    		{
    	    	set_val(PS4_LY, -100);
    	    	set_val(PS4_L3, 100);
    		}
		}	
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                     SWITCH PROFILE                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
      //if(get_ptime(PS4_TRIANGLE)>600&&event_release(PS4_TRIANGLE))
      	if(one_button_press)
			{
				if(event_release(profile_switch_button1)&& get_ptime(profile_switch_button1)<150)
        		{
        	    	profile_1or2=!profile_1or2;
     
        			if(ModMenu)
    					display_new = TRUE;
    				else
    					display_title = TRUE;
    			}
        	}
     
    	 	if(two_button_press)
           	{
           		if(get_lval(profile_switch_button2) && (event_press(profile_switch_button3)))
        		{
        	    	profile_1or2=!profile_1or2;
        	    
        			if(ModMenu)
    					display_new = TRUE;
    				else
    					display_title = TRUE;
    			}
        	}
    		if(get_val(PS4_L3))
    			set_val(PS4_TRIANGLE, 0);
     
   
        // If Profile 2
        	if(profile_1or2)
        		profile_idx = 1;
     
        // If Profile 1
        	else	
        		profile_idx = 0;

    // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    	} // ModMenu OFF end

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                   FEATURES THAT WORK EVERYTIME (MOD MENU/EDIT OR NOT)                                 |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    ANTI RECOIL (0)                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
// If Anti-Recoil is enable for the active profile
	if(toggle_antirecoilh[profile_idx] == 1)
	{
	// Antirecoil by Batts	
		// Vertical
    	if( antirecoil_start[profile_idx] < antirecoil_end[profile_idx])
    	    i_val = 1; 
    	else
    	    i_val = -1;
        
    	i_pnt = (antirecoil_time[profile_idx] * 10) / (abs(antirecoil_start[profile_idx] - antirecoil_end[profile_idx])); 
    	
    	// Horizontal		
    	if(antirecoilH_start[profile_idx] < antirecoilH_end[profile_idx])
    	    i_val_h = 1; 
    	else
    	    i_val_h = -1;
        
    	i_pnt_h = (antirecoilH_time[profile_idx] * 10) / (abs(antirecoilH_start[profile_idx] - antirecoilH_end[profile_idx])); 
    	
    	if(!get_val(PS4_R2)) 
   		{
   			// Vertical
   			ar_y = antirecoil_start[profile_idx];
   			i_cnt = 0;
   			i_num = 0;
   			
   			// Horizontal
   			ar_x = antirecoilH_start[profile_idx];
   			i_cnt_h = 0;
   			i_num_h = 0;
   		}   
    	
    	 if(get_val(PS4_L2) && get_val(PS4_R2))
    	{
   		    // Vertical
   		    if(!p_complete())  
   		        ar_y = p_val();
   		    else
   		        ar_y = antirecoil_end[profile_idx];
            
			if(y_val() < 100)
    	   		set_val(PS4_RY,y_val()); 
    	   		
    	   	// Horizontal	
   		    if(!p_complete_x())  
   		        ar_x = p_val_x();
   		    else
   		        ar_x = antirecoilH_end[profile_idx];
            
			if(x_val() < 100)
    	   		set_val(PS4_RX,x_val()); 
   		}		
	}
// If Anti-Recoil is enable for the active profile
	if(toggle_legacyar[profile_idx] == 1)
	{
		if(get_val(PS4_R2))
			combo_run(ANTIRECOIL);
		  else
			combo_stop(ANTIRECOIL);
	}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    RAPID FIRE (1)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/  
  
// If RapidFire is enable for the active profile
	if(toggle_rapidfire[profile_idx] == 1)
	{
	// Rate of Fire Calculation
    	hold_time = 500 / rate_of_fire[profile_idx]; 
   		rest_time = hold_time - 20;
    	if(rest_time < 0) rest_time = 0;
    
    // Run combo
    	if(get_val(PS4_R2))
    		combo_run(RAPIDFIRE);
    	else
    		combo_stop(RAPIDFIRE);
    		
    	led_on = 150;
    	led_off = 300;
    	combo_run(BLINK);
	}
  
  
  
 /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    REFRESH DISPLAY                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(display_new) 
	{
	// Clear OLED screen	
		cls_oled(0);
    	count_black = 0;// reset screen saver counter
			if(ModEdit2)
		{
          
	    	display_edit(valName2_idx,0 , center_x(sizeof(RADIUS1) - 1, OLED_FONT_MEDIUM_WIDTH) , RADIUS1[0] ,  RADIUS );
	    	display_edit(valName2_idx,1 , center_x(sizeof(ANGLE1) - 1, OLED_FONT_MEDIUM_WIDTH) , ANGLE1[0] ,  ANGLE );
	    	display_edit(valName2_idx,2 , center_x(sizeof(BOOST) - 1, OLED_FONT_MEDIUM_WIDTH) , BOOST[0] ,  POLAR_BOOST );
	    	display_edit(valName2_idx,3 , center_x(sizeof(SHAKE) - 1, OLED_FONT_MEDIUM_WIDTH) , SHAKE[0] ,  POLAR_SHAKE );
	    	display_edit(valName2_idx,4 , center_x(sizeof(INPUT) - 1, OLED_FONT_MEDIUM_WIDTH) , INPUT[0] ,  A_B_S );
	    	display_edit(valName2_idx,5 , center_x(sizeof(RELEASE) - 1, OLED_FONT_MEDIUM_WIDTH) , RELEASE[0] ,  POLAR_RELEASE );
	        display_edit1(valName2_idx,6 , center_x(sizeof(KILLPLUS) - 1, OLED_FONT_MEDIUM_WIDTH) , KILLPLUS[0] , D___AS );
	    	display_edit1(valName2_idx,7 , center_x(sizeof(KILLMIN) - 1, OLED_FONT_MEDIUM_WIDTH) , KILLMIN[0] ,  D_AS1 );	
	    	display_edit(valName2_idx,8 , center_x(sizeof(RELEASE1) - 1, OLED_FONT_MEDIUM_WIDTH) , RELEASE1[0] ,  NOTORIOUS_ASSIST_RELEASE );
	    	display_edit(valName2_idx,9 , center_x(sizeof(POS) - 1, OLED_FONT_MEDIUM_WIDTH) , POS[0] ,  POSI );
	    	display_edit(valName2_idx,10 , center_x(sizeof(NEG) - 1, OLED_FONT_MEDIUM_WIDTH) , NEG[0] ,  NEGI );
	    	display_edit(valName2_idx,11 , center_x(sizeof(WAIT) - 1, OLED_FONT_MEDIUM_WIDTH) , WAIT[0] ,  WA );
	    	display_edit(valName2_idx,12 , center_x(sizeof(PRELEASE) - 1, OLED_FONT_MEDIUM_WIDTH) , PRELEASE[0] ,  PROG_RELEASE );
	    	
		}
		else if(ModEdit) 
		   {  
		 
	    // Display Value Name and value
    		// Mods that can have different values depending the active Profile
    		
		  //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
			display_edit(valName_idx, 0 , center_x(sizeof(ANTIRECOIL_VERTICAL)   - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_VERTICAL[0]   , antirecoil_vertical[profile_idx]   );
			display_edit(valName_idx, 1 , center_x(sizeof(ANTIRECOIL_HORIZONTAL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_HORIZONTAL[0] , antirecoil_horizontal[profile_idx] );
			display_edit(valName_idx, 2 , center_x(sizeof(ANTIRECOIL_START)      - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0]      , antirecoil_start[profile_idx] );
            display_edit(valName_idx, 3 , center_x(sizeof(ANTIRECOIL_END)        - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_END[0]        , antirecoil_end[profile_idx]);
            display_edit(valName_idx, 4 , center_x(sizeof(ANTIRECOIL_TIME)       - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_TIME[0]       , antirecoil_time[profile_idx]  );
            display_edit(valName_idx, 5 , center_x(sizeof(ANTIRECOILH_START)     - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOILH_START[0]     , antirecoilH_start[profile_idx]);
            display_edit(valName_idx, 6 , center_x(sizeof(ANTIRECOILH_END)       - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOILH_END[0]       , antirecoilH_end[profile_idx]);
            display_edit(valName_idx, 7 , center_x(sizeof(ANTIRECOILH_TIME)      - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOILH_TIME[0]      , antirecoilH_time[profile_idx]);
            display_edit(valName_idx, 8 , center_x(sizeof(RATE_OF_FIRE)          - 1, OLED_FONT_MEDIUM_WIDTH) , RATE_OF_FIRE[0]          , rate_of_fire[profile_idx]     );
            display_mod (valName_idx, 9 , center_x(sizeof(NOTORIOUSPOLAR)             - 1, OLED_FONT_MEDIUM_WIDTH) , NOTORIOUSPOLAR[0]             , POLAR_ASSIST);
			display_mod (valName_idx,10 , center_x(sizeof(NOTORIOUSASSIST)            - 1, OLED_FONT_MEDIUM_WIDTH) , NOTORIOUSASSIST[0]            , NOTORIOUS_AIM_ASSIST );
			display_mod (valName_idx,11 , center_x(sizeof(NOTORIOUSPROG)              - 1, OLED_FONT_MEDIUM_WIDTH) , NOTORIOUSPROG[0]              , PROGRESSION_ASSIST );
		    display_edit(valName_idx,12 , center_x(sizeof(AIMBOOST)              - 1, OLED_FONT_MEDIUM_WIDTH) , AIMBOOST[0]              , Aim_Boost                     );
            display_edit(valName_idx,13 , center_x(sizeof(AIMCORRECT)            - 1, OLED_FONT_MEDIUM_WIDTH) , AIMCORRECT[0]            , Aim_Correction                );
            display_edit(valName_idx,14 , center_x(sizeof(AIMPERFECT)            - 1, OLED_FONT_MEDIUM_WIDTH) , AIMPERFECT[0]            , Aim_Perfection_Limit          );
            display_edit(valName_idx,15 , center_x(sizeof(POLAR_RADIUS1)          - 1,OLED_FONT_MEDIUM_WIDTH)  , POLAR_RADIUS1[0]          , RADIUS2                        );
            display_edit(valName_idx,16 , center_x(sizeof(POLAR_TIME)           - 1, OLED_FONT_MEDIUM_WIDTH) , POLAR_TIME[0]           , STEPS                         );
            display_edit(valName_idx,17 , center_x(sizeof(STICKYAIM_SIZE)    - 1, OLED_FONT_MEDIUM_WIDTH)    , STICKYAIM_SIZE[0]    , stickyaim_size                );
            display_edit(valName_idx,18 , center_x(sizeof(STICKYAIM_TIME)    - 1, OLED_FONT_MEDIUM_WIDTH)    , STICKYAIM_TIME[0]    , stickyaim_time                );
			display_mod1(valName_idx,19 , center_x(sizeof(ENEMYPINGBYFIRE)       - 1, OLED_FONT_MEDIUM_WIDTH) , ENEMYPINGBYFIRE[0]       , pingonfire            );
			display_edit(valName_idx,20 , center_x(sizeof(QUICKSCOPESPEED)   - 1, OLED_FONT_MEDIUM_WIDTH)  , QUICKSCOPESPEED[0]   , quickscopedelay              );
			
		}
		else
		{
	    // Display Mod Name and ON/OFF
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
			display_mod(modName_idx, 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , toggle_legacyar[profile_idx]);
			display_mod(modName_idx, 1 ,  center_x(sizeof(ANTIRECOILH) - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOILH[0]   , toggle_antirecoilh[profile_idx]);
            display_mod(modName_idx, 2 ,  center_x(sizeof(RAPIDFIRE)   - 1, OLED_FONT_MEDIUM_WIDTH)  , RAPIDFIRE[0]     , toggle_rapidfire[profile_idx]);
            display_mod2(modName_idx,3 ,  center_x(sizeof(NOTORIOUSAIM)     - 1, OLED_FONT_MEDIUM_WIDTH) , NOTORIOUSAIM[0] ); 
            display_mod(modName_idx, 4 ,  center_x(sizeof(EXTREME_AIMABUSE)     - 1, OLED_FONT_MEDIUM_WIDTH)  , EXTREME_AIMABUSE[0]   ,EXTREME_AIMABUSE_on );
            display_mod(modName_idx, 5 ,  center_x(sizeof(POLARAIM)    - 1, OLED_FONT_MEDIUM_WIDTH)  , POLARAIM[0]      , polar_aim );
            display_mod(modName_idx, 6 ,  center_x(sizeof(STICKYAIM)   - 1, OLED_FONT_MEDIUM_WIDTH)  , STICKYAIM[0]     , sticky_aim ); 
            display_mod(modName_idx, 7 , center_x(sizeof(TRACKING)   - 1, OLED_FONT_MEDIUM_WIDTH)  , TRACKING[0]     , enemy_ping); 
            display_mod(modName_idx, 8 , center_x(sizeof(QUICKSCOPE)   - 1, OLED_FONT_MEDIUM_WIDTH) , QUICKSCOPE[0]     ,toggle_quickscope);
            display_mod1(modName_idx, 9 , center_x(sizeof(HOLD_BREATH) - 1, OLED_FONT_MEDIUM_WIDTH)  , HOLD_BREATH[0]   , toggle_holdbreath);
            display_mod1(modName_idx, 10 , center_x(sizeof(EASY_PLATE)  - 1, OLED_FONT_MEDIUM_WIDTH)  , EASY_PLATE[0]    , easy_plate);
            display_mod1(modName_idx, 11, center_x(sizeof(CANCELSLIDE) - 1, OLED_FONT_MEDIUM_WIDTH) , CANCELSLIDE[0]    , cancel_slide ); 
            display_mod1(modName_idx, 12, center_x(sizeof(PRONESHOT)  - 1, OLED_FONT_MEDIUM_WIDTH)  , PRONESHOT[0]    , toggle_proneshot);
            display_mod1(modName_idx, 13, center_x(sizeof(BOUNCE_SHOT)  - 1, OLED_FONT_MEDIUM_WIDTH)  , BOUNCE_SHOT[0]    , toggle_BOUNCE_SHOT);
            display_mod1(modName_idx, 14, center_x(sizeof(BUNNYHOP)  - 1, OLED_FONT_MEDIUM_WIDTH)  , BUNNYHOP[0]    , toggle_bunnyhop);
           //  if(modName_idx == 4)
			  // display_mod1(modName_idx,4,(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);
				//printf(center_x(sizeof(NOTORIOUSAIM)   - 1, OLED_FONT_MEDIUM_WIDTH), 0, OLED_FONT_MEDIUM, OLED_WHITE, NOTORIOUSAIM[0]);	// display only Sweet Evil
               // printf(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);
                
			// Mods that have same ON/OFF status on every Profile
			display_mod1(modName_idx, 15 ,  center_x(sizeof(AUTORUN) - 1, OLED_FONT_MEDIUM_WIDTH) , AUTORUN[0] , autorun_on);
			display_mod1(modName_idx, 16 ,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)    , SWAP[0]    , swap_on);
		    display_mod1(modName_idx, 17 ,  center_x(sizeof(INVERTED) - 1, OLED_FONT_MEDIUM_WIDTH), INVERTED[0], inverted_on);
			 
                
		}
		
	// Display Profile only on mods that may have a different value depending on the Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
		{
			if(profile_idx == 0) // profile_idx = profile_idx = Profile
    			//printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
    			line_oled(0, 26, 39, 26, 5, 1); // print a line to the left to say profile 1
    		else if(profile_idx == 1)
    			//printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
    			line_oled(44, 26, 83, 26, 5, 1); // print a line in the middle to say Profile 2
    		
		}
		/*
		else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    	{
    		line_oled(0, 26, 39, 26, 5, 1);
    		line_oled(44, 26, 83, 26, 5, 1);
    		line_oled(88, 26, 127, 26, 5, 1);
    	}
    	*/
		display_black = TRUE;
        display_new = FALSE;
    } // display_new end
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
} // NOT KillSwitch end

	led(profile_idx);

} // main end
combo Aim_Assist_Perfection 
       {
        // Save the first joystick position 
        X_Last_Value = X_Current_Value
        Y_Last_Value = Y_Current_Value
 
        // Sampling frequency 
        wait(Sampling_Time);
 
        // Save the second joystick position 
        X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(PS4_RY)- RY_Axis_Joystick_calibrate; 
 
     if (Sampling_Done == TRUE )
        {
            //Applying BOOST
            //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
            Aim_Perfection(X_Last_Value, X_Current_Value, 1, 0, 1, 0 ); 
            Aim_Perfection(Y_Last_Value, Y_Current_Value, 1, 0, 0, 1 ); 
        }
 
        X_Last_Value = X_Current_Value;
        Y_Last_Value = Y_Current_Value;
 
        // Sampling frequency 
        wait(Sampling_Time);
 
        // Save the second joystick position 
        X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;
        Y_Current_Value = get_lval(PS4_RY)- RX_Axis_Joystick_calibrate; 
 
   if (Sampling_Done == TRUE )
        {
            //Applying CORRECTION
            //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS )
            Aim_Perfection(X_Last_Value, X_Current_Value, 0, 1, 1, 0 ); 
            Aim_Perfection(Y_Last_Value, Y_Current_Value, 0, 1, 0, 1 ); 
        }
 
        Sampling_Done = TRUE; 
        wait(Sampling_Time);
    }
 
combo Fine_Tune_Aim {
 
    set_val(PS4_RX,(15 - fine_pulse));//right
    set_val(PS4_LX,(-15 + fine_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(15 - fine_pulse));//right+down
    set_val(PS4_RY,(10 - fine_pulse));
    set_val(PS4_LX,(-5 + fine_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
 
    set_val(PS4_RY,(10 - fine_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(-15 + fine_pulse));//left+down
    set_val(PS4_RY,(10 - fine_pulse));
    set_val(PS4_LX,(5 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time)
    wait(Sampling_Time)
 
    set_val(PS4_RX,(-15 + fine_pulse));// left
    set_val(PS4_LX,(15 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(-15 + fine_pulse)); //left + up
    set_val(PS4_RY,(-10 + fine_pulse));
    set_val(PS4_LX,(5 - fine_pulse))//move 	right
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RY,(-10 + fine_pulse)); //up
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(15 - fine_pulse));//right+up
    set_val(PS4_RY,(-10 + fine_pulse));
    set_val(PS4_LX,(-5 + fine_pulse))//move 	left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
 
    fine_pulse = fine_pulse + 2;
 
 
    if ( fine_pulse >10)
       {
            fine_pulse = 0;   
        }
   }
 
combo spiroide_Aim_Assit {
 
    set_val(PS4_RX,(4 + spiroide_pulse));//right
    set_val(PS4_LX,(-15+ spiroide_pulse));//move left
    wait(Sampling_Time);
 
    wait(Sampling_Time);
 
 
    set_val(PS4_RY,(5 + spiroide_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
    set_val(PS4_RX,(-4 - spiroide_pulse));//left
    set_val(PS4_LX,15 - spiroide_pulse );//move right
    wait(Sampling_Time);
 
    wait(Sampling_Time)
 
    set_val(PS4_RY,(5 + spiroide_pulse));// down
    wait(Sampling_Time);
 
    wait(Sampling_Time);
    wait(Sampling_Time);
    wait(Sampling_Time);
 
 
    spiroide_pulse = spiroide_pulse + 2;
 
 
    if ( spiroide_pulse >10)
       {
            spiroide_pulse = 0;   
        }
   } 
combo AAS{
	set_val(PS4_RY, 1 * - AS);
	wait(AW);
	set_val(PS4_RX, 1 * - AS);
	wait(AW);
	set_val(PS4_RY,AS);
	wait(AW);
	set_val(PS4_RX,AS);
	wait(AW);
}

combo STICKY_AIM {
    set_val(PS4_RY,xy_val(PS4_RY, stickyaim_size));
    wait(stickyaim_time);
    set_val(PS4_RX,xy_val(PS4_RX, stickyaim_size));
    set_val(PS4_LX,xy_val(PS4_LX, stickyaim_size));
    wait(stickyaim_time);
    set_val(PS4_RY,xy_val(PS4_RY, stickyaim_size * -1));
    wait(stickyaim_time);
    set_val(PS4_RX,xy_val(PS4_RX, stickyaim_size * -1));
    set_val(PS4_LX,xy_val(PS4_LX, stickyaim_size * -1));
    wait(stickyaim_time);
    }   
combo CANCEL_SLIDE {              
    set_val(user_defined_crouch_button, 100);          
    wait(120);                         
    set_val(user_defined_crouch_button, 0);            
    wait(60);                          
    set_val(user_defined_crouch_button, 100);          
    wait(50);                          
    set_val(user_defined_crouch_button, 100);          
    set_val(user_defined_jump_button, 100);           
    wait(60);                          
    set_val(user_defined_crouch_button, 0);            
    set_val(user_defined_jump_button, 100);          
    wait(10);                        
    set_val(user_defined_jump_button, 0);         
} 
combo DS {
    set_val(user_defined_crouch_button,100);
    wait(40);
    set_val(user_defined_crouch_button,0);
    wait(DS_Speed);}
combo BUNNYHOP
{
    set_val(user_defined_jump_button, 100);
    wait(30);
    set_val(user_defined_jump_button, 0);
    wait(30);
    set_val(user_defined_jump_button, 100);
    wait(30);
    set_val(user_defined_jump_button, 0);
    wait(30);
}
 combo Quick_Scope {
 set_val(PS4_L2,100);
 wait(quickscopedelay); 
 set_val(PS4_L2,100);
 set_val(PS4_R2,100);
 wait(40);
 set_val(PS4_L2,100);
 wait(40); }        
   
 combo CH {
	set_val(PS4_L3,0);
	wait(60);
	set_val(PS4_L3,100);
	wait(110);
	set_val(PS4_L3,0);
	wait(110);}   
combo TRACKING
	{set_val(PS4_UP,100);
	wait(20)
	set_val(PS4_UP,0);
	wait(20)
	set_val(PS4_UP,100);
	wait(20)
	set_val(PS4_UP,0);
	}
combo easy_plate
	{set_val(PS4_TRIANGLE,100);
	wait(6000)}//time triangle is held for adjust higher or lower 500 if you only get 2 plates or cant switch weapons after replating

combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo SAVE { 
	cls_oled(0);						// clear OLED screen 
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	wait(10)
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times								
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_new = TRUE;				   // display mods
}
combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time);
    }	
    combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}
 combo ANTIRECOIL {
// Vertical
    AntirecoilVertical = get_val(PS4_RY) + (antirecoil_vertical[profile_idx]);  
    if(AntirecoilVertical > 100) AntirecoilVertical = 100;
    if(abs(get_val(PS4_RY)) < abs(antirecoil_vertical[profile_idx]) + 5)
    set_val(PS4_RY, (AntirecoilVertical * invert));
// Horizontal
    AntirecoilHorizontal = get_val(PS4_RX) +  (antirecoil_horizontal[profile_idx]);
    if(AntirecoilHorizontal > 100) AntirecoilHorizontal = 100;
    if(abs(get_val(PS4_RX)) < abs(antirecoil_horizontal[profile_idx]) + 5)
    set_val(PS4_RX, AntirecoilHorizontal);
}
function Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
    { 
 
 
       if(abs(Last_Value - Current_Value) < Aim_Perfection_Limit) 
            {
                //--moving right
                if(Last_Value < Current_Value)
                    {           
                        if (Boost)
                            { 
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value + Aim_Boost)); 
 
                                if (Y_AXIS)
                                        set_val(PS4_RY, (Current_Value + Aim_Boost));
                            }
 
 
                        else if(Correction)
                            {
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value - Aim_Correction)); 
 
                                if (Y_AXIS)
                                set_val(PS4_RY, (Current_Value - Aim_Correction));            
                            }
                    }
                else //--moving left
                    {
 
                        if (Boost)
                            { 
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value - Aim_Boost)); 
 
                                if (Y_AXIS)
                                        set_val(PS4_RY, (Current_Value - Aim_Boost));
                            }
 
 
                        else if(Correction)
                            {
                                if (X_AXIS)
                                    set_val(PS4_RX, (Current_Value + Aim_Correction)); 
 
                                if (Y_AXIS)
                                set_val(PS4_RY, (Current_Value + Aim_Correction));            
                            }
                    }
            }
    } 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function AIM() {
	if (D_AS) {
	if (D_AS && VM) {
		vm_tctrl(-2);
	}
		D__AS ++;
	if (D__AS >= D___AS)  D__AS = D__AS1;
		D__AS1 --;
	if (D__AS1 <= D_AS1)  D__AS1 = D__AS;
		D__AS ++;
	if (get_val(PS4_L2)) {	
		set_val(PS4_RX,get_val(PS4_RX) + D__AS);
		set_val(PS4_RY,get_val(PS4_RY) + D__AS);
	}
	if (get_val(PS4_R2)) {	
		set_val(PS4_RX,get_val(PS4_RX) + D__AS);
		set_val(PS4_RY,get_val(PS4_RY) + D__AS);
		}
	}
	else
	vm_tctrl(0); 
} 


function PROGRESSION(VALUE,MIN,MAX,INCREMENT,FLOW,ID) {
if (FLOW) {
    VALUE += INCREMENT;
if (VALUE <= MAX)  
    return VALUE;
if (VALUE > MAX) {
        PROG[ID] = 0;
    return VALUE - INCREMENT;}
	}
else {
    VALUE -= INCREMENT;    
if (VALUE >= MIN)  
    return VALUE;
if (VALUE < MIN) {
   	PROG[ID] = 1;
    return VALUE + INCREMENT;
    	}
	} 
   		 return FALSE;    
}

function calculate(int v, int lo, int hi) { 
  if(v < lo) return lo;               
  if(v > hi) return hi;        
  return v;     
}     
function xy_val(f_axis,f_val) {
    if(abs(get_val(f_axis)) < stickyaim_size + 1) 
        return f_val;
    return get_val(f_axis); 
}
function p_complete() { // Antirecoil

    i_cnt++;
    if(i_cnt > antirecoil_time[profile_idx] * 10) 
    {
        i_cnt = antirecoil_time[profile_idx] * 10;
        return 1;
    }    
    return 0;
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function p_val() { // Antirecoil

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function y_val() { // Antirecoil

    v = get_val(10);
    
    if(abs(v) < 10)
        v = 0;
        
    if(abs(v) > ar_y + 5)
        return v;
        
    return v + (ar_y * invert);           
}
function p_complete_x() { 
    i_cnt_h++;
    if (i_cnt_h > antirecoilH_time[profile_idx] * 10) 
    {
        i_cnt_h = antirecoilH_time[profile_idx] * 10 ;
        return 1;
    }
    return 0;
}   

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function p_val_x() {
    i_num_h++;
    if(i_num_h == i_pnt_h) 
    {
    	i_num_h = 0;
    	ar_x += i_val_h;
    }
    return ar_x;
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function x_val() {
	v_x = get_val(PS4_RX);
	if(abs(v_x) < 10)
		v_x = 0;
	if(abs(v_x) > abs(ar_x + 5))
		return v_x;
	return v_x + ar_x;   	    
}

function double_click(button) {        
    if (double__tap[button] >= 0) {                    
        double__tap[button] += get_rtime(); 
        if (double__tap[button] > 450)
            double__tap[button] = -1;                                                                                       
    }           
    if (event_release(button) && get_ptime(button) <= 200) { 
        if (double__tap[button] < 0) {                    
            double__tap[button] = 0;                        
        } else {             
            double__tap[button] = -1;                       
            return 1;                                   
        }                                                     
    }                                                  
    return 0;
    }
function vals_available1(f_min, f_max) { // Define adjustable values available for each of the mods

	if(valName2_idx < f_min)
		valName2_idx = f_max;
	if(valName2_idx > f_max)
		valName2_idx = f_min;	
}
function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods

	if(valName_idx < f_min)
		valName_idx = f_max;
	if(valName_idx > f_max)
		valName_idx = f_min;
		
}
function edit_val(f_name,f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
					
	if(f_name == f_idx)
	{
    // +1 or -1															 // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2

	// We can also add (f_ref)
	// Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_start[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;	
	}
	// Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
	if(rate_of_fire[profile_idx] < 0)
		rate_of_fire[profile_idx] = 0;

	//return f_ref;

	return f_val;
}
function toggle(f_name,f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(f_name == f_idx)
		{
			
				
			f_val = 1;
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(f_name == f_idx)
		{
			f_val = 0;
			combo_run(RUMBLE_OFF);
		}		
		display_new = TRUE;
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit(f_name,f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);

    	if(f_name == f_idx)
    	{
		// Display value name and value
    		printf(f_string, 0,OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    		//printf(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);
    		
    	// Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
    		if(valName_idx == 4 || valName_idx == 7) 
    			number_to_string(f_val * 100, find_digits(f_val * 100) );
    	
    	
    	// Display editable values that are not in the array (burstfire_hold for exemple)
    		else
    			number_to_string(f_val, find_digits(f_val));
    	}
}
function display_edit1(f_name,f_idx, f_string, f_print, f_val1) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);

    	if(f_name == f_idx)
    	{
		// Display value name and value
    		printf(f_string, 0,OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    		printf(center_x(sizeof(DEFAULT) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,DEFAULT[0]);
    		
    	   if(valName2_idx == 9)
    	   printf(center_x(sizeof(DEFAULT1) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,DEFAULT1[0]);
    	
    	// Display editable values that are not in the array (burstfire_hold for exemple)
    
    			number_to_string1(f_val1, find_digits(f_val1));
    	}
}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_mod(f_name,f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, MEDIUM) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(f_name == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    		// Display ON OFF
    			if(f_toggle == 1)
    				printf(center_x(sizeof(ON) + 10, OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    			else if(f_toggle == 0)
    				printf(center_x(sizeof(OFF) - 13,OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL, OLED_WHITE, OFF[0]);
    				
    			printf(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);	
    	}
}
function display_mod2(f_name,f_idx, f_string, f_print) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, MEDIUM) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(f_name == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    				
    			printf(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);	
    	}
}
function display_mod1(f_name,f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, MEDIUM) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(f_name == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    		// Display ON OFF
    			if(f_toggle == 1)
    				printf(center_x(sizeof(ON) + 10, OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    			else if(f_toggle == 0)
    				printf(center_x(sizeof(OFF) - 13,OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL, OLED_WHITE, OFF[0]);
    				
    			
    	}
}
function speed_toggle(f_hold, f_press, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			modName_idx = f_string;
			
			if(f_val == 0)
			{
	
			f_val = 1;
			combo_run(RUMBLE_ON);
			}
			else
			{
			f_val = 0;
			combo_run(RUMBLE_OFF);
			
			
			}
			display_new = TRUE;
		} 
	set_val(f_press, 0)
	}
		
	return f_val;
}
function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
      
    // Substract    
        if(f_val < inv(f_rng_min)) 
        	f_val = inv(f_rng_min); 
   	// Add   
       	if(f_val > f_rng_max) 
        	f_val = f_rng_max;

        display_new = TRUE;
    }
    return f_val; 
} 
function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,i - 1,OLED_WHITE); // adjustable value centered in X
}  
function number_to_string1(f_val1,f_digits1) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val1 < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val1 = abs(f_val1);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits1 >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val1 / c_val]);
            f_val1 = f_val1 % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,i - 1,OLED_WHITE); // adjustable value centered in X
}  
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function find_digits(f_num) {
//  find_digits(value)  
//	    return Number of Digits in Value Passed  

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//	    return X for Centering String Horizontally

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {
//  center_y(font size);  
//	    return Y for Centering String Vertically

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function press_hold(f_btn) { 
//  return TRUE - event_press()   
//			    - every 250ms when button is held

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 



// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function save () {
	combo_run(SAVE);
// Profile 1
	// Toggles                                       // Values
	set_pvar(SPVAR_1,toggle_legacyar[0]);           set_pvar(SPVAR_4,antirecoil_vertical[0]); 
	set_pvar(SPVAR_2,toggle_antirecoilh[0]);         set_pvar(SPVAR_5,antirecoil_horizontal[0]);
    set_pvar(SPVAR_3,toggle_rapidfire[0]);          set_pvar(SPVAR_6 ,antirecoil_start[0]     );         
	                                                set_pvar(SPVAR_7 ,antirecoil_end[0]       );        
	                                                set_pvar(SPVAR_8 ,antirecoil_time[0]      );  
	                                                set_pvar(SPVAR_9 ,antirecoilH_start[0]);
	                                                set_pvar(SPVAR_10 ,antirecoilH_end[0]);
	                                                set_pvar(SPVAR_11 ,antirecoilH_time[0]);
                                                    set_pvar(SPVAR_12,rate_of_fire[0]);
	                                               
// Profile 2
	// Toggles                                       // Values
	set_pvar(SPVAR_13,toggle_legacyar[1]);          set_pvar(SPVAR_16,antirecoil_vertical[1]); 
	set_pvar(SPVAR_14,toggle_antirecoilh[1]);        set_pvar(SPVAR_17,antirecoil_horizontal[1]);
    set_pvar(SPVAR_15,toggle_rapidfire[1]);         set_pvar(SPVAR_18 ,antirecoil_start[1]     );         
	       										    set_pvar(SPVAR_19 ,antirecoil_end[1]       );        
	                                                set_pvar(SPVAR_20 ,antirecoil_time[1]      );  
	                                                set_pvar(SPVAR_21 ,antirecoilH_start[1]);
	                                                set_pvar(SPVAR_22 ,antirecoilH_end[1]);
	                                                set_pvar(SPVAR_23 ,antirecoilH_time[1]);
                                                    set_pvar(SPVAR_24,rate_of_fire[1]);	

	                                                 
                                                    set_pvar(SPVAR_49,Aim_Boost);
                                                    set_pvar(SPVAR_50,Aim_Correction);
 set_pvar(SPVAR_25,POLAR_ASSIST);                   set_pvar(SPVAR_51,Aim_Perfection_Limit);
 set_pvar(SPVAR_26,NOTORIOUS_AIM_ASSIST);                set_pvar(SPVAR_52,RADIUS2);
 set_pvar(SPVAR_27,PROGRESSION_ASSIST);             set_pvar(SPVAR_53,STEPS);
 set_pvar(SPVAR_28,RADIUS);                         set_pvar(SPVAR_54,stickyaim_size); 
 set_pvar(SPVAR_29,ANGLE);                          set_pvar(SPVAR_55,stickyaim_time);
 set_pvar(SPVAR_30,POLAR_BOOST);                    set_pvar(SPVAR_56,quickscopedelay);  
 set_pvar(SPVAR_31,POLAR_SHAKE);                    set_pvar(SPVAR_57,toggle_BOUNCE_SHOT); 
 set_pvar(SPVAR_32,A_B_S); 
 set_pvar(SPVAR_33,POLAR_RELEASE);
 set_pvar(SPVAR_34,D___AS);
 set_pvar(SPVAR_35,D_AS1);
 set_pvar(SPVAR_36,NOTORIOUS_ASSIST_RELEASE);
 set_pvar(SPVAR_37,EXTREME_AIMABUSE_on);
 set_pvar(SPVAR_38,polar_aim);
 set_pvar(SPVAR_39,sticky_aim);
 set_pvar(SPVAR_40,enemy_ping);
 set_pvar(SPVAR_41,pingonfire);
 set_pvar(SPVAR_42,easy_plate);
 set_pvar(SPVAR_43,cancel_slide);
 set_pvar(SPVAR_44,autorun_on);
 set_pvar(SPVAR_45,swap_on);
 set_pvar(SPVAR_46,inverted_on);
 set_pvar(SPVAR_47,toggle_quickscope); 
 set_pvar(SPVAR_48,toggle_holdbreath);
 set_pvar(SPVAR_58,toggle_proneshot );
 set_pvar(SPVAR_59,toggle_bunnyhop ); 
 
	
}