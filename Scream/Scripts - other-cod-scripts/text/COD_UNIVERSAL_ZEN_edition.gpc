/*

										-----DRACARYSMODS SCRIPT ULTIMATE EDITION!-----
											programmed and published by: fadyszn
											
										join our discord:			https://discord.gg/auAVbaQZHz
										
					Device: CronusZEN ONLY
					
					Consoles: XB1 - XBSX - PS5 - PS4 - PC
					
									© 2020 - 2021 CronusMax & CronusZen. All rights reserved.

██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████

											W H A T  C U S T O M E R S  S A Y: 
											
											
							"				Awesome script! I quickly used it
									 	   on plunder and it worked very great!						"
											 			-BillCosby
											 			
											 			
											 				
							"				I received the script within an hour of
									 proving the payment. It works very well, the sticky 
									  aim assist is fire and anti recoil is very easy to
									   set up. Impressed so far, thanks devs!						"
									   					-windy smile
									   					
									   					
									   					
							"				Worked perfectly, can't wait for the new scripts
									 whenever you do others! Good work thank you friend.			"
									 					-criplord187
									 					
									 					
									 					
							"				This script is the closest thing to aimbot amazing!		"
														-The Boss
														
														
									
							"				Awesome aim assist is definitely top notch and anti
									 recoil is very reliable and strong, good work I love your 
									     			scripts so far!									"
									     				-IMDXCTORIVXX
									     				
									     				
									     				
							"				Man this script is the best I've ever used! Thank you
												and good job!!										"
														-donald
												
												
												
							"				Gotta say the script you made is great looking forward to
												seeing what you can do in the future!				"
														-Morpheus BN

██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████

PLEASE READ THE INSTRUCTIONS BELOW ON HOW TO USE THE SCRIPT

(tutorial video coming soon)

============================================================================================================================

=== Change Loadout Profile: ===            
==  Press Triangle to switch between profiles 1 & 2  ==
==  Double Press Triangle to switch to profile 3  ==

============================================================================================================================

=== Enter Mod Menu: ===            
==  Hold ADS/LT and tap OPTIONS/MENU  ==

============================================================================================================================

=== Navigate between mods on the ZEN Menu: ===
==  Tap LEFT or RIGHT on the D-PAD  ==

============================================================================================================================

=== Enable or Disable the diplayed mod: ===                   
==  Tap UP for ON and Tap DOWN for OFF  ==

============================================================================================================================
=== Switch Profiles/Loadouts: ===                               
==  Tap Triangle/Y  ==
============================================================================================================================

=== Enter or exit Mod Edit Screen: ===                                     
==  Press JUMP/A to enter Mod Edit screen  == 
==  Press PRONE/B to Exit Mod Edit screen  ==

============================================================================================================================

=== Navigate between available values in Mod Edit Screen: ===
==  Tap LEFT Or RIGHT  ==
                                                            
============================================================================================================================ 

=== Edit Values In Mod Edit Screen: ===  
==  Tap UP   to increase (+) value by 10  ==
==  Hold ADS/LT & Tap RIGHT to increase (+) value by 1  ==
==  Tap LEFT to decrease (-) value by 1  ==
==  Tap DOWN to decrease (-) value by 10  ==  
==  Hold ADS/LT & Tap LEFT to decrease (-) value by 1  ==
                                                        

============================================================================================================================

=== To SAVE all mods that have been edited & enabled: ===      
==  Press XBOX/HOME Button & Screen Will diplay "SAVED"  ==

============================================================================================================================

=== To enter & exit Driving Mode: ===      
==  Hold L3 + R3 till the controller vibrates to enter  ==
==  Once active, Press square to exit the driving mode  ==

============================================================================================================================


=== To exit Mod Menu once you have saved it: ===              
==  Hold ADS/LT and Tap OPTIONS/MENU button  ==

============================================================================================================================

██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████

*/

// Button Layout                                                      
    define HOME = PS4_PS; //OR XBOX HOME BUTTON
    define SHARE = PS4_SHARE; //OR XBOX VIEW BUTTON
    define OPTIONS = PS4_OPTIONS; //OR XBOX MENU BUTTON
    define LETHAL = PS4_R1; //OR RB
    define FIRE = PS4_R2; //OR RT
    define MELEE = PS4_R3; //OR RS
    define TACTICAL = PS4_L1; //OR LB
    define ADS = PS4_L2; //OR LT
    define SPRINT = PS4_L3; //OR LS
    define RX = PS4_RX; //MOVING THERIGHT ANALOG STICK RIGHT OR LEFT
    define RY = PS4_RY; //MOVING THE RIGHT ANALOG STICK UP OR DOWN
    define LX = PS4_LX; //MOVING THE LEFT ANALOG STICK RIGHT OR LEFT
    define LY = PS4_LY; //MOVING THE LEFT ANALOG STICK UP OR DOWN
    define UP = PS4_UP; //DPAD UP
    define DOWN = PS4_DOWN; //DPAD DOWN
    define LEFT = PS4_LEFT; //DPAD LEFT
    define RIGHT = PS4_RIGHT; //DPAD RIGHT
    define REVIVE = PS4_TRIANGLE; //OR Y
    define PRONE = PS4_CIRCLE; //OR B
    define JUMP = PS4_CROSS; //OR A
    define RELOAD = PS4_SQUARE; //OR X
    define TOUCHPAD = PS4_TOUCH; //OR SELECT
    
    // Mods (with values) that activates for all profiles at the same time (if toggled ON)
    
// BurstFire
    int burstfire_hold; 
    int burstfire_release;
    
// Anti Recoil
	int AntirecoilVertical; 
    int AntirecoilHorizontal;
    
// Classic Sticky Aim Assist
    int stickyaim_size;
    int stickyaim_time;
    
// Polar Aim Assist
	int polaraim_radius;
	int polaraim_speed;
	
	int angle; // DONT TOUCH                                                                

// Strafe Shot
    int strafeShot_time;
    
// Aim Snap
	int aimsnap_hold;
	int aimsnap_release;
	
// Anti Damage Wobble
	int antidw_vertical;
	int antidw_horizontal;

// Loadout Drop Reminders
	int first_loadout_time = 100; // time between start of the game and a couple seconds between the first loadout drop
	int second_loadout_time = 100; // time between the first loadout drop and the second one

// Crescens Aim Corrections
    int aimsens_on;
    int in_game_sens;
    int ads_grenade_sens, ads_fire_sens, Sens;
    
// ItzSnack Custom Sensitivity
    int custom_sens;
	
// Toggles
	int drivingmode_on;
    int autorun_on;
    int swap_on;
    int inverted_on;
    int silentaim_on; 
    int stickyaim_on;
    int meleeturbo_on;
    int quickscope_on;
    int mwslide_on;
    int cwslide_on;
    int aimsnap_on;
    int antidw_on;
    int holdbreath_on;
    int hairtriggers_on;
    int smartreload_on;
    int loadoutdrop_on;
    
// Other Variables Used

    int easyplate_on;
    int enemy_ping;
    int ANTIWOBBLE, BOOST;
    int Current_State          = 0;
	int Aim_Abuse_State      = 2;
	define Get_Last_Value     = 0;
	define Get_Current_Value = 1;
	int Aim_Correction;
	int Aim_Boost;
    int Aim_Perfection_Limit;
    int X_Last_Value     = 0;
	int Y_Last_Value     = 0;
	int X_Current_Value  = 0;
	int Y_Current_Value  = 0;
	int mvt = 0;
	int Aim_Boost_Val = 0; 
	int Aim_Correction_Val = 0;
// Constant bytes - Convert numbers array - ASCII_NUM[column number]
    const uint8 ASCII_NUM[] = 
//      0  1  2  3  4  5  6  7  8  9  (column numbers)
      {48,49,50,51,52,53,54,55,56,57};
// Variables for function number_to_string() 
    int i;
    int c,c_val;
 
data(
//    Blue      Pink    SkyBlue    Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//   Yellow    White      Red       OFF        
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
// Refresh OLED
    int display_title = TRUE;
    int display_new; 
    int display_black;
// ModMenu / ModEdit / KillSwitch
    int ModMenu;    
    int ModEdit;
    int KillSwitch;
// Anti Recoil values                                                 
    int invert; // -1 for inverted, 1 for standard
// RapidFire / BurstFire
    int hold_time;                                                    
    int rest_time;
    int led_on;
    int led_off;
// Counter
    int count_black; // for screen saver
// Double Tap
    int double_tap;
// Profiles
    int profile_1or2; // Profile 1 and 2
    int profile_3;   // Profile 3
    
// Double tap 
	int q;											
	int double__tap[30];
	init {
	while(q < 30) 
	{double__tap[q] = -1;       
	q++;}}
	
// Custom Sensitivity
	int GEN_SENS = 100;
	int ADS_SENS = 100;
	int FIRE_SENS = 100;
	int ADS_FIRE_SENS = 95;
	int GRENADE_SENS = 100;
	int USE_SENS;
	/*NOTE:
	Default Sens is 100
	Ranges from 0 to 327*//*

██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████

(DO NOT CHANGE ANYTHING BELOW OTHERWISE IT MIGHT NOT FUNCTION AT ALL) */

   const string TITLE = "ULTIMATE ST"; // 11 char max
   const string OFF = "OFF"; 
   const string ON = "ON"; 
   const string SAVE = "SAVED";
   const string PROFILE_1 = "Loadout 1": // primary weapon
   const string PROFILE_2 = "Loadout 2": // secondary weapon
   const string PROFILE_3 = "Loadout 3": // handgun
   
   
// Mod Names
    const string ANTIRECOIL = "Anti Recoil";           // modName_idx = 00
    const string RAPIDFIRE = "Rapid Fire";             // modName_idx = 01
    const string BURSTFIRE = "Burst Fire";             // modName_idx = 02
    const string AIMASSIST = "Polar AA"                // modName_idx = 03         
    const string STRAFE_SHOT = "Strafe Shot";          // modName_idx = 04
    const string STICKYAIM = "Sticky Aim"              // modName_idx = 05
    const string Aim_Sens = "Aim Sens"        		   // modName_idx = 06
    const string Silent_Aim = "Silent Aim"             // modName_idx = 07
    const string AIMSNAP = "Aim Snap"			  	   // modNmae_idx = 08
    const string ANTIDW = "Anti Wobble"			  	   // modName_idx = 09	
    const string AUTORUN = "Auto Run";                 // modName_idx = 10
    const string SWAP = "Swap Tr/Bu";                  // modName_idx = 11
    const string INVERTED = "Inverted Y";              // modName_idx = 12 
    const string CustomSens = "Custom Sens"            // modName_idx = 13
    const string EASYPLATE = "Easy Plates"             // modName_idx = 14
    const string ENEMYPING = "Auto Ping"               // modName_idx = 15
    const string MELEETURBO = "Melee Turbo"            // modName_idx = 16
    const string QUICKSCOPE = "Quick Scope"            // modName_idx = 17
    const string MWSLIDE = "MW Slide"                  // modName_idx = 18
    const string CWSLIDE = "CW Slide"                  // modName_idx = 19
    const string HOLDBREATH = "Hold Breath"            // modName_idx = 20
    const string HAIRTRIGGERS = "Hair Reflex"          // modName_idx = 21
    const string SMARTRELOAD = "Fast Reload"          // modName_idx = 22
    const string LOADOUTDROP = "Loadout T"         // modName_idx = 23   
    int modName_idx; 
//  Last Mod Index that can be activated
    define LAST_MODNAME_STRING = 23; 
//  Last Mod Index that can be edited
    define LAST_EDITABLE_STRING = 9;
    
    
// Value Name
    // modName_idx = 0 = ANTIRECOIL string
    const string ANTIRECOIL_V = "Vertical";         		 // valName_idx = 0  
    const string ANTIRECOIL_H = "Horizontal";                // valName_idx = 1
    // modName_idx = 1
    const string RATE_OF_FIRE = "Rounds/sec";            // valName_idx = 4
    // modName_idx = 2
    const string BURSTFIRE_HOLD = "BF Hold";            // valName_idx = 5
    const string BURSTFIRE_RELEASE = "BF Release";        // valName_idx = 6
    // modName_idx = 3 = AA string
    const string RADIUS = "Radius";            // valName_idx = 7
    const string SPEED = "Speed";            // valName_idx = 8
    // modName_idx = 4
    const string STRAFESHOT_TIME = "S.Shot Time";        // valName_idx = 9 
    // modName_idx = 5                                   
    const string STICKYAIM_SIZE = "Sticky Size"          // valName_idx = 10
    const string STICKYAIM_TIME = "Sticky Time"          // valName_idx = 11
    // modName_idx = 6
    const string INGAMESENS  = "Sensitivity"            // valName_idx = 12
    // modName_idx = 7 
    const string AIMCORRECT  = "Correction"           // valName_idx = 13
    const string AIMBOOST    = "Boost"                // valName_idx = 14
    const string AIMPERFECT  = "Perfection"           // valName_idx = 15
    // modName_idx = 18
    const string AIMSNAPHOLD = "Hold"			  // valName_idx = 16
    const string AIMSNAPRELEASE = "Release"		  // valName_idx = 17
    // modName_idx = 19
    const string ANTIDWDRAG = "Power" 			  // valName_idx = 18
    const string ANTIDWTIME = "Time" 			  // valName_idx = 19
// Index to find Value Name string - switchable in game with left/right in ModEdit 
    int valName_idx;
    define AMOUNT_OF_VALNAME_IDX = 19;
// /!\ DO NOT CHANGE RATE OF FIRE VALUE IN THE ARRAY
// Constant bytes - VALUES array (mods with value and toggle) - VALUES[line][column]
    const uint8 VALUES[][] = {         
/* Profile 1 */    {     10,                30,               20,                   0,                  1     },        // profile_idx = 0 
/* Profile 2 */    {    11,                31,               21,                   0,                  1     },         // profile_idx = 1 
/* Profile 3 */ {    12,                32,               22,                   0,                  1       }};        // profile_idx = 2 
/*             antirecoil_v[]  antirecoil_h[]  antirecoil_time[]  antirecoil_horizontal[]  rate_of_fire[]           
                 AntiRecoil          AntiRecoil       AntiRecoil            AntiRecoil          RapidFire  
val_col_idx          = 0               = 1               = 2                  = 3                 = 4       */
// VALUES array column number - Buffer to add or substract edited value to corresponding value in VALUES array
    int antirecoil_v[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
    int antirecoil_h[3];
    int antirecoil_time[3];
    int antirecoil_horizontal[3];
    int rate_of_fire[3];
/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
    int profile_idx; 
// Index to find VALUES array column - Follow valName_idx to edit the right value (that is in VALUES array or not like Strafe_t value)
    int val_col_idx;
// # of the last column - used in display_edit() function 
    define LAST_EDITABLE_COLUMN = 4;
// Multi toggles
    int toggle_antirecoil[3]; // for 3 Profiles: profile_idx = 0, 1 and 2
    int toggle_rapidfire[3];  
    int toggle_burstfire[3];
    int toggle_aimassist[3];
    int toggle_strafeShot[3]; 
// Amount of profiles - Used for switch profiles cycle
    define AMOUNT_OF_PROFILES = 3;  
// Amount of multi toggle - Used for display profiles
    define AMOUNT_OF_MULTI_TOGGLE = 5;
 
init{
// Profile 1
    // Toggles                                                  // Values
    toggle_antirecoil[0] = get_pvar(SPVAR_1, 0, 1, 0 );         antirecoil_v[0]      = get_pvar(SPVAR_6, -99, 99, 0);         
    toggle_rapidfire[0]  = get_pvar(SPVAR_2, 0, 1, 0 );         antirecoil_h[0]        = get_pvar(SPVAR_7, -99, 99, 0);         
    toggle_burstfire[0]  = get_pvar(SPVAR_3, 0, 1, 0 );         antirecoil_time[0]       = get_pvar(SPVAR_8, -99, 99, 0);      
    toggle_aimassist[0]  = get_pvar(SPVAR_4, 0, 1, 0 );         antirecoil_horizontal[0] = get_pvar(SPVAR_9, -99, 99, 0);
    toggle_strafeShot[0] = get_pvar(SPVAR_5, 0, 1, 0 );         rate_of_fire[0]          = get_pvar(SPVAR_10,  0, 25, 0);
// Profile 2
    // Toggles                                                  // Values
    toggle_antirecoil[1] = get_pvar(SPVAR_11, 0, 1, 0 );        antirecoil_v[1]      = get_pvar(SPVAR_16, -99, 99, 0);         
    toggle_rapidfire[1]  = get_pvar(SPVAR_12, 0, 1, 0 );        antirecoil_h[1]        = get_pvar(SPVAR_17, -99, 99, 0);         
    toggle_burstfire[1]  = get_pvar(SPVAR_13, 0, 1, 0 );        antirecoil_time[1]       = get_pvar(SPVAR_18, -99, 99, 0);        
    toggle_aimassist[1]  = get_pvar(SPVAR_14, 0, 1, 0 );        antirecoil_horizontal[1] = get_pvar(SPVAR_19, -99, 99, 0);
    toggle_strafeShot[1] = get_pvar(SPVAR_15, 0, 1, 0 );        rate_of_fire[1]          = get_pvar(SPVAR_20,   0, 25, 0);
// Profile 3
    // Toggles                                                  // Values
    toggle_antirecoil[2] = get_pvar(SPVAR_21, 0, 1, 0 );        antirecoil_v[2]      = get_pvar(SPVAR_26, -99, 99, 0);         
    toggle_rapidfire[2]  = get_pvar(SPVAR_22, 0, 1, 0 );        antirecoil_h[2]        = get_pvar(SPVAR_27, -99, 99, 0);         
    toggle_burstfire[2]  = get_pvar(SPVAR_23, 0, 1, 0 );        antirecoil_time[2]       = get_pvar(SPVAR_28, -99, 99, 0);         
    toggle_aimassist[2]  = get_pvar(SPVAR_24, 0, 1, 0 );        antirecoil_horizontal[2] = get_pvar(SPVAR_29, -99, 99, 0);
    toggle_strafeShot[2] = get_pvar(SPVAR_25, 0, 1, 0 );        rate_of_fire[2]          = get_pvar(SPVAR_30,   0, 25, 0);
// Misc    
// Toggles only                                                    // Values
    autorun_on   = get_pvar(SPVAR_31, 0, 1, 0);                    burstfire_hold    = get_pvar(SPVAR_34, 1, 999, 150); 
    swap_on      = get_pvar(SPVAR_32, 0, 1, 0);                    burstfire_release = get_pvar(SPVAR_35, 1, 999, 150); 
    inverted_on  = get_pvar(SPVAR_33, 0, 1, 0);                    polaraim_radius    = get_pvar(SPVAR_36, 1, 50 , 28); 
    silentaim_on = get_pvar(SPVAR_39, 0, 1, 0);                    polaraim_speed    = get_pvar(SPVAR_37, 1, 999, 20 ); 
    stickyaim_on = get_pvar(SPVAR_40, 0, 1, 0);                    strafeShot_time   = get_pvar(SPVAR_38, 1, 999, 500);
    aimsens_on   = get_pvar(SPVAR_43, 0, 1, 0);                    stickyaim_size    = get_pvar(SPVAR_41, 1, 50 , 20);
    custom_sens  = get_pvar(SPVAR_45, 0, 1, 0);                    stickyaim_time    = get_pvar(SPVAR_42, 1, 999, 20);
    easyplate_on = get_pvar(SPVAR_49, 0, 1, 0);                    in_game_sens      = get_pvar(SPVAR_44, 99, 99, 0 );
    enemy_ping   = get_pvar(SPVAR_50, 0, 1, 0);                    Aim_Correction    = get_pvar(SPVAR_46, 1, 15, 6);
    meleeturbo_on= get_pvar(SPVAR_51, 0, 1, 0);                    Aim_Boost         = get_pvar(SPVAR_47, 1, 10, 8);
    quickscope_on= get_pvar(SPVAR_52, 0, 1, 0);                    Aim_Perfection_Limit = get_pvar(SPVAR_48,  1, 60, 30);
    mwslide_on   = get_pvar(SPVAR_53, 0, 1, 0);					   aimsnap_hold = get_pvar(SPVAR_56, 1, 60, 30);
    cwslide_on   = get_pvar(SPVAR_54, 0, 1, 0); 				   aimsnap_release = get_pvar(SPVAR_57, 1, 60, 30);
    aimsnap_on   = get_pvar(SPVAR_55, 0, 1, 0);					   antidw_vertical = get_pvar(SPVAR_61, 1, 60, 30);
    antidw_on    = get_pvar(SPVAR_58, 0, 1, 0);			           antidw_horizontal = get_pvar(SPVAR_62, 1, 60, 30);
    holdbreath_on= get_pvar(SPVAR_59, 0, 1, 0);
    hairtriggers_on= get_pvar(SPVAR_60, 0, 1, 0);
    smartreload_on = get_pvar(SPVAR_63, 0, 1, 0);
    loadoutdrop_on = get_pvar(SPVAR_64, 0, 1, 0);
    
}
// MAIN SECTION                             
main{
    set_val(TRACE_4, toggle_burstfire[0]); // BurstFire toggle Profile 1
    set_val(TRACE_5, toggle_burstfire[1]); // BurstFire toggle Profile 2
    set_val(TRACE_6, toggle_burstfire[2]); // BurstFire toggle Profile 3
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
        if(get_console() == PIO_PS4) // If PS4 console:
        {
            swap(SHARE,TOUCHPAD); // View = TouchPad
 
                if(get_val(MELEE) && event_press(TOUCHPAD)) //  RS + View = ScreenShot
                {
                    set_val(SHARE,100);
                    set_val(TOUCHPAD,0);
                    set_val(MELEE,0);
                }
        }
    }    
 //DISPLAY TITLE
// Display Script Title    
    if(display_title)
    {
        cls_oled(0);    // clear OLED screen
        count_black = 0;// reset screen saver counter
 
        if(KillSwitch)
        {
            printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),8,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);    // display OFF centered in X 
            
        }
        else
        {
            printf(center_x(sizeof(TITLE) - 1, OLED_FONT_MEDIUM_WIDTH),13,OLED_FONT_MEDIUM,OLED_WHITE,TITLE[0]);    // display TITLE centered in X 
 
        // Display profile name
            if(profile_idx == 0)
                printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_1[0]); 
            if(profile_idx == 1)
                printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_2[0]);
            if(profile_idx == 2)
                printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_3[0]);
 
            display_black = TRUE;    // screen saver
            display_title = FALSE;
        }
    }
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
        count_black += get_rtime();
        if(count_black >= 18000)
        {
            cls_oled(0);
            count_black = 0;
            display_black = FALSE;
        }
    }
// KILL SWITCH
    if(get_val(ADS))
    {
    // Kill Switch    
        if(double_click(SHARE))
        {
            KillSwitch = !KillSwitch;
 
            if(KillSwitch)        
                combo_run(RUMBLE_OFF);    // rumble and LED blink
            else
                combo_run(RUMBLE_ON);    // rumble and LED blink
 
            //display_black = FALSE;
            display_title = TRUE;
        }
// MOD MENU
    // toggle ModMenu ON/OFF
        if(event_release(OPTIONS) && !KillSwitch)
        {
            ModMenu = !ModMenu;
 
            if(!ModMenu)
            {
                ModEdit = FALSE;         // close ModEdit too
                //save ();                // save function
                //combo_run(EXIT_SAVE);    // rumble, blink and display SAVED then display TITLE
                combo_run(RUMBLE_OFF);  // rumble and LED blink
                display_title = TRUE;   // display Title
            }
 
            if(ModMenu)
            {
                modName_idx = 0;        // start to the first adjustable value
                combo_run(RUMBLE_ON);    // rumble and LED blink
                display_new = TRUE;        // display mod name, profile, ON/OFF and value
            }
        }
        set_val(SHARE, 0);            // block
        set_val(OPTIONS, 0);        // block
    } // ADS end
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
if(!KillSwitch)
{
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
// ModMenu
    if(ModMenu)
    {
//MOD EDIT           
    // toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
        if(modName_idx <= LAST_EDITABLE_STRING)    // if ANTIRECOIL (so modName_idx = 0) or AA or RAPIDFIRE or BURSTFIRE or StrafeShot is diplayed 
        {
            if(event_press(JUMP) && !ModEdit) // Turn ModEdit ON
            {
                valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
                ModEdit = TRUE;
                combo_run(RUMBLE_ON);
                display_new = TRUE;
            }
 
            if(event_press(PRONE) && ModEdit) // Turn ModEdit OFF
            {
                ModEdit = FALSE;
                combo_run(RUMBLE_OFF);
                display_new = TRUE;
            }
        }
//EDIT VALUES        
    // ModEdit ON
        if(ModEdit)
        {
            if(get_val(ADS)) // Edit value: hold ADS + UP (+1) or DOWN (-1) or RIGHT (+10) or LEFT (-10)
            {
            // Mods that can have different values depending the active Profile
 
              //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], abs(range min) , range max );     
                antirecoil_v[profile_idx]      = edit_val( 0 , antirecoil_v[profile_idx]     , 0 , 99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
                antirecoil_h[profile_idx]        = edit_val( 1 , antirecoil_h[profile_idx]       , 0 , 99 , 1 , 10   ); // the 2 last numbers are range min and range max
                rate_of_fire[profile_idx]          = edit_val( 4 , rate_of_fire[profile_idx]         , 0 , 25 , 1 , 10   );  // 25 rounds/s max
 
            // Mods that have same value on every Profiles
 
              //val_I_want_to_edit = edit_val( corresponding valName_idx , val_I_want_to_edit, range min , range max );
                burstfire_hold    = edit_val( 5 , burstfire_hold    , 0 , 990  , 10 , 100  );
                burstfire_release = edit_val( 6 , burstfire_release , 0 , 990  , 10 , 100  );
                polaraim_radius    = edit_val( 7 , polaraim_radius    , 0,  50   , 1  , 10   );
                polaraim_speed    = edit_val( 8 , polaraim_speed    , 0,  990  , 1  , 10   ); 
                strafeShot_time   = edit_val( 9 , strafeShot_time   , 0,  9990 , 10 , 100  );
                stickyaim_size    = edit_val( 10 , stickyaim_size   , 0,  50   , 1  , 10   );
                stickyaim_time    = edit_val( 11 , stickyaim_time   , 0 , 990  , 1  , 10   );
                in_game_sens      = edit_val( 12 , in_game_sens     , 0 , 20   , 1  , 10   );
                Aim_Correction    = edit_val( 13 , Aim_Correction   , 0 , 15   , 1  , 10   );
                Aim_Boost         = edit_val( 14 , Aim_Boost        , 0 , 10   , 1  , 10   );
                Aim_Perfection_Limit = edit_val( 15 , Aim_Perfection_Limit   , 0, 60 , 1 , 10 );
                aimsnap_hold = edit_val( 16 , aimsnap_hold   , 0, 990 , 10 , 100 );
                aimsnap_release = edit_val( 17 , aimsnap_release   , 0, 990 , 10 , 100 );
                antidw_vertical = edit_val( 18 , antidw_vertical   , 0, 990 , 10 , 100 );
                antidw_horizontal = edit_val( 19 , antidw_horizontal   , 0, 990 , 10 , 100 );
            }
 //AVAILABLE VALUES
            else // NOT ADS (if not editing value)
            {
            // Navigate value name
                if(event_press(RIGHT))
                {
                    valName_idx += 1;
                    display_new = TRUE; // Display value name and value
                }
                if(event_press(LEFT))
                {
                    valName_idx -= 1;
                    display_new = TRUE;
                }
 
            // Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_v[<active profile>], 1 = antirecoil_h[], 2 = at_t, 3 = at_h  
             // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
                if(modName_idx == 0) vals_available( 0 , 1  );// Anti-Recoil        
                if(modName_idx == 1) vals_available( 4 , 4  );// RapidFire                            
                if(modName_idx == 2) vals_available( 5 , 6  );// If BurstFire was displayed before I enter ModEdit, I can only edit all BurstFire values            
                if(modName_idx == 3) vals_available( 7 , 8  );// AIM Assist                
                if(modName_idx == 4) vals_available( 9 , 9  );// StrafeShot 
                if(modName_idx == 5) vals_available( 10 , 11 ); // Sticky Aim
                if(modName_idx == 6) vals_available( 12 , 12 ); // IngameSens Crescens Aim Corrections
                if(modName_idx == 7) vals_available( 13 , 15 ); // Sweet evil
                if(modName_idx == 8) vals_available( 16,  17 ); // Aim Snap
                if(modName_idx == 9) vals_available( 18,  19 ); // Anti Damage Wobble
            } // NOT RELOAD (if not editing value) end
        } // ModEdit end
//TOGGLES
        else // if NOT ModEdit BUT if ModMenu
        {
        // Navigate mods name
            if(event_press(RIGHT))
            {
                modName_idx += 1;
                display_new = TRUE;
            }
            if(event_press(LEFT))
            {
                modName_idx -= 1;
                display_new = TRUE;
            }
        // Cycle mods name
            if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
                modName_idx = 0;
            if(modName_idx < 0)
                modName_idx = LAST_MODNAME_STRING;
        // Switch profiles    
            if(event_press(REVIVE))
            {
                profile_idx += 1;
                display_new = TRUE;
            }
        // Cycle profiles    
            if(profile_idx > (AMOUNT_OF_PROFILES - 1))
                profile_idx = 0;
        // Toggles (UP to turn ON, DOWN to turn OFF)
            // Mods that can have different ON/OFF status depending the active Profile
          //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
            toggle_antirecoil[profile_idx] = toggle( 0, toggle_antirecoil[profile_idx] );
            toggle_rapidfire[profile_idx]  = toggle( 1, toggle_rapidfire[profile_idx]  );
            toggle_burstfire[profile_idx]  = toggle( 2, toggle_burstfire[profile_idx]  );
            toggle_aimassist[profile_idx]  = toggle( 3, toggle_aimassist[profile_idx]  );
            toggle_strafeShot[profile_idx] = toggle( 4, toggle_strafeShot[profile_idx] );
            // Mods that have same ON/OFF status on every Profiles
          //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
            stickyaim_on = toggle( 5 , stickyaim_on );
            aimsens_on = toggle( 6 , aimsens_on );
            silentaim_on = toggle( 7 , silentaim_on );
            aimsnap_on  = toggle( 8 , aimsnap_on  );
            antidw_on   = toggle( 9, antidw_on   );
            autorun_on  = toggle( 10 , autorun_on  );
            swap_on     = toggle( 11 , swap_on     );
            inverted_on = toggle( 12 , inverted_on );
            custom_sens = toggle(13 , custom_sens );
            easyplate_on = toggle(14 , easyplate_on ); 
            enemy_ping = toggle(15 , enemy_ping );
            meleeturbo_on  = toggle( 16 , meleeturbo_on  );
            quickscope_on  = toggle( 17 , quickscope_on  );
            mwslide_on  = toggle( 18 , mwslide_on  );
            cwslide_on  = toggle( 19 , cwslide_on  );
            holdbreath_on   = toggle( 20, holdbreath_on   );
            hairtriggers_on = toggle(21, hairtriggers_on  );
            smartreload_on = toggle(22, smartreload_on    );
            loadoutdrop_on = toggle(23, loadoutdrop_on    );
            
        } // if NOT ModEdit BUT if ModMenu end
    // If ModMenu AND ModEdit
        if(event_press(HOME))
            save ();
        //block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
        block_all_inputs();
    } // ModMenu ON end
//MOD MENU MOD EDIT  
    if(!ModMenu)
    {
    // Speed Toggles
      //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2 300ms   , toggle_I_want_to_edit[profile] , corresponding modName_idx );
        toggle_rapidfire[profile_idx]  = speed_toggle( ADS, UP   , toggle_rapidfire[profile_idx] , 1 );
        toggle_burstfire[profile_idx]  = speed_toggle( ADS, DOWN , toggle_burstfire[profile_idx] , 2 );
        toggle_aimassist[profile_idx]  = speed_toggle( ADS, RIGHT, toggle_aimassist[profile_idx] , 3 );
        toggle_strafeShot[profile_idx] = speed_toggle( ADS, LEFT , toggle_strafeShot[profile_idx], 4 );
        // We can add as many speed toogle as we need
    // Double Tap
        if(double_tap) 
            double_tap -= get_rtime();
//AIM ASSIST
    // If AIM Assist is enable for the curent profile
  //update main every 8ms --> only for PS4
    //vm_tctrl(-2); 
    
    if (drivingmode_on)
    {
    	if(event_release(RELOAD)) drivingmode_on = FALSE;
    }
    
    // if driving mode is on you cant use any of the other mods
    if (!drivingmode_on)
    {
    	if(get_val(PS4_L3) && get_val(PS4_R3))
    	{
    		combo_run(RUMBLE_ON);
    		drivingmode_on = TRUE;	
    	}
    	if(event_press(ADS)) set_val(ADS, 100);
    	if(event_release(ADS)) set_val(ADS, 0);
	    if (silentaim_on) 
	           if(get_val(ADS)) 
	        {        
	            if (Current_State == Get_Last_Value)
	            {
	                X_Last_Value = get_lval(RX);
	                Y_Last_Value = get_lval(RY);
	 
	                Current_State = Get_Current_Value;
	 
	            }
	            else if (Current_State == Get_Current_Value)
	            {
	                X_Current_Value = get_val(RX);
	                Y_Current_Value = get_val(RY);
	 
	                if(Aim_Abuse_State == Aim_Correction)
	                {    
	                    Current_State = Aim_Boost;
	                }
	                else
	                {
	                    Current_State = Aim_Correction;
	                }    
	            }
	            if (Current_State == Aim_Boost)
	            {
	                //Applying BOOST
	                //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) 
	                Aim_Perfection(X_Last_Value, X_Current_Value, 1, 0, 1, 0 ); 
	                Aim_Perfection(Y_Last_Value, Y_Current_Value, 1, 0, 0, 1 ); 
	 
	                Current_State = Get_Last_Value;
	                Aim_Abuse_State = Aim_Boost;  
	            }
	            else if (Current_State == Aim_Correction)
	            {
	                //Applying CORRECTION
	                //Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS )
	                Aim_Perfection(X_Last_Value, X_Current_Value, 0, 1, 1, 0 ); 
	                Aim_Perfection(Y_Last_Value, Y_Current_Value, 0, 1, 0, 1 ); 
	 
	                Current_State = Get_Last_Value;
	                Aim_Abuse_State = Aim_Correction; 
	            } 
	        }
	        else //--LT not pulled
	        {
	            Current_State = Get_Last_Value;
	            Aim_Abuse_State = Aim_Correction; 
	        }  
	    
	        if(toggle_aimassist[profile_idx] == 1)
	        {	
				if(get_ival(ADS) > 95 && get_val(FIRE) && get_val(ADS))
				{
	        		if(isqrt(abs(get_val(RX)) * abs(get_val(RX)) + abs(get_val(RY)) * abs(get_val(RY))) <= polaraim_radius) 
	        		{
		              	angle = mod(polaraim_radius, polaraim_speed, 360);
		              	set_polar(POLAR_RS, angle, polaraim_radius * random(326,328)); 
	              	}
	    }
	        }
	        
	        if(stickyaim_on)
	        {
	        if(get_val(ADS) && get_val(FIRE))
	                combo_run(STICKY_AIM);
	            else 
	                combo_stop(STICKY_AIM); 
	        }
	 if(aimsens_on)	
	      {
	      ads_grenade_sens=100-(in_game_sens); ads_fire_sens=96-(in_game_sens); 
	      if (get_val (ADS))
	                    {
	                                      if(get_val(FIRE) && get_val(ADS))                              
	                                              { 
	                                              Sens = ads_fire_sens;                                              
	                                              }
	                                    if(!get_val(FIRE) && !get_val(ADS) || get_val (FIRE) &&!get_val(ADS)) 
	                                              {
	                                            Sens = 100; //--general sens & hip fire sens 
	                                              }   
	                                      if(!get_val(FIRE) && get_val(ADS))
	                                              {
	                                            Sens = ads_grenade_sens;
	                                              }
	        if(Sens > 100) Sens = 100;  
	        sensitivity(RX, NOT_USE, Sens);
	        sensitivity(RY, NOT_USE, Sens);
	    }
	    }  //------end AIM_CORRECTIONS   
	    
	// STRAFE SHOT
	   // If Strafe Shot is enable for the curent profile
	        if(toggle_strafeShot[profile_idx] == 1)
	        {
	        // Run combo
	            if(get_val(FIRE))
	                combo_run(STRAFESHOT);
	            else
	                combo_stop(STRAFESHOT);
	        }
	// OTHER MODS  
	    if(enemy_ping)
			{
			if(event_release(FIRE) && event_press(FIRE)) combo_run(auto_ping);
			}
			
		if(easyplate_on)
			{
			if(get_val(REVIVE)&&get_ptime(REVIVE)>350)// change to double click if you want to put 3 plates after double pressing triangle
			combo_run(easy_plate);
			if(get_val(ADS)>10)
			combo_stop(easy_plate);
			if(get_val(FIRE)>10)
			combo_stop(easy_plate);
			if(get_val(RELOAD))
			combo_stop(easy_plate);
			}
	    if(custom_sens)
	    if(!get_val(ADS) && !get_val(FIRE)) { 
	    USE_SENS=GEN_SENS;}
	    else if(get_val(ADS) && !get_val(FIRE)) { 
	    USE_SENS=ADS_SENS;}    
	    else if(!get_val(ADS) && get_val(FIRE)) { 
	    USE_SENS=FIRE_SENS;}
	    else if(get_val(ADS) && get_val(FIRE)) { 
	    USE_SENS=ADS_FIRE_SENS;}
	    else if(get_val(LETHAL)) { 
	    USE_SENS=GRENADE_SENS;}
	    sensitivity(RY,NOT_USE,USE_SENS);
	    sensitivity(RX,NOT_USE,USE_SENS);		
			
	        if(autorun_on) // (5)
	        {
	            if(get_val(LY) < -60)
	            {
	                set_val(LY, -100);
	                set_val(SPRINT, 100);
	            }
	        }
	    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?    
	        if(swap_on) // (6)
	        {
	            swap(LETHAL, FIRE);
	            swap(TACTICAL, ADS);
	        }
	    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
	        if(inverted_on) // (7)
	            invert = -1;
	        else
	            invert = 1;
	            
	    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
	    	if(meleeturbo_on) //  (8)
	    	{
	    		if(get_val(MELEE)) 
	    			combo_run(melee_turbo);
	    		if (event_release(MELEE)) 
	    			combo_stop(melee_turbo);
	    	}
	    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
	    	if(quickscope_on)  //   (9)
				{
					if(event_release(ADS) && get_ptime(ADS) < 320) combo_run(Quick_Scope);
				}
		// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(mwslide_on)    //     (10)
				{
					if((get_val(LY) < -60) || (get_val(LY) > 60) || (get_val(LX) < -60) || (get_val(LX) > 60)) 
					{
						if (event_release(PRONE)) combo_run(CANCEL_SLIDE_MW); 												      
					}
				}
		// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(cwslide_on)    //     (11)
				{
					if((get_val(LY) < -60) || (get_val(LY) > 60) || (get_val(LX) < -60) || (get_val(LX) > 60)) 
					{
						if (event_release(PRONE)) combo_run(CANCEL_SLIDE_CW); 												      
					}
				}
		// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(aimsnap_on)   // (12)
				{
					if(get_val(ADS)) combo_run(aimsnap);
					else if(get_val(ADS) && get_val(FIRE)) combo_stop(aimsnap);
					else combo_stop(aimsnap);
				}
	   // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(antidw_on)   // (13)
				{
					if((get_val(RUMBLE_A) || get_val(RUMBLE_B) || get_val(RUMBLE_LT) || get_val(RUMBLE_RT)) && !get_val(FIRE))
					{
						combo_run(anti_damage_wobble);
					}
				}
	    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(holdbreath_on)   // (14)
				{
					if(get_val(ADS))
						set_val(SPRINT,100);
			
					if(get_val(LY) <-90 && get_val(ADS) && get_ptime(ADS) > 200 && combo_running(hold_breath))
						combo_stop(hold_breath);
			
					if(event_press(ADS))
						combo_run(hold_breath);
			
					if(get_val(ADS) && get_lval(SPRINT))
						set_val(SPRINT,0);
						
				}
		// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(hairtriggers_on)   // (15)
				{
					if(get_val(ADS) > 10) set_val(ADS, 100);
					if(get_val(FIRE) > 10) set_val(FIRE, 100);
					if(get_val(LETHAL) > 10) set_val(LETHAL, 100);
					if(get_val(TACTICAL) > 10) set_val(TACTICAL, 100);
				}
		// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(smartreload_on)   // (16)
				{
	      			if (double_click(ADS))
	      			{
	      				combo_run(cancel_reload);
	      			}
				}
		// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
			if(loadoutdrop_on)   // (17)
				{
	      			combo_run(loadout_drop_reminder);
				}
	}
// SWITCH PROFILE
    // Switch Profiles - tap REVIVE/Y to switch profile 1 or 2 - double tap for profile 3 - hold MELEE/RS + tap for sync color
        if(event_press(REVIVE) || (get_val(SPRINT) && event_press(REVIVE)))
        {
            profile_1or2=!profile_1or2; 
            profile_3 = FALSE;
 
            if(double_tap) 
            { 
                 profile_3 = TRUE ; 
                profile_1or2 = !profile_1or2;
            }
            else
                double_tap = 200;
 
            if(ModMenu)
                display_new = TRUE;
            else
                display_title = TRUE;
        }

    // If Profile 3
        if(profile_3)
            profile_idx = 2;
 
        else
        {    
        // If Profile 2
            if(profile_1or2)
                profile_idx = 1;
 
        // If Profile 1
            else    
                profile_idx = 0;
        }
    } // ModMenu OFF end
//ANTI RECOIL
// If Anti-Recoil is enable for the active profile
    if(toggle_antirecoil[profile_idx] == 1)
    {    
         if(get_val(FIRE)) combo_run(anti_recoil);
	     else combo_stop(anti_recoil);
    }
// RAPID FIRE
// If RapidFire is enable for the active profile
    if(toggle_rapidfire[profile_idx] == 1)
    {
    // Rate of Fire Calculation
        hold_time = 500 / (VALUES[profile_idx][4] + rate_of_fire[profile_idx]); 
           rest_time = hold_time - 20;
        if(rest_time < 0) rest_time = 0;
 
    // Run combo
        if(get_ival(FIRE))
            combo_run(RAPIDFIRE);
        else
            combo_stop(RAPIDFIRE);
 
        led_on = 150;
        led_off = 300;
        combo_run(BLINK);
    }
// BURST FIRE
// If BurstFire is enable for the active profile
    if(toggle_burstfire[profile_idx] == 1)
    {
    // Hold and Release
        hold_time = burstfire_hold;
        rest_time = burstfire_release;
 
    // Run combo
        if(get_ival(FIRE))    
            combo_run(BURSTFIRE);
        else
            combo_stop(BURSTFIRE);
 
        led_on = 200;
        led_off = 1000;
        combo_run(BLINK);
    }  
// REFRESH DISPLAY   
    if(display_new) 
    {
    // Clear OLED screen    
        cls_oled(0);
        count_black = 0;// reset screen saver counter
 
        if(ModEdit)
        {
        // Display Value Name and value
            // Mods that can have different values depending the active Profile
          //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
            display_edit( 0 , center_x(sizeof(ANTIRECOIL_V) - 1, OLED_FONT_MEDIUM_WIDTH)      , ANTIRECOIL_V[0]      , antirecoil_v[profile_idx]      );
            display_edit( 1 , center_x(sizeof(ANTIRECOIL_H) - 1, OLED_FONT_MEDIUM_WIDTH)        , ANTIRECOIL_H[0]        , antirecoil_h[profile_idx]        );
            display_edit( 4 , center_x(sizeof(RATE_OF_FIRE) - 1 , OLED_FONT_MEDIUM_WIDTH)         , RATE_OF_FIRE[0]          , rate_of_fire[profile_idx]          );
            // Mods that have same value on every Profile
            display_edit( 5 , center_x(sizeof(BURSTFIRE_HOLD) - 1, OLED_FONT_MEDIUM_WIDTH)    , BURSTFIRE_HOLD[0]    , burstfire_hold    );
            display_edit( 6 , center_x(sizeof(BURSTFIRE_RELEASE) - 1, OLED_FONT_MEDIUM_WIDTH) , BURSTFIRE_RELEASE[0] , burstfire_release );
            display_edit( 7 , center_x(sizeof(RADIUS) - 1, OLED_FONT_MEDIUM_WIDTH)    , RADIUS[0]    , polaraim_radius    );
            display_edit( 8 , center_x(sizeof(SPEED) - 1, OLED_FONT_MEDIUM_WIDTH)    , SPEED[0]    , polaraim_speed    );
            display_edit( 9 , center_x(sizeof(STRAFESHOT_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)   , STRAFESHOT_TIME[0]   , strafeShot_time   );
            display_edit( 10 , center_x(sizeof(STICKYAIM_SIZE) - 1, OLED_FONT_MEDIUM_WIDTH)   , STICKYAIM_SIZE[0]   , stickyaim_size   );
            display_edit( 11 , center_x(sizeof(STICKYAIM_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)   , STICKYAIM_TIME[0]   , stickyaim_time   );
            display_edit( 12 , center_x(sizeof(INGAMESENS)     - 1, OLED_FONT_MEDIUM_WIDTH)   , INGAMESENS[0]        , in_game_sens   );
            display_edit( 13 , center_x(sizeof(AIMCORRECT)     - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMCORRECT[0]        , Aim_Correction   );
            display_edit( 14 , center_x(sizeof(AIMBOOST)     - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMBOOST[0]        , Aim_Boost  );
            display_edit( 15 , center_x(sizeof(AIMPERFECT)     - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMPERFECT[0]        , Aim_Perfection_Limit   );
            display_edit( 16 , center_x(sizeof(AIMSNAPHOLD)     - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMSNAPHOLD[0]        , aimsnap_hold   );
            display_edit( 17 , center_x(sizeof(AIMSNAPRELEASE)     - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMSNAPRELEASE[0]        , aimsnap_release   );
            display_edit( 18 , center_x(sizeof(ANTIDWDRAG)     - 1, OLED_FONT_MEDIUM_WIDTH)   , ANTIDWDRAG[0]        , antidw_vertical   );
            display_edit( 19 , center_x(sizeof(ANTIDWTIME)     - 1, OLED_FONT_MEDIUM_WIDTH)   , ANTIDWTIME[0]        , antidw_horizontal   );
        }
        else
        {
        // Display Mod Name and ON/OFF
            // Mods that can have different ON/OFF status depending the active Profile
          //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
            display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , toggle_antirecoil[profile_idx]);
            display_mod( 1 ,  center_x(sizeof(RAPIDFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)  , RAPIDFIRE[0]  , toggle_rapidfire[profile_idx]);
            display_mod( 2 ,  center_x(sizeof(BURSTFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)  , BURSTFIRE[0]  , toggle_burstfire[profile_idx]);
            display_mod( 3 ,  center_x(sizeof(AIMASSIST) - 1, OLED_FONT_MEDIUM_WIDTH)  , AIMASSIST[0]  , toggle_aimassist[profile_idx]);
            display_mod( 4 ,  center_x(sizeof(STRAFE_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH), STRAFE_SHOT[0], toggle_strafeShot[profile_idx]);
            // Mods that have same ON/OFF status on every Profile
            display_mod( 5 ,  center_x(sizeof(STICKYAIM) - 1, OLED_FONT_MEDIUM_WIDTH) , STICKYAIM[0] , stickyaim_on);
            display_mod( 6 ,  center_x(sizeof(Aim_Sens) - 1, OLED_FONT_MEDIUM_WIDTH) , Aim_Sens[0] , aimsens_on);
            display_mod( 7 ,  center_x(sizeof(Silent_Aim) - 1, OLED_FONT_MEDIUM_WIDTH), Silent_Aim[0], silentaim_on);
            display_mod( 8 ,  center_x(sizeof(AIMSNAP) - 1, OLED_FONT_MEDIUM_WIDTH) , AIMSNAP[0] , aimsnap_on);
            display_mod( 9 ,  center_x(sizeof(ANTIDW) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIDW[0] , antidw_on);
            display_mod( 10 ,  center_x(sizeof(AUTORUN) - 1, OLED_FONT_MEDIUM_WIDTH) , AUTORUN[0] , autorun_on);
            display_mod( 11 ,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)    , SWAP[0]    , swap_on);
            display_mod( 12 ,  center_x(sizeof(INVERTED) - 1, OLED_FONT_MEDIUM_WIDTH), INVERTED[0], inverted_on);
            display_mod( 13 , center_x(sizeof(CustomSens) - 1, OLED_FONT_MEDIUM_WIDTH), CustomSens[0], custom_sens);
            display_mod( 14 , center_x(sizeof(EASYPLATE) - 1, OLED_FONT_MEDIUM_WIDTH), EASYPLATE[0], easyplate_on);
            display_mod( 15 , center_x(sizeof(ENEMYPING) - 1, OLED_FONT_MEDIUM_WIDTH), ENEMYPING[0], enemy_ping);
            display_mod( 16 ,  center_x(sizeof(MELEETURBO) - 1, OLED_FONT_MEDIUM_WIDTH) , MELEETURBO[0] , meleeturbo_on);
            display_mod( 17 ,  center_x(sizeof(QUICKSCOPE) - 1, OLED_FONT_MEDIUM_WIDTH) , QUICKSCOPE[0] , quickscope_on);
            display_mod( 18 ,  center_x(sizeof(MWSLIDE) - 1, OLED_FONT_MEDIUM_WIDTH) , MWSLIDE[0] , mwslide_on);
            display_mod( 19 ,  center_x(sizeof(CWSLIDE) - 1, OLED_FONT_MEDIUM_WIDTH) , CWSLIDE[0] , cwslide_on);
            display_mod( 20 ,  center_x(sizeof(HOLDBREATH) - 1, OLED_FONT_MEDIUM_WIDTH) , HOLDBREATH[0] , holdbreath_on);
            display_mod( 21 ,  center_x(sizeof(HAIRTRIGGERS) - 1, OLED_FONT_MEDIUM_WIDTH) , HAIRTRIGGERS[0] , hairtriggers_on);
            display_mod( 22 ,  center_x(sizeof(SMARTRELOAD) - 1, OLED_FONT_MEDIUM_WIDTH) , SMARTRELOAD[0] , smartreload_on);
            display_mod( 23 ,  center_x(sizeof(LOADOUTDROP) - 1, OLED_FONT_MEDIUM_WIDTH) , LOADOUTDROP[0] , loadoutdrop_on);
            
        }
    // Display Profile only on mods that may have a different value depending on the Profile
        if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
        {
            if(profile_idx == 0) // profile_idx = profile_idx = Profile
                //printf(center_x(sizeof(PROFILE_1) - 1, SMALL),23,SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
                line_oled(0, 26, 39, 26, 5, 1); // print a line to the left to say profile 1
            else if(profile_idx == 1)
                //printf(center_x(sizeof(PROFILE_2) - 1, SMALL),23,SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
                line_oled(44, 26, 83, 26, 5, 1); // print a line in the middle to say Profile 2
            else if(profile_idx == 2)
                //printf(center_x(sizeof(PROFILE_3) - 1, SMALL),23,SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
                line_oled(88, 26, 127, 26, 5, 1); // print a line to the right to say Profile 3
        }
        else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
        {
            line_oled(0, 26, 39, 26, 5, 1);
            line_oled(44, 26, 83, 26, 5, 1);
            line_oled(88, 26, 127, 26, 5, 1);
        }
 
        display_black = TRUE;
        display_new = FALSE;
    } // display_new end
 
} // NOT KillSwitch end
 
    led(profile_idx);
 
} // main end
// AIM ASSIST COMBO

// COMBO SECTION

combo anti_recoil {
// V
   AntirecoilVertical = get_val(RY) + antirecoil_v[profile_idx];  
   if(AntirecoilVertical > 100) AntirecoilVertical = 100;
   if(abs(get_val(RY)) < abs(antirecoil_v[profile_idx]) +  5)
   set_val(RY, (AntirecoilVertical * invert));
// H
   AntirecoilHorizontal = get_val(RX) + antirecoil_h[profile_idx];
   if(AntirecoilHorizontal > 100) antirecoil_h = 100;
   if(abs(get_val(RX)) < abs(antirecoil_h[profile_idx])  + 5)
   set_val(RX, AntirecoilHorizontal);
}

combo cancel_reload {
set_val(REVIVE, 100);
wait(30);
wait(20);
set_val(REVIVE, 100);
wait(30);
wait(20);
}

combo auto_ping{
set_val(UP,100);
wait(20)
set_val(UP,0);
wait(20)
set_val(UP,100);
wait(20)
set_val(UP,0);
}
	
combo melee_turbo
	{set_val(MELEE, 100);
    wait(10);
    set_val(MELEE, 0);
    wait(25);
	}

combo easy_plate
{
set_val(REVIVE,100);
wait(6000)
}//time triangle is held for adjust higher or lower 500 if you only get 2 plates or cant switch weapons after replating
 
combo loadout_drop_reminder
{
set_ledx(3, 3);
wait(first_loadout_time);
set_rumble(RUMBLE_A, 100);
set_rumble(RUMBLE_B, 100);
set_rumble(RUMBLE_LT, 100);
set_rumble(RUMBLE_RT, 100);
wait(200);
set_rumble(RUMBLE_A, 0);
set_rumble(RUMBLE_B, 0);
set_rumble(RUMBLE_LT, 0);
set_rumble(RUMBLE_RT, 0);
wait(second_loadout_time);
set_rumble(RUMBLE_A, 100);
set_rumble(RUMBLE_B, 100);
set_rumble(RUMBLE_LT, 100);
set_rumble(RUMBLE_RT, 100);
wait(200);
set_rumble(RUMBLE_A, 0);
set_rumble(RUMBLE_B, 0);
set_rumble(RUMBLE_LT, 0);
set_rumble(RUMBLE_RT, 0);
}
 
combo RUMBLE_ON {                        // 2 high rumbles + green blink 2 times
    set_ledx(2, 2);
    set_rumble(RUMBLE_B, 50);
    wait(150);
    reset_rumble();
    wait(100);
    set_rumble(RUMBLE_B, 50);
    wait(150);
    reset_rumble();
}
 
combo RUMBLE_OFF {                        // 1 high rumble + red blink 1 time
    set_ledx(1, 1);
    set_rumble(RUMBLE_A, 50);
    wait(300);
    reset_rumble();
    wait(400);
}
 
combo SAVE { 
    cls_oled(0);                        // clear OLED screen 
    printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]);     // display SAVED... centered in X Y 
    wait(10)
    call(RUMBLE_ON);                    // 2 high rumbles + green blink 2 times                                
    wait(100);
    call(RUMBLE_ON);                    // 2 high rumbles + green blink 2 times    
    wait(100);
    display_new = TRUE;                   // display mods
}

combo BURSTFIRE { 
    wait(hold_time);
    call(RAPIDFIRE);
    call(RAPIDFIRE);
    call(RAPIDFIRE);
    call(RAPIDFIRE);
    }
 
combo RAPIDFIRE { 
    wait(hold_time);
    set_val(FIRE, 0);
    wait(rest_time);
    }
 

combo STICKY_AIM {
    set_val(RY,xy_val(RY, stickyaim_size));
    wait(stickyaim_time);
    set_val(RX,xy_val(RX, stickyaim_size));
    set_val(LX,xy_val(LX, stickyaim_size));
    wait(stickyaim_time);
    set_val(RY,xy_val(RY, stickyaim_size * -1));
    wait(stickyaim_time);
    set_val(RX,xy_val(RX, stickyaim_size * -1));
    set_val(LX,xy_val(LX, stickyaim_size * -1));
    wait(stickyaim_time);
    }

combo STRAFESHOT { // StrafeShot
    set_val(LX, 100);
    wait(strafeShot_time);
    wait(50);
    set_val(LX, -100);
    wait(strafeShot_time);
    wait(50);
}
 
combo BLINK {
    led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}

combo anti_damage_wobble 
{
	BOOST++;
	ANTIWOBBLE = get_val(RY) + antidw_vertical + BOOST;
	if(BOOST == 10) {
	BOOST = 0; }
	if(ANTIWOBBLE > 100) {
	ANTIWOBBLE = 100; }
	set_val(RY, ANTIWOBBLE * invert);
	ANTIWOBBLE = get_val(RX) + antidw_horizontal;
	if(ANTIWOBBLE > 100){
	ANTIWOBBLE = 100; }
	set_val(RX, ANTIWOBBLE);
}

combo Quick_Scope
{
	set_val(ADS,100);
	wait(360);
	set_val(ADS,100);
	set_val(FIRE,100);
	wait(40);
	set_val(ADS,100);
	wait(40);
}

combo CANCEL_SLIDE_MW 
{
	set_val(PRONE, 100);
	wait(120);
	set_val(PRONE, 0);
	wait(60);
	set_val(PRONE, 100);
	wait(50);
	set_val(PRONE, 100);
	set_val(JUMP, 100);
	wait(60);
	set_val(PRONE, 0);
	set_val(JUMP, 100);
	wait(10);
	set_val(JUMP, 0);
}

combo CANCEL_SLIDE_CW {
	set_val(PRONE, 100);
	wait(80);
	set_val(PRONE, 0);
	wait(20);
	set_val(SPRINT, 0);
	set_val(ADS, 100);
	wait(10);
	set_val(ADS, 0);
	set_val(PRONE, 100);
	set_val(SPRINT, 100);
	wait(20);
	set_val(PRONE, 0);
	set_val(SPRINT, 0);
	wait(20);
}

combo aimsnap{
	set_val(ADS, 100);
	wait(random(aimsnap_hold, aimsnap_release)); // Hold Time Between 220ms and 420ms
	set_val(ADS, 0);
	wait(random(aimsnap_hold, aimsnap_release));  //  Release Time Between 95ms and 220ms 
}

combo hold_breath{

	set_val(SPRINT,0);
	wait(64);
	set_val(SPRINT,100);
	wait(112);
	set_val(SPRINT,0);
	wait(112);
}

// FUNCTIONS 
function 
Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS) 
    { 
       mvt = abs(Last_Value) + abs(Current_Value);
       Aim_Boost_Val = ( mvt + 1 )/2; //Rounding integer division (instead of truncating)
       Aim_Correction_Val = Aim_Boost_Val + 4;
 
       if(Aim_Boost_Val >= 10)
       {
           Aim_Boost_Val = 10;
           Aim_Correction_Val = 14;
       }
       else if(Aim_Boost_Val == 0)
       {
            Aim_Boost_Val = 2
            Aim_Correction_Val = 4;
       }
 
 
       if(mvt < Aim_Perfection_Limit) 
       {
            //--moving right
            if(Last_Value < Current_Value)
            {           
                if (Boost)
                { 
                    if (X_AXIS)
                        set_val(RX, (Current_Value + Aim_Boost_Val)); 
 
                    if (Y_AXIS)
                        set_val(RY, (Current_Value + Aim_Boost_Val));
                }
                else if(Correction)
                {
                    if (X_AXIS)
                        set_val(RX, (Current_Value - Aim_Correction_Val)); 
 
                    if (Y_AXIS)
                        set_val(RY, (Current_Value - Aim_Correction_Val));            
                }
            }
            else //--moving left
            {
                if (Boost)
                { 
                    if (X_AXIS)
                        set_val(RX, (Current_Value - Aim_Boost_Val)); 
 
                    if (Y_AXIS)
                        set_val(RY, (Current_Value - Aim_Boost_Val));
                }
                else if(Correction)
                {
                    if (X_AXIS)
                        set_val(RX, (Current_Value + Aim_Correction_Val)); 
 
                    if (Y_AXIS)
                        set_val(RY, (Current_Value + Aim_Correction_Val));            
                }
            }
        }
    } 
function double_click(button) {        
    if (double__tap[button] >= 0) {                    
        double__tap[button] += get_rtime(); 
        if (double__tap[button] > 450)
            double__tap[button] = -1;                                                                                       
    }           
    if (event_release(button) && get_ptime(button) <= 200) { 
        if (double__tap[button] < 0) {                    
            double__tap[button] = 0;                        
        } else {             
            double__tap[button] = -1;                       
            return 1;                                   
        }                                                     
    }                                                  
    return 0;
    }


function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods
 
    if(valName_idx < f_min)
        valName_idx = f_max;
    if(valName_idx > f_max)
        valName_idx = f_min;
 
// Match the # of value names index with the right column in VALUES array
    val_col_idx = valName_idx;    
}
 
function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_v[profile_idx] = edit_val( 0 , antirecoil_v[profile_idx], 99  , 99  )
 
    if(valName_idx == f_idx)
    {
    // +1 or -1                                                             // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
        f_val    = value_change( f_val ,LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
        f_val    = value_change( f_val ,RIGHT, f_inc1     , f_min, f_max ); // f_inc1
        // +10 or -10
              f_val    = value_change( f_val ,DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
           f_val    = value_change( f_val ,UP   , f_inc2     , f_min, f_max ); // f_inc2
 
    // We can also add (f_ref)
    // Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_v[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;    
    }
    // Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
    //if(rate_of_fire[profile_idx] < 0)
    //    rate_of_fire[profile_idx] = 0;
 
    //return f_ref;
 
    return f_val;
}
 
function speed_toggle(f_hold, f_press, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(MELEE, UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
 
    if(get_val(f_hold))
    {
        if(get_val(f_press) && get_ptime(f_press) == 300) // Hold second button 300ms or more
        {
            modName_idx = f_string;
 
            if(f_val == 0)
            {
                if(f_string == 1) // If RapidFire is enable, 
                    toggle_burstfire[profile_idx] = 0; // disable BurstFire
                else if(f_string == 2) // If BurstFire is enable, 
                    toggle_rapidfire[profile_idx] = 0; // disable RapidFire
 
                f_val = 1;
                combo_run(RUMBLE_ON);
            }
            else
            {
                f_val = 0;
                combo_run(RUMBLE_OFF);
            }
            display_new = TRUE;
        } 
    set_val(f_press, 0)
    }
 
    return f_val;
}
 
function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, UP, toggle_antirecoil[profile_idx]);
 
    if(event_press(UP))
    {
        if(modName_idx == f_idx)
        {
            if(f_idx == 1) // If RapidFire is enable, 
                toggle_burstfire[profile_idx] = 0; // disable BurstFire
            else if(f_idx == 2) // If BurstFire is enable, 
                toggle_rapidfire[profile_idx] = 0; // disable RapidFire
 
            f_val = 1;
            combo_run(RUMBLE_ON);
        }
 
        display_new = TRUE;
    }
 
    if(event_press(DOWN))
    {
        if(modName_idx == f_idx)
        {
            f_val = 0;
            combo_run(RUMBLE_OFF);
        }        
        display_new = TRUE;
    }
    return f_val;
}
 
function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_V) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_V[0], antirecoil_v[profile_idx]);
 
        if(valName_idx == f_idx)
        {
        // Display value name and value
            printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
 
        // Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
            if(f_idx == 2) 
                number_to_string((VALUES[profile_idx][val_col_idx] + f_val) * 100, find_digits((VALUES[profile_idx][val_col_idx] + f_val) * 100));
 
        // Display all editable values in VALUES array
            else if(f_idx <= LAST_EDITABLE_COLUMN) 
                number_to_string(VALUES[profile_idx][val_col_idx] + f_val, find_digits(VALUES[profile_idx][val_col_idx] + f_val));
 
        // Display editable values that are not in the array (burstfire_hold for exemple)
            else 
                number_to_string(f_val, find_digits(f_val));
        }
}  
 
function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
        if(modName_idx == f_idx)
        {
        // Display MOD_NAME
            printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
 
        // Display ON OFF
            if(f_toggle == 1)
                printf(center_x(sizeof(ON) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,ON[0]);
            else
                printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);
        }
}
 
function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 
 
    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
 
    // Values that are not in the array (aimassist_time for exemple)
        if(valName_idx > LAST_EDITABLE_COLUMN)
        {
        // Substract    
            if(f_val < inv(f_rng_min)) 
                f_val = inv(f_rng_min); 
           // Add   
              if(f_val > f_rng_max) 
                f_val = f_rng_max;
        }
 
    // Values that are in the array 
        else
        {
    // Substract    
        if((f_val + VALUES[profile_idx][val_col_idx]) < inv(f_rng_min)) 
            f_val = inv(f_rng_min + VALUES[profile_idx][val_col_idx]); 
    // Add   
        if((f_val + VALUES[profile_idx][val_col_idx]) > f_rng_max) 
            f_val = f_rng_max - VALUES[profile_idx][val_col_idx]; 
        }
        display_new = TRUE;
    }
    return f_val; 
}
function mod(var,val1,val2){
var += val1;
var %= val2;
return var;
}  








 
function xy_val(f_axis,f_val) {
    if(abs(get_val(f_axis)) < stickyaim_size + 1) 
        return f_val;
    return get_val(f_axis); 
}

 
function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
 
    if(f_val < 0) //--neg numbers
    {          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
    } 
 
    for(c = 5; c >= 1; c--) 
    {
        if(f_digits >= c) 
        {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function find_digits(f_num) {
//  find_digits(value)  
//        return Number of Digits in Value Passed  
 
    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//        return X for Centering String Horizontally
 
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function center_y(f_size) {
//  center_y(font size);  
//        return Y for Centering String Vertically
 
    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function press_hold(f_btn) { 
//  return TRUE - event_press()   
//                - every 250ms when button is held
 
    return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
           && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
 
function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}
 
function save () {
    combo_run(SAVE);
 
// Profile 1
    // Toggles                                      // Values
    set_pvar(SPVAR_1,toggle_antirecoil[0]);         set_pvar(SPVAR_6 ,antirecoil_v[0]     );         
    set_pvar(SPVAR_2,toggle_rapidfire[0] );         set_pvar(SPVAR_7 ,antirecoil_h[0]       );        
    set_pvar(SPVAR_3,toggle_burstfire[0] );         set_pvar(SPVAR_8 ,antirecoil_time[0]      );     
    set_pvar(SPVAR_4,toggle_aimassist[0] );         set_pvar(SPVAR_9 ,antirecoil_horizontal[0]);
    set_pvar(SPVAR_5,toggle_strafeShot[0]);         set_pvar(SPVAR_10,rate_of_fire[0]         );
// Profile 2
    // Toggles                                       // Values
    set_pvar(SPVAR_11,toggle_antirecoil[1]);         set_pvar(SPVAR_16,antirecoil_v[1]     );       
    set_pvar(SPVAR_12,toggle_rapidfire[1] );         set_pvar(SPVAR_17,antirecoil_h[1]       );      
    set_pvar(SPVAR_13,toggle_burstfire[1] );         set_pvar(SPVAR_18,antirecoil_time[1]      );     
    set_pvar(SPVAR_14,toggle_aimassist[1] );         set_pvar(SPVAR_19,antirecoil_horizontal[1]);
    set_pvar(SPVAR_15,toggle_strafeShot[1]);         set_pvar(SPVAR_20,rate_of_fire[1]         );
// Profile 3
    // Toggles                                       // Values
    set_pvar(SPVAR_21,toggle_antirecoil[2]);         set_pvar(SPVAR_26,antirecoil_v[2]     );       
    set_pvar(SPVAR_22,toggle_rapidfire[2] );         set_pvar(SPVAR_27,antirecoil_h[2]       );      
    set_pvar(SPVAR_23,toggle_burstfire[2] );         set_pvar(SPVAR_28,antirecoil_time[2]      );      
    set_pvar(SPVAR_24,toggle_aimassist[2] );         set_pvar(SPVAR_29,antirecoil_horizontal[2]);
    set_pvar(SPVAR_25,toggle_strafeShot[2]);         set_pvar(SPVAR_30,rate_of_fire[2]         );
// Misc
    // Toggles only                                      // Values
    set_pvar(SPVAR_31, autorun_on  );                set_pvar(SPVAR_34, burstfire_hold    );
    set_pvar(SPVAR_32, swap_on     );                set_pvar(SPVAR_35, burstfire_release );
    set_pvar(SPVAR_33, inverted_on );                set_pvar(SPVAR_36, polaraim_radius    );
    set_pvar(SPVAR_39, silentaim_on );               set_pvar(SPVAR_37, polaraim_speed    );
    set_pvar(SPVAR_40, stickyaim_on );               set_pvar(SPVAR_38, strafeShot_time   );
    set_pvar(SPVAR_43, aimsens_on );                 set_pvar(SPVAR_41, stickyaim_size    ); 
    set_pvar(SPVAR_45, custom_sens );                set_pvar(SPVAR_42, stickyaim_time    );
    set_pvar(SPVAR_49, easyplate_on );               set_pvar(SPVAR_44, in_game_sens      );
    set_pvar(SPVAR_50, enemy_ping   );               set_pvar(SPVAR_46, Aim_Correction    );
    set_pvar(SPVAR_51, meleeturbo_on);               set_pvar(SPVAR_47, Aim_Boost         );
    set_pvar(SPVAR_52, quickscope_on);               set_pvar(SPVAR_48, Aim_Perfection_Limit );
    set_pvar(SPVAR_53, mwslide_on);	                 set_pvar(SPVAR_56, aimsnap_hold );
    set_pvar(SPVAR_54, cwslide_on);                  set_pvar(SPVAR_57, aimsnap_release );
    set_pvar(SPVAR_55, aimsnap_on);
    set_pvar(SPVAR_58, antidw_on);
    set_pvar(SPVAR_59, holdbreath_on);
    set_pvar(SPVAR_60, hairtriggers_on);
    set_pvar(SPVAR_61, smartreload_on);
    set_pvar(SPVAR_62, loadoutdrop_on);
}
 
// ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 
/*
function block_btn() {
 
set_val(UP     , 0 );     set_val(DOWN  , 0 );     set_val(LEFT  , 0 );    set_val(RIGHT   , 0);
set_val(JUMP  , 0 );     set_val(PRONE, 0 );     set_val(RELOAD, 0 );     set_val(REVIVE, 0);
set_val(TACTICAL     , 0 );     set_val(LETHAL    , 0 );     set_val(SPRINT    , 0 );     set_val(MELEE      , 0);
set_val(OPTIONS, 0 );     set_val(SHARE , 0 );    set_val(TOUCHPAD , 0 );    set_val(HOME      , 0);
set_val(XB1_PL1    , 0 );     set_val(XB1_PL2   , 0 );    set_val(XB1_PR1   , 0 );    set_val(XB1_PR2     , 0);
//set_val(LX, 0);         set_val(LY, 0);         set_val(RX, 0);         set_val(RY, 0);
//set_val(ADS, 0);         set_val(FIRE, 0);
}   */