/*
 								 **** PUBG ITALIA ZEN EDITION ENGLISH VERSION ****
                               							
                               							Ver 6.0
                               							
              										MADE BY ANDRY 85
              										
              UN GRAZIE A NOOZBAR E TAYLORDRIFT21 PER LA BASE DELLO SCRIPT A BATTS PER IL RECOIL PROGRESSIVO
             
              SE VI PIACE LO SCRIPT POTETE FARE UNA DONAZIONE SU: IF YOU LIKE A SCRIPT CAN DONATE AT:

  										https://www.paypal.com/paypalme/andry1985
 												
 												
 														PER ASSISTENZA:
 												
 												https://discord.gg/rR3nAWSpKQ
  								https://www.facebook.com/groups/cronusmaxitaliaofficial
 					 https://cronusmax.com/forums/forumdisplay.php/262-CronusMAX-Supporto-Italiano
 
          										  ***** FEATURES *****
          										  
 This script you can select and set all the weapons through the menu, for each weapon you can set the vertical recoil through
 the previous recoil, in the script there is a self-tracking of the position, you can also adjust the reduction of the recoil if you are kneeling or lying down.
 In the script you can also set the recoil boost for 2/3/4/6 lenses.
 Rapid fire can be activated on the weapons that allow it, and then for each profile you can enable TBag, Jumpshot, strafe, autolean, peekshot, crouch on ADS.
 the automatic breathing if activated works on all profiles while the Quickscope if activated works only if the sniper is selected
 Change weapon name directly from the zen menu, guide mode where it disables part of the script, and grenade mode
 The fast toogle menu has been inserted from the keyboard you can assign various mods (therefore activation / deactivation or execution) to the keyboard keys
 Within the script you have to set whether you play from pad or from M&K
 If you play from a pad you can also connect a keyboard to perform a quick profile reset and use the keypad (NUMPAD) to equip weapons and sights quickly,
 the keys assigned to each weapon have been written below.

 
 FAST ARM KEYS via NUMPAD:

ace 32 			 tasto 1
ak47		     tasto 2
M416	         tasto 3
SCAR_L 		     tasto 4
K2 			     tasto 5
UZI  		     tasto 6
AUG 		     tasto 7
G36 		     tasto 8
QBZ		         tasto 9
BERYL 			 tasto .
VECTOR 			 tasto *
P90 		     tasto /
mp5K			 tasto 0
Sniper 			 tasto  PAGEUP
slr 			 tasto  PAGEDOWN
sks				 tasto  FINE
mini 14 		 tasto  CANC
		
FAST SIGHT KEYS

To increase OPTICAL KEY + (NUMPAD)
To decrease OPTICAL KEY - (NUMPAD)
Reset spindle ENTER KEY (NUMPAD)


RESET key in fast toogle if assigned to pressure resets the primary and secondary profiles to generic with 1x


 PROFILE COLORS

GREEN PRIMARY PROFILE
RED SECONDARY PROFILE
LIGHT BLUE WARZONE PROFILE
		
							
FAST ENABLES
autolean = HOLD PS4_L2 and PRESS FOR MORE THAN 0.3s PS4_UP
rapidfire = HOLD PS4_L2 and PRESS FOR MORE THAN 0.3s PS4_LEFT Flash profile color
strafe = HOLD PS4_L2 and PRESS FOR MORE THAN 0.3s PS4_RIGHT flashing profile color + BLUE
peekshot = HOLD PS4_L2 and PRESS FOR MORE THAN 0.3s PS4_DOWN
TBAG = HOLD KEY TO DOWN and PRESS FOR MORE THAN 0.3s PS4_DOWN profile color flashing + YELLOW
CROUCHON ADS = HOLD BUTTON TO JUMP and PRESS FOR MORE THAN 0.3s PS4_RIGHT flashing color profile + WHITE


DRIVE MODE:  Activation  LT and  double clik Dpad Right deactivation  Press B OR CIRCLE
NADE MODE : Activation with Right click and deactivation with Y OR triangle CLICK 
NADE mode you recognize it because it is written on the monitor (when it is activated and deactivated and the zen colors have a rainbow effect
To change the firing distance press AIM + breath and the arrows work.
		
/*=============================================================================================================================                                          
| Please read the instructions before programming the script on zen. READ INSTRUCTIONS - READ INSTRUCTIONS                    |
| In the following section you can change some buttons according to your personal preferences.                                |
| REAL; means ON FALSE means OFF          																		              |                 
|==============================================================================================================================   
===============================================================================================================================
| Choose your 1 button to switch profiles        		        |*/ define pulsante_cambio_arma = PS4_TRIANGLE;     /* |
===============================================================================================================================
|BUTTONS FOR PANIC BUTTON HOLD PS4 L2 AND PRESS TRIANGLE    |*/  define Primo_pulsante_panic = PS4_L2; /* |
=======================================================================  ===================================================|
|																		*/define secondo_pulsante_panic = PS4_TRIANGLE;/*|                                                                    
|
===============================================================================================================================
|PUBG Loot is an additional profile below you can choose the buttons to select it without interfering with the game
| TO ENTER THE PUBG Loot IN GAME PROFILE, PRESS R3 AND DOWN ARROW
|DO NOT USE the same button you use to switch between primary and secondary weapons |*/ define pubg_generico      = PS4_R3;/*  |
| to exit pubg loot mode press and hold R3 / RS for 1 second      |*/ define pubg_generico_2     = PS4_DOWN;/*|
|==============================================================================================================================
|  If you don't use the Default buttons you need to change the buttons below                                        |
|==============================================================================================================================
|   ====>   THIS IS YOUR BUTTON TO LOWER          |*/  define tasto_abbassarsi = PS4_CIRCLE;               /* |
|   ====> THIS IS THE KEY TO JUMP                  |*/   define tasto_salto  = PS4_CROSS;      /* 			  |
===============================================================================================================================
 */    
                  /*  LIST OF PAD IDENTIFIERS FOR USEABLE BUTTONS ABOVE ARE ALSO OK FOR xbox
 
  PS4_L1 - PS4_L2 - PS4_L3 - PS4_R1 - PS4_R2 - PS4_R3 - PS4_CROSS /(XB1_A) - PS4_SQUARE /(XB1_X) - PS4_CIRCLE (XB1_B) - 
  
  									PS4_TRIANGLE /(XB1_Y) -  PS4_UP - PS4_DOWN - PS4_LEFT - PS4_RIGHT
 						
 						 Read the instructions below for how to use the Zen menu
============================================================================================================================
==== Enter menu mode                                           ===== Press L2 / LT and Press OPTIONS / MENU              ===
============================================================================================================================
==== To edit any mod in the menu                                  ===== Press CROSS / A to edit                          ===
============================================================================================================================
==== Navigate through the mods in the zen menu                  ===== press right or left using the arrows on the D-PAD  ===
============================================================================================================================
==== Enable or disable mods                              ===== Press UP ACTIVATE press DOWN DEACTIVATE                   ===
============================================================================================================================
==== Change primary and secondary weapon in the menu          ===== Press  Y/TRIANGLE                                    ===
============================================================================================================================
==== Change primary and secondary weapon in the game          ===== Press  Y/TRIANGLE                                    ===
============================================================================================================================
==== Modes editing mods in the zen menu                     ===== Press CROSS / A  to enter or Press CIRCLE / B to exit  ===
============================================================================================================================
==== HOW TO MODIFY THE PARAMETERS                           =====HOLD L2 / LT and CLICK RIGHT to increase +1             ===
                                                            =====              			    LEFT CLICK to decrease -1    ===
                                                            =====              			    CLICK UP to increment +10    ===
                                                            =====                           CLICK DOWN to decrease -10   ===
============================================================================================================================ 
==== Navigate through the editable values ​​in edit mode           =====      CLICK RIGHT OR LEFT                          ===
============================================================================================================================
====  TO SAVE ALL MODS THAT HAVE BEEN EDITED OR ACTIVATED ===== PRESS XBOX / PS Button ON THE DISPLAY WILL BE WRITTEN    ===
===  SAVED																												 ===
============================================================================================================================
==== TO EXIT MENU MODE ONCE SAVED    ===== HOLD L2 / LT AND PRESS OPTIONS / MENU           ===
============================================================================================================================
==== DISABLE ALL THAT ACTIVATED AT THE SAME TIME         =====      HOLD LT / L2 & AND DOUBLE CLICK SHARE / VIEW         ===
														
													END INSTRUCTION
													
NON TOCCARE DA QUI IN GIU //NON TOCCARE DA QUI IN GIU // NON TOCCARE DA QUI IN GIU //  NON TOCCARE DA QUI IN GIU //	
*/


// Text to display 
	const string TITLE = "x ANDRY85 x";
	const string MW = "PUBG V6";
	const string WARZONE = "ver 6.0 32 Bit";
	const string PRESS_A_TO_CONTINUE = "Press A for change";
	const string PRESS_A_TO_GO = " A for change";
	const string TOGGLEONLY = "Only on off ";
	const string ALLPROFILES = "ALL Profile"; 
	const string NOT_AVAILABLE = "Unavailablewith ";
	const string ARMAINUSO = "currentweapon";
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE= "SAVE";
	const string GUIDAON= "DRIVE ON";
	const string GUIDAOFF= "DRIVEOff";
	const string NADEON= "NADE ON";
	const string NADEOFF= "NADEOff";
	const string Position[] = {"S","C","P",""} 
	const string PRESS_A_TO_ASSIGN =  "A for assign";
	const string PREMI_IL_TASTO =  "Press a KEY";
	const string PRESS_B_TO_GO =  "B for exit";
	const string PADORMKINUSE = "Choosewhatyouuse";
	const string Weapons[]={ // Weapon Names Displayed On Title Screen \ Total 33;
	//       0		  1		   2		 3		 4       5       6         7     8       9     10     11     12      13			14
		"Generic", "BERYL", "ACE32", "AK47", "GROZA", "M416", "SCAR-L", "K2", "G36C", "QBZ", "AUG", "P90", "UZI", "VECTOR", "MP5K",
	//15      16 		17		18		19		20		21		22		23		  24	  25	   26      27     28
    "MP9", "PP-19", "TOMMY", "UMP45", "DP-28", "M249", "MG3", "M16A4", "MK47", "MINI14", "MK12", "QBU", "MK14", "SKS",
   //29   	30		31			32		33
    "SLR", "VSS", "SNIPER", "SHOTGUN", "O12", ""} ;
		const string Optics[]={
	//	  0   1		2	 3	  4	  5	 // Optics Names Displayed On Title Screen \ Total 5;
		"X1","X2","X3","X4","X6","X8",""} ;
		
   const string PROFILE_1 = "Primary": 
   const string PROFILE_2 = "Secondary":  
   const string PROFILE_3 = "Pubg loot"; 
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
const string MKbutton[] = {
	"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0",
	"ENTER","ESC","BACKSPACE","TAB","SPACE","MINUS","EQUAL","LEFTBRACE","RIGHTBRACE","BACKSLASH","HASHTILDE","SEMICOLON",
	"APOSTROPHE","GRAVE","COMMA","DOT","SLASH","CAPSLOCK","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","SYSRQ","SCROLLLOCK","PAUSE","INSERT",
    "HOME","PAGEUP","DELETE","END","PAGEDOWN","RIGHT","LEFT","DOWN","UP","NUMLOCK","KPASTERISK","KPMINUS","KPPLUS","KPENTER","KP1","KP2","KP3",
	"KP4","KP5","KP6","KP7","KP8","KP9","KP0","KPDOT",""}

const uint8 LayoutsMK[] = {KEY_A,KEY_B,KEY_C,KEY_D,KEY_E,KEY_F,KEY_G,KEY_H,KEY_I,KEY_J,KEY_K, KEY_L,KEY_M,KEY_N,KEY_O,KEY_P,KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, 
KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, KEY_1 ,KEY_2,KEY_3,KEY_4,KEY_5,KEY_6,KEY_7,KEY_8,KEY_9,KEY_0,KEY_ENTER,KEY_ESC,KEY_BACKSPACE,KEY_TAB,
KEY_SPACE,KEY_MINUS,KEY_EQUAL,KEY_LEFTBRACE,KEY_RIGHTBRACE,KEY_BACKSLASH,KEY_HASHTILDE,KEY_SEMICOLON,KEY_APOSTROPHE,KEY_GRAVE,KEY_COMMA,KEY_DOT,KEY_SLASH,KEY_CAPSLOCK,
KEY_F1,KEY_F2,KEY_F3,KEY_F4,KEY_F5,KEY_F6,KEY_F7,KEY_F8,KEY_F9,KEY_F10,KEY_F11,KEY_F12,KEY_SYSRQ,KEY_SCROLLLOCK,KEY_PAUSE,KEY_INSERT,KEY_HOME,KEY_PAGEUP,KEY_DELETE,
KEY_END,KEY_PAGEDOWN,KEY_RIGHT,KEY_LEFT,KEY_DOWN,KEY_UP,KEY_NUMLOCK,KEY_KPASTERISK,KEY_KPMINUS,KEY_KPPLUS,KEY_KPENTER,KEY_KP1,KEY_KP2,KEY_KP3,KEY_KP4,KEY_KP5,KEY_KP6,
KEY_KP7,KEY_KP8,KEY_KP9,KEY_KP0,KEY_KPDOT};

	const string PADMK[]= {"PAD","M&K",""}
    const string fastoogle[] = {"Rapid", "Burstfire", "Strafe", "TBAG", "jumpshot","peekshot","Autolean","CrouchADS","Autorun","RESET",""}
// Mod Name // Profile 1 
	const string ARMI         = "Weapon";       	  // modName_idx = 0
	const string ANTIRECOIL   = "Progressive";		 // modName_idx = 1
    const string OPTICS       = "Opticsinuse";       // modName_idx - 2
	const string OPTICSET     = "OpticalSect";       // modName_idx - 3
    const string RAPIDFIRE    = "RapidFire";         // modName_idx = 4 
    const string BURSTFIRE    = "BurstFire";         // modName_idx = 5 
    const string STRAFE       = "Strafe";            // modName_idx = 6
    const string TBAG         = "TBAG"               // modName_idx = 7
    const string JUMPSHOT     = "Jump Shot"          // modName_idx = 8
 	const string HOLD_BREATH  = "Holdbreath";      	 // modName_idx = 9
 	const string PEEK         = "Peekshot";          // modName_idx = 10
 	const string AUTOLEAN     = "AutoLean";          // modName_idx = 11
 	const string AUTORUN      = "CrouchOnAds";       // modName_idx = 12
 	const string SWAP         = "Swap Tr/Bu";        // modName_idx - 13
	const string QUIK         = "Quickscope";        // modName_idx = 14
	const string AUTORUN1     = "Auto Run";          // modName_idx - 15
	const string FASTTOGLE    = "F.Toggle MK";       // modName_idx = 16
    const string PADORMK	  = "PAD OR M&K"  	     // modName_idx = 17
// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;
    
// modName # of the last Mod Name string - Used for cycle modName_idx
	define LAST_MODNAME_STRING = 17;

// # of the last modName_idx that has a value that can be edited
	define LAST_EDITABLE_STRING = 4;

    
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

// Value Name
	// modName_idx = 0 = ANTIRECOIL string
	
    const string X1                       = "X1";      			 // valName_idx = 0
    const string X2                       = "X2";      			 // valName_idx = 1
    const string X3                       = "X3";       		 // valName_idx = 2
    const string X4                       = "X4";       		 // valName_idx = 3
    const string X6                       = "X6";      			 // valName_idx = 4
    const string X8                       = "X8";       		 // valName_idx = 5
    const string COR_OPTIC                = "COR OPTICS";        // valName_idx = 6
	const string ANTIRECOIL_START         = "ARV Start"; 		 // valName_idx = 7  
	const string ANTIRECOIL_MID           = "ARV mid"; 		     // valName_idx = 8
	const string ANTIRECOIL_END           = "ARV End";			 // valName_idx = 9
	const string ANTIRECOIL_TIME          = "ARV Time";			 // valName_idx = 10
	const string RECOIL_HIP               = "Recoil HIP";	     // valName_idx = 11
	const string RECOIL_CROUCH            = "Rec Crounch";	     // valName_idx = 12
	const string RECOIL_PRONE			  = "Rec Prone";		 // valName_idx = 13
	const string RATE_OF_FIRE             = "Rounds/sec";	     // valName_idx = 14
    const string BURSTFIRE_HOLD           = "BF Hold";			 // valName_idx = 15
	const string BURSTFIRE_RELEASE        = "BF Release";		 // valName_idx = 16
    const string AMP_STRAFE               = "Amp strafe";        // valName_idx = 17
    const string VELO_STRAFE              = "Vel strafe";        // valName_idx = 18
   
	
// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
	define AMOUNT_OF_VALNAME_IDX = 18;

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

// Values for [3] profiles/weapons
	int antirecoil_start[34]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 
	int antirecoil_mid[34];
	int antirecoil_end[34];
	int antirecoil_time[34];
	int rate_of_fire[34];
	int nomearmi[33];
	int correction_opticsweap[34]
	//int quickscopedelay;
/* Used to define Profiles and also define # of profile to find, edit, and display the right index */
	int profile_idx; 
	
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

// Multi toggles
	int toggle_antirecoil[3];  // for 3 Profiles: profile_idx = 0, 1 and 2
    int toggle_rapidfire[34]; 
    int toggle_burstfire[3];
    int toggle_holdbreath; // ItzSnack Hold Breath
	int toggle_jumpshot[3];

	 
// Amount of profiles - Used for switch profiles cycle
	define AMOUNT_OF_PROFILES = 3;  
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 4;
	 //define per_profile_idx = 4; 
// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};

// Variables for function number_to_string() 
	int i;
	int c,c_val;

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

data(
//    Green     Red    SkyBlue    Blue         
    0,0,1,0,  0,1,0,0,  1,0,1,0,  1,0,0,0,
//   Yellow    White      Pink       OFF        
    0,3,3,0,  3,3,3,0,  0,0,0,1,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_black;
	int warzone_loot_profile; // Special weapon
// BurstFire
	int burstfire_hold; // BurstFire have toggle for each profiles BUT the same values for each
	int burstfire_release;    
// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int Modtoogle
	int KillSwitch;
    int count_black; // for screen saver
    int profile_1or2;
    
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
// Anti Recoil values   
    int pad_or_MK;
	int p,inc,inc_2,pr,pr_2,vm,vm_2; 
    int vm_count,vm_loops,p_count,v,ar_y;
    int quickscope; 
    int optic[6]
   int Auto_run
   int x1
   int x2
   int x3
   int x4
   int x6
   int x8
   int optic_recoil
   int  Crouchvalue;
   int 	Hipvalue;
	define movy = XB1_LY
	define movx = XB1_LX
	define adsy = XB1_RY
	define adsx = XB1_RX
// Variables Used for all mods 
 
// DROPSHOT   
   int TBAG_on[3];   
   int peekshot_on[3];
   int leanright_on;
   int leanleft_on:
   int autolean_on[3];
   int autodown_onADS[3];
// STRAFE 
   int strafe_on[3];       
   int Amp_strafe[3];
   int Vel_strafe[3];
   //CAMBIO ARMA 1 o 2 
   define cambio_arma = TRUE;
   define two_button_press = TRUE; 
 
   //LOOT
   int loot = TRUE;
   int DriveMode;
   int Nademode;
// Toggles
   int swap_on;
   int quickscope_on
   int hold_time;                                                    
   int rest_time;
   int led_on;
   int led_off;
   // rainbow led
   int incled = 1, decled, colorledx[3];
    int MAX_TIME_TO_CHECK = 5000;
   int double_tap;
   int q;											
   int double__tap[30];
   int MK; 
   int KBStates_Press[8];
   int KBStates_Release[8];
   int bitindex, varindex;
   int fast_toogle;
   int rapidmk,Burstmk,strafemk,tbagmk,jumpmk,peekshotmk,Autoleanmk,CrouchADSmk,Autorunmk ;
   int RESET;
   define CharacterStanding  = 0;
   define CharacterCrouch    = 1;
   define CharacterProne     = 2;
   int CharacterPosition;
   int pronevalue;
   

/*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
|                                                     MAIN SECTION                                                      |
??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	
init{
 colorledx = 255;
 Load();
 for (i = 0; i < 8; i++) {
        KBStates_Release[i] = -1; 
    }
  while(q < 30) 
   {double__tap[q] = -1;       
   q++;}   
 }

main {
refresh_kb_states();
MK = supported_key_pressed();
block_rumble();

if(pad_or_MK == 0)
 { if(abs(get_val(movy)) < 8 && abs(get_val(movx)) < 8 ){        
        set_val(movy,0);                                                
        set_val(movx,0); }                                           
    if(abs(get_val(adsy)) < 8 && abs(get_val(adsx)) < 8 ){         
        set_val(adsy,0);                                                 
        set_val(adsx,0); }
        }

if(event_press(XB1_MENU))
 
 {  loot = !loot;}	
 if (event_release(XB1_B)){loot = TRUE;}		
		

	set_val(TRACE_1, profile_idx);
	set_val(TRACE_2, modName_idx);
	set_val(TRACE_3, MK);
	set_val(TRACE_4,CharacterPosition);
	set_val(TRACE_5,(spvar_current_slot - SPVAR_1) + (spvar_current_bit > 0));
    set_val(TRACE_6,((spvar_current_slot - SPVAR_1) * 32) + spvar_current_bit);


// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
        if(get_console() == PIO_PS4) // If PS4 console:
        {
            swap(PS4_SHARE,PS4_TOUCH); // View = TouchPad
        
                if(get_val(PS4_R3) && event_press(PS4_TOUCH)) //  RS + View = ScreenShot
                {
                    set_val(PS4_SHARE,100);
                    set_val(PS4_TOUCH,0);
                    set_val(PS4_R3,0);
                }
        }
	}
  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |         DISPLAY TITLE                                                     |
  ??? ?????? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	 

// Display Script Title    
    if(display_title)
    {
    	cls_oled(0);	// clear OLED screen
    	count_black = 0;// reset screen saver counter
    	
    	if(KillSwitch)
    	{
    		print(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),8,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);	// display OFF centered in X 
	
    		}
    	else
    	{
    	   print(5, 5, 1, 1, TITLE[0]);
   
              print(20, 32, 0, 1, MW[0]);
            
			 if(warzone_loot_profile){
									 print(1, 47, 1, 1, Weapons[nomearmi[profile_idx]]);
    		     					print(100, 47, 1, 1, Optics[optic[profile_idx]]);
    		     					 print(100, 27, 1, 1, Position[CharacterPosition]);}
        else
        { 
    		      if(profile_idx == 0)
    		     print(1, 47, 1, 1, Weapons[nomearmi[profile_idx]]);
    		     print(100, 47, 1, 1, Optics[optic[profile_idx]]);
    		      print(100, 27, 1, 1, Position[CharacterPosition]);
    		               
    	     if(profile_idx == 1)
    		 print(1, 47, 1, 1, Weapons[nomearmi[profile_idx]]);
    		 print(100, 47, 1, 1, Optics[optic[profile_idx]]);
    		  print(100, 27, 1, 1, Position[CharacterPosition]);
    	  
  }
    		
    		display_black = TRUE;	
    		display_title = FALSE;
   }
     
   }
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch && !DriveMode && !Nademode)
    {
    	count_black += get_rtime();
    	if(count_black >= 5000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    	}
    }
  /*??? ??? ??? ??? ??? ?? ? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                      KILL SWITCH                                                      |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	 
 if (RESET != 0){
 if (event_press_kb(RESET)&& !ModMenu && !ModEdit && !Modtoogle)
	    {nomearmi[0] = 0 
		nomearmi[1] = 0
		display_title = TRUE
		optic[0]= 0
		optic[1]= 0}
		}
		
if (event_press_kb(KEY_KP1)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 2 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP2)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 3 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP3)&& !ModMenu && !ModEdit&& !Modtoogle)
      {nomearmi[profile_idx] = 5 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP4)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 6 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP5)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 7 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP6)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 12 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP7)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 10 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP8)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 8 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP9)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 9 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KP0)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 14 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KPENTER)&& !ModMenu && !ModEdit&& !Modtoogle)
      {optic[profile_idx] = 0 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KPASTERISK)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 13 
		display_title = TRUE
		 }
if (event_press_kb(KEY_KPSLASH)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 11 
		display_title = TRUE
 }		 
if (event_press_kb(KEY_KPDOT)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 1 
		display_title = TRUE
 }	
if (event_press_kb(KEY_PAGEUP)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 31 
		display_title = TRUE
 }
if (event_press_kb(KEY_PAGEDOWN)&& !ModMenu && !ModEdit&& !Modtoogle )
      {nomearmi[profile_idx] = 29 
		display_title = TRUE
 } 
 if (event_press_kb(KEY_END)&& !ModMenu && !ModEdit & !Modtoogle )
      {nomearmi[profile_idx] = 28 
		display_title = TRUE
		}
if (event_press_kb(KEY_INSERT)&& !ModMenu && !ModEdit & !Modtoogle )
      {nomearmi[profile_idx] = 24 
		display_title = TRUE
		}
if(get_val(PS4_L2))
	{
	// Kill Switch	
		if(event_release(PS4_SHARE))
		{
			KillSwitch = !KillSwitch;
			
			if(KillSwitch)        
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			else
				combo_run(RUMBLE_ON);	// rumble and LED blink
			
    		//display_black = FALSE;
			display_title = TRUE;
		}
if(event_press(PS4_RIGHT) && get_brtime(PS4_RIGHT) <= 200 && !ModMenu && !ModEdit)
	        {
	        	DriveMode = TRUE;
	        	combo_run(DriveModeOn);
	        	
	        }

  /*??? ??? ????????? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                       MOD MENU                                                   |
  ??? ??? ?????? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	 

	// toggle ModMenu ON/OFF
		if(event_release(PS4_OPTIONS) && !KillSwitch && !DriveMode && !Nademode)
		{
			ModMenu = !ModMenu;
			loot = TRUE;
			
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				//save ();				// save function
				//combo_run(EXIT_SAVE);	// rumble, blink and display SAVED then display TITLE
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
		}
		set_val(PS4_SHARE, 0);		    // block
		set_val(PS4_OPTIONS, 0);		// block
	} // L2 end
if(DriveMode) 
	{
	       	if(event_release(XB1_B))
	       		{
	       		
	       				DriveMode = FALSE;	       				
	       				combo_stop(DriveModeOn);
	       				combo_run(DriveModeOff);
	       				}
	       		combo_run(rgb);
  	}
if (!ModMenu && !ModEdit && !DriveMode && loot && !KillSwitch ) {
if(CharacterStanding == CharacterPosition)  // Standing Position \\ 
    {
	 if(event_press(XB1_B))
        { 
            CharacterPosition = CharacterCrouch;
            display_title = TRUE;
        }
        else if(get_ival(XB1_B) && get_ptime(XB1_B) > 200)
        {
            CharacterPosition = CharacterProne;
            display_title = TRUE;
        }
    }
    else if(CharacterCrouch == CharacterPosition)  // Crouch Position \\ 
    {
        
        
        if(event_press(XB1_A) || event_press(XB1_B))
        {
            CharacterPosition = CharacterStanding;
            display_title = TRUE;
        } 
        else if(get_ival(XB1_B) && get_ptime(XB1_B) > 200)
        {
            CharacterPosition = CharacterProne;
            display_title = TRUE;
        }     
    } 
    else if(CharacterProne == CharacterPosition)   // Prone Position \\ 
    {
       
     if(event_press(XB1_A))
        {
            CharacterPosition = CharacterStanding;
            display_title = TRUE;
        } 
        else if(event_press(XB1_B))
        { 
            CharacterPosition = CharacterCrouch;
            display_title = TRUE;
        }
    } 
     
 }
	
 if(event_press(PS4_RIGHT) && !get_val(PS4_L2)&&!get_val(PS4_R1) && !ModMenu && !ModEdit && !get_val(XB1_VIEW))
   { 
   Nademode = TRUE;
   combo_run(NademodOn);
   }  	
 if(Nademode) 
	{
	       	if(event_press(XB1_Y))
	       		{
	       		
	       		 combo_stop(NademodOn);
	       		 combo_run(NademodOff);
	       		}
	       				
	       		combo_run(rgb);
  	} 	
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
if(!KillSwitch)
{
if(!DriveMode)
{
if(!Nademode)
{
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
// ModMenu

 
	if(ModMenu) 
	{
            /*??? ??? ??? ???  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
            |                                            MOD EDIT                                               |
            ??? ??? ??? ?? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	 

	// toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
		if(modName_idx == 1 || modName_idx == 3 || modName_idx == 4 || modName_idx == 5 || modName_idx == 6 )	// if ANTIRECOIL (so modName_idx = 0) or AA or RAPIDFIRE or BURSTFIRE or StrafeShot is diplayed 
		{
			if(event_press(PS4_CROSS) && !ModEdit) // Turn ModEdit ON
			{
				valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
				ModEdit = TRUE;
				combo_run(RUMBLE_ON);
				display_new = TRUE;
			}
			
			if(event_press(PS4_CIRCLE) && ModEdit) // Turn ModEdit OFF
			{
				ModEdit = FALSE;
				combo_run(RUMBLE_OFF);
				display_new = TRUE;
				valName_idx = 0
			}
			}
		 if (modName_idx == 16)
	     		{ 
	     			
				 
				if(event_press(PS4_CROSS) && !Modtoogle) // Turn ModEdit ON
				{
				Modtoogle = TRUE;
				ModEdit = FALSE;
				DriveMode = FALSE;	
				display_new = TRUE;
				
				}
				if(event_press(PS4_CIRCLE) && Modtoogle) // Turn ModEdit ON
				{
				Modtoogle = FALSE;
				ModEdit = FALSE;
				DriveMode = FALSE;	
				display_new = TRUE;
				}
			
		
		}	
	
           /*??? ??? ??? ???? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
           |                                          EDIT VALUES                                              |
            ??? ??? ??? ?? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/
            
	// ModEdit ON
		if(ModEdit)
		{
			if(get_val(PS4_L2)) // Edit value: hold L2 + UP (+1) or DOWN (-1) or RIGHT (+10) or LEFT (-10)
			{
			// Mods that can have different values depending the active Profile
			
    		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], abs(range min) , range max ); 	
			   
  				x1 											 = edit_val( 0 , x1     , 0 , 50  , 1  , 10   );
   				x2  										 = edit_val( 1 , x2     , 0 , 50  , 1  , 10   );
   				x3  										 = edit_val( 2 , x3     , 0 , 50  , 1  , 10   );
   				x4  										 = edit_val( 3 , x4     , 0 , 50  , 1  , 10   );
   				x6  										 = edit_val( 4 , x6     , 0 , 50  , 1  , 10   );
 				x8  							    		 = edit_val( 5 , x8     , 0 , 50  , 1  , 10   ); 
 				correction_opticsweap[nomearmi[profile_idx]] = edit_val( 6 , correction_opticsweap[nomearmi[profile_idx]]     , 20 , 20  , 1  , 10   ); 
				antirecoil_start[nomearmi[profile_idx]]      = edit_val( 7 , antirecoil_start[nomearmi[profile_idx]]    , 0 , 99 , 1 , 10   );
				antirecoil_mid[nomearmi[profile_idx]]        = edit_val( 8 , antirecoil_mid[nomearmi[profile_idx]]      , 0 , 99 , 1 , 10   );// the first 0 define valName_idx so in this case, AR Start
				antirecoil_end[nomearmi[profile_idx]]        = edit_val( 9 , antirecoil_end[nomearmi[profile_idx]]       , 0 , 99 , 1 , 10   ); // the 2 last numbers are range min and range max
				antirecoil_time[nomearmi[profile_idx]]       = edit_val( 10 , antirecoil_time[nomearmi[profile_idx]]      , 0 , 99 , 1 , 10   ); // only ar_t display value x100 (real time in ms) - so 99 display 9,900 so 9.9 seconds 
				Hipvalue									 = edit_val( 11 , Hipvalue      , 50 , 50 , 1 , 10   );
				Crouchvalue									 = edit_val( 12 , Crouchvalue      , 50 , 50 , 1 , 10   );
			    pronevalue									 = edit_val( 13 , pronevalue      , 50 , 50 , 1 , 10   );
			    rate_of_fire[nomearmi[profile_idx]]          = edit_val( 14 , rate_of_fire[nomearmi[profile_idx]]         ,  0 ,   25 , 1 , 10   );
			    burstfire_hold        			  			 = edit_val( 15 , burstfire_hold         , 0 , 990  , 10 , 100 );
				burstfire_release      		 	   			 = edit_val( 16 , burstfire_release      , 0 , 990  , 10 , 100 );
			    Amp_strafe [profile_idx]                     = edit_val( 17 , Amp_strafe[profile_idx]             , 0 , 990   , 1  , 10   ); 
                Vel_strafe  [profile_idx]                    = edit_val( 18 , Vel_strafe [profile_idx]            , 0 , 990   , 1  , 10   ); 
			   
			}

            /*??? ??? ??? ? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
            |                                        VALUES AVAILABLE                                           |
            ??? ??? ??? ??? ? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/

			else // NOT L2 (if not editing value)
			{
			
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
					display_new = TRUE; // Display value name and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
					display_new = TRUE;
				}
			
			// Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
			 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
				
				if(modName_idx == 1) vals_available(7  , 13 ); 
				if(modName_idx == 3) vals_available(0  , 6  );		
				if(modName_idx == 4) vals_available(14 , 14 ); 
				if(modName_idx == 5) vals_available(15 , 16 ); 
				if(modName_idx == 6) vals_available(17 , 18 );
				
				
			} // NOT SQUARE (if not editing value) end
		} // ModEdit end

            /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
            |                                            TOGGLES                                                |
            ??? ???  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/

		else // if NOT ModEdit BUT if ModMenu
		{
	
	// Navigate mods name
	     	if(event_press(PS4_RIGHT))
			{
				modName_idx += 1;
				display_new = TRUE;
			}
			if(event_press(PS4_LEFT))
			{
				modName_idx -= 1;
				display_new = TRUE;
			}
			
		// Cycle mods name
			if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
				modName_idx = 0;
			if(modName_idx < 0)
				modName_idx = LAST_MODNAME_STRING;
			
			
		// Switch profiles	
			if(event_press(PS4_TRIANGLE))
			{
				profile_idx += 1;
				display_new = TRUE;
			}
		// Cycle profiles	
			if(profile_idx > (AMOUNT_OF_PROFILES - 1))
				profile_idx = 0;
			
		// Toggles (UP to turn ON, DOWN to turn OFF)
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			nomearmi[profile_idx]		   = toggle( 0, nomearmi[profile_idx] );
			toggle_antirecoil[profile_idx] = toggle( 1, toggle_antirecoil[profile_idx] );
			optic[profile_idx]		       = toggle( 2, optic[profile_idx] );
			toggle_rapidfire[nomearmi[profile_idx]]  = toggle( 4, toggle_rapidfire[nomearmi[profile_idx]] ); 
			toggle_burstfire[profile_idx]  = toggle( 5, toggle_burstfire[profile_idx] );
			strafe_on[profile_idx]         = toggle( 6, strafe_on[profile_idx]    );			
			TBAG_on[profile_idx]           = toggle( 7, TBAG_on[profile_idx]   ); 
			toggle_jumpshot[profile_idx]   = toggle( 8, toggle_jumpshot[profile_idx] );
            toggle_holdbreath              = toggle( 9, toggle_holdbreath              );
            peekshot_on[profile_idx]       = toggle( 10, peekshot_on[profile_idx] ); 
            autolean_on [profile_idx]      = toggle( 11, autolean_on[profile_idx]);
            autodown_onADS [profile_idx]   = toggle( 12 , autodown_onADS[profile_idx] );
			swap_on                        = toggle( 13 , swap_on     );
			quickscope_on                  = toggle( 14, quickscope_on );
		    Auto_run					   = toggle(15, Auto_run);
		    fast_toogle					   = MKtoggle(16, fast_toogle);
		    pad_or_MK					   = toggle( 17, pad_or_MK );
			// Mods that have same ON/OFF status on every Profiles
    		
		  //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
		
		} // if NOT ModEdit BUT if ModMenu end
		
	// If ModMenu AND ModEdit
		if(event_press(PS4_PS))
			Save ();
			
		//block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
		block_all_inputs();

	} // ModMenu ON end


/*??? ??? ??? ??? ? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
|                                              NOT MOD MENU AND NOT MOD EDIT                                             |

??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? */	 

if(Modtoogle){ 
cls_oled(0);
 print(center_x (sizeof(PREMI_IL_TASTO) - 1, OLED_FONT_SMALL_WIDTH),5,OLED_FONT_SMALL,OLED_WHITE,PREMI_IL_TASTO[0]); 
 print(center_x (sizeof(PRESS_B_TO_GO) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_B_TO_GO[0]); 
 			  if (fast_toogle == 0){
			  	 if(get_keyboard(LayoutsMK[i]))
						{ rapidmk = MK;
						  print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
					else if(rapidmk != 0){ 
						  print(center_x(mkbutton(rapidmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[rapidmk - 4]);}
						 }
						
			  if (fast_toogle == 1){	
					if(get_keyboard(LayoutsMK[i]))
						{ Burstmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(Burstmk != 0){
						print(center_x(mkbutton(Burstmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[Burstmk - 4]);}
						}
			  if (fast_toogle == 2){	
					if(get_keyboard(LayoutsMK[i]))
						{ strafemk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(strafemk != 0){
						print(center_x(mkbutton(strafemk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[strafemk - 4]);}
						}
			  if (fast_toogle == 3){	
					if(get_keyboard(LayoutsMK[i]))
						{ tbagmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(tbagmk != 0){
						print(center_x(mkbutton(tbagmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[tbagmk - 4]);}
						}
			 if (fast_toogle == 4){	
					 if(get_keyboard(LayoutsMK[i]))
						{ jumpmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(jumpmk != 0){
						print(center_x(mkbutton(jumpmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[jumpmk - 4]);}
						}
			 if (fast_toogle == 5){	
					 if(get_keyboard(LayoutsMK[i]))
						{ peekshotmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(peekshotmk != 0){
						print(center_x(mkbutton(peekshotmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[peekshotmk - 4]);}
						}
			 if (fast_toogle == 6){	
					 if(get_keyboard(LayoutsMK[i]))
						{ Autoleanmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(Autoleanmk != 0){
						print(center_x(mkbutton(Autoleanmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[Autoleanmk - 4]);}
						}
			if (fast_toogle == 7){	
					 if(get_keyboard(LayoutsMK[i]))
						{ CrouchADSmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(CrouchADSmk != 0){
						print(center_x(mkbutton(CrouchADSmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[CrouchADSmk - 4]);}
						}
			if (fast_toogle == 8){	
					 if(get_keyboard(LayoutsMK[i]))
						{ Autorunmk = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(Autorunmk != 0){
						print(center_x(mkbutton(Autorunmk - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[Autorunmk- 4]);}
						}	
		   if (fast_toogle == 9){	
					 if(get_keyboard(LayoutsMK[i]))
						{ RESET = MK
						print(center_x(mkbutton(i), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[i]);}
						else if(RESET != 0){
						print(center_x(mkbutton(RESET - 4), OLED_FONT_MEDIUM_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,MKbutton[RESET - 4]);}
						}			
}	
if(!ModMenu)
	{
	
	 if(TBAG_on[profile_idx])
	 {  
	   if(get_val(PS4_L2) && get_ival(PS4_R2)) 
	   { combo_run(TBAG);}
	    
	    led_on = 400;
    	led_off = 400;
    	combo_run(BLINKTBAG);
	} 
	

		if(swap_on) // (6)
		{
			swap(PS4_R1, PS4_R2);
			swap(PS4_L1, PS4_L2);
		}
		
   
         
   
            /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
            |                                        SPEED TOGGLES                                              |
            ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/
	// Speed Toggles

	  //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2 300ms   , toggle_I_want_to_edit[profile] , corresponding modName_idx );
		autolean_on	[profile_idx]	   = speed_toggle( PS4_L2, PS4_UP   , autolean_on[profile_idx], 11 );
		toggle_rapidfire[nomearmi[profile_idx]]  = speed_toggle( PS4_L2, PS4_LEFT   , toggle_rapidfire[nomearmi[profile_idx]] , 4 );
	    strafe_on [profile_idx]		   = speed_toggle( PS4_L2, PS4_RIGHT   ,  strafe_on[profile_idx] , 6 );
		peekshot_on	[profile_idx]	   = speed_toggle( PS4_L2, PS4_DOWN   ,  peekshot_on[profile_idx] , 10 );
		autodown_onADS[profile_idx]	   = speed_toggle( tasto_salto, PS4_RIGHT   ,  autodown_onADS[profile_idx]	 , 12 );
		TBAG_on	[profile_idx]		   = speed_toggle( tasto_abbassarsi, PS4_DOWN  ,  TBAG_on[profile_idx] , 7 );
		nomearmi[profile_idx]		   = speed_toggle_weapon( PS4_R1, nomearmi[profile_idx],0 );
		optic[profile_idx]		       = speed_toggle_optic( PS4_R1, optic[profile_idx],2 );
        

if (MK != -1){
        optic[profile_idx]		                 = speed_toggle_opticMKplus( KEY_KPPLUS, optic[profile_idx],2 );
        optic[profile_idx]		                 = speed_toggle_opticMKminus( KEY_KPMINUS, optic[profile_idx],2 );
        toggle_rapidfire[nomearmi[profile_idx]]  = speed_toggleMK( rapidmk ,toggle_rapidfire[nomearmi[profile_idx]],4 );
		toggle_burstfire[profile_idx]  			 = speed_toggleMK( Burstmk, toggle_burstfire[profile_idx],5 );
		strafe_on[profile_idx] 					 = speed_toggleMK( strafemk ,  strafe_on[profile_idx] , 6 );
  		toggle_jumpshot[profile_idx]   			 = speed_toggleMK( jumpmk ,  toggle_jumpshot [profile_idx] , 8 );
		peekshot_on	[profile_idx]                = speed_toggleMK( peekshotmk , peekshot_on[profile_idx],10 );
		autolean_on	[profile_idx]      			 = speed_toggleMK( Autoleanmk , autolean_on[profile_idx],11 );
		TBAG_on	[profile_idx]	       			 = speed_toggleMK( tbagmk  , TBAG_on[profile_idx] , 7 );
		autodown_onADS [profile_idx]   			 = speed_toggleMK( CrouchADSmk, autodown_onADS[profile_idx],12 );
		Auto_run					   			 = speed_toggleMK( Autorunmk,Auto_run,15);}
		

	// Hair Trigger
   	 	deadzone(PS4_L2,PS4_R2,99,99);
   	 	
   	  if(get_val(pubg_generico) && event_press(pubg_generico_2))
    {
        profile_idx = 2; 
        warzone_loot_profile = TRUE; 
        display_title = TRUE; 
     }
    
       if(warzone_loot_profile && get_val(pubg_generico) && get_ptime(pubg_generico) > 1000)     
           warzone_loot_profile = FALSE;
      
     if (strafe_on[profile_idx]) 
     { 
           if(get_val(PS4_R2)) {
    				combo_run(strafe);
    			} else {
        			combo_stop(strafe);
        		}
        led_on = 200;
    	led_off = 400;
    	combo_run(BLINKSTRAFE);  
    
 	 } 	 
   	 	
 
   if(toggle_holdbreath)
   {
          if(get_val(PS4_L2) && get_ptime(PS4_L2) > 500 && !get_val(PS4_R1))
               set_val(PS4_L1,100);
                      
      
  }
  // QUICKSCOPE
  if (quickscope_on && nomearmi[profile_idx] == 31)
  {
   if(event_release(PS4_L2))
   combo_run(QUICK);
  }
  
  
 if(Auto_run){       //autodown
 if(get_val(PS4_LY) <=-85 && !get_val(XB1_LT) && !get_val(XB1_RT))
   combo_run(AUTOrun);
  else
    combo_stop(AUTOrun);} 
    
  if (autodown_onADS[profile_idx]) {
        
        if(event_press(XB1_LT))
          {combo_run(ABBASSA);
           CharacterPosition = CharacterCrouch
           display_title = TRUE;}
        if(event_release(XB1_LT))
          {combo_run(ABBASSA)
           CharacterPosition = CharacterStanding;
           display_title = TRUE;}  
        }
  
  if(autolean_on[profile_idx])
   {
     	if(get_val(XB1_LT) && get_ival(XB1_LX)<= -65 || get_val(XB1_LB) && get_ival(XB1_LX)<= -65 ){
     	set_val(XB1_LS, 100);}
     	
     	
        if(get_val(XB1_LT) && get_ival(XB1_LX)>= +65 || get_val(XB1_LB) && get_ival(XB1_LX)>= +65){
     	set_val(XB1_RS, 100);
     }
     }
		
  if(toggle_jumpshot[profile_idx])
  {
     if(get_val(PS4_R2)) {
        	combo_run(Turbo_JUMP)
	}
  		led_on = 400;
    	led_off = 600;
    	combo_run(BLINKJUMP);
 }	
	
  if(peekshot_on[profile_idx])  // (10)
    {  
    	if(get_ival(XB1_LT)){
    	combo_run(PEEKSHOT);
     }
     
    	if (get_val(XB1_RT)||get_val(XB1_LS)||get_val(XB1_RS)){
    	combo_stop(PEEKSHOT);
     }
    	}
	
	
  	/*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  	|                                                     SWITCH PROFILE                                                    |
  	??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/
  
	// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold R3/RS + tap for sync color
		
 if(loot)
	{
		if(cambio_arma) 
			{ 
				if(event_release(pulsante_cambio_arma)&& get_ptime(pulsante_cambio_arma)<250)
        		{
        	    	profile_1or2=!profile_1or2; 
        	    	
     
        			if(ModMenu)
    					display_new = TRUE;
    				else
    					display_title = TRUE;
    			}
    			if(event_release(pulsante_cambio_arma) && get_ptime(pulsante_cambio_arma)>500 && get_ptime(pulsante_cambio_arma) < MAX_TIME_TO_CHECK ){
    			profile_1or2=!profile_1or2;
    				
    				double_click(PS4_TRIANGLE)
        	} 
        	} 
     
           	  if(two_button_press) 
           	  { 
           		if(get_val(Primo_pulsante_panic) && (get_val(secondo_pulsante_panic)))
        		{
        	    	//profile_1or2=!profile_1or2;
					 set_val(secondo_pulsante_panic,0);
        	    
        			if(ModMenu)
    					display_new = TRUE;
    				else
    					display_title = TRUE;
    				
    			}
        	} 
    	
            if(!warzone_loot_profile)
             {
               
    				if(profile_1or2)
	    				profile_idx = 1;
	    		
	    			// If Profile 1
	    			else 	
	    				profile_idx = 0; 
         }      
    
	} // ModMenu OFF end
}
							/*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
						|                                   FEATURES THAT WORK EVERYTIME (MOD MENU/EDIT OR NOT)                                 |
							??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	 

  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                    ANTI RECOIL (0)                                                    |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/
        if (optic[profile_idx] == 0){
         optic_recoil = x1}
        if (optic[profile_idx] == 1){
        optic_recoil = x2 + correction_opticsweap[nomearmi[profile_idx]]}
        if (optic[profile_idx] == 2){
        optic_recoil = x3 + correction_opticsweap[nomearmi[profile_idx]]}
        if (optic[profile_idx] == 3){
         optic_recoil = x4 + correction_opticsweap[nomearmi[profile_idx]]}
        if (optic[profile_idx] == 4){
        optic_recoil = x6 + correction_opticsweap[nomearmi[profile_idx]]}
        if (optic[profile_idx] == 5){
        optic_recoil = x8 + correction_opticsweap[nomearmi[profile_idx]]}
// If Anti-Recoil is enable for the active profile
	if(toggle_antirecoil[profile_idx] == 1)
	{
	// Antirecoil by Batts	
		
		vm_loops = (antirecoil_time[nomearmi[profile_idx]] * 10) / 2;
    if((antirecoil_start[nomearmi[profile_idx]] + optic_recoil) < (antirecoil_mid[nomearmi[profile_idx]] + optic_recoil))
        inc = 1;
    else
        inc = -1;
    if((antirecoil_mid[nomearmi[profile_idx]] + optic_recoil)<(antirecoil_end[nomearmi[profile_idx]] + optic_recoil))
        inc_2 = 1;
    else
        inc_2 = -1;
    pr = abs((antirecoil_start[nomearmi[profile_idx]]+optic_recoil) - (antirecoil_mid[nomearmi[profile_idx]]+optic_recoil));
    pr_2 = abs((antirecoil_mid[nomearmi[profile_idx]]+optic_recoil) - (antirecoil_end[nomearmi[profile_idx]]+optic_recoil));
    vm = vm_loops / pr;
    vm_2 = vm_loops / pr_2;
		

    	if(!get_val(PS4_R2)) 
   		{
   			// Vertical
   			p = 0;
       		vm_count = 0;
        	p_count = 0;
        	ar_y = (antirecoil_start[nomearmi[profile_idx]] + optic_recoil);
   			
   		
   		}   
    	
    	 if(get_val(PS4_L2) && get_val(PS4_R2)&& CharacterPosition == 0 ) 
    	{
   		    // Vertical
   		     p = p_cycle();
        if(p != -1)
            ar_y = p_val();
        else
            ar_y = (antirecoil_end[nomearmi[profile_idx]]+ optic_recoil);
         
        
       
        OffsetAR(XB1_RY,ar_y);
              
    	 }		
	   if(get_val(PS4_L2) && get_val(PS4_R2) && CharacterPosition == 1 )
	   {
   		    // Vertical
   		     p = p_cycle();
        if(p != -1)
            ar_y = p_val();
        else
            ar_y = (antirecoil_end[nomearmi[profile_idx]]+ optic_recoil);
         
         OffsetAR(XB1_RY,ar_y - ((ar_y * Crouchvalue)/100 ));
        
    	   		}	
     if(get_val(PS4_L2) && get_val(PS4_R2) && CharacterPosition == 2 )
	   {
   		    // Vertical
   		     p = p_cycle();
        if(p != -1)
            ar_y = p_val();
        else
            ar_y = (antirecoil_end[nomearmi[profile_idx]]+ optic_recoil);
         
         OffsetAR(XB1_RY,ar_y - ((ar_y * pronevalue)/100 ));
        
    	   		}		

      if (get_val(PS4_L1) && get_val(PS4_R2) && !get_val(PS4_L2)) 
    	{
   		    // Vertical
   		     p = p_cycle();
        if(p != -1)
            ar_y = p_val();
        else
            ar_y = (antirecoil_end[nomearmi[profile_idx]]+ optic_recoil);
         
         OffsetAR(XB1_RY,ar_y + ((ar_y * Hipvalue)/100 ));
       
    	 }
   
	}



  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                    RAPID FIRE (1)                                                     |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/  
  if(toggle_rapidfire[nomearmi[profile_idx]] == 1)
	{
	// Rate of Fire Calculation
    	hold_time = 500 / rate_of_fire[nomearmi[profile_idx]]; 
   		rest_time = hold_time - 20;
    	if(rest_time < 0) rest_time = 0;
    
    // Run combo
    	if(get_val(PS4_R2))
    		combo_run(RAPIDFIRE);
    	else
    		combo_stop(RAPIDFIRE);
    		
    	led_on = 400;
    	led_off = 400;
    	combo_run(BLINKRAPID);
	}

  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                    AKIMBO (1)                                                     |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/ 

if(toggle_burstfire[profile_idx] == 1) 
		{
    	// Hold and Release
			hold_time = burstfire_hold;
			rest_time = burstfire_release;
			
    	// Run combo
    		if(get_val(PS4_R2))	
    			combo_run(burstfire);

    		led_on = 400;
    		led_off = 400;
    		combo_run(BLINKburstfire);
		} 
		if(event_release(PS4_R2))
    		combo_stop(burstfire);
}
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
	 // MOT Special weapon end	
   
  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                    REFRESH DISPLAY                                                    |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	
	if(display_new) 
	{
	// Clear OLED screen	
		cls_oled(0);
    	count_black = 0;// reset screen saver counter
		
		if(ModEdit)
		{
	    // Display Value Name and value
    		// Mods that can have different values depending the active Profile
    		
		  //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
            display_edit( 0 , center_x(sizeof(X1)    - 1, OLED_FONT_MEDIUM_WIDTH)   , X1[0]    , x1   );
            display_edit( 1 , center_x(sizeof(X2)    - 1, OLED_FONT_MEDIUM_WIDTH)   , X2[0]    , x2   );
            display_edit( 2 , center_x(sizeof(X3)    - 1, OLED_FONT_MEDIUM_WIDTH)   , X3[0]    , x3   );
            display_edit( 3 , center_x(sizeof(X4)    - 1, OLED_FONT_MEDIUM_WIDTH)   , X4[0]    , x4   );
            display_edit( 4 , center_x(sizeof(X6)    - 1, OLED_FONT_MEDIUM_WIDTH)   , X6[0]    , x6   );
            display_edit( 5 , center_x(sizeof(X8)    - 1, OLED_FONT_MEDIUM_WIDTH)   , X8[0]    , x8   );
            display_edit( 6 , center_x(sizeof(COR_OPTIC )    - 1, OLED_FONT_MEDIUM_WIDTH)   , COR_OPTIC[0]    ,  correction_opticsweap[nomearmi[profile_idx]]);
			display_edit( 7 , center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH)      , ANTIRECOIL_START[0]      , antirecoil_start[nomearmi[profile_idx]]      );
			display_edit( 8, center_x(sizeof(ANTIRECOIL_MID) - 1, OLED_FONT_MEDIUM_WIDTH)        , ANTIRECOIL_MID[0]        , antirecoil_mid[nomearmi[profile_idx]]     );
			display_edit( 9 , center_x(sizeof(ANTIRECOIL_END) - 1, OLED_FONT_MEDIUM_WIDTH)        , ANTIRECOIL_END[0]        , antirecoil_end[nomearmi[profile_idx]]       );
			display_edit( 10 , center_x(sizeof(ANTIRECOIL_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)       , ANTIRECOIL_TIME[0]       , antirecoil_time[nomearmi[profile_idx]]       );
			display_edit( 11 , center_x(sizeof(RECOIL_HIP) - 1, OLED_FONT_MEDIUM_WIDTH)       , RECOIL_HIP[0]       , Hipvalue );   
			display_edit( 12 , center_x(sizeof(RECOIL_CROUCH ) - 1, OLED_FONT_MEDIUM_WIDTH)       , RECOIL_CROUCH [0]  ,    Crouchvalue	 );   	
			display_edit( 13 , center_x(sizeof(RECOIL_PRONE ) - 1, OLED_FONT_MEDIUM_WIDTH)       , RECOIL_PRONE [0]  ,    pronevalue	 );
			display_edit( 14 , center_x(sizeof(RATE_OF_FIRE)      - 1, OLED_FONT_MEDIUM_WIDTH)     , RATE_OF_FIRE[0]      ,  rate_of_fire[nomearmi[profile_idx]] );
		    display_edit( 15 , center_x(sizeof(BURSTFIRE_HOLD)      - 1, OLED_FONT_MEDIUM_WIDTH)  , BURSTFIRE_HOLD[0]      , burstfire_hold    );
		    display_edit( 16 , center_x(sizeof(BURSTFIRE_RELEASE)   - 1, OLED_FONT_MEDIUM_WIDTH), BURSTFIRE_RELEASE[0]      , burstfire_release    );
		    display_edit( 17 , center_x(sizeof(AMP_STRAFE)          - 1, OLED_FONT_MEDIUM_WIDTH)  , AMP_STRAFE[0]          , Amp_strafe[profile_idx]   );
            display_edit( 18 , center_x(sizeof(VELO_STRAFE)        - 1, OLED_FONT_MEDIUM_WIDTH)    , VELO_STRAFE[0]        , Vel_strafe [profile_idx]   );
           
			// Mods that have same value on every Profile
		}
		else
		{
	    // Display Mod Name and ON/OFF
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
		    display_mod3( 0 ,  center_x(sizeof(ARMI) - 1, OLED_FONT_MEDIUM_WIDTH)    , ARMI [0]   , nomearmi[profile_idx]);
			display_mod( 1 ,   center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , toggle_antirecoil[profile_idx]);
			display_mod6( 2 , center_x(sizeof(OPTICS)   - 1, OLED_FONT_MEDIUM_WIDTH)  , OPTICS[0]  , optic[profile_idx]);
			display_mod7( 3 , center_x(sizeof(OPTICSET)   - 1, OLED_FONT_MEDIUM_WIDTH)  , OPTICSET[0]  );
			display_mod5( 4 ,   center_x(sizeof(RAPIDFIRE)   - 1, OLED_FONT_MEDIUM_WIDTH)  , RAPIDFIRE[0] ,toggle_rapidfire[nomearmi[profile_idx]]);
		    display_mod( 5 ,   center_x(sizeof(BURSTFIRE) - 1, OLED_FONT_MEDIUM_WIDTH), BURSTFIRE[0], toggle_burstfire[profile_idx]);
		    display_mod( 6 ,   center_x(sizeof(STRAFE)   - 1, OLED_FONT_MEDIUM_WIDTH)  , STRAFE[0]     , strafe_on[profile_idx] );
		    display_mod1( 7 ,  center_x(sizeof(TBAG)   - 1, OLED_FONT_MEDIUM_WIDTH)  , TBAG[0]     , TBAG_on[profile_idx] ); 
		    display_mod1( 8 ,  center_x(sizeof(JUMPSHOT)   - 1, OLED_FONT_MEDIUM_WIDTH) , JUMPSHOT[0]     ,toggle_jumpshot[profile_idx]);
            display_mod1( 9 ,  center_x(sizeof(HOLD_BREATH) - 1, OLED_FONT_MEDIUM_WIDTH)  , HOLD_BREATH[0]   , toggle_holdbreath);
            display_mod1( 10 ,  center_x(sizeof(PEEK) - 1, OLED_FONT_MEDIUM_WIDTH) , PEEK[0]    , peekshot_on[profile_idx] ); 
            display_mod1( 11,   center_x(sizeof(AUTOLEAN)  - 1, OLED_FONT_MEDIUM_WIDTH)  , AUTOLEAN[0]    , autolean_on[profile_idx]);
		    display_mod1( 12 ,  center_x(sizeof(AUTORUN) - 1, OLED_FONT_MEDIUM_WIDTH) , AUTORUN[0] , autodown_onADS[profile_idx]);
			display_mod1( 13 ,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)    , SWAP[0]    , swap_on);
			display_mod1( 14 ,  center_x(sizeof(QUIK) - 1, OLED_FONT_MEDIUM_WIDTH), QUIK[0], quickscope_on);
			display_mod1( 15 ,  center_x(sizeof(AUTORUN1) - 1, OLED_FONT_MEDIUM_WIDTH)    , AUTORUN1[0] , Auto_run);
			display_mod10( 16 ,  center_x(sizeof(FASTTOGLE) - 1, OLED_FONT_MEDIUM_WIDTH)    , FASTTOGLE[0] , fast_toogle);
			display_mod11( 17 , center_x(sizeof(PADORMK)   - 1, OLED_FONT_MEDIUM_WIDTH)  , PADORMK[0],pad_or_MK  );
	} 	
	// Display Profile only on mods that may have a different value depending on the Profile

		if(modName_idx == 0 || modName_idx == 1 ||modName_idx == 2 ||modName_idx == 4 ||modName_idx == 5 ||modName_idx == 6 || modName_idx == 7 || modName_idx == 8  || modName_idx == 10 || modName_idx == 11 ||modName_idx == 12 )  // idx from 0 to 4 are mods that can have different values depending the active Profile
		{
		 if(profile_idx == 0)
			   // display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , toggle_antirecoil[profile_idx]); // profile_idx = profile_idx = Profile
    			print(center_x(sizeof(PROFILE_1) - 1,OLED_FONT_SMALL_WIDTH) ,23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
    			//line_oled(0, 26, 39, 26, 5, 1); // print a line to the left to say profile 1
    			
    	else if(profile_idx == 1)
    				print(center_x(sizeof(PROFILE_2) - 1,OLED_FONT_SMALL_WIDTH) ,23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
    				
    			//line_oled(44, 26, 83, 26, 5, 1); // print a line in the middle to say Profile 2
    	else if(profile_idx == 2)
    				print(center_x(sizeof(PROFILE_3) - 1,OLED_FONT_SMALL_WIDTH) ,23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
    		 if (valName_idx == 11 || valName_idx == 12|| valName_idx == 13 )
   	     {  print(center_x(sizeof(ALLPROFILES) - 1,OLED_FONT_SMALL_WIDTH) ,23,OLED_FONT_SMALL,OLED_WHITE,ALLPROFILES[0]); // print All profiles
   	     }
         }
		else if (modName_idx == 3 || modName_idx == 13 || modName_idx == 14 || modName_idx == 15 || modName_idx == 9  ) // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    	{
    	    print(center_x(sizeof(ALLPROFILES) - 1,OLED_FONT_SMALL_WIDTH) ,23,OLED_FONT_SMALL,OLED_WHITE,ALLPROFILES[0]); // print All profiles
    		
    		//line_oled(88, 26, 127, 26, 5, 1);ANDRY85
    	if (valName_idx == 6)
   	     {  print(center_x(sizeof(ARMAINUSO) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,ARMAINUSO[0]);
    	  
    		//line_oled(44, 26, 83, 26, 5, 1);ANDRY85
    		//line_oled(88, 26, 127, 26, 5, 1);ANDRY85
    	}
    	}
 
		display_black = TRUE;
        display_new = FALSE;
    } // display_new end
    
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
} // NOT KillSwitch end

	led(profile_idx);
}
} 
// main end 
  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                     COMBO SECTION                                                     |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	
combo QUICK{
set_val(PS4_R2,100);
wait(30);
set_val(PS4_R2,0);
}

combo AUTOrun{
    set_val(XB1_LS, 100);
    wait(50);
    set_val(XB1_LS, 0);
    wait(32767);
    wait(32767);   
}

combo ABBASSA {
            set_val(XB1_B,100); //pressione b
            wait(150);
            wait(150);
            }

combo strafe {
        		set_val(11, 100);
        		wait(Amp_strafe);    
        		wait(Vel_strafe);
        		set_val(11,-100);
        		wait(Amp_strafe);
        		wait(Vel_strafe);    
    }
 combo TBAG {
            set_val(XB1_B,100); //pressione b
            wait(150);
            set_val(XB1_B,0); //pressione b
            wait(150);
                } 

combo burstfire { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
    }
        
combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time);
    }
    

combo PEEKSHOT {
	set_val(XB1_LS,100);
	set_led(LED_2, 1);
	wait(50);
	wait(50);
	wait(200);
	set_val(XB1_RS,100);
	set_led(LED_2, 0);
	wait(50);
	wait(50);
	wait(200);
}                    


combo Turbo_JUMP {
    			set_val(PS4_CROSS, 100);
    			wait(60);
    			set_val(PS4_CROSS, 0);
    			wait(40);
    			set_val(PS4_CROSS, 0);
}  
   

//ANDRY85ANDRY85

 
        		

   
combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

combo SAVE { 
	cls_oled(0);						// clear OLED screen 
	print(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	wait(10)
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times								
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_new = TRUE;				   // display mods
}
combo DriveModeOn { 
	cls_oled(0);
	print(center_x(sizeof(GUIDAON) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,GUIDAON[0]); 	// display SAVED... centered in X Y
	//call(rgb)
}// display mods
combo DriveModeOff { 
	cls_oled(0);
	print(center_x(sizeof(GUIDAOFF) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,GUIDAOFF[0]); 				// 2 high rumbles + green blink 2 times	
	wait(2000);
	display_title = TRUE;
	}// display mods
combo NademodOn { 
	cls_oled(0);
	wait(100);
	print(center_x(sizeof(NADEON) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,NADEON[0]); 	// display SAVED... centered in X Y
	//call(rgb)
}// display mods
combo NademodOff { 
	cls_oled(0);
	print(center_x(sizeof(NADEOFF) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,NADEOFF[0]); 				// 2 high rumbles + green blink 2 times	
	wait(1000);
	Nademode = FALSE;
	display_title = TRUE;
	}// display mods
	combo CrouchmodeOff { 
	cls_oled(0);
	print(center_x(sizeof(CmOff) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,CmOff[0]); 				// 2 high rumbles + green blink 2 times	
	wait(500);
	display_title = TRUE;
	}// display mods
	combo CrouchmodeOn { 
	cls_oled(0);
	print(center_x(sizeof(CrmOn) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,CrmOn[0]); 
	wait(500);	
	}
combo rgb {
	wait(5);
  set_rgb(colorledx, colorledx[1], colorledx[2]);
  colorledx[decled] -= 5; colorledx[incled] += 5;
  if(!colorledx[decled]) { incled = (incled + 1) % 3; decled = (decled + 1) % 3; }
  }
  
combo BLINKRAPID {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}
combo BLINKburstfire {
	led(profile_idx);
    wait(led_on);
    led(6);
    wait(led_off);
}
combo BLINKSTRAFE {
	led(profile_idx);
    wait(led_on);
    led(3);
    wait(led_off);
} 
combo BLINKTBAG {
	led(profile_idx);
    wait(led_on);
    led(4);
    wait(led_off);
} 
combo BLINKJUMP {
	led(profile_idx);
    wait(led_on);
    led(5);
    wait(led_off);
} 
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

  /*??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
  |                                                       FUNCTIONS                                                       |
  ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???*/	


// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function double_click(button) {        
    if (double__tap[button] >= 0) {                    
        double__tap[button] += get_rtime(); 
        if (double__tap[button] > 450)
            double__tap[button] = -1;                                                                                       
    }           
    if (event_release(button) && get_ptime(button) <= 200) { 
        if (double__tap[button] < 0) {                    
            double__tap[button] = 0;                        
        } else {             
            double__tap[button] = -1;                       
            return 1;                                   
        }                                                     
    }                                                  
    return 0;
    }
    
function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods

	if(valName_idx < f_min)
		valName_idx = f_max;
	if(valName_idx > f_max)
		valName_idx = f_min;	
}
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
					
	if(valName_idx == f_idx)
	{
    // +1 or -1															 
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2
	
	}

	return f_val;
}

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
function MKtoggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx && !Modtoogle)
		{
		// Increase
				f_val += 1;
			// Limits
				if(f_val > 9)
					f_val = 0;
				if(f_val < 0)
					f_val = 9;
		
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx && !Modtoogle)
		
		{
			// decrease
				f_val -= 1;
			// Limits
				if(f_val > 9)
					f_val = 0;
				if(f_val < 0)
					f_val = 9;
			
			combo_run(RUMBLE_ON);	
		}		
		display_new = TRUE;
	}
	return f_val;
}
function speed_toggleMK(f_press,f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	
		if(event_press_kb(f_press))  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			
			modName_idx = f_string;
			
			if(f_val == 0)
			{
			f_val = 1;
			combo_run(RUMBLE_ON);
			}
			else if(f_val == 1)
			{f_val = 0;
			combo_run(RUMBLE_OFF);
			}
 			display_new = TRUE;
		} 		
	return f_val;
}
function speed_toggle(f_hold, f_press, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold)&& !get_val(PS4_L1) )
	{
		if(get_val(f_press) && get_ptime(f_press) == 300)  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			modName_idx = f_string;
			
			if(f_val == 0)
			{
			f_val = 1;
			combo_run(RUMBLE_ON);
			}
			else if(f_val == 1)
			{f_val = 0;
			combo_run(RUMBLE_OFF);
			}
 			display_new = TRUE;
		} 
	set_val(f_press, 0)
	}
		
	return f_val;
}
function speed_toggle_weapon(f_hold, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(event_press(PS4_UP))  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			modName_idx = f_string
			
			{f_val += 1;
			// Limits
				if(f_val > 33)
					f_val = 0;
				if(f_val < 0)
					f_val = 33;} 
 			display_new = TRUE;
		} 
		if(event_press(PS4_DOWN))  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			modName_idx = f_string
			
			// Decrease
				{f_val -= 1;
			// Limits
				if(f_val > 33)
					f_val = 0;
				if(f_val < 0)
					f_val = 33;} 
		display_new = TRUE;
		} 
		set_val(PS4_DOWN, 0)
		set_val(PS4_UP, 0)
	}
	if (event_release(f_hold)){
	display_title = TRUE;} 
	return f_val;
}
function speed_toggle_optic(f_hold, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(event_press(PS4_RIGHT))  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			modName_idx = f_string
			
			{f_val += 1;
			// Limits
				if(f_val > 5)
					f_val = 0;
				if(f_val < 0)
					f_val = 5;} 
 			display_new = TRUE;
		} 
		if(event_press(PS4_LEFT))  // Hold second button 300ms or more	if(get_val(f_press) && get_ptime(f_press) == (get_rtime() * 30))  // Hold second button 300ms or more
		{
			modName_idx = f_string
			
			// Decrease
				{f_val -= 1;
			// Limits
				if(f_val > 5)
					f_val = 0;
				if(f_val < 0)
					f_val = 5;} 
		display_new = TRUE;
		} 
		set_val(PS4_LEFT, 0)
		set_val(PS4_RIGHT, 0)
	}
	if (event_release(f_hold)){
	display_title = TRUE;} 
	return f_val;
}
function speed_toggle_opticMKplus(f_hold, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(event_press_kb(f_hold))
	{
		modName_idx = f_string
			
			{f_val += 1;
			// Limits
				if(f_val > 5)
					f_val = 0;
				if(f_val < 0)
					f_val = 5;} 
	display_new = TRUE;
	}
	return f_val;
	
}
function speed_toggle_opticMKminus(f_hold, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(event_press_kb(f_hold))
	{
		modName_idx = f_string
			
			{f_val -= 1;
			// Limits
				if(f_val > 5)
					f_val = 0;
				if(f_val < 0)
					f_val = 5;} 
			display_new = TRUE;
 			}	
	return f_val;
}
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(modName_idx == 0)
			{
			// Increase
				f_val += 1;
			// Limits
				if(f_val > 33)
					f_val = 0;
				if(f_val < 0)
					f_val = 33;
			}
			 else if(modName_idx == 2)
			{
			// Increase
				f_val += 1;
			// Limits
				if(f_val > 5)
					f_val = 0;
				if(f_val < 0)
					f_val = 5;
			}
			else 	
			f_val = 1;
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{    if(modName_idx == 0)
			{
			// Decrease
				f_val -= 1;
			// Limits
				if(f_val > 33)
					f_val = 0;
				if(f_val < 0)
					f_val = 33;
			}
			else if(modName_idx == 2)
			{
			// Decrease
				f_val -= 1;
			// Limits
				if(f_val > 5)
					f_val = 0;
				if(f_val < 0)
					f_val = 5;
			}	
			else 	
			f_val = 0;
			combo_run(RUMBLE_OFF);
		}		
		display_new = TRUE;
	}
	return f_val;
}

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);

    	if(valName_idx == f_idx)
    	{
		// Display value name and value
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    		
    	// Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
    		if(f_idx == 10)
    			number_to_string(f_val * 100, find_digits(f_val * 100) );
    	
    	// Display editable values 
    		else 
    			number_to_string(f_val, find_digits(f_val));
    	}
}

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		// Display ON OFF
    			if(f_toggle == 1)
    				print(center_x(sizeof(ON) + 10, OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    			else if(f_toggle == 0)
    				print(center_x(sizeof(OFF) - 13,OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL, OLED_WHITE, OFF[0]);		
        	        print(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);
    	}
}
function display_mod1(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		// Display ON OFF
    			if(f_toggle == 1)
    				print(center_x(sizeof(ON) + 10, OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    			else if(f_toggle == 0)
    				print(center_x(sizeof(OFF) - 13,OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL, OLED_WHITE, OFF[0]);		
        	        print(center_x(sizeof(TOGGLEONLY) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,TOGGLEONLY[0]);
    	}
}
function display_mod3(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		
        	if(f_toggle)
					print(center_x(get_weapon_chars(nomearmi[profile_idx]), OLED_FONT_MEDIUM_WIDTH),48,OLED_FONT_MEDIUM,OLED_WHITE,Weapons[nomearmi[profile_idx]]);
			else if(f_toggle == 0)
					print(center_x(get_weapon_chars(nomearmi[profile_idx]), OLED_FONT_MEDIUM_WIDTH),48,OLED_FONT_MEDIUM,OLED_WHITE,Weapons[nomearmi[profile_idx]]);
		}
}
function display_mod7(f_idx, f_string, f_print ) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		// Display ON OFF
    				
        	        print(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);
    	}
}
function display_mod5(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{ 
    	print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);	     
        if ((nomearmi[profile_idx]) <= 21 ||(nomearmi[profile_idx]) == 30 ||(nomearmi[profile_idx]) == 31 ||(nomearmi[profile_idx]) == 32 ||(nomearmi[profile_idx]) == 33)
        { 
        	         print(center_x(sizeof(NOT_AVAILABLE) - 1, OLED_FONT_SMALL_WIDTH),35,OLED_FONT_SMALL,OLED_WHITE,NOT_AVAILABLE[0]);
        	         print(center_x(sizeof(ARMAINUSO) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,ARMAINUSO[0]);}
        if ((nomearmi[profile_idx]) == 22 || (nomearmi[profile_idx]) == 23 || (nomearmi[profile_idx]) == 24 || (nomearmi[profile_idx]) == 25 ||(nomearmi[profile_idx]) == 26 ||(nomearmi[profile_idx]) == 27 ||(nomearmi[profile_idx]) == 28 ||(nomearmi[profile_idx]) == 29){	                	  
		       if(f_toggle == 1)
    				print(center_x(sizeof(ON) + 10, OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    			else if(f_toggle == 0)
    				print(center_x(sizeof(OFF) - 13,OLED_FONT_SMALL_WIDTH),37,OLED_FONT_SMALL, OLED_WHITE, OFF[0]);		
        	        print(center_x(sizeof(PRESS_A_TO_CONTINUE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_CONTINUE[0]);}
        	        }
        	    
        	
}
function display_mod6(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		
        	if(f_toggle)
					print(center_x(get_optic_chars(optic[profile_idx]), OLED_FONT_MEDIUM_WIDTH),48,OLED_FONT_MEDIUM,OLED_WHITE,Optics[optic[profile_idx]]);
			else if(f_toggle == 0)
					print(center_x(get_optic_chars(optic[profile_idx]), OLED_FONT_MEDIUM_WIDTH),48,OLED_FONT_MEDIUM,OLED_WHITE,Optics[optic[profile_idx]]);
		}
}
function display_mod10(f_idx, f_string, f_print, MKtoggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		// Display ON OFF
    			if(MKtoggle)
    				print(center_x(fasttoogleMK(fast_toogle) + 5,OLED_FONT_SMALL_WIDTH),25,OLED_FONT_MEDIUM,OLED_WHITE,fastoogle[fast_toogle]);
    			else if(MKtoggle == 0)
    				print(center_x(fasttoogleMK(fast_toogle) + 5,OLED_FONT_SMALL_WIDTH),25,OLED_FONT_MEDIUM, OLED_WHITE,fastoogle[fast_toogle]);		
        	        print(center_x(sizeof(PRESS_A_TO_ASSIGN) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,PRESS_A_TO_ASSIGN[0]);}
}
function display_mod11(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
    	
		// Display MOD_NAME
    		print(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        		// Display ON OFF
    			if(f_toggle == 1)
    				print(center_x(padormkinuse(1)- 5, OLED_FONT_MEDIUM_WIDTH),40,OLED_FONT_MEDIUM,OLED_WHITE,PADMK[1]);
    			else if(f_toggle == 0)
    				print(center_x(padormkinuse(0)+ 5,OLED_FONT_MEDIUM_WIDTH),40,OLED_FONT_MEDIUM, OLED_WHITE, PADMK[0]);		
        	         print(center_x(sizeof(PADORMKINUSE) - 1, OLED_FONT_SMALL_WIDTH),26,OLED_FONT_SMALL,OLED_WHITE,PADORMKINUSE[0]);
}
        	
}
function padormkinuse(f_idx){
	if (PADMK[f_idx + 1] != -1) 
		return PADMK[f_idx + 1] - PADMK[f_idx] - 1;
	return sizeof(PADMK) - PADMK[f_idx];		
}
function mkbutton(f_idx){
	if (MKbutton[f_idx + 1] != -1) 
		return MKbutton[f_idx + 1] - MKbutton[f_idx] - 1;
	return sizeof(MKbutton) - MKbutton[f_idx];		
}
function get_weapon_chars(f_idx){
	if (Weapons[f_idx + 1] != -1) 
		return Weapons[f_idx + 1] - Weapons[f_idx] - 1;
	return sizeof(Weapons) - Weapons[f_idx];		
}
function fasttoogleMK(f_idx){
	if (fastoogle[f_idx + 1] != -1) 
		return fastoogle[f_idx + 1] - fastoogle[f_idx] - 1;
	return sizeof(fastoogle) - fastoogle[f_idx];		
}

function get_optic_chars(f_idx){
	if (Optics[f_idx + 1] != -1) 
		return Optics[f_idx + 1] - Optics[f_idx] - 1;
	return sizeof(Optics) - Optics[f_idx];		
}
// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
      
    // Substract    
        if(f_val < inv(f_rng_min)) 
        	f_val = inv(f_rng_min); 
   	// Add   
       	if(f_val > f_rng_max) 
        	f_val = f_rng_max;

        display_new = TRUE;
    }
    return f_val; 
} 

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function p_val() {
    p_count++;
    if(p_count == vm[p]) {
        p_count = 0;
        ar_y += inc[p];
    }
    return ar_y;
} 

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function p_cycle() { 
    vm_count++;
    if (vm_count > vm_loops) { 
        if(!p) {
            vm_count = 0;
            return 1;
        }
        else{
            vm_count = vm_loops; 
            return -1;
         } 
     }
     return p;
}        

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
function OffsetAR( axis,  offset_val) {
  set_val(axis, clamp(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));
  return;
}


// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII ANDRY85
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function find_digits(f_num) {
//  find_digits(value)  
//	    return Number of Digits in Value Passed  

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//	    return X for Centering String Horizontally

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function center_y(f_size) {
//  center_y(font size);  
//	    return Y for Centering String Vertically

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function press_hold(f_btn) { 
//  return TRUE - event_press()   
//			    - every 250ms when button is held

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 

function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}


// Function used to reset the SPVAR state to where we begin, this one you can change if you like, the rest you should leave as-is or you risk breaking the logic of this. YOU HAVE BEEN WARNED!
function reset_spvar() {
	spvar_current_slot = SPVAR_1; // Change this to say where it's safe to start storing data
	spvar_current_bit = 0; // Should always be 0, unless you're using part of the first SPVAR in which case you should also change the next line to include the value you are storing in the bits you are using
	spvar_current_value = 0;
}

// ------ DO NOT TOUCH ANYTHING BELOW THIS LINE UNLESS YOU KNOW WHAT YOU ARE DOING! ------

int spvar_current_bit, 		// Variable used to keep track of the next available bit
	spvar_current_slot,		// Variable used to keep track of the currently used SPVAR slot
	spvar_current_value,	// Variable used to keep track of the current value with all the bits from the previous variables saved in the current SPVAR
	spvar_tmp,				// Variable used temporarily during the various calculation steps
	spvar_bits;				// Variable used to keep track of the number of bits required to represent the currently saved/loaded variable

// Function used to count the number of bits used by the given value
function get_bit_count(val) {
	spvar_tmp = 0; // We need to start at 0, we use spvar_tmp here as we need to track the bits during our loop below
	while (val) { // Loop while val is anything but 0
		spvar_tmp++; // Increment the bit count by 1
		val = abs(val >> 1); // Shift the value down 1 bit, once we have no more bits set this will result in 0, unless the value is negative - in which case this will be endless, we do abs here to make it always
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(val1, val2) {
	spvar_tmp = max(get_bit_count(val1), get_bit_count(val2)); // Get the highest bit count required for either min or max
	if (is_signed2(val1, val2)) { // Check if we need to know if the value is negative or not
		spvar_tmp++; // If we need to track if the saved value is negative, we need 1 bit for that specifically - the others are used to store the actual value
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(val1, val2) { return val1 < 0 || val2 < 0; }

// Function used to generate a bitmask for the sign bit, this will always be the highest bit in the range we're requesting it for, to do that - we need to start with the lowest bit set and move it up the number of steps there is between 1 and the bits we need, this needs to be a maximum of 31 but can never be negative
function make_sign(bits) { return 1 << clamp(bits - 1, 0, 31); }

// Function used to generate a full bitmask (essentially all bits set up to and including the number of bits given)
function make_full_mask(bits) {
	if (bits == 32) { // If we're wanting a bitmask for all bits, we can simply return -1 (which is all bits set to 1)
		return -1;
	}
	return 0x7FFFFFFF >> (31 - bits); // What we do here is basically take a value with all bits except the highest set and shift them down as many times as we need to get a mask that fits the bit count we're looking for
}

// Function used to generate a bitmask for just the bits required for the value part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) { return make_full_mask(bits - 1); }

// Function used to pack a value that has potential for being negative in a way that we use the least number of bits we really need to represent the value
function pack_i(val, bits) {
	if (val < 0) { // Check if we have a negative value, if so - handle it accordingly
		return (abs(val) & make_sign_mask(bits)) | make_sign(bits); // Get the positive version of the value and keep the bits that are within range of what we're doing and add the sign bit since we have a negative value and return the result
	}
	return val & make_sign_mask(bits); // Get the bits that are within our range
}

// Function used to unpack (restore) a value that has potential for being negative, essentially reversing what pack_i does above
function unpack_i(val, bits) {
	if (val & make_sign(bits)) { // Check if the stored value is supposed to ve negative
		return 0 - (val & make_sign_mask(bits)); // Retrieve the stored positive value and subtract it from 0 (resulting in the same value except negative), return the result
	}
	return val & make_sign_mask(bits); // Retrieve the stored positive value and return it
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) { return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0); }

// Function used to save your value in the SPVARs, this is the function you'll be calling when saving a value. You need to provide the value to save aswell as the range (minimum and maximum value, this is how we determine how many bits to use when saving this value)
function save_spvar(val, min, max) {
	spvar_bits = get_bit_count2(min, max); // Set spvar_bits to the number of bits we need for this range

	val = clamp(val, min, max); // Make sure the value is within our defined range to begin with

	if (is_signed2(min, max)) { // If either min or max is negative, we need to pack this value as a possibly negative value
		val = pack_i(val, spvar_bits); // Pack as signed value (possibly negative)
	}
	val = val & make_full_mask(spvar_bits); // Pack as unsigned value (always positive), this essentially just makes the resulting value not have any extra bits set - it's safe to use after the signed packing since we're not using any bits outside of the unsigned range anyways

	if (spvar_bits >= 32 - spvar_current_bit) { // Check if there is not enough bits remaining to save this value as-is. if there aren't enough bits, we save what we can here and store the remaining bits in the next spvar, if this means we're hitting the end, we can make this smaller by handling the case where we use all bits here aswell
		spvar_current_value = spvar_current_value | (val << spvar_current_bit); // Add what we can to the current value where there is bits available to use
		set_pvar(spvar_current_slot, spvar_current_value); // Save the current SPVAR before advancing to the next one
		spvar_current_slot++; // Move to the next slot
		spvar_bits -= (32 - spvar_current_bit); // Update the required bits according to our needs for the next slot, if we don't do this here, we'll screw up the saved value by moving it too far out of range
		val = val >> (32 - spvar_current_bit); // Move the remaining bits down, discarding the bits we've already saved
		spvar_current_bit = 0; // Reset the current bit counter since we're starting with a new SPVAR
		spvar_current_value = 0; // Reset our value so we start clean, we aren't currently using any bits anyways
	}

	spvar_current_value = spvar_current_value | (val << spvar_current_bit); // Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_bit += spvar_bits; // Move up the counter of next available bit to where we are currently saving data at
	if (!spvar_current_bit) {
		spvar_current_value = 0; // Reset our value so we start clean, we aren't currently using any bits anyways
	}
	set_pvar(spvar_current_slot, spvar_current_value); // Save the SPVAR with the current value, this won't write anything to flash unless the value changed - so we can do this for each variable saved to no risk missing anything
}

// Function used to read your value from the SPVARs, this is the function you'll be calling when reading a value. You need to provide the range (minimum and maximum value, this is how we determine how many bits to use when reading the value) aswell as a default value if what we read is out of range
function read_spvar(min, max, def) {
	spvar_bits = get_bit_count2(min, max); // Set spvar_bits to the number of bits we need for this range
		spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits); // Read the current SPVAR value from flash and shift them into position, we'll handle split values next

	if (spvar_bits >= 32 - spvar_current_bit) { // Check if we are dealing with a split SPVAR value, essentially if the current position means we're using more than 32 bits in the SPVAR, we need to retrieve the missing bits from the next SPVAR and put them back to our current value, we use the same space saving trick here as in the save function
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	spvar_current_bit += spvar_bits; // Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); // Extract all bits included for this value and discard any other bits
	if (spvar_current_bit >= 32) {
		spvar_current_slot++; // Move to the next SPVAR slot
		spvar_current_bit -= 32; // Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
	}

	if (is_signed2(min, max)) { // Check if the value can be negative and handle it accordingly
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); // Restore the signed, possibly negative value
	}

	if (spvar_current_value < min || spvar_current_value > max) { // Check if the value is below our specified min or above our specified max, if so - return the default value instead
		return def; // This can be changed to min instead as a reasonable default with the default parameter being removed if you don't need to have a override value for the default when out of range, that will save a bit of code size
	}

	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


	
 function Load(){ 
	reset_spvar();
	if (read_spvar(0, 1, 0)) {
    antirecoil_start[0]      = read_spvar(0, 99, 0);
    antirecoil_mid[0]        = read_spvar(0, 99, 0);
    antirecoil_end[0]        = read_spvar(0, 99, 0);       
    antirecoil_time[0]       = read_spvar(0, 99, 0);
    antirecoil_start[1]      = read_spvar(0, 99, 0); 
   	antirecoil_mid[1]        = read_spvar(0, 99, 0);
	antirecoil_end[1]        = read_spvar(0, 99, 0);         
    antirecoil_time[1]       = read_spvar(0, 99, 0);
    antirecoil_start[2]      = read_spvar(0, 99, 0);
  	antirecoil_mid[2]        = read_spvar(0, 99, 0);
	antirecoil_end[2]        = read_spvar(0, 99, 0);         
    antirecoil_time[2]       = read_spvar(0, 99, 0);
	antirecoil_start[3]      = read_spvar(0, 99, 0);
    antirecoil_mid[3]        = read_spvar(0, 99, 0);
    antirecoil_end[3]        = read_spvar(0, 99, 0);       
    antirecoil_time[3]       = read_spvar(0, 99, 0);
    antirecoil_start[4]      = read_spvar(0, 99, 0);
    antirecoil_mid[4]        = read_spvar(0, 99, 0);
    antirecoil_end[4]        = read_spvar(0, 99, 0);       
    antirecoil_time[4]       = read_spvar(0, 99, 0);
    antirecoil_start[5]      = read_spvar(0, 99, 0);
    antirecoil_mid[5]        = read_spvar(0, 99, 0);
    antirecoil_end[5]        = read_spvar(0, 99, 0);       
    antirecoil_time[5]       = read_spvar(0, 99, 0);
    antirecoil_start[6]      = read_spvar(0, 99, 0);
    antirecoil_mid[6]        = read_spvar(0, 99, 0);
    antirecoil_end[6]        = read_spvar(0, 99, 0);       
    antirecoil_time[6]       = read_spvar(0, 99, 0);
    antirecoil_start[7]      = read_spvar(0, 99, 0);
    antirecoil_mid[7]        = read_spvar(0, 99, 0);
    antirecoil_end[7]        = read_spvar(0, 99, 0);       
    antirecoil_time[7]       = read_spvar(0, 99, 0);
    antirecoil_start[8]      = read_spvar(0, 99, 0);
    antirecoil_mid[8]        = read_spvar(0, 99, 0);
    antirecoil_end[8]        = read_spvar(0, 99, 0);       
    antirecoil_time[8]       = read_spvar(0, 99, 0);
    antirecoil_start[9]      = read_spvar(0, 99, 0);
    antirecoil_mid[9]        = read_spvar(0, 99, 0);
    antirecoil_end[9]        = read_spvar(0, 99, 0);       
    antirecoil_time[9]       = read_spvar(0, 99, 0);
    antirecoil_start[10]      = read_spvar(0, 99, 0);
    antirecoil_mid[10]        = read_spvar(0, 99, 0);
    antirecoil_end[10]        = read_spvar(0, 99, 0);       
    antirecoil_time[10]       = read_spvar(0, 99, 0);
    antirecoil_start[11]      = read_spvar(0, 99, 0);
    antirecoil_mid[11]        = read_spvar(0, 99, 0);
    antirecoil_end[11]        = read_spvar(0, 99, 0);       
    antirecoil_time[11]       = read_spvar(0, 99, 0);
    antirecoil_start[12]      = read_spvar(0, 99, 0);
    antirecoil_mid[12]        = read_spvar(0, 99, 0);
    antirecoil_end[12]        = read_spvar(0, 99, 0);       
    antirecoil_time[12]       = read_spvar(0, 99, 0);
    antirecoil_start[13]      = read_spvar(0, 99, 0);
    antirecoil_mid[13]        = read_spvar(0, 99, 0);
    antirecoil_end[13]        = read_spvar(0, 99, 0);       
    antirecoil_time[13]       = read_spvar(0, 99, 0);
    antirecoil_start[14]      = read_spvar(0, 99, 0);
    antirecoil_mid[14]        = read_spvar(0, 99, 0);
    antirecoil_end[14]        = read_spvar(0, 99, 0);       
    antirecoil_time[14]       = read_spvar(0, 99, 0);
    antirecoil_start[15]      = read_spvar(0, 99, 0);
    antirecoil_mid[15]        = read_spvar(0, 99, 0);
    antirecoil_end[15]        = read_spvar(0, 99, 0);       
    antirecoil_time[15]       = read_spvar(0, 99, 0);
    antirecoil_start[16]      = read_spvar(0, 99, 0);
    antirecoil_mid[16]        = read_spvar(0, 99, 0);
    antirecoil_end[16]        = read_spvar(0, 99, 0);       
    antirecoil_time[16]       = read_spvar(0, 99, 0);
    antirecoil_start[17]      = read_spvar(0, 99, 0);
    antirecoil_mid[17]        = read_spvar(0, 99, 0);
    antirecoil_end[17]        = read_spvar(0, 99, 0);       
    antirecoil_time[17]       = read_spvar(0, 99, 0);
    antirecoil_start[18]      = read_spvar(0, 99, 0);
    antirecoil_mid[18]        = read_spvar(0, 99, 0);
    antirecoil_end[18]        = read_spvar(0, 99, 0);       
    antirecoil_time[18]       = read_spvar(0, 99, 0);
    antirecoil_start[19]      = read_spvar(0, 99, 0);
    antirecoil_mid[19]        = read_spvar(0, 99, 0);
    antirecoil_end[19]        = read_spvar(0, 99, 0);       
    antirecoil_time[19]       = read_spvar(0, 99, 0);
    antirecoil_start[20]      = read_spvar(0, 99, 0);
    antirecoil_mid[20]        = read_spvar(0, 99, 0);
    antirecoil_end[20]        = read_spvar(0, 99, 0);       
    antirecoil_time[20]       = read_spvar(0, 99, 0);
    antirecoil_start[21]      = read_spvar(0, 99, 0);
    antirecoil_mid[21]        = read_spvar(0, 99, 0);
    antirecoil_end[21]        = read_spvar(0, 99, 0);       
    antirecoil_time[21]       = read_spvar(0, 99, 0);
    antirecoil_start[22]      = read_spvar(0, 99, 0);
    antirecoil_mid[22]        = read_spvar(0, 99, 0);
    antirecoil_end[22]        = read_spvar(0, 99, 0);       
    antirecoil_time[22]       = read_spvar(0, 99, 0);
    antirecoil_start[23]      = read_spvar(0, 99, 0);
    antirecoil_mid[23]        = read_spvar(0, 99, 0);
    antirecoil_end[23]        = read_spvar(0, 99, 0);       
    antirecoil_time[23]       = read_spvar(0, 99, 0);
    antirecoil_start[24]      = read_spvar(0, 99, 0);
    antirecoil_mid[24]        = read_spvar(0, 99, 0);
    antirecoil_end[24]        = read_spvar(0, 99, 0);       
    antirecoil_time[24]       = read_spvar(0, 99, 0);
    antirecoil_start[25]      = read_spvar(0, 99, 0);
    antirecoil_mid[25]        = read_spvar(0, 99, 0);
    antirecoil_end[25]        = read_spvar(0, 99, 0);       
    antirecoil_time[25]       = read_spvar(0, 99, 0);
    antirecoil_start[26]      = read_spvar(0, 99, 0);
    antirecoil_mid[26]        = read_spvar(0, 99, 0);
    antirecoil_end[26]        = read_spvar(0, 99, 0);       
    antirecoil_time[26]       = read_spvar(0, 99, 0);
    antirecoil_start[27]      = read_spvar(0, 99, 0);
    antirecoil_mid[27]        = read_spvar(0, 99, 0);
    antirecoil_end[27]        = read_spvar(0, 99, 0);       
    antirecoil_time[27]       = read_spvar(0, 99, 0);
    antirecoil_start[28]      = read_spvar(0, 99, 0);
    antirecoil_mid[28]        = read_spvar(0, 99, 0);
    antirecoil_end[28]        = read_spvar(0, 99, 0);       
    antirecoil_time[28]       = read_spvar(0, 99, 0);
    antirecoil_start[29]      = read_spvar(0, 99, 0);
    antirecoil_mid[29]        = read_spvar(0, 99, 0);
    antirecoil_end[29]        = read_spvar(0, 99, 0);       
    antirecoil_time[29]       = read_spvar(0, 99, 0);
    antirecoil_start[30]      = read_spvar(0, 99, 0);
    antirecoil_mid[30]        = read_spvar(0, 99, 0);
    antirecoil_end[30]        = read_spvar(0, 99, 0);       
    antirecoil_time[30]       = read_spvar(0, 99, 0);
    antirecoil_start[31]      = read_spvar(0, 99, 0);
    antirecoil_mid[31]        = read_spvar(0, 99, 0);
    antirecoil_end[31]        = read_spvar(0, 99, 0);       
    antirecoil_time[31]       = read_spvar(0, 99, 0);
    antirecoil_start[32]      = read_spvar(0, 99, 0);
    antirecoil_mid[32]        = read_spvar(0, 99, 0);
    antirecoil_end[32]        = read_spvar(0, 99, 0);       
    antirecoil_time[32]       = read_spvar(0, 99, 0);
    antirecoil_start[33]      = read_spvar(0, 99, 0);
    antirecoil_mid[33]        = read_spvar(0, 99, 0);
    antirecoil_end[33]        = read_spvar(0, 99, 0);       
    antirecoil_time[33]       = read_spvar(0, 99, 0);
    toggle_antirecoil[0]     = read_spvar(0, 1, 0);
    toggle_antirecoil[1]     = read_spvar(0, 1, 0);
    toggle_antirecoil[2]     = read_spvar(0, 1, 0);
    toggle_rapidfire[22]     = read_spvar(0, 1, 0);
    toggle_rapidfire[23]     = read_spvar(0, 1, 0);
    toggle_rapidfire[24]     = read_spvar(0, 1, 0);
    toggle_rapidfire[25]     = read_spvar(0, 1, 0);
    toggle_rapidfire[26]     = read_spvar(0, 1, 0);
    toggle_rapidfire[27]     = read_spvar(0, 1, 0);
    toggle_rapidfire[28]     = read_spvar(0, 1, 0);
    toggle_rapidfire[29]     = read_spvar(0, 1, 0);
    toggle_burstfire[0]      = read_spvar(0, 1, 0);
    toggle_burstfire[1]      = read_spvar(0, 1, 0);
    toggle_burstfire[2]      = read_spvar(0, 1, 0);
    autolean_on[0]           = read_spvar(0, 1, 0);
    peekshot_on[0]		     = read_spvar(0, 1, 0);
    autolean_on[1]       	 = read_spvar(0, 1, 0);
    autolean_on[2]       	 = read_spvar(0, 1, 0);
    peekshot_on[1]           = read_spvar(0, 1, 0);
    peekshot_on[2]           = read_spvar(0, 1, 0);
    autodown_onADS[0]        = read_spvar(0, 1, 0);
    autodown_onADS[1]        = read_spvar(0, 1, 0);
    autodown_onADS[2]        = read_spvar(0, 1, 0);
    TBAG_on[0]               = read_spvar(0, 1, 0);
    TBAG_on[1]               = read_spvar(0, 1, 0);
    TBAG_on[2]               = read_spvar(0, 1, 0);
    toggle_jumpshot[0]       = read_spvar(0, 1, 0);
    toggle_jumpshot[1]       = read_spvar(0, 1, 0);
    toggle_jumpshot[2]       = read_spvar(0, 1, 0);
    toggle_holdbreath        = read_spvar(0, 1, 0);                                                                                                          
	strafe_on[0]             = read_spvar(0, 1, 0);
	strafe_on[1]             = read_spvar(0, 1, 0);
	strafe_on[2]             = read_spvar(0, 1, 0);
	Amp_strafe[0]            = read_spvar(0, 999, 0);                                               
    Vel_strafe[0]            = read_spvar(0, 999, 0);  
    Amp_strafe[1]            = read_spvar(0, 999, 0);                                               
    Vel_strafe[1]            = read_spvar(0, 999, 0); 
    Amp_strafe[2]            = read_spvar(0, 999, 0);                                               
    Vel_strafe[2]            = read_spvar(0, 999, 0); 
    burstfire_hold           = read_spvar(0, 999, 0);  
	burstfire_release        = read_spvar(0, 999, 0);   		    
	swap_on             	 = read_spvar(0, 1, 0);	    
	quickscope_on        	 = read_spvar(0, 1, 0);           
	nomearmi[0]    			 = read_spvar(0, 33, 0);                                
    nomearmi[1]         	 = read_spvar(0, 33, 0);                                          
	nomearmi[2]       		 = read_spvar(0, 33, 0);
	optic[0]                 = read_spvar(0, 5, 0);
	optic[1]                 = read_spvar(0, 5, 0);
	optic[2]                 = read_spvar(0, 5, 0);
    x1 						 = read_spvar(0, 50, 0);
    x2 						 = read_spvar(0, 50, 0);
    x3 						 = read_spvar(0, 50, 0);
    x4 						 = read_spvar(0, 50, 0);
    x6 			 			 = read_spvar(0, 50, 0);
    x8 			 		     = read_spvar(0, 50, 0);
    rate_of_fire[22]          = read_spvar(1, 25, 0);
    rate_of_fire[23]          = read_spvar(1, 25, 0);
    rate_of_fire[24]          = read_spvar(1, 25, 0);
    rate_of_fire[25]          = read_spvar(1, 25, 0);
    rate_of_fire[26]          = read_spvar(1, 25, 0);
    rate_of_fire[27]          = read_spvar(1, 25, 0);
    rate_of_fire[28]          = read_spvar(1, 25, 0);
    rate_of_fire[29]          = read_spvar(1, 25, 0);
    correction_opticsweap[0]  = read_spvar(-20, 20, 0);
    correction_opticsweap[1]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[2]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[3]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[4]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[5]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[6]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[7]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[8]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[9]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[10]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[11]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[12]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[13]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[14]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[15]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[16]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[17]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[18]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[19]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[20]  = read_spvar(-20, 20, 0);
    correction_opticsweap[21]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[22]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[23]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[24]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[25]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[26]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[27]  = read_spvar(-20, 20, 0); 
    correction_opticsweap[28]  = read_spvar(-20, 20, 0);
    correction_opticsweap[29]  = read_spvar(-20, 20, 0);
    correction_opticsweap[30]  = read_spvar(-20, 20, 0);
    correction_opticsweap[31]  = read_spvar(-20, 20, 0);
    correction_opticsweap[32]  = read_spvar(-20, 20, 0);
    correction_opticsweap[33]  = read_spvar(-20, 20, 0);
   rapidmk          = read_spvar( 0, 99,0);
   Burstmk     	 	= read_spvar( 0, 99,0);
   strafemk      	= read_spvar( 0, 99,0);
   jumpmk      	 	= read_spvar( 0, 99,0);
   tbagmk       	= read_spvar( 0, 99,0);
   peekshotmk     	= read_spvar( 0, 99,0);
   Autoleanmk      	= read_spvar( 0, 99,0);
   CrouchADSmk      = read_spvar( 0, 99,0);
   Autorunmk      	= read_spvar( 0, 99,0);
   RESET        	= read_spvar( 0, 99,0);
   Hipvalue       	= read_spvar( -50, 50,0);
   Crouchvalue      = read_spvar( -50, 50,0);
   pronevalue       = read_spvar( -50, 50,0);
   pad_or_MK     	= read_spvar( 0, 1,0);
   }
   else {
    Amp_strafe[0]            =  300;                                               
    Vel_strafe[0]            =  100;  
    Amp_strafe[1]            =  300;                                               
    Vel_strafe[1]            =  100; 
    Amp_strafe[2]            =  300;                                               
    Vel_strafe[2]            =  100; 
    burstfire_hold           =  120;  
	burstfire_release        =  120;
	toggle_rapidfire[22]     =  1 ;
    toggle_rapidfire[23]     =  1 ;
    toggle_rapidfire[24]     =  1 ;
    toggle_rapidfire[25]     =  1 ;
    toggle_rapidfire[26]     =  1 ;
    toggle_rapidfire[27]     =  1 ;
    toggle_rapidfire[28]     =  1 ;
    toggle_rapidfire[29]     =  1 ;
    rate_of_fire[22]          =  13;
    rate_of_fire[23]          =  13;
    rate_of_fire[24]          =  13;
    rate_of_fire[25]          =  13;
    rate_of_fire[26]          =  13;
    rate_of_fire[27]          =  13;
    rate_of_fire[28]          =  13;
    rate_of_fire[29]          =  13;
   }
}  
                                                     
 function Save(){ 
    reset_spvar();
    combo_run(SAVE);	
	save_spvar(   1,	0,     1);
	save_spvar(antirecoil_start[0]      ,0, 99);
    save_spvar(antirecoil_mid[0]        ,0, 99);
    save_spvar(antirecoil_end[0]        ,0, 99);      
    save_spvar(antirecoil_time[0]       ,0, 99);
	save_spvar(antirecoil_start[1]      ,0, 99); 
   	save_spvar(antirecoil_mid[1]        ,0, 99);
	save_spvar(antirecoil_end[1]        ,0, 99);         
    save_spvar(antirecoil_time[1]       ,0, 99);
    save_spvar(antirecoil_start[2]      ,0, 99);
  	save_spvar(antirecoil_mid[2]        ,0, 99);
	save_spvar(antirecoil_end[2]        ,0, 99);        
    save_spvar(antirecoil_time[2]       ,0, 99);
    save_spvar(antirecoil_start[3]      ,0, 99);
    save_spvar(antirecoil_mid[3]        ,0, 99);
    save_spvar(antirecoil_end[3]        ,0, 99);      
    save_spvar(antirecoil_time[3]       ,0, 99);
    save_spvar(antirecoil_start[4]      ,0, 99);
    save_spvar(antirecoil_mid[4]        ,0, 99);
    save_spvar(antirecoil_end[4]        ,0, 99);      
    save_spvar(antirecoil_time[4]       ,0, 99);
    save_spvar(antirecoil_start[5]      ,0, 99);
    save_spvar(antirecoil_mid[5]        ,0, 99);
    save_spvar(antirecoil_end[5]        ,0, 99);      
    save_spvar(antirecoil_time[5]       ,0, 99);
    save_spvar(antirecoil_start[6]      ,0, 99);
    save_spvar(antirecoil_mid[6]        ,0, 99);
    save_spvar(antirecoil_end[6]        ,0, 99);      
    save_spvar(antirecoil_time[6]       ,0, 99);
    save_spvar(antirecoil_start[7]      ,0, 99);
    save_spvar(antirecoil_mid[7]        ,0, 99);
    save_spvar(antirecoil_end[7]        ,0, 99);      
    save_spvar(antirecoil_time[7]       ,0, 99);
    save_spvar(antirecoil_start[8]      ,0, 99);
    save_spvar(antirecoil_mid[8]        ,0, 99);
    save_spvar(antirecoil_end[8]        ,0, 99);      
    save_spvar(antirecoil_time[8]       ,0, 99);
    save_spvar(antirecoil_start[9]      ,0, 99);
    save_spvar(antirecoil_mid[9]        ,0, 99);
    save_spvar(antirecoil_end[9]        ,0, 99);      
    save_spvar(antirecoil_time[9]       ,0, 99);
    save_spvar(antirecoil_start[10]      ,0, 99);
    save_spvar(antirecoil_mid[10]        ,0, 99);
    save_spvar(antirecoil_end[10]        ,0, 99);      
    save_spvar(antirecoil_time[10]       ,0, 99);
    save_spvar(antirecoil_start[11]      ,0, 99);
    save_spvar(antirecoil_mid[11]        ,0, 99);
    save_spvar(antirecoil_end[11]        ,0, 99);      
    save_spvar(antirecoil_time[11]       ,0, 99);
    save_spvar(antirecoil_start[12]      ,0, 99);
    save_spvar(antirecoil_mid[12]        ,0, 99);
    save_spvar(antirecoil_end[12]        ,0, 99);      
    save_spvar(antirecoil_time[12]       ,0, 99);
    save_spvar(antirecoil_start[13]      ,0, 99);
    save_spvar(antirecoil_mid[13]        ,0, 99);
    save_spvar(antirecoil_end[13]        ,0, 99);      
    save_spvar(antirecoil_time[13]       ,0, 99);
    save_spvar(antirecoil_start[14]      ,0, 99);
    save_spvar(antirecoil_mid[14]        ,0, 99);
    save_spvar(antirecoil_end[14]        ,0, 99);      
    save_spvar(antirecoil_time[14]       ,0, 99);
    save_spvar(antirecoil_start[15]      ,0, 99);
    save_spvar(antirecoil_mid[15]        ,0, 99);
    save_spvar(antirecoil_end[15]        ,0, 99);      
    save_spvar(antirecoil_time[15]       ,0, 99);
    save_spvar(antirecoil_start[16]      ,0, 99);
    save_spvar(antirecoil_mid[16]        ,0, 99);
    save_spvar(antirecoil_end[16]        ,0, 99);      
    save_spvar(antirecoil_time[16]       ,0, 99);
    save_spvar(antirecoil_start[17]      ,0, 99);
    save_spvar(antirecoil_mid[17]        ,0, 99);
    save_spvar(antirecoil_end[17]        ,0, 99);      
    save_spvar(antirecoil_time[17]       ,0, 99);
    save_spvar(antirecoil_start[18]      ,0, 99);
    save_spvar(antirecoil_mid[18]        ,0, 99);
    save_spvar(antirecoil_end[18]        ,0, 99);      
    save_spvar(antirecoil_time[18]       ,0, 99);
    save_spvar(antirecoil_start[19]      ,0, 99);
    save_spvar(antirecoil_mid[19]        ,0, 99);
    save_spvar(antirecoil_end[19]        ,0, 99);      
    save_spvar(antirecoil_time[19]       ,0, 99);
    save_spvar(antirecoil_start[20]      ,0, 99);
    save_spvar(antirecoil_mid[20]        ,0, 99);
    save_spvar(antirecoil_end[20]        ,0, 99);      
    save_spvar(antirecoil_time[20]       ,0, 99);
    save_spvar(antirecoil_start[21]      ,0, 99);
    save_spvar(antirecoil_mid[21]        ,0, 99);
    save_spvar(antirecoil_end[21]        ,0, 99);      
    save_spvar(antirecoil_time[21]       ,0, 99);
    save_spvar(antirecoil_start[22]      ,0, 99);
    save_spvar(antirecoil_mid[22]        ,0, 99);
    save_spvar(antirecoil_end[22]        ,0, 99);      
    save_spvar(antirecoil_time[22]       ,0, 99);
    save_spvar(antirecoil_start[23]      ,0, 99);
    save_spvar(antirecoil_mid[23]        ,0, 99);
    save_spvar(antirecoil_end[23]        ,0, 99);      
    save_spvar(antirecoil_time[23]       ,0, 99);
    save_spvar(antirecoil_start[24]      ,0, 99);
    save_spvar(antirecoil_mid[24]        ,0, 99);
    save_spvar(antirecoil_end[24]        ,0, 99);      
    save_spvar(antirecoil_time[24]       ,0, 99);
    save_spvar(antirecoil_start[25]      ,0, 99);
    save_spvar(antirecoil_mid[25]        ,0, 99);
    save_spvar(antirecoil_end[25]        ,0, 99);      
    save_spvar(antirecoil_time[25]       ,0, 99);
    save_spvar(antirecoil_start[26]      ,0, 99);
    save_spvar(antirecoil_mid[26]        ,0, 99);
    save_spvar(antirecoil_end[26]        ,0, 99);      
    save_spvar(antirecoil_time[26]       ,0, 99);
    save_spvar(antirecoil_start[27]      ,0, 99);
    save_spvar(antirecoil_mid[27]        ,0, 99);
    save_spvar(antirecoil_end[27]        ,0, 99);      
    save_spvar(antirecoil_time[27]       ,0, 99);
    save_spvar(antirecoil_start[28]      ,0, 99);
    save_spvar(antirecoil_mid[28]        ,0, 99);
    save_spvar(antirecoil_end[28]        ,0, 99);      
    save_spvar(antirecoil_time[28]       ,0, 99);
    save_spvar(antirecoil_start[29]      ,0, 99);
    save_spvar(antirecoil_mid[29]        ,0, 99);
    save_spvar(antirecoil_end[29]        ,0, 99);      
    save_spvar(antirecoil_time[29]       ,0, 99);
    save_spvar(antirecoil_start[30]      ,0, 99);
    save_spvar(antirecoil_mid[30]        ,0, 99);
    save_spvar(antirecoil_end[30]        ,0, 99);     
    save_spvar(antirecoil_time[30]       ,0, 99);
    save_spvar(antirecoil_start[31]      ,0, 99);
    save_spvar(antirecoil_mid[31]        ,0, 99);
    save_spvar(antirecoil_end[31]        ,0, 99);    
    save_spvar(antirecoil_time[31]       ,0, 99);
    save_spvar(antirecoil_start[32]      ,0, 99);
    save_spvar(antirecoil_mid[32]        ,0, 99);
    save_spvar(antirecoil_end[32]        ,0, 99);      
    save_spvar(antirecoil_time[32]       ,0, 99);
    save_spvar(antirecoil_start[33]      ,0, 99);
    save_spvar(antirecoil_mid[33]        ,0, 99);
    save_spvar(antirecoil_end[33]        ,0, 99);      
    save_spvar(antirecoil_time[33]       ,0, 99);
    save_spvar(toggle_antirecoil[0]      ,0, 1);
    save_spvar(toggle_antirecoil[1]      ,0, 1);
    save_spvar(toggle_antirecoil[2]      ,0, 1);
    save_spvar(toggle_rapidfire[22]      ,0, 1);
    save_spvar(toggle_rapidfire[23]      ,0, 1);
    save_spvar(toggle_rapidfire[24]      ,0, 1);
    save_spvar(toggle_rapidfire[25]      ,0, 1);
    save_spvar(toggle_rapidfire[26]      ,0, 1);
    save_spvar(toggle_rapidfire[27]      ,0, 1);
    save_spvar(toggle_rapidfire[28]      ,0, 1);
    save_spvar(toggle_rapidfire[29]      ,0, 1);
    save_spvar(toggle_burstfire[0]       ,0, 1);
    save_spvar(toggle_burstfire[1]       ,0, 1);
    save_spvar(toggle_burstfire[2]       ,0, 1);
    save_spvar(autolean_on[0]            ,0, 1);
    save_spvar(peekshot_on[0]		     ,0, 1);
    save_spvar(autolean_on[1]       	 ,0, 1);
    save_spvar(autolean_on[2]       	 ,0, 1);
    save_spvar(peekshot_on[1]            ,0, 1);
    save_spvar(peekshot_on[2]            ,0, 1);
    save_spvar(autodown_onADS[0]         ,0, 1);
    save_spvar(autodown_onADS[1]         ,0, 1);
    save_spvar(autodown_onADS[2]         ,0, 1);
    save_spvar(TBAG_on[0]                ,0, 1);
    save_spvar(TBAG_on[1]                ,0, 1);
    save_spvar(TBAG_on[2]                ,0, 1);
    save_spvar(toggle_jumpshot[0]        ,0, 1);
    save_spvar(toggle_jumpshot[1]        ,0, 1);
    save_spvar(toggle_jumpshot[2]        ,0, 1);
    save_spvar(toggle_holdbreath         ,0, 1);                                                                                                          
	save_spvar(strafe_on[0]              ,0, 1);
	save_spvar(strafe_on[1]              ,0, 1);
	save_spvar(strafe_on[2]              ,0, 1);
	save_spvar(Amp_strafe[0]             ,0, 999);                                              
    save_spvar(Vel_strafe[0]             ,0, 999); 
    save_spvar(Amp_strafe[1]             ,0, 999);                                              
    save_spvar(Vel_strafe[1]             ,0, 999);  
    save_spvar(Amp_strafe[2]             ,0, 999);                                              
    save_spvar(Vel_strafe[2]             ,0, 999);  
    save_spvar(burstfire_hold            ,0, 999); 
	save_spvar(burstfire_release         ,0, 999);		    
	save_spvar(swap_on                   ,0, 1);	    
	save_spvar(quickscope                ,0, 1);           
	save_spvar(nomearmi[0]    		     ,0, 33);                                
    save_spvar(nomearmi[1]               ,0, 33);                                          
	save_spvar(nomearmi[2]       	     ,0, 33);
	save_spvar(optic[0]       	 		 ,0, 5);
	save_spvar(optic[1]       	 		 ,0, 5);
	save_spvar(optic[2]       	 		 ,0, 5);
    save_spvar(x1         				 ,0, 50);
    save_spvar(x2           			 ,0, 50);
    save_spvar(x3        				 ,0, 50);
    save_spvar(x4        				 ,0, 50);
    save_spvar(x6        				 ,0, 50);
    save_spvar(x8        				 ,0, 50);
	save_spvar(rate_of_fire[22]          ,1, 25);
	save_spvar(rate_of_fire[23]          ,1, 25);
	save_spvar(rate_of_fire[24]          ,1, 25);
	save_spvar(rate_of_fire[25]          ,1, 25);
	save_spvar(rate_of_fire[26]          ,1, 25);
	save_spvar(rate_of_fire[27]          ,1, 25);
	save_spvar(rate_of_fire[28]          ,1, 25);
	save_spvar(rate_of_fire[29]          ,1, 25);
	save_spvar(correction_opticsweap[0]  ,-20, 20);
    save_spvar(correction_opticsweap[1]  ,-20, 20);
    save_spvar(correction_opticsweap[2]  ,-20, 20);
    save_spvar(correction_opticsweap[3]  ,-20, 20);
    save_spvar(correction_opticsweap[4]  ,-20, 20);
    save_spvar(correction_opticsweap[5]  ,-20, 20);
    save_spvar(correction_opticsweap[6]  ,-20, 20);
    save_spvar(correction_opticsweap[7]  ,-20, 20);
    save_spvar(correction_opticsweap[8]  ,-20, 20);
    save_spvar(correction_opticsweap[9]  ,-20, 20);
    save_spvar(correction_opticsweap[10]  ,-20, 20);
    save_spvar(correction_opticsweap[11]  ,-20, 20);
    save_spvar(correction_opticsweap[12]  ,-20, 20);
    save_spvar(correction_opticsweap[13]  ,-20, 20);
    save_spvar(correction_opticsweap[14]  ,-20, 20);
    save_spvar(correction_opticsweap[15]  ,-20, 20);
    save_spvar(correction_opticsweap[16]  ,-20, 20);
    save_spvar(correction_opticsweap[17]  ,-20, 20);
    save_spvar(correction_opticsweap[18]  ,-20, 20);
    save_spvar(correction_opticsweap[19]  ,-20, 20);
    save_spvar(correction_opticsweap[20]  ,-20, 20);
    save_spvar(correction_opticsweap[21]  ,-20, 20);
    save_spvar(correction_opticsweap[22]  ,-20, 20);
    save_spvar(correction_opticsweap[23]  ,-20, 20);
    save_spvar(correction_opticsweap[24]  ,-20, 20);
    save_spvar(correction_opticsweap[25]  ,-20, 20);
    save_spvar(correction_opticsweap[26]  ,-20, 20);
    save_spvar(correction_opticsweap[27]  ,-20, 20);
    save_spvar(correction_opticsweap[28]  ,-20, 20);
    save_spvar(correction_opticsweap[29]  ,-20, 20);
    save_spvar(correction_opticsweap[30]  ,-20, 20);
    save_spvar(correction_opticsweap[31]  ,-20, 20);
    save_spvar(correction_opticsweap[32]  ,-20, 20);
    save_spvar(correction_opticsweap[33]  ,-20, 20);
    save_spvar(rapidmk      	 		     ,0, 99);
    save_spvar(Burstmk     	 		         ,0, 99);
    save_spvar(strafemk      	 		     ,0, 99);
    save_spvar(jumpmk      	 		     	 ,0, 99);
    save_spvar(tbagmk       	 		     ,0, 99);
    save_spvar(peekshotmk     	 		     ,0, 99);
    save_spvar(Autoleanmk      	 		     ,0, 99);
    save_spvar(CrouchADSmk      	 		 ,0, 99);
    save_spvar(Autorunmk      	 		     ,0, 99);
    save_spvar(RESET        	 		     ,0, 99);
    save_spvar(Hipvalue       	 		     ,-50, 50);
    save_spvar(Crouchvalue       	 		 ,-50, 50);
    save_spvar(pronevalue       	 		 ,-50, 50);
    save_spvar(pad_or_MK     	 		     ,0, 1);  
 }
 function supported_key_pressed() {
  for (i = 0; i < sizeof(LayoutsMK); i++) {
    if (get_keyboard(LayoutsMK[i])) { return LayoutsMK[i]; }
  }
  return -1; // No key pressed
}

function refresh_kb_states() {
    bitindex = 0;
    varindex=0;
    for (i = 0; i < sizeof(LayoutsMK); i++) {
        if (bitindex >= 32) {
            bitindex = 0;
            varindex++;
        }
        if (get_keyboard(i)) {
            if (!test_bit(KBStates_Press[varindex], bitindex)) {
               KBStates_Press[varindex] = custom_set_bit(KBStates_Press[varindex], bitindex);
            }
            else {
                KBStates_Release[varindex] = custom_clear_bit(KBStates_Release[varindex], bitindex);
            }
        }
        else {
            if (!test_bit(KBStates_Release[varindex], bitindex)) {
               KBStates_Release[varindex] = custom_set_bit(KBStates_Release[varindex], bitindex);
            }
            else {
               KBStates_Press[varindex] = custom_clear_bit(KBStates_Press[varindex], bitindex);
            }
        }        
     bitindex++;
  }
}

function event_press_kb(btn) {
    bitindex = btn % 32;
    varindex = btn / 32;
    return get_keyboard(btn) && test_bit(KBStates_Release[varindex], bitindex);
}

function event_release_kb(btn) {
    bitindex = btn % 32;
    varindex = btn / 32;
    return !get_keyboard(btn) && test_bit(KBStates_Press[varindex], bitindex);
}

function custom_set_bit(value, bitindex) {
  return value | (1 << bitindex);
}
function custom_clear_bit(value, bitindex) {
  return value & (~(1 << bitindex));
}


// ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? 
/*
function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
//set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
//set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);  ANDRY85ANDRY85ANDRY85ANDRY85ANDRY85ANDRY85ANDRY85ANDRY85ANDRY85
}   */ 