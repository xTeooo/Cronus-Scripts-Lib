// GPC Online Library
// the_division_2_pro_script_-_zen_only.gpc

/*———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Game: The Division 2
Version: PRO 4.4
Device: CronusZEN ONLY
Controller tested: DS4 - Elite 2
Console tested: PS4 (XBOX and PC compatible)
Author: noozbar
																							Thanks to CronusMAX community and staff
																					  Thanks to DoGzTheFiGhTeR for the awesome screen saver
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸

Arrays with pre-stored values 
	- 7 arrays (for each Weapon Category: Assault Rifle, SMG, LMG, ...)
	- many weapons per category (I can add more weapons)
	
In the arrays for full auto weapons, only the AntiRecoil values are stored
In the arrays for semi auto weapons, the AntiRecoil and Rate of Fire values are stored


As you have 3 weapons in The Division, you can have 3 different profiles with this script.
	- Profiles 1 and 2 are for primary and secondary, you can choose any weapon category exept HandGun
	- Profile 3 is for HandGun only
	
There is a profile 4 for the Special weapon, this profile disables: AntiRecoil, Rapid/Burst Fire, AIM Assist and StrafeShot

Switch profile as you switch weapon IN Game (Division 2).

If your weapon IN game and your weapon on the OLED screen are unsync, hold L3/LS and tap TRIANGLE/Y

Each of the 3 profiles also has a temporary value which is adjustable.
This Temp Val will be added to or subtracted from the pre-stored value to allow you to make fine adjustments to your Antirecoil or Rate Of Fire
As Temp Val is profile-dependent, if you change the weapon on a profile, remember to reset the Temp Val
	- You can reset these temporary values from the ModWeapon by holding down CROSS/A 500ms
	
/!\ YOU ONLY RESET THE TEMP VALUES OF THE ACTIVE PROFILE /!\ 
	
You can write down your adjusted values on a piece of paper.
You will then be able to modify the value in the corresponding arrays.
This way, while In Game, when you change category or weapon, antirecoil will already be perfectly adjusted for you.


Each profile has (private features)
	- its own AntiRecoil Type with its own toggle and its own values (private toggles and private values)
	- its own RapidFire with its own toggle and its own rate of fire (private toggles and private values)
	- its own BurstFire with its own toggle and a value that applies to all profiles (private toggles and global value)
	- its own AIM Assist with its own toggle and values that apply to all profiles (private toggle and global value)
	- its own StrafeShot with its own toggle and a value that applies to all profiles (private toggle and global value)

This applies to all profiles (global features with global toggles and values))
	- DynaSens (Dynamic Sensitivity) with global toggle and values 
	- Reload (then switch weapon) with global toggle and value 
	- AutoRun with global toggle
	- Easy MedKit with global toggle
	- Quick Nade with global toggle
	- Skill Destroy with global toggle
	- Easy Roll with global toggle
	- Parkour with global toggle
	- Swap Trigger/Bumper with global toggle
	- Inverted Y (for vertical AntiRecoil) with global toggle
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸

											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	P R I V A T E   F E A T U R E S   W I T H   P R I V A T E   V A L U E S
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	
			Antirecoil (you can choose between 3 types of antirecoil) with smart stop feature (in game, rumble MUST BE ON, you can disable rumble with "Rumble" mod on OLED)
			
				- Progressive (advanced users)
					* Vertical AntiRecoil that gradually increases or decreases from Start value to End value, the duration of the progression is defined by Time value (progressive, 3 values)
					* Horizontal AntiRecoil (standard, 1 value)
					
				- Standard (easy to adjust)
					* Vertical AntiRecoil (standard, 1 value)
					* Horizontal AntiRecoil (standard, 1 value)
					
				- On Rumble(for noob)
					* Vertical AntiRecoil called Rumble power (standard, 1 value)
					* Horizontal AntiRecoil (standard, 1 value)
					
					
			RapidFire 
				If you have set up your script with a semi-automatic weapon on one of the profiles, when you are on that profile, RapidFire will be enabled by default, 
				you will unlock the Speed Toggle of this mod (and lock BurstFire Speed Toggle),
				and you will also have access to the RapidFire menu in the ModMenu to have the possibility to disable the mod or adjust Rate Of Fire (BurstFire menu is hidden)
				
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	P R I V A T E   F E A T U R E S   W I T H   G L O B A L   V A L U E S
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————	

			BurstFire
				If you have set up your script with a full-automatic weapon on one of the profiles, when you are on that profile,
				you will unlock the Speed Toggle of this mod (and lock RapidFire Speed Toggle),
				and you will also have access to the BurstFire menu in the ModMenu to have the possibility to disable the mod or adjust Hold and Release time (RapidFire menu is hidden)
			
			
			AIM Assist (Polar Assist with TaylorDrift Shapes) You can quickly change the Shape by holding the ADS button and double tapping RIGHT
				There is 2 values
					- Radius is the size of the micro-movements
						the bigger the size, the more you will have a Screen Shake effect
						Decrease the value until the shaking is almost over

					- Steps is the frequency of micro movements
						- With Batts Sticky:
							the lower the value, the more likely you will experience a slowdown in the character's movements 
						- With others shapes:
							the higher the value, the more likely you will experience a slowdown in the character's movements 
						Decrease the value until your movements are normal
						
			
			Strafe Shot 
				Strafe Right and Left while fireing

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	G L O B A L   F E A T U R E S   W I T H   G L O B A L   V A L U E S
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	
			DynaSens
				Customize the sensitivity of your right stick
				while aiming and also while aiming to deploy a skill
				- more instructions below
			
			
			Reload 
				Double tap reload button to stop and change weapon in the middle of the reload animation
				With the right Time value, the empty weapon you just holstered will be reloaded

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	G L O B A L   F E A T U R E S   
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
				
			AutoRun
				- push the left stick 90% forward or to the sides to run  - hold to sprint must be enabled in the game settings
			
			
			Easy Medkit
				- double tap Dpad RIGHT to change armor plate
			
					Easy MedKit Cancel
						- move LEFT stick to cancel 
				
				
			Quick Nade
				- double tap LEFT to throw grenade (while aiming or not)
					- Elite controller: hold PL1 (Paddle Left 1) to take a grenade and release PL1 to throw the nade
					
					Quick Nade Cancel
						- tap CIRCLE/B to cancel
			
			
			Skill Destroy
				- hold any skill button and tap CROSS/A to destroy the corresponding skill
				
					Skill Destroy Cancel
						- tap any skill button
			
			
			Easy Roll - with toggle
				- Standard controller:
					- tap CROSS/A to roll, HOLD to take cover (it is preferable to activate the "hold to cover" option in game)
				- Elite Controller: 
					- quick tap PR1 (Paddle Right 1) to roll
			
			
			Parkour 
				- automatically jumps over obstacles when push the left stick forward
			
			
			Swap Trigger/bumper - (don't set alternate/inverted/flipped or I don't know what in game settings or in console settings)
				- swap L1/LB with L2/LT and swap R1/RB with R2/RT 
			
			
			Inverted Y for vertical antirecoil - (in game, inverted must be ON)
				- invert Y axis 
			
			
			Rumbles - (in game, rumble must be ON)
				- disable controller rumbles 

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	A D D I T I O N N A L   F E A T U R E S
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	
			KillSwitch
				In the inventory, if some mods start to run (because you move stick, press/hold a button ...), this can mark objects as trash
				On the map, this will have a nefaste effect on navigation and GPS
				That's why the script is frequently deactivated
				Get into the habit of spamming CIRCLE/B to get out of the menus or the map, this turn the script ON
				- more instrictions below


			Hair Trigger
				- makes your triggers ultra sensitive, perfect for reactivity
			
			
			BigHorn Mode
				- RapidFire is automatically enabled when you scope with BigHorn and is disable when you don't scope in your weapon 
					If you have set up your script with BigHorn on one of the profiles
					
					
			Resync Button 
				Sometimes your weapon in game is unsync with the weapon displayed on ZEN, profiles are mixed
				- Hold L3/LS and tap TRIANGLE/Y to resync
				
				
			Speed Toggle
				- toggle on the fly one of the 4 most popular mod (without having to go into ModMenu)
				- more instructions below
				
			
			Speed Weapon Swap
				- switch on the fly your weapon category and weapon name (without having to go into ModWeapon)
				- more instructions below
				
				
			Smart Cover (Elite Controller)
				- hold PR1 to cover, release PR1 to exit cover
				- if DynaSens is ON, the feature is running while PR1 is held down
						
						
◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸												

How to use the ModMenu:

	Open ModMenu (L2/LT + OPTIONS/MENU to open or exit)
	
		Choose which profile you want to modify (Primary, Secondary or SideArm) 
			- Tap TRIANGLE/Y 
			
		Navigate between the different MODS with LEFT or RIGHT (D pad)
			- tap UP or DOWN to turn ON or OFF
			- For Antirecoil, tap UP or DOWN to switch between AntiRecoil Type: OFF, Progressive Antirecoil, Standard Antirecoil, Rumble Antirecoil
			- For Polar AIM Assist, UP or DOWN to switch between every Shapes
		
		Activate the mods you want on each profile...
		
	If the mod displayed has one or more editable value(s): 
		- Tap CROSS/A to close ModMenu and go to ModEdit
	
	Tap SQUARE/X to close ModMenu and go to ModWeapon
			
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

How to use the ModEdit: (while in ModMenu, tap CROSS/A to close ModMenu and go to ModEdit - if the mod displayed has one or more editable value(s))

		Navigate between the different value name with LEFT or RIGHT
		Change/edit the value:
			- Hold CROSS/A and 
				- tap UP or RIGHT to increase value 
				- tap DOWN or LEFT to decrease value
		
		To exit ModEdit and go back to ModMenu, tap CIRCLE/B
		
		Hold L2/LT and tap PS/XBOX to close every Menu
	
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

How to use the ModWeapon: (while in ModMenu, tap SQUARE/X to close ModMenu and go to ModWeapon)
	
		Choose which profile you want to modify (Primary, Secondary or SideArm) 
			- Tap TRIANGLE/Y 
			
		To switch between Weapon Category 
			- Tap UP or DOWN
			
		To switch between Weapon Name 
			- Tap LEFT or RIGHT
		
		Hold CROSS/A 500ms to restore to default Antirecoil temporary values and Rate of Fire temporary values of the active profile
		
		Tap CIRCLE/B to close ModWeapon and go to ModMenu
		
		Hold L2/LT and tap PS/XBOX to close every Menu
		
		
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
				           
	Save every values and exit(only available if you are in ModMenu or ModEdit or ModWeapon)		
		- Tap PS/XBOX to save EVERY values, toggles, weapon category and weapon name, independently for EACH profiles 

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Speed toggles for the active profile (outside Mod Menu/Edit/Weapon)
		- Hold aiming button and hold 300ms UP, DOWN, RIGHT or LEFT
			- UP for	RapidFire (if available with your current weapon category)
			- DOWN for	BurstFire (if available with your current weapon category)
			- RIGHT for	Polar Assist
			- LEFT for	Strafe Shot
			
		- Hold aiming button and
			- DOUBLE TAP RIGHT to switch between Polar Assist Shapes

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

	Speed weapon swap for the active profile (outside Mod Menu/Edit/Weapon)
		- Hold R3/RS and tap UP, DOWN, RIGHT or LEFT
			- UP and DOWN change your current weapon category
			- RIGHT and LEFT change your current weapon name

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	
	Switch profiles
		- In Game:
			- Tap TRIANGLE/Y to switch profile 1 and 2 (primary and secondary)
			- Double tap to switch to profile 3 (sidearm) (tap again to go back to the previous profile)
			- Hold TRIANGLE to switch to special weapon (every "assist" disabled)
		- In Mod Menu/Edit/Weapon
			- Tap TRIANGLE/Y to loop profile 1, 2, 3, 1, 2, 3 ...
			
	Resync profiles
		- Hold L3/LS and tap TRIANGLE/Y

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Kill Switch (disable everything)
		- Turn ON to OFF or OFF to ON
			- Hold aiming button and tap SHARE/VIEW 
			- Tap PS/XBOX 
			
		- Turn ON (disable everything)
			- Tap OPTIONS/MENU
			- Tap Map button
			
		- Turn OFF (enable everything)
			- Double tap CIRCLE/B
			- Hold CIRCLE/B more than 600ms
			- Hold SQUARE/X more than 1000ms while on the map only (for fast travel)
		
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Dynamic sensitivity (while aiming with weapons or skill): 

	DYNASENS_INITIAL_SENS displayed on OLED screen "DS Ini Sens" is your initial X and Y sensitivity (value range 0 - 100)
		While aiming, I want my sensitivity which is set to 100% in my game to be reduced by half as long as the stick input does not exceed DYNASENS_LIMIT
		So "DS Ini Sens" = 50 on the OLED screen

	DYNASENS_LIMIT displayed on OLED screen "DS Limit" is the stick input point from which the sensitivity increases (value range 0 - 100)
		When the stick input exceeds 65 (my DYNASENS_LIMIT value), it gradually increases the sensitivity from 50 (my DYNASENS_INITIAL_SENS value) to 100 (my DYNASENS_MAX_SENS value)
		The sensitivity increase rate is defined by DYNASENS_INCREASE_RATE

	DYNASENS_RESTART displayed on OLED screen "DS Restart" stick input point where sensitivity will reset back to initial sens (value range 0 - 100)
		When stick input goes down below 30 (my DYNASENS_RESTART value), stick sensitivity return to 50 (my DYNASENS_INITIAL_SENS value)

	DYNASENS_MAX_SENS displayed on OLED screen "DS Max Sens" is the maximum sensitivity value you want
		100 means that your maximum "DynaSens" sensitivity will be the one you set in your game

	DYNASENS_INCREASE_RATE displayed on OLED screen "DS Inc Rate" sensitivity increase rate
		1 = 10ms delay between increase


															THANK YOU FOR READING
															THANK YOU FOR READING
															THANK YOU FOR READING
											
											
◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺
———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*/

// Text to display 
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE = "SAVED";
	const string SPECIAL = "Special weapon";
	const string ALL = "Every Profiles";
	const string MUTE = "Script OFF";
	const string HOLD = "Dbl-Tap CIRCLE/B";
	const string ACTIVE = "to turn ON"
	const string ANTIRECOIL_VERTICAL = "AR Vertical";
	
	const string PROFILE[] = {
	"Primary", "Secondary", "SideArm" };
	
	const string ANTIRECOIL[] = {
	"OFF", "Progressive", "Standard", "On Rumble" };
	
	const string SHAPES[] = {
	"OFF", "Sticky", "Circular", "Tall Oval", "Wide Oval", "Spiral", "Helix" };
	
	const string INFO_MENU[] = {
	"Switch Profile:", "tap TRIANGLE/Y", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", "Edit Menu:", "tap CROSS/A", "Weapon Menu:", "tap SQUARE/X", "Close ModMenu:", "hold L2/LT +", "tap OPTION/MENU", "Save and exit:", "tap PS/XBOX"}; 
	
	const string INFO_EDIT[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold CROSS/A +", "UP DOWN LEFT RIGHT", "Toggle Menu:", "tap CIRCLE/B", "Close ModMenu:", "hold L2/LT +", "tap OPTION/MENU", "Save and exit:", "tap PS/XBOX"}; 
	
	const string INFO_WEAPON[] = {
	"Switch Profile:", "tap TRIANGLE/Y", "Weapon Category:", "tap UP or DOWN", "Weapon Name:", "tap LEFT or RTGHT", "Toggle Menu:", "tap CIRCLE/B", "Close ModMenu:", "hold L2/LT +", "tap OPTION/MENU", "Save and exit:", "tap PS/XBOX" }; 

	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mod Name
	const string MODNAME[] = {
			"AntiRecoil"   , "RapidFire", "BurstFire", "Polar Assist"   , "StrafeShot", 
// modName_idx = 0         |      1     |      2     |       3          |      4      |      
			"DynaSens"     , "Reload"   , "AutoRun"  , "Easy MedKit"    , "Quick Nade",
// modName_idx = 5         |      6     |      7     |       8          |      9      |      
			"Skill Destroy", "Easy Roll", "Parkour"  , "Swap Trig/Bump" , "Rumbles"
// modName_idx = 10        |     11     |     12     |      13          |     14
	};

// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	const string VALNAME [] = {
			"AR Start"   , "AR End"   , "AR Time"   , "AR Horiz"   , "RPM / BPM"  , 
// valName_idx = 0       |      1     |      2      |       3      |       4      |   
 			"BF Hold"    ,"BF Release", "Radius"    , "Steps"      , "S.Shot Time", 
// valName_idx = 5       |      6     |      7      |       8      |       9      |   
 			"DS Ini Sens", "DS Limit" , "DS Restart", "DS Max Sens", "DS Inc Rate", "Reload Time", "Rumble Power"
// valName_idx =10       |     11     |      12     |      13      |      14      |      15      
	};

// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

const string WEAPON_CAT[] = {
							"Assault R.", "SMG", "LMG", "Rifle", "ShotGun", "Sniper", "HandGun"
// weapon_category[profile_idx] = 0     |   1  |   2  |    3   |     4    |     5   |     6
};
	
// To define if RapidFire or BurstFire will be available with the current weapon category	
	define AMOUNT_OF_FULLAUTO_CAT = 3; // If a new full automatic Weapon Category is added, add it before RIFLE[][] and change this define

// To define the Weapon Category of each of the profiles independently
	int weapon_category[3];
	
// To define the Weapon Name of each of the profiles independently	
	int weapon_name[3]; 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

// Weapon Caregory arrays with several pre-registered weapons (line) and the values antirecoil_start, antirecoil_end, antirecoil_time, antirecoil_horizontal (column)
// arrays below LMG have in addition to these values, the rate_of_fire value of each weapon
	
	const int16 A_RIFLE[][] = { 
 // ar start, ar end, ar time, ar horiz
	{ 59    ,   40  ,   500  ,   -7   }, // Famas
	{ 35    ,   21  ,   500  ,   -3   }, // M4
	{ 38    ,   21  ,   500  ,    0   }, // P416
	{ 40    ,   40  ,   500  ,    0   }, // AK M
	{ 71    ,   27  ,   500  ,   -3   }, // BigHorn
	{ 48    ,   15  ,  1500  ,    0   }, // Chameleon
	{ 45    ,   20  ,   500  ,    0   }, // Savage Wolverine
	{ 45    ,   28  ,   500  ,    0   }, // CTAR-21
	{ 35    ,   25  ,   500  ,    0   }, // G36
	{ 36    ,   30  ,   800  ,    0   }, // Manic
	{ 35    ,   23  ,   900  ,    0   }, // Mechanical Animal
	{ 60    ,   35  ,   500  ,    0   }, // Shield Splinterer
	{ 69    ,   40  ,   500  ,   -5   }, // BurnOut
	{ 30    ,   30  ,   500  ,    0   }, // ACR
	{ 50    ,   22  ,   800  ,   -5   }, // FAL
	{ 22    ,   33  ,   500  ,    1   }, // Eagle Bearer
	{ 52    ,   25  ,   300  ,    0   }  // Test Subject
	};
	
	const int16 SMG[][] = { // start, end, time, horiz
	{ 39, 28,  800,  0 }, // MPX / Safety
	{ 39, 32,  800, -6 }, // LadyDeath
	{ 37, 27,  800,  0 }, // Vector
	{ 37, 25,  600,  0 }, // Emeline
	{ 37, 28,  600,  0 }, // Grudge
	{ 37, 25,  600,  0 }, // AUG XS
	{ 37, 24,  600,  0 }, // T821
	{ 39, 28,  800,  0 }, // P90
	{ 40, 27,  800,  0 }, // M1928
	{ 39, 26,  800,  0 }, // MP5
	{ 39, 26,  800,  0 }, // PP19
	{ 41, 30,  800, -1 }  // UMP 45
	};
	
	const int16 LMG[][] = { // start, end, time, horiz
	{ 62, 33, 1000, -6 }, // BulletKing
	{ 35, 23,  800, -5 }, // M60
	{ 48, 30, 1000, -5 }, // MG5
	{ 35, 25,  800,  0 }, // Pestilence
	{ 70, 35, 1000, -5 }, // Carnage
	{ 33, 20,  800, -3 }, // QuietRoar
	{ 35, 27,  800,  6 }, // RPK-74 / New Reliable
	{ 45, 30,  800, -7 }, // NEGEV
	{ 37, 27,  800,  2 }, // M249
	{ 35, 24,  500, -3 }  // Stoner LAMG
	};
	
	const int16 RIFLE[][] = { // start, end, time, horiz, RoF(val min = 60)
	{ 40,  0,  500, 0, 100 }, // DiamondBack
	{  0, 10, 1500, 0, 180 }, // M1A / Backer's
	{ 35,  0,  500, 0, 320 }, // M1A CQB
	{ 40,  0,  500, 0, 300 }, // Harmony
	{ 40, 15,  800, 0, 100 }, // 1886
	{ 35, 40, 1000, 0, 360 }, // LW M4
	{ 30,  0, 1000, 0, 300 }, // Artist's Tool
	{ 30,  0,  300, 0, 275 }, // Everlasting Gaze
	{ 20, 30, 4500, 0, 380 }, // Surge
	{ 40, 45,  800, 0, 600 }, // Merciless
	{ 60, 59,  500, 0, 420 }, // ACR SS
	{ 35, 65, 4000, 0, 420 }, // USC 45
	{ 30,  0, 1000, 0, 320 }  // SIG 716
	};
	
	const int16 SHOTGUN[][] = { 
 // ar start, ar end, ar time, ar horiz, RoF(val min = 60)
	{  17   ,   34  ,   800  ,    -3   ,   180 }, // SASG12
	{  15   ,   15  ,   500  ,     0   ,   160 }, // Super90
	{  15   ,   24  ,   800  ,     0   ,   315 }, // ACS-12
	{  12   ,   10  ,   500  ,     0   ,    70 }, // Sweet Dream
	{  12   ,   10  ,   500  ,     0   ,    70 }, // SPAS-12
	{  20   ,   22  ,   500  ,     0   ,   130 }  // Scorpio
	};
	
	const int16 SNIPER[][] = { // start, end, time, horiz, RoF(val min = 60)
	{ 40, 70,  500,   0, 260 }, // SVD
	{ 57,  0,  100, -10,  60 }, // M700
	{ 30,  0,  100, -25,  60 }, // M44
	{ 99,  0,  100, -25,  70 }  // Mantis
	};
	
	const int16 HANDGUN[][] = { // start, end, time, horiz, RoF(val min = 60)
	{ 30, 35,  500, 0, 310 }, // M1911
	{ 40, 60,  500, 0, 200 }, // DoubleBarel
	{ 20, 37, 1000, 0, 173 }, // Liberty
	{ 30, 35,  500, 0, 350 }, // M9 
	{ 25, 35,  500, 0, 370 }, // PF45 
	{ 20, 15, 1000, 0, 160 }  // Magnum
	};
	
	// String arrays with weapons Name
	const string A_RIFLE_NAME[] = { // A_RIFLE[weapon_name[profile_idx]]
	"Famas", "Police M4", "P416", "AK-M", "BigHorn", "Chameleon", "S.Wolver.", "CTAR-21", "G36", "Manic", "Mechanical", "Shield Spl.", "BurnOut", "ACR", "FAL", "Eagle B." , "Test Subject"
	};
	
	const string SMG_NAME[] = { // SMG[weapon_name[profile_idx]]
	"MPX/Safety", "LadyDeath", "Vector.45", "Emeline", "Grudge", "AUG XS", "T821", "P90", "M1928", "MP5", "PP19" , "UMP 45"
	};
	
	const string LMG_NAME[] = { // LMG[weapon_name[profile_idx]]
	"BulletKing", "M60", "MG5", "Pestilence", "Carnage", "QuietRoar", "RPK74/NewRe", "NEGEV", "M249", "Stoner LAMG"
	};	
	
	const string RIFLE_NAME[] = { // RIFLE[weapon_name[profile_idx]]
	"DiamondBack", "M1A/Backer", "M1A CQB", "Harmony", "1886", "LW M4", "Art. Tool", "Mk17/E.Gaze", "Surge", "Merciless", "ACR SS", "USC 45", "SIG 716"
	};	
	
	const string SHOTGUN_NAME[] = { // SHOTGUN[weapon_name[profile_idx]]
	"SASG-12", "Super 90", "ACS-12", "SweetDream", "SPAS-12", "Scorpio"
	};	
	
	const string SNIPER_NAME[] = { // SNIPER[weapon_name[profile_idx]]
	"SVD", "M700", "M44", "Mantis"
	};	
		
	const string HANDGUN_NAME[] = { // HANDGUN[weapon_name[profile_idx]]
	 "M1911", "Dbl.Barrel", "Liberty", "M9", "PF45", "Magnum"           
	};	

	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// array column number - Buffer to add or substract edited value to corresponding value in the array
	int antirecoil_start[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the array to find your final value
	int antirecoil_end[3];
	int antirecoil_time[3];
	int antirecoil_horizontal[3];
	int rate_of_fire[3];
	int rumble_power[3];

// Used to define how many values there are per line - used in display_edit() function 
	int amount_of_val_in_array; // = 4 for A_RIFLE, SMG and LMG, 5 for RIFLE, SHOTGUN, SNIPER and HANDGUN (who have also Rate of Fire values)
	
// Adjustable value + array value = final value
	int final_antirecoil_start;
	int final_antirecoil_end;
	int final_antirecoil_time;
	int final_antirecoil_horizontal;
	int final_rate_of_fire;

// Used to define Profiles and also define # of profile to find, edit, and display the right index 
	int profile_idx; 
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Multi toggles
	int toggle_antirecoil[3];  // for 3 Profiles: profile_idx = 0, 1 and 2
	int toggle_rapidfire[3];  
	int toggle_burstfire[3];
	int toggle_aimassist[3];
	int toggle_strafeShot[3]; 
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 5;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mods (toggles and values) that activates for all profiles at the same time (if toggled ON)
// BurstFire
	int burstfire_hold; // BurstFire have toggle for each profiles BUT the same values for each
	int burstfire_release;
// AIM Assist
	int aimassist_radius; // AIM Assist have toggle for each profiles BUT the same values for each
	int aimassist_angle;
// Strafe Shot
	int strafeShot_time; // StrafeShot have toggle for each profiles BUT the same value for each
// DynaSens
	int dynasens_initial_sens;    // initial RX/RY sentitivity
	int dynasens_limit;           // stick input point where RX/RY sens increases
	int dynasens_restart;         // stick input point where RX/RY sens will reset back to initial value dynasens_initial_sens
	int dynasens_max_sens;        // maximum sensitivity value 
	int dynasens_increase_rate;   // rate sensitivity increased (8 = 80ms delay between increase)
// Reload Switch 
	int reload_time;              // amount of time before you cut reload animation and switch weapon
	
// Toggles
	int dynasens_on;
	int reload_on;
	int autorun_on;
	int medkit_on;
	int nade_on;
	int skill_on;
	int roll_on;
	int parkour_on;
	int swap_on;
	int rumble_on;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for functions 
	int i;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_info;
	int display_black;
	int screensaver;

// ModMenu / ModEdit / ModWeapon / KillSwitch
	int ModMenu;	
	int ModEdit;
	int ModWeapon; 
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil  
	int rumble;
	int rumble_recoil;
	int antirecoil_boost;
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter
	int count_black;  // for screen saver
	int info_timer;
	
// Profiles
	int switch_ref;
	int special_weapon; // Special weapon
 	
//Misc
	int button;
	int map_btn;
	int map;
	int currentSlot;
	int nade_wait;
	int BigHorn;
	int current_info;
	int TheDivision2; // check if logo is ON or OFF to refresh display
	int roll;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

init{
// Load default/stored values
	// Private toggles
	pmemValue = get_pvar(SPVAR_1, 1, 32767, 0);
	toggle_rapidfire[0]    = get_15var(pmemValue, 0);		toggle_rapidfire[1]  = get_15var(pmemValue, 1);		toggle_rapidfire[2]  = get_15var(pmemValue, 2);
	toggle_burstfire[0]    = get_15var(pmemValue, 3);		toggle_burstfire[1]  = get_15var(pmemValue, 4);		toggle_burstfire[2]  = get_15var(pmemValue, 5);
	toggle_strafeShot[0]   = get_15var(pmemValue, 6);		toggle_strafeShot[1] = get_15var(pmemValue, 7);		toggle_strafeShot[2] = get_15var(pmemValue, 8);

// Global toggles
	pmemValue = get_pvar(SPVAR_2, 1, 32767, 0);
	dynasens_on  = get_15var(pmemValue, 0);		reload_on = get_15var(pmemValue, 1);		autorun_on = get_15var(pmemValue, 2);
	medkit_on    = get_15var(pmemValue, 3);		nade_on   = get_15var(pmemValue, 4);		skill_on   = get_15var(pmemValue, 5);
	parkour_on   = get_15var(pmemValue, 6);		swap_on   = get_15var(pmemValue, 7);		rumble_on  = get_15var(pmemValue, 8);
	roll_on      = get_15var(pmemValue, 9);
	
// AntiRecoil Toggles (Private)
	pmemValue = get_pvar(SPVAR_3, -32768, 32767, 0);
	toggle_antirecoil[0] = get_4var(pmemValue, 3);		toggle_antirecoil[1] = get_4var(pmemValue, 2);		toggle_antirecoil[2] = get_4var(pmemValue, 1);

// AIM Assist Toggles (Private)
	pmemValue = get_pvar(SPVAR_4, -32768, 32767, 0);
	toggle_aimassist[0] = get_4var(pmemValue, 3);		toggle_aimassist[1] = get_4var(pmemValue, 2);		toggle_aimassist[2] = get_4var(pmemValue, 1);

// Weapon selection
	pmemValue = get_pvar(SPVAR_5, 0, 32767, 0);
	weapon_category[0] = get_2var(pmemValue, 0);		weapon_name[0] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_6, 0, 32767, 0);
	weapon_category[1] = get_2var(pmemValue, 0);		weapon_name[1] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_7, 0, 32767, 0);
	weapon_category[2] = get_2var(pmemValue, 0);		weapon_name[2] = get_2var(pmemValue, 1);
	
// Antirecoil vertical values
	pmemValue = get_pvar(SPVAR_8, -32768, 32767, 0);
	antirecoil_start[0] = get_2var(pmemValue, 0);		antirecoil_end[0] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_9, -32768, 32767, 0);
	antirecoil_start[1] = get_2var(pmemValue, 0);		antirecoil_end[1] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_10, -32768, 32767, 0);
	antirecoil_start[2] = get_2var(pmemValue, 0);		antirecoil_end[2] = get_2var(pmemValue, 1);
	
	antirecoil_time[0] = get_pvar(SPVAR_11, -32768, 32767, 0);
	antirecoil_time[1] = get_pvar(SPVAR_12, -32768, 32767, 0);
	antirecoil_time[2] = get_pvar(SPVAR_13, -32768, 32767, 0);
	
// Antirecoil horizontal & rumble recoil values
	pmemValue = get_pvar(SPVAR_14, -32768, 32767, 0);
	antirecoil_horizontal[0] = get_2var(pmemValue, 0);		rumble_power[0] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_15, -32768, 32767, 0);
	antirecoil_horizontal[1] = get_2var(pmemValue, 0);		rumble_power[1] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_16, -32768, 32767, 0);
	antirecoil_horizontal[2] = get_2var(pmemValue, 0);		rumble_power[2] = get_2var(pmemValue, 1);
	
// Rate of fire values
	rate_of_fire[0] = get_pvar(SPVAR_17, -32768, 32767, 0);
	rate_of_fire[1] = get_pvar(SPVAR_18, -32768, 32767, 0);
	rate_of_fire[2] = get_pvar(SPVAR_19, -32768, 32767, 0);
	
// BurstFire values
	burstfire_hold     = get_pvar(SPVAR_20, 1,  1000, 120);
	burstfire_release  = get_pvar(SPVAR_21, 1,  1000, 120);
	
// AIM Assist values
	pmemValue = get_pvar(SPVAR_22, 1, 32767, set_2var(20, 15));
	aimassist_radius = get_2var(pmemValue, 0);		aimassist_angle = get_2var(pmemValue, 1);
	
// StrafeShot value
	strafeShot_time = get_pvar(SPVAR_23, 1, 10000, 500);
	
// Dynasens values
	dynasens_initial_sens = get_pvar(SPVAR_24, 1, 327, 60 );
	
	pmemValue = get_pvar(SPVAR_25, 1, 32767, set_2var(80, 30));
	dynasens_limit   = get_2var(pmemValue, 0);		dynasens_restart = get_2var(pmemValue, 1);
	
	dynasens_max_sens      = get_pvar(SPVAR_26, 1, 327, 100);
	dynasens_increase_rate = get_pvar(SPVAR_27, 1, 50 , 1  );
	
// Reload value
	reload_time = get_pvar(SPVAR_28, 1, 10000, 800);
	
	
// Get current slot
	currentSlot = get_slot();

// Default configuration of profile 3
	weapon_category[2] = 6;  // HANDGUN array
	toggle_rapidfire[2] = 1; // RapidFire is ON
}

main { // main section start
/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                         DEBUG                                                         |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
/*
	set_val(TRACE_1, profile_idx);
	set_val(TRACE_2, dynasens_on);
	set_val(TRACE_3, reload_on);
	set_val(TRACE_4, autorun_on);
	set_val(TRACE_5, medkit_on);
	set_val(TRACE_6, final_rate_of_fire);
*/

	set_val(TRACE_1, aimassist_radius);
	set_val(TRACE_2, aimassist_angle);
	set_val(TRACE_3, dynasens_limit);
	set_val(TRACE_4, dynasens_restart);
	set_val(TRACE_5, modName_idx);
	set_val(TRACE_6, valName_idx);
/*		
	set_val(TRACE_1, toggle_antirecoil[profile_idx]);
	set_val(TRACE_1, toggle_rapidfire[profile_idx]);
	set_val(TRACE_1, toggle_burstfire[profile_idx]);
	set_val(TRACE_1, toggle_aimassist[profile_idx]);
	set_val(TRACE_1, toggle_strafeShot[profile_idx]);
	set_val(TRACE_1, dynasens_on);
	set_val(TRACE_1, reload_on);
	set_val(TRACE_1, autorun_on);
	set_val(TRACE_1, medkit_on);
	set_val(TRACE_1, nade_on);
	set_val(TRACE_1, skill_on);
	set_val(TRACE_1, roll_on);
	set_val(TRACE_1, parkour_on);
	set_val(TRACE_1, swap_on);
	set_val(TRACE_1, inverted_on);
	
	set_val(TRACE_2, weapon_category[profile_idx]);
	set_val(TRACE_3, weapon_name[profile_idx]);
	set_val(TRACE_4, final_antirecoil_start);
	set_val(TRACE_5, final_antirecoil_end);
	set_val(TRACE_6, final_antirecoil_time);
	
	set_val(TRACE_5, final_antirecoil_horizontal);
	set_val(TRACE_6, final_rate_of_fire);
*/

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                       CROSSOVER                                                       |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
    if(get_controller() != PIO_PS4) // If not PS4 controller:
    {
    	// If PS4 console:
        if(get_console() == PIO_PS4)
        { 
        	if(get_ival(PS4_SHARE))
        	{
        		if(get_ival(PS4_R3)) // RS + View =  ScreenShot
        		{
					set_val(PS4_SHARE,100);
                	set_val(PS4_TOUCH,0);
                	set_val(PS4_R3,0);
        			map_btn = PS4_TOUCH;
        		}
        		else // View only = PS4_TOUCH
        		{
        			set_val(PS4_TOUCH, 100);
        			set_val(PS4_SHARE, 0);
        			map_btn = PS4_SHARE;
        		}
        	}
        }
        else // if not PS4 console
            map_btn = PS4_SHARE;
	}
    else // If PS4 controller
        map_btn = PS4_TOUCH;

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                   TOGGLE KILLSWITCH                                                   |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
	if(!ModMenu && !ModEdit && !ModWeapon)
	{
	// KillSwitch ON or OFF method
		if( (get_ival(PS4_L2) && event_press(PS4_SHARE)) || (!get_ival(PS4_L2) && event_press(PS4_PS)) )
		{			
			KillSwitch = !KillSwitch;
			
			if(KillSwitch) 
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				
			else
			{
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_title = TRUE;	// display Title screen, profile, Weapon Name, active slot and killswitch
			}
		}

	// KillSwitch - activation method (TRUE, script is muted)
		if(!KillSwitch)
		{
			combo_stop(KILLSWITCH);
			
			if(!get_ival(PS4_L2) && !get_ival(PS4_L3) && event_press(PS4_OPTIONS))
			{
				KillSwitch = TRUE;
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			}
			if(!get_ival(PS4_L2) && event_release(map_btn) && get_ptime(map_btn) < 250) 
			{
				KillSwitch = TRUE;
				map = TRUE;
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			}
		}
		
	// KillSwitch - exit method (FALSE, script is actived)
		if(KillSwitch) 
		{
    		screensaver= FALSE;
			count_black = 0;
			TheDivision2 = FALSE;
    		
			if(map)
			{
			// Exit KillSwitch for fast travel while on the map
				if(get_ival(PS4_SQUARE) && get_ptime(PS4_SQUARE) > 1000) // Hold SQUARE/X 1000ms to exit
				{
					KillSwitch = FALSE;
					map = FALSE;
					combo_run(RUMBLE_ON);
					display_title = TRUE; // display Title screen, profile, Weapon Name, active slot and killswitch
				}
			
				if(event_press(PS4_OPTIONS))
					map = FALSE;
			}
			
			else // if NOT map
			{
				if(event_release(map_btn))
					map = FALSE;
			}
		
			if(get_ival(PS4_CIRCLE) && get_ptime(PS4_CIRCLE) > 600) // Hold CIRCLE/B 600ms to exit
			{
				KillSwitch = FALSE;
				map = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE; // display Title screen, profile, Weapon Name, active slot and killswitch
			}
	
			if(event_press(PS4_CIRCLE) && get_brtime(PS4_CIRCLE) < 200) // Double tap CIRCLE/B to exit
			{
				KillSwitch = FALSE;
				map = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE; // display Title screen, profile, Weapon Name, active slot and killswitch
				
			}
			combo_run(KILLSWITCH);
		}
	// Block button	
		if(get_ival(PS4_L2))
		{
			if(get_controller() != PIO_PS4) 
				set_val(PS4_TOUCH, 0);
			else
				set_val(PS4_SHARE, 0);
		}
	}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                        IF KILLSWITCH IS OFF (SCRIPT IS ACTIVE)                                        |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(!KillSwitch)
	{
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                     TOGGLE MOD MENU                                   |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(get_ival(PS4_L2))
		{	
			if(event_release(PS4_OPTIONS))
			{
				cls_oled(OLED_BLACK);
    			TheDivision2 = FALSE;
				
				if(ModWeapon)
				{
					ModWeapon = FALSE;
					display_title = TRUE;   // display Title screen, profile, Weapon Name, active slot and killswitch
				}
				else if(ModEdit)
				{
					ModEdit = FALSE;
					display_title = TRUE;   // display Title screen, profile, Weapon Name, active slot and killswitch
				}
				else 
					ModMenu = !ModMenu;
				
				if(!ModMenu)
				{
					combo_run(RUMBLE_OFF);  // rumble and LED blink
					display_title = TRUE;   // display Title screen, profile, Weapon Name, active slot and killswitch
				}
				if(ModMenu)
				{
					modName_idx = 0;        // start to the first mod
					current_info = 0;		// restart user info cycle
					combo_run(RUMBLE_ON);	// rumble and LED blink
					draw_base_menu();		// draw Menu contour and the rectangle (first line only) where arrows or TRIANGLE/Y are displayed 
					draw_modMenu();			// clears lines 2 and 3, and draw the rectangle (line 2 and 3 only) where arrows are displayed 
					draw_chars_line1();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					draw_chars_line2(); 	// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					draw_chars_line3();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					display_new = TRUE;
					display_info = TRUE;
				}
			}
		// Block button	   
			set_val(PS4_OPTIONS, 0);
		} // L2/LT section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                   MOD MENU IS ACTIVE                                  |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(ModMenu) // Switch ModEdit and ModWeapon, switch modName, toggle
		{
		// Buttons animation
			button_animation(); // define if the rectangle behind the arrow must be clear or fill, and define if the arrow must be black or white
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                           TOGGLE FOR MODS                             |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		// From ModMenu to ModEdit
			if(check_toggle()) 	 
			{// if ANTIRECOIL (so modName_idx = 0) or AIMASSIST or RAPIDFIRE or BURSTFIRE or StrafeShot or Dynasens or Reload is diplayed
			
				if(event_release(PS4_CROSS))
				{
					valName_idx = entry_count(VALNAME_TXT) + 1; // always display first val names available when enter in edition mod
					current_info = 0;		// restart user info cycle
					ModEdit = TRUE;
					ModMenu = FALSE;
					draw_modEdit();			// clears lines 2 and 3, and draw the rectangle (line 2 and 3 only) where arrows, +, -, CROSS and A are displayed
					draw_chars_line1();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					draw_chars_line2();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					draw_hold_to_edit();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the +, -, CROSS, A (fill or empty)
					draw_chars_line3();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					display_new = TRUE;
					display_info = TRUE;
				}
			}
		// From ModMenu to ModWeapon	
			if(event_press(PS4_SQUARE))
			{
				current_info = 0;		// restart user info cycle
				ModWeapon = TRUE;
				ModMenu = FALSE;
				draw_chars_line1();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
				draw_chars_line2();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
				draw_chars_line3();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
				display_new = TRUE;
				display_info = TRUE;
			}
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                  MOD NAME NAVIGATION                  |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx = cycle(modName_idx + 1, 0, entry_count(MODNAME_TXT)); // create a loop in the values
				
			//Skip RapidFire or BurstFire	
				if(weapon_category[profile_idx] >= AMOUNT_OF_FULLAUTO_CAT && modName_idx == 2) // if weapon array have RoF value and BurstFire is to be displayed
					modName_idx = 3;                                                             // skip BurstFire and display next mod name
					
				if(weapon_category[profile_idx] < AMOUNT_OF_FULLAUTO_CAT && modName_idx == 1)  // if weapon array don't have RoF value and RapidFire is to be displayed
					modName_idx = 2;                                                             // skip RapidFire and display next mod name
				
				display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
			}
			
			if(event_press(PS4_LEFT))
			{
				modName_idx = cycle(modName_idx - 1, 0, entry_count(MODNAME_TXT));  // create a loop in the values
					
			//Skip RapidFire or BurstFire
				if(weapon_category[profile_idx] >= AMOUNT_OF_FULLAUTO_CAT && modName_idx == 2) // if weapon array have RoF value and BurstFire is to be displayed
					modName_idx = 1;                                                             // skip BurstFire and display previous mod name
					
				if(weapon_category[profile_idx] < AMOUNT_OF_FULLAUTO_CAT && modName_idx == 1)  // if weapon array don't have RoF value and RapidFire is to be displayed
					modName_idx = 0;                                                             // skip RapidFire and display previous mod name
					
				display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
			}
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                    TOGGLE FOR MODS                    |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Tap UP to turn ON, DOWN to turn OFF
	   		// Mods that may have different ON/OFF status depending on the active Profile
	   		
		//toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			toggle_antirecoil[profile_idx] = toggle( 0, toggle_antirecoil[profile_idx]);
			toggle_rapidfire[profile_idx]  = toggle( 1, toggle_rapidfire[profile_idx] );
			toggle_burstfire[profile_idx]  = toggle( 2, toggle_burstfire[profile_idx] );
			toggle_aimassist[profile_idx]  = toggle( 3, toggle_aimassist[profile_idx] );
			toggle_strafeShot[profile_idx] = toggle( 4, toggle_strafeShot[profile_idx]);
		
		// Mods that have same ON/OFF status on every Profiles
			dynasens_on = toggle( 5 , dynasens_on );
			reload_on   = toggle( 6 , reload_on   );
			autorun_on  = toggle( 7 , autorun_on  );
			medkit_on   = toggle( 8 , medkit_on   );
			nade_on     = toggle( 9 , nade_on     );
			skill_on    = toggle( 10, skill_on    );
			roll_on     = toggle( 11, roll_on     );
			parkour_on  = toggle( 12, parkour_on  );
			swap_on     = toggle( 13, swap_on     );
			rumble_on   = toggle( 14, rumble_on   );
		} // ModMenu section end
	
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                   MOD EDIT IS ACTIVE                                  |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/	
		if(ModEdit) // Edit values, switch values name, switch ModMenu
		{
		// Buttons animation
			button_animation(); // define if the rectangle behind the arrow must be clear or fill, and define if the arrow must be black or white
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                EDIT ADJUSTABLE VALUES                 |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Edit value: hold CROSS/A + UP (+1 or +10) or DOWN (-1 or -10) or RIGHT (+10 or +100) or LEFT (-10 or -100)	
			if(get_ival(PS4_CROSS)) 
			{
			// Mods that may have different values depending on the active Profile
			
	   		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], range min(positive val only) , range max, increase/decrease by X with RIGHT/LEFT, increase/decrease by X with UP/DOWN); 	
				antirecoil_start[profile_idx]      = edit_val( 0 , antirecoil_start[profile_idx]     , 99 ,    99 ,   1 , 10   ); 
				antirecoil_end[profile_idx]        = edit_val( 1 , antirecoil_end[profile_idx]       , 99 ,    99 ,   1 , 10   ); 
				antirecoil_time[profile_idx]       = edit_val( 2 , antirecoil_time[profile_idx]      , 0  , 10000 , 100 , 1000 );  
				antirecoil_horizontal[profile_idx] = edit_val( 3 , antirecoil_horizontal[profile_idx], 99 ,    99 ,   1 , 10   );
				rate_of_fire[profile_idx]          = edit_val( 4 , rate_of_fire[profile_idx]         , 0  ,   750 ,   1 , 10   ); 
				rumble_power[profile_idx]          = edit_val(16 , rumble_power[profile_idx]         , 60 ,    60 ,   1 , 10   ); 
				
			// Mods that have same value on every Profiles
				burstfire_hold         = edit_val( 5 , burstfire_hold         , 0 ,  1000 , 10 , 100 );
				burstfire_release      = edit_val( 6 , burstfire_release      , 0 ,  1000 , 10 , 100 );
				aimassist_radius       = edit_val( 7 , aimassist_radius       , 0 ,    50 , 1  , 10  );
				aimassist_angle        = edit_val( 8 , aimassist_angle        , 0 ,    50 , 1  , 10  ); 
				strafeShot_time        = edit_val( 9 , strafeShot_time        , 0 , 10000 , 10 , 100 );
				dynasens_initial_sens  = edit_val( 10, dynasens_initial_sens  , 0 ,   327 , 1  , 10  );
				dynasens_limit         = edit_val( 11, dynasens_limit         , 0 ,   100 , 1  , 10  );
				dynasens_restart       = edit_val( 12, dynasens_restart       , 0 ,   100 , 1  , 10  );
				dynasens_max_sens      = edit_val( 13, dynasens_max_sens      , 0 ,   327 , 1  , 10  );
				dynasens_increase_rate = edit_val( 14, dynasens_increase_rate , 1 ,    50 , 1  , 10  );
				reload_time            = edit_val( 15, reload_time            , 0 , 10000 , 10 , 100 );
			} // CROSS/A section end
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|  FIND AVAILABLE VALUES AND NAVIGATION BETWEEN VALUES  |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
			else // if NOT EDIT_BTN
			{	
			// From ModEdit to ModMenu	
				if(event_press(PS4_CIRCLE))
				{
					current_info = 0;		// restart user info cycle
					ModMenu = TRUE;
					ModEdit = FALSE;
					draw_modMenu();			// clears lines 2 and 3, and draw the rectangle (line 2 and 3 only) where arrows are displayed
					draw_chars_line1();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					draw_chars_line2();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					draw_chars_line3();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
					display_new = TRUE;
					display_info = TRUE;
				}
				
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
						valName_idx += 1;
					// Limits for Standard Anti-Recoil	
						if(modName_idx == 0 && toggle_antirecoil[profile_idx] == 2)
						{								
							if(valName_idx == 2)
								valName_idx = 3;
							if(valName_idx > 3)
								valName_idx = 1;
						}
					// Limits for Standard Anti-Recoil	
						if(modName_idx == 0 && toggle_antirecoil[profile_idx] == 3)
						{								
							if(valName_idx == 4)
								valName_idx = 16;
							if(valName_idx > 16)
								valName_idx = 3;
						}
					
					display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
				}
				if(event_press(PS4_LEFT))
				{
						valName_idx -= 1;
					// Limits for Standard Anti-Recoil 
						if(modName_idx == 0 && toggle_antirecoil[profile_idx] == 2)
						{	
							if(valName_idx == 2)
								valName_idx = 1;
							if(valName_idx < 1)
								valName_idx = 3;
						}
					// Limits for Rumble Anti-Recoil 
						if(modName_idx == 0 && toggle_antirecoil[profile_idx] == 3)
						{	
							if(valName_idx == 15)
								valName_idx = 3;
							if(valName_idx < 3)
								valName_idx = 16;
						}
					
					display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
				}
					
			// Available values for each of the mods (exemple: Anti-Recoil progressive (modName_idx = 0) have 4 values per profile: valName_idx = 0 for antirecoil_start[<active profile>], = 1 for antirecoil_end[], = 2 for antirecoil_time[], = 3 for antirecoil_horizontal[]  
				 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 and 3>
				if(modName_idx == 0) 
				{
					if(toggle_antirecoil[profile_idx] == 3)
						valName_idx = cycle(valName_idx, 3, 16 );// Rumble AR
					else if(toggle_antirecoil[profile_idx] == 2)
						valName_idx = cycle(valName_idx, 1 , 3  );// AntiRecoil Standard
					else
						valName_idx = cycle(valName_idx, 0 , 3  );// AntiRecoil Progressive
				}
				if(modName_idx == 1) valName_idx = cycle(valName_idx, 4 , 4  );// RapidFire
				if(modName_idx == 2) valName_idx = cycle(valName_idx, 5 , 6  );// If BurstFire
				if(modName_idx == 3) valName_idx = cycle(valName_idx, 7 , 8  );// AIM Assist
				if(modName_idx == 4) valName_idx = cycle(valName_idx, 9 , 9  );// StrafeShot
				if(modName_idx == 5) valName_idx = cycle(valName_idx, 10, 14 );// DynaSens
				if(modName_idx == 6) valName_idx = cycle(valName_idx, 15, 15 );// Reload Switch

			} // NOT EDIT_BTN section end
		
		} // ModEdit section end	
		
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                  MOD WEAPON IS ACTIVE                                 |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/	
		if(ModWeapon) //  Switch ModMenu, select weapon name and weapon category
		{
		// Buttons animation
			button_animation(); // define if the rectangle behind the arrow must be clear or fill, and define if the arrow must be black or white
			
		// From ModWeapon to ModMenu
			if(event_press(PS4_CIRCLE))
			{
				current_info = 0;		// restart user info cycle
				ModMenu = TRUE;
				ModWeapon = FALSE;
				modName_idx = 0;        // start to the first adjustable value (vals_available function do the correction to find the right idx)
				draw_chars_line1();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
				draw_chars_line2();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
				draw_chars_line3();		// define the buttons to be displayed, clears or fill the rectangle behind the button and draw the arrows (fill or empty)
				display_new = TRUE;
				display_info = TRUE;
			}
		// Weapon Category and Weapon Name navigation
			if(weapon_selection())
			{
				weapon_limit();
				display_new = TRUE;
			}
				
		// Reset Temp value
			if(get_ival(PS4_CROSS) && get_ptime(PS4_CROSS) == 500)
			{
				antirecoil_start[profile_idx] = 0;
				antirecoil_end[profile_idx] = 0;
				antirecoil_time[profile_idx] = 0;
				antirecoil_horizontal[profile_idx] = 0;
				rate_of_fire[profile_idx] = 0;
				combo_run(RUMBLE_ON);
			}
		} // ModWeapon section end	
		
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                            MOD MENU OR MOD WEAPON IS ACTIVE                           |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(ModMenu ||  ModWeapon || ModEdit) // Stop screen saver, save, block btn, switch profile
		{
		//Stop screen Saver
    		screensaver = FALSE;
			count_black = 0;
			
		// Timer to display user infos
			info_timer += get_rtime();
	
			if(info_timer > 2000)
			{
				current_info ++;
				display_info = TRUE;
			}
			
		// Save everything and EXIT
			if(!get_val(PS4_L2) && event_release(PS4_PS))
				save();
				
		// block ALL inputs (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire on a wall without leaving ModEdit)	
			block_btn(); // user function
			
		// Switch Profiles (not in ModEdit)
			if(event_release(PS4_TRIANGLE) && !ModEdit)
			{	
				profile_idx = cycle(profile_idx + 1, 0, 2);
				
			// Refresh display for RapidFire or BurstFire
				if((weapon_category[profile_idx] >= AMOUNT_OF_FULLAUTO_CAT) && modName_idx == 2) // if weapon array have RoF value and BurstFire is to be displayed
					modName_idx = 1;                                                               // skip BurstFire and display RapidFire
					
				if((weapon_category[profile_idx] < AMOUNT_OF_FULLAUTO_CAT) && modName_idx == 1)  // if weapon array don't have RoF value and RapidFire is to be displayed
					modName_idx = 2;                                                               // skip RapidFire and display BurstFire
					
				display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
			}
		}

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                      FIND FINAL ANTIRECOIL AND RAPIDFIRE VALUES                       |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
	// Defines the amount of value that the active (profile_idx) Weapon Category array has
		if(weapon_category[profile_idx] < AMOUNT_OF_FULLAUTO_CAT)
			amount_of_val_in_array = 4;
		else
			amount_of_val_in_array = 5;
			
	// Find final values in relation to Weapon Category and Weapon Name arrays		
		final_antirecoil_start       = get_weapon_values(0) + antirecoil_start[profile_idx];
		final_antirecoil_end         = get_weapon_values(1) + antirecoil_end[profile_idx];
		final_antirecoil_time        = get_weapon_values(2) + antirecoil_time[profile_idx];
		final_antirecoil_horizontal  = get_weapon_values(3) + antirecoil_horizontal[profile_idx];
          
		if(weapon_category[profile_idx] > 2)
			final_rate_of_fire = get_weapon_values(4) + rate_of_fire[profile_idx];
			
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                             FEATURES ACTIVE IN GAME ONLY                              |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(!ModMenu && !ModWeapon && !ModEdit)
		{
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                               FEATURES                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		// Swap triggers and bumpers 
			if(swap_on) 
			{
				swap(PS4_R1, PS4_R2);
				swap(PS4_L1, PS4_L2);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
		
		// Elite Controller PR1 remap
			if(get_ival(XB1_PR1) && get_ptime(XB1_PR1) < 250) 
				set_val(PS4_CROSS, 100);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
		
		// Hair Trigger
	   	 	deadzone(PS4_L2,PS4_R2,99,99);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	
		// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold L3/LS + tap TRIANGLE/Y for sync color
			if(!get_val(PS4_DOWN) && event_press(PS4_TRIANGLE) || get_val(PS4_L3) && event_press(PS4_TRIANGLE))
			{
				if(get_brtime(PS4_TRIANGLE) < 300) 
					profile_idx = 2;
				else
				{
				    if(switch_ref != 2) 
						switch_ref = !switch_ref;  
				                	
					profile_idx = switch_ref;
		        	special_weapon = FALSE;
				}	
				
				display_title = TRUE; // display Title screen, profile, Weapon Name, active slot and killswitch
		   	}
		    	
			if(get_lval(PS4_L3))
				set_val(PS4_TRIANGLE, 0);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		/* Switch Special Weapon (Anti-Recoil, RapidFire, BurstFire disabled)
		   hold TRIANGLE/Y (Led color turn OLED_WHITE)*/
		    if(!special_weapon && get_val(PS4_TRIANGLE) && get_ptime(PS4_TRIANGLE) > 500)
		    {
		        special_weapon = TRUE;
		        display_title = TRUE; // display Title screen, profile, Weapon Name, active slot and killswitch
		    }
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Dynamic Sensitivity
	    	if(dynasens_on)
	    	{	
	    		if((get_val(PS4_L2) || get_val(PS4_R2) || get_val(PS4_R1) || get_val(PS4_L1) || get_ival(XB1_PR1)) && isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 20)
	    			set_sens();
	    	}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		/* AutoRun 
		   push the left stick 90% forward or to the sides to run - hold to sprint must be enable */
			if(autorun_on)
			{
				if((isqrt(pow(abs(get_ival(PS4_LX)),2) + pow(abs(get_ival(PS4_LY)),2)) >= 90) && get_ival(PS4_LY) < 20 && !get_val(PS4_L2) && !get_val(PS4_R2))
					set_val(PS4_L3, 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

	    /* Easy MedKit
	       double tap Dpad RIGHT to change armor plate, move Left stick to cancel */
			if(medkit_on) 
			{
	    		if(!get_val(PS4_R3) && !get_val(PS4_L2) && event_press(PS4_RIGHT) && get_brtime(PS4_RIGHT) < 200) 
	    		{
	           		button = PS4_RIGHT;
	            	combo_run(maxcmb1);
	    		}
			/* Easy MedKit Cancel */    
				if(button == PS4_RIGHT && (abs(get_val(PS4_LX)) > 90 || abs(get_val(PS4_LY)) > 90))
					combo_stop(HOLD);
	        }
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
	    /*Quick GRENADE
		  double tap D Pad LEFT to throw a grenade */
			if(nade_on) 
			{
				if(!get_val(PS4_R3) && event_press(PS4_LEFT) && get_brtime(PS4_LEFT) < 200)
				{
					nade_wait = 1000;
					combo_run(GRENADE);
				}
					
			/* Elite Controller - hold PL1 (as long as you want) to take a nade and throw the nade when you release PL1 
								- tap PL1 more than 150ms to take and throw your nade */
							
				if(get_ival(XB1_PL1) && get_ptime(XB1_PL1) >= 150)
					set_val(PS4_LEFT, 100);
						
				if(event_release(XB1_PL1) && get_ptime(XB1_PL1) > 150)
				{
					nade_wait = 1150 - get_ptime(XB1_PL1);
					combo_run(GRENADE);
				}
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		/* Skill Destroy
	       hold any skill button and tap CROSS/A to destroy the corresponding skill
	       tap any skill button to cancel */
			if(skill_on) 
			{
				SkillDestroy (PS4_R1, PS4_R2);
				SkillDestroy (PS4_L1, PS4_L2);
	    	}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Easy Roll
			if(roll_on) 
			{
			//PS4 Controller tap Cross to roll
				if(get_controller() == PIO_PS4)
				{
					if(event_release(PS4_CROSS) && get_ptime(PS4_CROSS) < 200)
						roll = 150;
				}
			// Elite Controller tap PR1 to roll
				else if(!get_ival(PS4_L2) && event_release(XB1_PR1))
					roll = 150;
			}
		// Roll / Exit cover counter
			if(roll)
			{
				roll -= get_rtime();
				if(roll <= 50)
					set_val(PS4_CROSS, 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Parkour 
			if(parkour_on)
			{
				if(!get_val(PS4_L2) && get_val(PS4_LY) < -70)  // Press sensitive
					set_val(PS4_CIRCLE, 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

		// In game rumbles block
			if(!rumble_on)
				block_rumble();
					
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|              FEATURES THAT NOT ACTIVE WITH SPECIAL WEAPON             |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
			if(!special_weapon)
			{
			// Speed Weapon Swap
				speed_weapon_swap();
	
			// Speed Toggles
			  //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2, hold time, toggle_I_want_to_edit([profile]) , corresponding modName_idx );
				toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT, 500 , toggle_aimassist[profile_idx] , 3 );
				toggle_strafeShot[profile_idx] = speed_toggle( PS4_L2, PS4_LEFT , 500 , toggle_strafeShot[profile_idx], 4 );
				dynasens_on                    = speed_toggle( PS4_L2, PS4_DOWN , 500 , dynasens_on                   , 5 );
				
			  // Bolck RapidFire or BurstFire Speed Toggle
				if(weapon_category[profile_idx] >= AMOUNT_OF_FULLAUTO_CAT) 
					toggle_rapidfire[profile_idx]  = speed_toggle( PS4_L2, PS4_UP   , 500 , toggle_rapidfire[profile_idx] , 1 );
				else
					toggle_burstfire[profile_idx]  = speed_toggle( PS4_L2, PS4_UP , 500 , toggle_burstfire[profile_idx] , 2 );
					
	
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// If Strafe Shot is enable for the curent profile
				if(toggle_strafeShot[profile_idx] == 1)
				{
				// Run combo
					if(get_val(PS4_R2))
						combo_run(STRAFESHOT);
					else
						combo_stop(STRAFESHOT);
				}
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
			// If Reload is enable for the curent profile
			    if(reload_on && (event_press(PS4_SQUARE) && get_brtime(PS4_SQUARE) < 300)) 
			    {
			        combo_run(RELOAD);
			        profile_idx=!profile_idx;
			    }
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// BigHorn auto RapidFire when scoping
				if(weapon_category[profile_idx] == 0 && weapon_name[profile_idx] == 4)
				{
					if(get_val(PS4_L2) && event_release(PS4_R3))
					{
						BigHorn = !BigHorn;
					// Enable RapidFire
						toggle_rapidfire[profile_idx] = !toggle_rapidfire[profile_idx];
					}
						
					if(BigHorn)
					{
					// Define Rate of Fire
						final_rate_of_fire = 600;
						
						if(event_release(PS4_L2))
						{
							BigHorn = FALSE;
						// Disable RapidFire
							toggle_rapidfire[profile_idx] = 0;
						}
						
					}
				}
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                          SCREEN SAVER BY DoGz                         |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
			    if(display_black)
			    {
			    	count_black += get_rtime();
			    	if(count_black >= 5000)
			    	{
			    		cls_oled(0);
			    		count_black = 0;
			    		screensaver = TRUE;
			    		TheDivision2 = FALSE;
			    		display_black = FALSE;
			    	}
			    }
			    
			    if(screensaver)
			    {
			    	DGT += get_rtime();
					if(DGT >= 100) 
					{
						SD1 += 2;	TP1 += 1;
						TP2 -= 1;	DGT  = 0;
					}
					DGR += get_rtime();
					
					if(DGR >= 30) 
					{
						Y_1 += 1;	Y_2 += 2;	Y_3 += 3;	Y_4 += 4;
						Y_5 += 5;	Y_6 += 6;	Y_7 += 7;	Y_8 += 8;
						DGR  = 0;
					}
					
					name();
					MSC += get_rtime();
					
					if(MSC >= 1000) 
					{
						MSC = 0;
						RT += 1;
					}
					
					if(RT == 30) 
					{
						screensaver = 0;
						RT = 0;
						cls_oled(0);
					}
			    }
			} // NOT Secial Weapon section end
			
		} // NOT ModMenu and NOT ModEdit and NOT ModWeapon section end
		
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                         FEATURES ACTIVE IN GAME AND IN MOD EDIT                       |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(!special_weapon && !ModWeapon && !ModMenu)
		{
		// If AIM Assist is enable for the curent profile
			if(toggle_aimassist[profile_idx])
			{
				if(toggle_aimassist[profile_idx] == 1) // Batts Sticky
				{	
					if(get_val(PS4_L2) || get_val(PS4_R2))
					    combo_run(STICKY);
				}
				else // Polar Shapes
				{
					if(toggle_antirecoil[profile_idx] && get_val(PS4_R2))
					{
						RX = SmartSens(final_antirecoil_horizontal, PS4_RX);
						RY = SmartSens(ar_y, PS4_RY);
					}
					else
					{
						RX = get_val(PS4_RX);
						RY = get_val(PS4_RY);
					}
					
					actual_Magnitude = isqrt(pow(RX, 2) + pow(RY, 2));	
					max_Magnitude = (actual_Magnitude < 100);
				
					if(!(time++ % 1))
						angle += aimassist_angle;
						
					angle = angle % 360;
					sin_angle = Polar_Array[angle % 360];
					cos_angle = Polar_Array[(angle + 270) % 360];
					
				  
				  	if(get_val(PS4_R2) || get_val(PS4_L2))
				  	{
				    	if(actual_Magnitude <= aimassist_radius) 
				    	{
							sin_angle -= RY;
				      		cos_angle -= RX;
				    	}
					    else 
					    {
							sin_angle = (sin_angle * (200 - ((abs(RY) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
							cos_angle = (cos_angle * (200 - ((abs(RX) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
					    }
					    
					    GetShapesV1(aimassist_radius);
					    
					    if((!get_val(PS4_R2) && toggle_antirecoil[profile_idx]) || !toggle_antirecoil[profile_idx])
					    {
							set_val(PS4_RX, clamp(get_val(PS4_RX) + cos_angle, -100, 100));
							set_val(PS4_RY, clamp(get_val(PS4_RY) + sin_angle, -100, 100));
				  		}
					}
				}
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
		// AntiRecoil
			if(toggle_antirecoil[profile_idx])
			{
			// Antirecoil Standard final value
				if(toggle_antirecoil[profile_idx] == 2)
					final_antirecoil_start = final_antirecoil_end;
					
			// Progressive AntiRecoil vertical		
	    		if(final_antirecoil_start < final_antirecoil_end)
	    	   		i_val = 1; 
	    		else
	    	    	i_val = -1;
	    		i_pnt = (final_antirecoil_time / 10) / (abs(final_antirecoil_start - final_antirecoil_end)); 
	    		
	    	// Reset
	    		if(!get_val(PS4_R2)) 
	    		{
					ar_y = final_antirecoil_start;
	    	    	i_cnt = 0;
	    	    	i_num = 0;
	    	    	rumble = 0;
	    	    	rumble_recoil = 0;
	    	    	antirecoil_boost = 0;
	    		}     
	    					
	    		if(get_val(PS4_R2))
				{
				// Rumble AntiRecoil Boost
					antirecoil_boost += random(1, 5);
					if(antirecoil_boost > 10)
						antirecoil_boost = 0;
						
				// SmartStop
					if(get_ptime(PS4_R2) < 500 || get_rumble(RUMBLE_A))
						rumble = 1;
					else if(get_rumble(RUMBLE_A) == 0)
						rumble = 0;
						
				// Progression Calculation
			        if(!p_complete())  
						ar_y = p_val();
			        else
			            ar_y = final_antirecoil_end;
			 
				// Run Rumble Antirecoil
					if(toggle_antirecoil[profile_idx] == 3) 
					{	
						rumble_recoil = max(get_rumble(RUMBLE_A),get_rumble(RUMBLE_B));
					                 				
						if(rumble_recoil > 10 && rumble_recoil < 90) 
						{
							if(!toggle_aimassist[profile_idx])
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY), -100, 100));
								set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX), -100, 100));
							}
							else if(toggle_aimassist[profile_idx] == 1)
							{
								recoilAssist = rumble_recoil + rumble_power[profile_idx] + antirecoil_boost;
								combo_run(STICKY);
							}
							else
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY) + sin_angle, -100, 100));
								set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX) + cos_angle, -100, 100));
							}
						}
						else if(rumble_recoil < 10)
						{
							ar_y = final_antirecoil_end;
							antirecoil();
						}
					}
				// Run Progressive or Standard AntiRecoil
					else
					{	
				    // If BurstFire
				    	if(toggle_burstfire[profile_idx] == 1 && get_ptime(PS4_R2) <= hold_time)
				    	{
				    		antirecoil();
				    	}
				    // Full auto and RapidFire with smart stop
				        if((toggle_burstfire[profile_idx] == 0  || toggle_rapidfire[profile_idx] == 1))
				        {
					        if(rumble)
					        {
								antirecoil();
					    	}
				    	}
				    }
		    	}
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
		// RapidFire
			if(toggle_rapidfire[profile_idx] == 1)
			{
			// Rate of Fire Calculation
	    		rest_time = 5000 / ((final_rate_of_fire * 10) / 60); 
	   			hold_time = rest_time;
	    		if(rest_time < 0) rest_time = 0;
	    
	    	// Run combo
	    		if(get_val(PS4_R2))
	    			combo_run(RAPIDFIRE);
	    		else
	    			combo_stop(RAPIDFIRE);
	    		
	    		led_on = 150;
	    		led_off = 300;
	    		combo_run(BLINK);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		//BurstFire
			if(toggle_burstfire[profile_idx] == 1) 
			{
	    	// Hold and Release
				hold_time = burstfire_hold;
				rest_time = burstfire_release;
				
	    	// Run combo
	    		if(get_val(PS4_R2))	
	    			combo_run(BURSTFIRE);
	    		
				if(event_release(PS4_R2))
	    			combo_stop(BURSTFIRE);
	
	    		led_on = 200;
	    		led_off = 1000;
	    		combo_run(BLINK);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
		}// NOT Special weapon and NOT ModWeapon section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|            DISPLAY TEXT AND VALUES IN MOD MENU, MOD EDIT AND MOD WEAPON               |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(display_new) 
		{
			screensaver = FALSE;
			count_black = 0;
			
			if(ModEdit) // Display editable value 
			{
				display_edit_line1();
			// Clears value zone
				rect_oled(38, 18, 51 , OLED_FONT_SMALL_HEIGHT + 3 , OLED_WHITE , OLED_BLACK); // small rectangle left (line 2 value)
				rect_oled(27, 31, 74 , OLED_FONT_SMALL_HEIGHT + 6 , OLED_WHITE , OLED_BLACK); // small rectangle left (line 3 value)
			
			// Display editable value
				display_values();
				
				if(valName_idx < amount_of_val_in_array) // Display a Star for Private values
				{
					putc_oled(1, 42); // +
					puts_oled(center_x(1, OLED_FONT_SMALL_WIDTH), LINE_2_Y, OLED_FONT_SMALL, 1, OLED_WHITE); 
				}
			}
			else if(ModMenu || ModWeapon) // Display Profile, mod name/weapon category, toggle/weapon name
			{
				display_edit_line1();
				display_edit_line2();
				display_edit_line3();
			}
			else // Speed Toggle Display
			{
				cls_oled(OLED_BLACK);
			// Display mod name
				printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));
			// Display toggle
				display_edit_line3();
				count_black = 2000;
			}
			
			display_black = TRUE;
	        display_new = FALSE;
	       
	    } // display_new section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|               DISPLAY USER INFOS IN MOD MENU, MOD EDIT AND MOD WEAPON                 |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
	
		if(display_info) // display navigation infos
		{
			info_timer = 0;
			rect_oled(1, 50, 126, 13, OLED_WHITE, OLED_BLACK); // bottom rectangle (clear)
			if(ModMenu)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_MENU_TXT));
				printf(center_x(get_string_length(get_string(INFO_MENU_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_MENU_TXT, current_info));
			}
			if(ModEdit)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_EDIT_TXT));
				printf(center_x(get_string_length(get_string(INFO_EDIT_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_EDIT_TXT, current_info));
			}
			if(ModWeapon)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_WEAPON_TXT));
				printf(center_x(get_string_length(get_string(INFO_WEAPON_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_WEAPON_TXT, current_info));
			}
			display_info = FALSE;
		}
		    
	} // !KillSwitch section end

// back to main section

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                           DISPLAY TITLE - KILLSWITCH - PROFILE - WEAPON NAME - # SLOT                                 |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
// Display Script Title    
    if(display_title)
    {
    	screensaver= FALSE;
    	count_black = 0;        // reset screen saver timer
    	
    // Display Division(2) logo
    	if(!TheDivision2)
    	{
    		cls_oled(0);	        // clear OLED screen
   			draw_logo(0,0,0);		// draw game logo
   		}
   		else
   			rect_oled(0, 33, 128, 31, OLED_WHITE, OLED_BLACK); // clear profile, weapon and #slot
   			
   	// Display current slot
   		number_to_string(currentSlot, find_digits(currentSlot)); 
    	    		
   		if(special_weapon)
   			printf(center_x(sizeof(SPECIAL) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,SPECIAL[0]);
   		else 
   		{
   		// Display profile name
			display_profile();
		// Display active Weapon Name	
    		printf(center_x(get_string_length(get_string(WEAPON_NAME_TXT, weapon_name[profile_idx])), OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,get_string(WEAPON_NAME_TXT, weapon_name[profile_idx]));
		}
		
		TheDivision2 = TRUE;
   		display_black = TRUE;	// screen saver
    	display_title = FALSE;
    }

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                      COLOR LED                                                        |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	if(KillSwitch)
		led(7);
	else if(special_weapon)
		led(4);
	else
		led(profile_idx);
		
} // main section end
/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                  MAIN SECTION END                                                     |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                   COMBO SECTION                                                       |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
combo RACE {
	X_1 = random(0,127);
	wait(SAVER1);
	X_2 = random(0,127);
	wait(SAVER1);
	X_3 = random(0,127);
	wait(SAVER1);
	X_4 = random(0,127);
	wait(SAVER1); 
	X_5 = random(0,127);
	wait(SAVER1);
	X_6 = random(0,127);
	wait(SAVER1); 
	X_7 = random(0,127);
	wait(SAVER1); 
	X_8 = random(0,127);
	wait(SAVER1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
	}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
combo KILLSWITCH {
	cls_oled(OLED_BLACK);
    printf(center_x(sizeof(MUTE) - 1, OLED_FONT_MEDIUM_WIDTH),8,OLED_FONT_MEDIUM,OLED_WHITE,MUTE[0]);    // Script OFF
    wait(get_rtime());
    wait(250);
    printf(center_x(sizeof(HOLD) - 1, OLED_FONT_SMALL_WIDTH),38,OLED_FONT_SMALL,OLED_WHITE,HOLD[0]);     // hold CIRCLE/B
    printf(center_x(sizeof(ACTIVE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,ACTIVE[0]); // to turn ON
    wait(get_rtime());
    wait(5000);  // display 5 sec
    cls_oled(OLED_BLACK);
    wait(get_rtime());
    wait(5000);  // oled black 5 sec.
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo SAVE { 
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_title = TRUE;
	}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RN {
	RN1 = random(65,90);
	RN2 = random(60,90);
	RN3 = random(65,90);
	RN4 = random(65,90); 
	RN5 = random(65,90);
	RN6 = random(65,90);
	RN7 = random(65,90);
	RN8 = random(65,90);
	wait(SAVER);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time - get_rtime());
    set_val(PS4_R2, 0);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo STRAFESHOT { // StrafeShot
    set_val(PS4_LX, 100);
    wait(strafeShot_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafeShot_time);
    wait(50);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RELOAD {
    wait(reload_time); 
    set_val(PS4_TRIANGLE,100);
    wait(15);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo HOLD {
    set_val(button, 100);
    wait(2900);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo maxcmb1 {
set_val(XB1_RIGHT, 100);
	wait(330);
	set_val(XB1_MENU, 100);
	set_val(XB1_RIGHT, 100);
	wait(90);
	set_val(XB1_MENU, 0);
	set_val(XB1_RIGHT, 100);
	wait(200);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 100);
	wait(70);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 0);
	wait(430);
	set_val(XB1_LY, 40);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 64);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 66);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 88);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 90);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 100);
	set_val(XB1_RIGHT, 100);
	wait(20);
	set_val(XB1_LY, 98);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 66);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 62);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 33);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 29);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 22);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 20);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 0);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 20);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 44);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 70);
	set_val(XB1_RIGHT, 100);
	wait(20);
	set_val(XB1_LY, 73);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 75);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 77);
	set_val(XB1_RIGHT, 100);
	wait(20);
	set_val(XB1_LY, 74);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 44);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 42);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 0);
	set_val(XB1_RIGHT, 100);
	wait(60);
	set_val(XB1_LY, 41);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 66);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 69);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 95);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 100);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LX, 22);
	set_val(XB1_LY, 100);
	set_val(XB1_RIGHT, 100);
	wait(20);
	set_val(XB1_LX, 25);
	set_val(XB1_LY, 100);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LX, 26);
	set_val(XB1_LY, 96);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LX, 24);
	set_val(XB1_LY, 56);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LX, 21);
	set_val(XB1_LY, 32);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LX, 0);
	set_val(XB1_LY, 0);
	set_val(XB1_RIGHT, 100);
	wait(50);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 100);
	wait(60);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 0);
	wait(210);
	set_val(XB1_LY, 38);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 40);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 68);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 72);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 97);
	set_val(XB1_RIGHT, 100);
	wait(20);
	set_val(XB1_LY, 100);
	set_val(XB1_RIGHT, 100);
	wait(30);
	set_val(XB1_LY, 96);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 68);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 38);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, 0);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 100);
	wait(90);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 0);
	wait(1320);
	set_val(XB1_LY, -33);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, -69);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, -72);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, -96);
	set_val(XB1_RIGHT, 100);
	wait(10);
	set_val(XB1_LY, -100);
	set_val(XB1_RIGHT, 100);
	wait(60);
	set_val(XB1_LY, -96);
	set_val(XB1_RIGHT, 100);
	wait(20);
	set_val(XB1_LY, -64);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 100);
	wait(10);
	set_val(XB1_LY, -37);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 100);
	wait(10);
	set_val(XB1_LY, 0);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 100);
	wait(60);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_A, 0);
	wait(310);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_B, 100);
	wait(70);
	set_val(XB1_RIGHT, 100);
	set_val(XB1_B, 0);
	wait(40);
	set_val(XB1_RIGHT, 0);
	wait(60);
	set_val(XB1_B, 100);
	wait(70);
	set_val(XB1_B, 0);
	wait(90);
	set_val(XB1_B, 100);
	wait(60);
	set_val(XB1_B, 0);
	wait(80);
	set_val(XB1_B, 100);
	wait(60);
	set_val(XB1_B, 0);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
combo GRENADE {
	if(get_val(PS4_L2))
		set_val(PS4_LEFT, 100);
    wait(nade_wait);
	set_val(PS4_LEFT, 0);
    set_val(PS4_R2, 100);
    wait(100);
    set_val(PS4_L2, 0);
    wait(500);
    }
  
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int recoilAssist;

combo STICKY {
	if(toggle_antirecoil[profile_idx] && get_val(PS4_R2))
	{
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    	set_val(PS4_RY, SmartSens(aimassist_radius + recoilAssist, PS4_RY));
    }
    else 
    	set_val(PS4_RY, SmartSens(aimassist_radius, PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(PS4_R2))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(aimassist_radius, PS4_RX));
    set_val(PS4_LX, SmartSens(aimassist_radius, PS4_LX));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(PS4_R2))
	{
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius) + recoilAssist, PS4_RY));
    }
    else
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius), PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(PS4_R2))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(inv(aimassist_radius), PS4_RX));
    set_val(PS4_LX, SmartSens(inv(aimassist_radius), PS4_LX));
    wait(aimassist_angle);
}    

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                 FUNCTION SECTION                                                      |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

function display_edit_line1() {

// Clears text emplacement line 1
	rect_oled(13, 1, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
	
	if(ModMenu)
	{				
	// Display Profile only on mods that may have different ON/OFF status depending on the active Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE) // idx from 0 to 4 are mods that may have different ON/OFF status depending on the active Profile
			display_profile ();
		else // Mods that have the same toggle on every profiles, display EVERY PROFILE
    		printf(center_x(sizeof(ALL) - 1, OLED_FONT_SMALL_WIDTH),4,OLED_FONT_SMALL,OLED_WHITE,ALL[0]);
	}
	
	if(ModWeapon)
	{
	// Display active Profile
		display_profile (); 
	}
	
	if(ModEdit) 
	{
	// Display Value Name
    	if(valName_idx == 1 && toggle_antirecoil[profile_idx] == 2)
    		printf(center_x(sizeof(ANTIRECOIL_VERTICAL) - 1, OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,ANTIRECOIL_VERTICAL[0]);  
    	else
    		printf(center_x(get_string_length(get_string(VALNAME_TXT, valName_idx)), OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(VALNAME_TXT, valName_idx));  
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit_line2() {
	
// Clears text emplacement line 2
	rect_oled(13, 17, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
		
	if(ModMenu)
	{
	// Display Mod Name
		printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));  // small size
	}
		
	if(ModWeapon)
	{
	// Display active Weapon Category
		printf(center_x(get_string_length(get_string(WEAPON_CAT_TXT, weapon_category[profile_idx])), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(WEAPON_CAT_TXT, weapon_category[profile_idx]));
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit_line3() {
	
// Clears text emplacement line 3
	rect_oled(13, 33, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
		
	if(ModWeapon)
	{
	// Display active Weapon Name	
    	printf(center_x(get_string_length(get_string(WEAPON_NAME_TXT, weapon_name[profile_idx])), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(WEAPON_NAME_TXT, weapon_name[profile_idx]));
	}
	else
	{
	// Display toggle ON/OFF status
	    // Mods that may have different ON/OFF status depending on the active Profile
		display_toggle( 0 , toggle_antirecoil[profile_idx]); // display_toggle( corresponding modName_idx , toggle_I_want_to_be_displayed[profile]);
		display_toggle( 1 , toggle_rapidfire[profile_idx] );
		display_toggle( 2 , toggle_burstfire[profile_idx] );
		display_toggle( 3 , toggle_aimassist[profile_idx] );
		display_toggle( 4 , toggle_strafeShot[profile_idx]);
		
		// Mods that have same ON/OFF status on every Profile
		display_toggle( 5 , dynasens_on);
		display_toggle( 6 , reload_on  );
		display_toggle( 7 , autorun_on );
		display_toggle( 8 , medkit_on  );
		display_toggle( 9 , nade_on    );
		display_toggle( 10, skill_on   );
		display_toggle( 11, roll_on    );
		display_toggle( 12, parkour_on );
		display_toggle( 13, swap_on    );
		display_toggle( 14, rumble_on  );
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_values() {
// Mods that may have different values depending on the active Profile
	display_edit( 0 , antirecoil_start[profile_idx]      );// Display_edit( corresponding valName_idx , val_I_want_to_be_displayed[profile] );
	display_edit( 1 , antirecoil_end[profile_idx]        );
	display_edit( 2 , antirecoil_time[profile_idx]       );
	display_edit( 3 , antirecoil_horizontal[profile_idx] );
	display_edit( 4 , rate_of_fire[profile_idx]          );
	display_edit( 16, rumble_power[profile_idx]          );
				
// Mods that have same value on every Profile
	display_edit( 5 , burstfire_hold         );
	display_edit( 6 , burstfire_release      );
	display_edit( 7 , aimassist_radius       );
	display_edit( 8 , aimassist_angle        );
	display_edit( 9 , strafeShot_time        );
	display_edit( 10, dynasens_initial_sens  );
	display_edit( 11, dynasens_limit         );
	display_edit( 12, dynasens_restart       );
	display_edit( 13, dynasens_max_sens      );
	display_edit( 14, dynasens_increase_rate );
	display_edit( 15, reload_time            );
}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int profile_y;

function display_profile() {

	if(display_title)
		profile_y = 34; // Title screen
	else
		profile_y = 4; // Menus
	
    printf(center_x(get_string_length(get_string(PROFILE_TXT, profile_idx)), OLED_FONT_SMALL_WIDTH),profile_y,OLED_FONT_SMALL,OLED_WHITE,get_string(PROFILE_TXT, profile_idx));
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int array_val;

function display_edit(f_idx, f_val) { // display_edit( 16, rumble_power[profile_idx]          );
	
    if(valName_idx == f_idx)
    {
    	array_val = get_weapon_values(valName_idx);
    // Display all editable values in the arrays (every AntiRecoil values and RoF values)
    	if(f_idx < amount_of_val_in_array)
			number_to_string( array_val + f_val, find_digits(array_val + f_val)   );
  
    // Display editable values that are not in the arrays (every values exept AntiRecoil values and RoF values)
    	else 
    		number_to_string(f_val, find_digits(f_val));
    }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_toggle(f_idx, f_toggle) { // display_toggle( 7 , autorun_on );

    if(modName_idx == f_idx)
   	{
		if(f_idx == 0) // if AntiRecoil MOD
    	// Display OFF or Progressive or Standard or On Rumble
    		printf(center_x(get_string_length(get_string(ANTIRECOIL_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(ANTIRECOIL_TXT, f_toggle));
    		
		else if(f_idx == 3) // if Polar Assist MOD
    	// Display AIM Assist shapes
    		printf(center_x(get_string_length(get_string(SHAPES_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHAPES_TXT, f_toggle));
    	
		else
		{
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,OFF[0]);
   		}
   	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function check_toggle() {
	if(modName_idx == 0 && toggle_antirecoil[profile_idx]) return TRUE;
	if(modName_idx == 1 && toggle_rapidfire[profile_idx]) return TRUE;
	if(modName_idx == 2 && toggle_burstfire[profile_idx]) return TRUE;
	if(modName_idx == 3 && toggle_aimassist[profile_idx]) return TRUE;
	if(modName_idx == 4 && toggle_strafeShot[profile_idx]) return TRUE;
	if(modName_idx == 5 && dynasens_on) return TRUE;
	if(modName_idx == 6 && reload_on) return TRUE;
	return FALSE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define MODNAME_TXT = 0;
define VALNAME_TXT = 1;
define WEAPON_CAT_TXT = 2;
define WEAPON_NAME_TXT = 3;
define INFO_MENU_TXT = 4;
define INFO_EDIT_TXT = 5;
define INFO_WEAPON_TXT = 6;
define A_RIFLE_NAME_TXT = 7;
define SMG_NAME_TXT = 8;
define LMG_NAME_TXT = 9;
define RIFLE_NAME_TXT = 10;
define SHOTGUN_NAME_TXT = 11;
define SNIPER_NAME_TXT = 12;
define HANDGUN_NAME_TXT = 13;
define SHAPES_TXT = 14;
define ANTIRECOIL_TXT = 15;
define PROFILE_TXT = 16;

function entry_count(f_array_idx) { // entry_count(SHOTGUN_NAME_TXT)
// by Swizzy
    i = 0;
    if (f_array_idx == MODNAME_TXT) { while (MODNAME[i] != -1) { i++; } }
    else if (f_array_idx == VALNAME_TXT) { while (VALNAME[i] != -1) { i++; } }
    else if (f_array_idx == WEAPON_CAT_TXT) { while (WEAPON_CAT[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MENU_TXT) { while (INFO_MENU[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_TXT) { while (INFO_EDIT[i] != -1) { i++; } }
    else if (f_array_idx == INFO_WEAPON_TXT) { while (INFO_WEAPON[i] != -1) { i++; } }
    else if (f_array_idx == A_RIFLE_NAME_TXT) { while (A_RIFLE_NAME[i] != -1) { i++; } }
    else if (f_array_idx == SMG_NAME_TXT) { while (SMG_NAME[i] != -1) { i++; } }
    else if (f_array_idx == LMG_NAME_TXT) { while (LMG_NAME[i] != -1) { i++; } }
    else if (f_array_idx == RIFLE_NAME_TXT) { while (RIFLE_NAME[i] != -1) { i++; } }
    else if (f_array_idx == SHOTGUN_NAME_TXT) { while (SHOTGUN_NAME[i] != -1) { i++; } }
    else if (f_array_idx == SNIPER_NAME_TXT) { while (SNIPER_NAME[i] != -1) { i++; } }
    else if (f_array_idx == HANDGUN_NAME_TXT) { while (HANDGUN_NAME[i] != -1) { i++; } }
    else if (f_array_idx == SHAPES_TXT) { while (SHAPES[i] != -1) { i++; } }
    else if (f_array_idx == ANTIRECOIL_TXT) { while (ANTIRECOIL[i] != -1) { i++; } }
    else if (f_array_idx == PROFILE_TXT) { while (PROFILE[i] != -1) { i++; } }
    return i - 1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function get_string(f_array_idx, f_idx) { // get_string(WEAPON_CAT_TXT, weapon_category[profile_idx])

	if(f_array_idx == MODNAME_TXT)
		return MODNAME[f_idx];
		
	if(f_array_idx == VALNAME_TXT)
		return VALNAME[f_idx];
		
	if(f_array_idx == WEAPON_CAT_TXT)
		return WEAPON_CAT[f_idx];
		
	if(f_array_idx == WEAPON_NAME_TXT)
	{
		if(weapon_category[profile_idx] == 0)
			return A_RIFLE_NAME[f_idx];
			
		else if(weapon_category[profile_idx] == 1)
			return SMG_NAME[f_idx];
			
		else if(weapon_category[profile_idx] == 2)
			return LMG_NAME[f_idx];
			
		else if(weapon_category[profile_idx] == 3)
			return RIFLE_NAME[f_idx];
			
		else if(weapon_category[profile_idx] == 4)
			return SHOTGUN_NAME[f_idx];
			
		else if(weapon_category[profile_idx] == 5)
			return SNIPER_NAME[f_idx];
			
		else if(weapon_category[profile_idx] == 6)
			return HANDGUN_NAME[f_idx];
	}
	
	if(f_array_idx == INFO_MENU_TXT)
		return INFO_MENU[f_idx];
		
	if(f_array_idx == INFO_EDIT_TXT)
		return INFO_EDIT[f_idx];
		
	if(f_array_idx == INFO_WEAPON_TXT)
		return INFO_WEAPON[f_idx];
		
	if(f_array_idx == SHAPES_TXT)
		return SHAPES[f_idx];
		
	if(f_array_idx == ANTIRECOIL_TXT)
		return ANTIRECOIL[f_idx];
		
	if(f_array_idx == PROFILE_TXT)
		return PROFILE[f_idx];
		
	return -1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int stringLength;
function get_string_length(offset) { // get_string_length(get_string(MODNAME_TXT, modName_idx)
// by Swizzy
    stringLength = 0;
    while (duint8(offset++)) { stringLength++; }
    return stringLength + 1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function get_weapon_values(f_idx) { // get_weapon_values(valName_idx);

    if(weapon_category[profile_idx] == 0) return A_RIFLE[weapon_name[profile_idx]][f_idx];
    if(weapon_category[profile_idx] == 1) return SMG[weapon_name[profile_idx]][f_idx];
    if(weapon_category[profile_idx] == 2) return LMG[weapon_name[profile_idx]][f_idx]; 
    if(weapon_category[profile_idx] == 3) return RIFLE[weapon_name[profile_idx]][f_idx];
    if(weapon_category[profile_idx] == 4) return SHOTGUN[weapon_name[profile_idx]][f_idx]; 
    if(weapon_category[profile_idx] == 5) return SNIPER[weapon_name[profile_idx]][f_idx];
    if(weapon_category[profile_idx] == 6) return HANDGUN[weapon_name[profile_idx]][f_idx];
    
    return 0; 
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define SSA1 = 78,SSA2 = 79,SSA3 = 90,SSA4 = 66,SSA5 = 65,SSA6 = 82,SSA7 = 68,SSA8 = 82,SSA9 = 73,SSA10 = 70,SSA11 = 82,SSA13 = 50,SSA14 = 49,SAVER = 5000,SAVER1 = 10;

function weapon_selection() {

// Select Weapon Category 
	if(event_press(PS4_UP))
	{
		weapon_category[profile_idx] -= 1;
	   		
		return TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
	}
	if(event_press(PS4_DOWN))
	{
		weapon_category[profile_idx] += 1;
	   		
		return TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
	}
			
// Select Weapon Name		
	if(event_press(PS4_RIGHT))
	{
		weapon_name[profile_idx] += 1;
		return TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
	}
	if(event_press(PS4_LEFT))
	{
		weapon_name[profile_idx] -= 1;
		return TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
	}
	return FALSE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function weapon_limit() {
// Limits for Weapon Category
	if(profile_idx != 2) 
	{
	// Every Weapon category (exept HANDGUN) are available with profile_idx = 0 or 1
		if(weapon_category[profile_idx] > entry_count(WEAPON_CAT_TXT) - 1)
			weapon_category[profile_idx] = 0;
		else if(weapon_category[profile_idx] < 0)
			weapon_category[profile_idx] = entry_count(WEAPON_CAT_TXT) - 1;
	}
	else
	// Only HANDGUN is available with profil_idx = 2
		weapon_category[2] = entry_count(WEAPON_CAT_TXT);
		
// Enabling RapidFire by default for Semi-Automatic Weapons
	if((weapon_category[profile_idx] >= AMOUNT_OF_FULLAUTO_CAT))
		toggle_rapidfire[profile_idx] = 1;
	else
	   	toggle_rapidfire[profile_idx] = 0;
		
// Limits for Weapon Name
	if(weapon_name[profile_idx] > get_weapon_name_limit())
		weapon_name[profile_idx] = 0;
	if(weapon_name[profile_idx] < 0)
		weapon_name[profile_idx] = get_weapon_name_limit();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function get_weapon_name_limit() {
	if(weapon_category[profile_idx] == 0) return entry_count(A_RIFLE_NAME_TXT);
    if(weapon_category[profile_idx] == 1) return entry_count(SMG_NAME_TXT);
    if(weapon_category[profile_idx] == 2) return entry_count(LMG_NAME_TXT); 
    if(weapon_category[profile_idx] == 3) return entry_count(RIFLE_NAME_TXT);
    if(weapon_category[profile_idx] == 4) return entry_count(SHOTGUN_NAME_TXT); 
    if(weapon_category[profile_idx] == 5) return entry_count(SNIPER_NAME_TXT);
    if(weapon_category[profile_idx] == 6) return entry_count(HANDGUN_NAME_TXT);
    
    return 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
	
	if(valName_idx == f_idx)
	{
    // +1 or -1															 
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2
	}
	
// Block Rate of Fire to 60RPM minimum 
	if(weapon_category[profile_idx] == 3 && (rate_of_fire[profile_idx] < inv(RIFLE[weapon_name[profile_idx]][4]) + 60))
		rate_of_fire[profile_idx] = inv(RIFLE[weapon_name[profile_idx]][4]) + 60;
	if(weapon_category[profile_idx] == 4 && (rate_of_fire[profile_idx] < inv(SHOTGUN[weapon_name[profile_idx]][4]) + 60))
		rate_of_fire[profile_idx] = inv(SHOTGUN[weapon_name[profile_idx]][4]) + 60;
	if(weapon_category[profile_idx] == 5 && (rate_of_fire[profile_idx] < inv(SNIPER[weapon_name[profile_idx]][4]) + 60))
		rate_of_fire[profile_idx] = inv(SNIPER[weapon_name[profile_idx]][4]) + 60;
	if(weapon_category[profile_idx] == 6 && (rate_of_fire[profile_idx] < inv(HANDGUN[weapon_name[profile_idx]][4]) + 60))
		rate_of_fire[profile_idx] = inv(HANDGUN[weapon_name[profile_idx]][4]) + 60;
			
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == 0) // toggle 0 or 1 or 2 or 3 to select antirecoil type
				f_val = cycle(f_val + 1, 0, entry_count(ANTIRECOIL_TXT));
				
			else if(f_idx == 3) // toggle 0 or 1 or 2 ... or 5 to select aim assist shape
			{
				f_val = cycle(f_val + 1, 0, entry_count(SHAPES_TXT));
				
				if(f_val >= 1) // if AIM Assist disable dynasens
					dynasens_on = 0;
			}
			else
			{
				f_val = cycle(f_val + 1, 0, 1);
				
				if(f_idx == 5) // if dynasens disable AIM Assist
				{
					if(f_val == 1)
					{
						toggle_aimassist[0] = 0;
						toggle_aimassist[1] = 0;
						toggle_aimassist[2] = 0;
					}
				}
			}
		
		// Rumble	
			if(f_val == 0) 
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);
		}
		display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
	}

	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == 0) // toggle 0 or 1 or 2 or 3 to select antirecoil type
				f_val = cycle(f_val - 1, 0, entry_count(ANTIRECOIL_TXT));
			else if(f_idx == 3) // toggle 0 or 1 or 2 or 3 to select aim assist shape
			{
				f_val = cycle(f_val - 1, 0, entry_count(SHAPES_TXT));
				
				if(f_val >= 1) // if AIM Assist disable dynasens
					dynasens_on = 0;
			}
			else
			{
				f_val = cycle(f_val - 1, 0, 1);
				
				if(f_idx == 5) // if dynasens disable AIM Assist
				{
					if(f_val == 1)
					{
						toggle_aimassist[0] = 0;
						toggle_aimassist[1] = 0;
						toggle_aimassist[2] = 0;
					}
				}
			}
		
		// Rumble	
			if(f_val == 0) 
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);	
		}
		display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function speed_toggle(f_hold, f_press, f_time, f_val, f_idx) {  // toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT, 500 , toggle_aimassist[profile_idx] , 3 );
	
	if(get_val(f_hold))
	{
		if(f_idx == 3) // if Polar Assist
		{		
			if(event_press(f_press) && get_brtime(f_press) <= 200) // switch shapes
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(SHAPES_TXT)) ;
				display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
			}
		}
		
		if(get_val(f_press) && get_ptime(f_press) == f_time) // Hold second button 300ms or more
		{
			modName_idx = f_idx;
			f_val = !f_val;	
			
			if(f_idx == 3) // polar assist
			{
				if(f_val == 1)
					dynasens_on = 0;
			}
			else if(f_idx == 5) // dynasens
			{
				if(f_val == 1)
				{
					toggle_aimassist[0] = 0;
					toggle_aimassist[1] = 0;
					toggle_aimassist[2] = 0;
				}
			}
			
			if(f_val == 0)
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);
				
			display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
		} 
		
		set_val(f_press, 0)
	}
		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

function speed_weapon_swap() {

	if(get_ival(PS4_R3))
	{
		if(weapon_selection())
		{	
			weapon_limit();
			display_title = TRUE;
		}
		
		set_val(PS4_UP, 0);
		set_val(PS4_DOWN, 0);
		set_val(PS4_LEFT, 0);
		set_val(PS4_RIGHT, 0);
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int sens_x;
int sens_y;
int sens_xcnt,sens_ycnt;

function set_sens () { // DynaSens by Batts

    if(abs(get_lval(PS4_RX)) >= dynasens_limit) 
    {
	    sens_xcnt += 1;
	    
		if(sens_xcnt >= dynasens_increase_rate && sens_x < dynasens_max_sens) 
		{ 
		    sens_x += 1; 
		    sens_xcnt = 0; 
		} 
			else if(sens_x >= dynasens_max_sens) 
				sens_xcnt = 0;  
	}
	
    else if(abs(get_val(PS4_RX)) < dynasens_restart) 
    {
	    sens_xcnt = 0; 
	    sens_x = dynasens_initial_sens;
	} 
	
    if(abs(get_val(PS4_RY)) >= dynasens_limit) 
    {
	    sens_ycnt += 1;
		if(sens_ycnt >= dynasens_increase_rate && sens_y < dynasens_max_sens) 
		{ 
		    sens_y += 1; 
		    sens_ycnt = 1; 
		} 
			else if(sens_y >= dynasens_max_sens) 
				sens_ycnt = 0; 
	}
	
    else if(abs(get_val(PS4_RY)) < dynasens_restart) 
    {
	    sens_y = dynasens_initial_sens; 
	    sens_ycnt = 0;
	}
	
	sensitivity(PS4_RX,NOT_USE,sens_x);
    sensitivity(PS4_RY,NOT_USE,sens_y);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function SkillDestroy (f_btn1, f_btn2) {

	if(get_val(f_btn1)) 
	{
		if(event_press(PS4_CROSS))
		{
			button = f_btn1;
			combo_run(HOLD);
		}
		set_val(PS4_CROSS, 0);
	}
	if(combo_running(HOLD) && (!swap_on && event_press(f_btn1)) || (swap_on && event_press(f_btn2))) 
		combo_stop(HOLD);

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Antirecoil                                           
int i_cnt;    

function p_complete() { 

    i_cnt++;
    if(i_cnt > final_antirecoil_time / 10) 
    {
        i_cnt = final_antirecoil_time / 10;
        return 1;
    }    
    return 0;
}  

int i_num;
int i_pnt;
int ar_y;	
int i_val;

function p_val() { 

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int SmartSens_side;
int SmartSens;
	
function SmartSens(f_val, f_axis) { 

	if(f_val < 0)
		SmartSens_side = -1; // Left / Up 
	else 
		SmartSens_side = 1; // Right / Down 

	if(SmartSens_side == -1) // if f_val has a negative value (Left side or Up) 
	{
	    if(get_ival(f_axis) > 0) // if stick input has a positive value (Right side or Down)
	    	SmartSens = ((get_ival(f_axis) * (100 - f_val)) / 100); 
	    
	    else if(get_ival(f_axis) <= 0) // if stick input has a negative value (Left side or Up)
	    	SmartSens = ((get_ival(f_axis) * (100 + f_val)) / 100);
	}
	
	if(SmartSens_side == 1) // if f_val has a positive value (Right side or Down)
	{
	    if(get_ival(f_axis) < 0) // if stick input has a negative value (Left side or Up)
	    	SmartSens = ((get_ival(f_axis) * (100 + f_val)) / 100); 
	    	
	    else if(get_ival(f_axis) >= 0) // if stick input has a positive value (Right side or Down)
	    	SmartSens = ((get_ival(f_axis) * (100 - f_val)) / 100);
	}
// Set SmartSens on the axis
	if(SmartSens_side == -1 && get_ival(f_axis) >= f_val + SmartSens || SmartSens_side == 1 && get_ival(f_axis) <= f_val + SmartSens)
	    return clamp(f_val + SmartSens, -100, 100);
	    
	return 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function antirecoil() {

	if(!toggle_aimassist[profile_idx])
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY), -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX), -100, 100));
	}
	else if(toggle_aimassist[profile_idx] > 1)
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY) + sin_angle, -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX) + cos_angle, -100, 100));
	}
	else if(toggle_aimassist[profile_idx] == 1)
	{
		recoilAssist = ar_y;
		combo_run(STICKY);
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
    // Values that are not in the array (aimassist_angle for exemple)
		if(valName_idx > amount_of_val_in_array + 1)
		{
    	// Substract    
        	if(f_val < inv(f_rng_min)) 
        		f_val = inv(f_rng_min); 
   		// Add   
       		if(f_val > f_rng_max) 
        		f_val = f_rng_max;
		}
		
    // Values that are in the array 
		else
		{
		// Substract    
		    if((f_val + get_weapon_values(valName_idx)) < inv(f_rng_min)) 
				f_val = inv(f_rng_min + get_weapon_values(valName_idx)); 
		// Add   
			if((f_val + get_weapon_values(valName_idx)) > f_rng_max) 
				f_val = f_rng_max - get_weapon_values(valName_idx);
        }		
        display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_base_menu() {
	rect_oled(0, 0, 128, 49, OLED_BLACK, OLED_WHITE); // white contour 
	line_oled(1, 16, 126, 16, 1, OLED_WHITE); // draw line 1
	
// Filled rectangle white (emplacement for the chars line 1)	
	rect_oled(2, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 1)
	rect_oled(115, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 1)
/*
			Rectangle (rec) used to create a "button" with an arrow or letter (char) printed in it
			When the rectangle is filled, the char is empty, when the rectangle is empty, the char is filled 
			Also, the rectangle allows the char to be correctly centred when it's filled or empty
			That's why there are a lot of small adjustments (+4 here, +6 there...)
*/
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_modMenu() {
// Clears text emplacement line 2 and 3 (value zone while in ModEdit)
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Separate ex value zone
	line_oled(1, 32, 126, 32, 1, OLED_WHITE); // line 2 
	
// Filled rectangle white (emplacement for the chars line 2, 3)
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_modEdit() {
// Clears line 2 and 3
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Filled rectangle white 
	// Emplacement for the chars line 2, 3)	
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
	// Emplacement for + / -
	rect_oled(14, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE , OLED_WHITE); // rectangle left (line 2 + 3)
	rect_oled(102, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE, OLED_WHITE); // rectangle right (line 2 + 3)

// Display - / +
	line_oled(16, 31, 23, 31, 2, OLED_BLACK); // left -
	putc_oled(1, 43); // +
	puts_oled(103, 24, OLED_FONT_MEDIUM, 1, OLED_BLACK); // right + 	    

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define UP = 131; define DOWN = 132; define LEFT = 133; define RIGHT = 134; define TRIANGLE = 130; define Y = 89; define CROSS = 127; define A = 65;
define LEFT_X = 4; define RIGHT_X = 117;
define LINE_1_Y = 4; define LINE_2_Y = 20;  define LINE_3_Y = 36; define LINE_4_Y = 53;  
int btn_left;
int btn_right;

function draw_chars_line1() {
// Define button
	if(ModMenu || ModWeapon)
	{		
		if(get_controller() == PIO_PS4)
		{
			btn_left = TRIANGLE;
			btn_right = TRIANGLE;
		}
		else
		{
			btn_left = Y;
			btn_right = Y;
		}
	}
	if(ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}

// Clears/fill rectangle
	rect_oled(3, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 1)
	rect_oled(116, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 1)
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_right); 

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_chars_line2() {
// Define button
	if (ModMenu || ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}
	if (ModWeapon)
	{
		btn_left = DOWN;
		btn_right = UP;
	}

	if(ModEdit)
	{
	// Clears/fill rectangle
		rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 2)
		rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
	}
	else
	{
	// Clears/fill rectangle
		rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); //  rectangle left (line 2)
		rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
	}
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_right); 
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_chars_line3() { 
// Define button
	if (ModMenu)
	{
		btn_left = DOWN;
		btn_right = UP;
	}
	if (ModWeapon)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}
	if(ModEdit)
	{
		btn_left = DOWN;
		btn_right = UP;
		
	// Clears/fill rectangle
		rect_oled(3, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 3)
		rect_oled(116, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); // rectangle right (line 3)	
	}
	else
	{
	// Clears/fill rectangle
		rect_oled(3, 35, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 3)
		rect_oled(116, 35, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 3)
	}
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_left); 
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_right);  
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_hold_to_edit() { 
// Clears/fill the inside of the "hold button" rectangle
	rect_oled(28, 19, OLED_FONT_SMALL_WIDTH + 1 , OLED_FONT_SMALL_HEIGHT , OLED_WHITE , col_rec_left); 
	rect_oled(91, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT  , OLED_WHITE, col_rec_right); 
// Display chars	
	if(get_controller() == PIO_PS4)
	{	
		putc_oled(1, CROSS);
		puts_oled(92, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, CROSS);
		puts_oled(28, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_right);
	}
	else
	{
		putc_oled(1, A);
		puts_oled(92, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, A);
		puts_oled(29, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_right);
	}
// Contour for chars X / A (must be after display chars)
	rect_oled(27, 18, OLED_FONT_SMALL_WIDTH + 3 , OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK , OLED_WHITE); // small rectangle left (line 2)
	rect_oled(90, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK, OLED_WHITE); // small rectangle right (line 2)
}	

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int col_char_left; 
int col_char_right;
int col_rec_left = 1;
int col_rec_right = 1;

function button_animation() {
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_TRIANGLE))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModMenu || ModWeapon)
			draw_chars_line1();
	}
	else if(event_release(PS4_TRIANGLE))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModMenu || ModWeapon)
			draw_chars_line1();
	}	
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	if(event_press(PS4_LEFT))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
			{
				draw_chars_line1();
			}
		}
		
		if(ModWeapon)
			draw_chars_line3();
	}
	if(event_release(PS4_LEFT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
		
		if(ModWeapon)
			draw_chars_line3();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_RIGHT))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;	
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
			{
				draw_chars_line1();
			}
		}
		
		if(ModWeapon)
			draw_chars_line3();
	}
	if(event_release(PS4_RIGHT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
		
		if(ModWeapon)
			draw_chars_line3();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_UP))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		
		if(ModWeapon)
			draw_chars_line2();
	}
	if(event_release(PS4_UP))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		
		if(ModWeapon)
			draw_chars_line2();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_DOWN))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		
		if(ModWeapon)
			draw_chars_line2();
	}
	if(event_release(PS4_DOWN))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		
		if(ModWeapon)
			draw_chars_line2();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_CROSS))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
	if(event_release(PS4_CROSS))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int SSMU1 = 1,SSMU2 = 8,SSMU3 = 15,SSMU4 = 22,SSMU5 = 29,SSMU6 = 36,SSMU7 = 43;

function cycle(f_val, f_lo, f_hi) {
	if(f_val > f_hi) return f_lo;
	if(f_val < f_lo) return f_hi;
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int c,c_val;

function number_to_string(f_val,f_digits) {

    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            /*if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }*/
        }
        c_val /= 10;
    }
    if(display_title)
    	puts_oled(120, 34, OLED_FONT_SMALL, i - 1, OLED_WHITE); // display current # slot
    else
    	puts_oled(center_x(i - 1,OLED_FONT_MEDIUM_WIDTH),28,OLED_FONT_MEDIUM,i - 1,OLED_WHITE); // adjustable value centered in X - medium size
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int X_1,Y_1,X_2,Y_2,X_3,Y_3, X_4,Y_4,X_5,Y_5,X_6,Y_6,X_7,Y_7,X_8,Y_8,RN1,RN2,RN3,RN4,RN5,RN6,RN7,RN8;

function find_digits(f_num) {

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int RT,MSC,SD1,DGT,DGR,TP1,TP2;

function press_hold(f_btn) { 

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {

   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function save() {
	ModMenu = FALSE;
	ModEdit = FALSE;
	ModWeapon = FALSE;
	cls_oled(OLED_BLACK);
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	combo_run(SAVE);
	
// Private toggles
	pmemValue = set_15var(pmemValue, toggle_rapidfire[0] , 0);		pmemValue = set_15var(pmemValue, toggle_rapidfire[1] , 1);		pmemValue = set_15var(pmemValue, toggle_rapidfire[2] , 2);
	pmemValue = set_15var(pmemValue, toggle_burstfire[0] , 3);		pmemValue = set_15var(pmemValue, toggle_burstfire[1] , 4);		pmemValue = set_15var(pmemValue, toggle_burstfire[2] , 5);
	pmemValue = set_15var(pmemValue, toggle_strafeShot[0], 6);		pmemValue = set_15var(pmemValue, toggle_strafeShot[1], 7);		pmemValue = set_15var(pmemValue, toggle_strafeShot[2], 8);
	set_pvar(SPVAR_1,pmemValue);
	
// Global toggles
	pmemValue = set_15var(pmemValue, dynasens_on, 0);		pmemValue = set_15var(pmemValue, reload_on, 1);		pmemValue = set_15var(pmemValue, autorun_on, 2);
	pmemValue = set_15var(pmemValue, medkit_on  , 3);		pmemValue = set_15var(pmemValue, nade_on  , 4);		pmemValue = set_15var(pmemValue, skill_on  , 5);
	pmemValue = set_15var(pmemValue, parkour_on , 6);		pmemValue = set_15var(pmemValue, swap_on  , 7);		pmemValue = set_15var(pmemValue, rumble_on , 8);
	pmemValue = set_15var(pmemValue, roll_on    , 9);
	set_pvar(SPVAR_2,pmemValue);
	
// AntiRecoil Toggles (Private)
	pmemValue = set_4var(toggle_antirecoil[0], toggle_antirecoil[1], toggle_antirecoil[2], NOT_USE);
	set_pvar(SPVAR_3,pmemValue);
// AIM Assist Toggles (Private)
	pmemValue = set_4var(toggle_aimassist[0], toggle_aimassist[1], toggle_aimassist[2], NOT_USE);
	set_pvar(SPVAR_4,pmemValue);
	
// Weapon selection
	pmemValue = set_2var(weapon_category[0], weapon_name[0]);
	set_pvar(SPVAR_5,pmemValue);
	pmemValue = set_2var(weapon_category[0], weapon_name[0]);
	set_pvar(SPVAR_6,pmemValue);
	pmemValue = set_2var(weapon_category[0], weapon_name[0]);
	set_pvar(SPVAR_7,pmemValue);

// Antirecoil vertical
	pmemValue = set_2var(antirecoil_start[0], antirecoil_end[0]);
	set_pvar(SPVAR_8,pmemValue);
	pmemValue = set_2var(antirecoil_start[1], antirecoil_end[1]);
	set_pvar(SPVAR_9,pmemValue);
	pmemValue = set_2var(antirecoil_start[2], antirecoil_end[2]);
	set_pvar(SPVAR_10,pmemValue);
	set_pvar(SPVAR_11,antirecoil_time[0]);
	set_pvar(SPVAR_12,antirecoil_time[1]);
	set_pvar(SPVAR_13,antirecoil_time[2]);

// Antirecoil horizontal & rumble recoil
	pmemValue = set_2var(antirecoil_horizontal[0], rumble_power[0]);
	set_pvar(SPVAR_14,pmemValue);
	pmemValue = set_2var(antirecoil_horizontal[1], rumble_power[1]);
	set_pvar(SPVAR_15,pmemValue);
	pmemValue = set_2var(antirecoil_horizontal[2], rumble_power[2]);
	set_pvar(SPVAR_16,pmemValue);
	
// Rate of fire
	set_pvar(SPVAR_17,rate_of_fire[0]);
	set_pvar(SPVAR_18,rate_of_fire[1]);
	set_pvar(SPVAR_19,rate_of_fire[2]);
	set_pvar(SPVAR_20, burstfire_hold   );
	set_pvar(SPVAR_21, burstfire_release);

// AIM Assist
	pmemValue = set_2var(aimassist_radius, aimassist_angle);
	set_pvar(SPVAR_22,pmemValue);
	
// StrafeShot
	set_pvar(SPVAR_23,strafeShot_time);

// Dynasens	
	set_pvar(SPVAR_24,dynasens_initial_sens);
	pmemValue = set_2var(dynasens_limit, dynasens_restart);
	set_pvar(SPVAR_25,pmemValue);
	set_pvar(SPVAR_26,dynasens_max_sens);
	set_pvar(SPVAR_27,dynasens_increase_rate);
	
// Reload
	set_pvar(SPVAR_28,reload_time);
}

int mask;
int ret;
int pmemValue;

function set_15var(pvar, ret, position) {
	for(i = position; i < (1 + position); i++)
	{
		pvar = pvar & (~(1 << i));
	}
	pvar = pvar | (ret << position);
	
	return pvar;
}
function get_15var(pvar, position){
	mask = 0;
	ret = 0;
	for(i = 0; i < 1 ; i++)
	{
		mask = mask | (1 << i);
	}
	mask = mask << position
	ret = (pvar & mask) >> position
return ret;
}
//----

function set_4var(_1, _2, _3, _4) { 
	return 0xff00 & ((0xf0 & (_1 << 4) | _2) << 8) | (0xf0 & (_3 << 4) | _4); 
}
function get_4var(f_PMemory, f_dec_pos) { 
	return  (f_PMemory >> (4 * f_dec_pos)) & 0x0F; 
}
//----

function set_2var(var1, var2) {
	ret = 0;
	
	if(var1 < 0)
   		var1 = abs(var1) | 0x80;

	ret = (abs(var2) << 8)|var1;
	
	if(var2 < 0)
		ret *= -1;
	
	return ret;
}
function get_2var(pvar, var) {
	ret = 0;
	
	if(var == 0)
	{	 
		ret = 0x80 & abs(pvar) ;
		ret = ret >> 7;
		ret = ((-2) * ret) + 1;
		ret = (abs(pvar) & 0x7F) * ret;
	}
	else
	{
		ret = pvar >> 8;

	    if(pvar < 0)
			ret += 1;
	}
	
	return ret;

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function name(){
	cls_oled(0);
	combo_run(RACE);
	combo_run(RN);
if (Y_1 > 64)  Y_1 =   0;
if (Y_2 > 64)  Y_2 =   0;
if (Y_3 > 64)  Y_3 =   0;
if (Y_4 > 64)  Y_4 =   0;
if (Y_5 > 64)  Y_5 =   0;
if (Y_6 > 64)  Y_6 =   0;
if (Y_7 > 64)  Y_7 =   0;
if (Y_8 > 64)  Y_8 =   0;
if (SD1 > 105) SD1 = -50;
if (TP1 > 45)  TP1 =   0;
if (TP2 < 0)   TP2 =  55;
	putc_oled(1,RN1);
	puts_oled(X_1,Y_1,0,1,1);
	putc_oled(1,RN2);
	puts_oled(X_2,Y_2,0,1,1);
	putc_oled(1,RN3);
	puts_oled(X_3,Y_3,0,1,1);
	putc_oled(1,RN4);
	puts_oled(X_4,Y_4,0,1,1);
	putc_oled(1,RN5);
	puts_oled(X_5,Y_5,0,1,1);
	putc_oled(1,RN6);
	puts_oled(X_6,Y_6,0,1,1);
	putc_oled(1,RN7);
	puts_oled(X_7,Y_7,0,1,1);
	putc_oled(1,RN8);
	puts_oled(X_8,Y_8,0,1,1);
	putc_oled(1,SSA1);
	puts_oled(SSMU1 + SD1,TP1 + 2,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU2 + SD1,TP2 + 4,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU3 + SD1,TP1 + 6,0,1,1);
	putc_oled(1,SSA3);
	puts_oled(SSMU4 + SD1,TP2 + 8,0,1,1);
	putc_oled(1,SSA4);
	puts_oled(SSMU5 + SD1,TP1 + 10,0,1,1);
	putc_oled(1,SSA5);
	puts_oled(SSMU6 + SD1,TP2 + 12,0,1,1);
	putc_oled(1,SSA6);
	puts_oled(SSMU7 + SD1,TP1 + 14,0,1,1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
/*set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);*/
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

	const uint8 logo[] = {
	126, 31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xE8, 0xBE, 0x7E, 0x0F, 0x38, 0x1D, 0xE1, 0xFC, 0x3C, 0x3F, 
	0x83, 0xC1, 0xC0, 0x3F, 0x01, 0x02, 0x22, 0x81, 0xFE, 0x3C, 0xE0, 0x77, 0x8F, 0xF8, 0xF1, 0xFF, 0x0F, 
	0x87, 0x01, 0xFE, 0x06, 0x08, 0xFB, 0xCF, 0xFC, 0xF3, 0xC3, 0xDE, 0x7F, 0xF3, 0xCF, 0xFE, 0x3E, 0x1C, 
	0x0F, 0xFC, 0x08, 0x22, 0x28, 0x31, 0xF3, 0xC7, 0x0E, 0x79, 0xE1, 0xCF, 0x3C, 0x7C, 0xFC, 0x70, 0x38, 
	0x70, 0x30, 0x88, 0xA1, 0xC3, 0xEF, 0x1C, 0x39, 0xE7, 0x80, 0x3D, 0xE0, 0xF3, 0xF1, 0xC0, 0xE1, 0xC0, 
	0x42, 0x22, 0xE7, 0x07, 0xBC, 0x39, 0xC7, 0x8F, 0xC0, 0xF7, 0x83, 0xCF, 0xE7, 0x00, 0x0F, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC1, 
	0xEF, 0x0F, 0xF1, 0xE0, 0x7E, 0x3D, 0xE0, 0xF3, 0x9F, 0xC0, 0x1E, 0x00, 0x40, 0x00, 0x0F, 0x0F, 0xBC, 
	0x1F, 0x87, 0x80, 0x1C, 0xF7, 0x83, 0xCE, 0x3F, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x7C, 0x7C, 0xF0, 0x7E, 
	0x1E, 0x70, 0x73, 0xCF, 0x1F, 0x38, 0xFC, 0x07, 0x80, 0x04, 0x00, 0x01, 0xFF, 0xF3, 0xC0, 0xF0, 0x79, 
	0xFF, 0xCF, 0x3F, 0xF8, 0xE1, 0xF0, 0x3F, 0xF0, 0x30, 0x00, 0x0F, 0xFF, 0x8F, 0x03, 0xC1, 0xE3, 0xFE, 
	0x3C, 0x7F, 0xE3, 0x87, 0xC1, 0xFF, 0xC0, 0x80, 0x00, 0x3F, 0xF8, 0x3C, 0x06, 0x07, 0x87, 0xF0, 0xF0, 
	0xFE, 0x0E, 0x0F, 0x07, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
	0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 
	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x07, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x70, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00};

int __logoX, __logoX2, __logoY, __logoY2, __logoBit, __logoOffset, __logoData;

function draw_logo(x, y, invert) {
	__logoOffset = 2; // Reset the starting point
	__logoBit = 8; // Reset bit flag
	for (__logoY = 0; __logoY < logo[1]; __logoY++) { // Loop the Y axis
		for (__logoX = 0; __logoX < logo[0]; __logoX++) { // Loop the X axis
			__logoData = logo[__logoOffset]
			__logoX2 = x + __logoX;
			__logoY2 = y + __logoY;
			if (__logoX2 < 0 || __logoX2 >= 128) {
				__logoX2 -= 128;
			}
			if (__logoY2 < 0 || __logoY2 >= 64) {
				__logoY2 -= 64;
			}
			if (test_bit(__logoData, __logoBit - 1)) {
				pixel_oled(__logoX2, __logoY2, !invert);
			}
			else {
				pixel_oled(__logoX2, __logoY2, invert);
			}
			__logoBit--; // Decrement the bit flag, we're moving to the next bit
			if (!__logoBit) { // Check if we've just handled the last bit
				__logoBit = 8; // Reset the bit flag
				__logoOffset++; // Move to the next value
			}
		}
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int time;
int RX, RY;
int angle, cos_angle, sin_angle;
int SpiralPosition1,SpiralPosition2,InnerSpiral,OuterSpiral;
int actual_Magnitude, max_Magnitude, Position;

const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,    
80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7, 
6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,  
-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95, 
-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,   
-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61, 
-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,
9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,
82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int timer;

function GetShapesV1(f_var) {     
   
    if(!SpiralPosition1)                                
	{
		InnerSpiral -= 1;
		if(InnerSpiral < 1)
			SpiralPosition1 = TRUE;
	}
	else
	{
	    InnerSpiral += 1;
		if(InnerSpiral > f_var)
			SpiralPosition1 = FALSE;
	}
	if(!SpiralPosition2)
	{
		OuterSpiral -= 1;
		if(OuterSpiral < 1)
			SpiralPosition2 = TRUE;
	}
	else
	{
		OuterSpiral += 1;
		if(OuterSpiral >  f_var)
			SpiralPosition2 = FALSE;
	} 
	if(toggle_aimassist[profile_idx] == 1)                    
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 2)        
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * (f_var / 2)) /100; 
	}
	if(toggle_aimassist[profile_idx] == 3)                     
	{ 
        RY = (sin_angle * (f_var / 2)) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 4)                  
	{
        RY = (sin_angle * InnerSpiral) /100;
        RX = (cos_angle * OuterSpiral) /100;  
	}
    if(toggle_aimassist[profile_idx] == 5)
	{
		RX = (cos_angle * Position) /100;
		RY = (sin_angle * Position) /100;
	
		if(Position == 0)
		    RX = (cos_angle * f_var) /100;
		    
		if(Position == 1)
			RY = (sin_angle * f_var) /100;
			
		if(Position == 2) 
			RX = (cos_angle * f_var) /100 * -1;
			
		if(Position == 3)
			RY = (sin_angle * f_var) /100 * -1;
			
		timer++;
		if(timer >= aimassist_angle)
		{
			Position++;
			timer = 0;
		}
				
		if(Position == 4)
			Position = 0;
    }
    
	cos_angle = RX;
	sin_angle = RY;
}