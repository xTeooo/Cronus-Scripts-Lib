/* * * * * * * * * * * * * * * * * * * * * * *
// GPC Private Library "MY PERSONAL DAILY"	||
// noobProof-NOBuild-V15.0.gpc				||
// FORT9 SCRIPT -- "Chapter 3 Season 4"		||
// SERIE = 15-E    for  EXPONENCIAL PLAYERS || 
'                          _                                            _       
'                         / |_                                         / \      
'   _ .--.   .--.   .---.`| |-'_   _   __  _ .--.  _ .--.    _   __   / _ \     
'  [ `.-. |/ .'`\ \/ /'`\]| | [ \ [ \ [  ][ `/'`\][ `.-. |  [ \ [  ] / ___ \    
'   | | | || \__. || \__. | |, \ \/\ \/ /  | |     | | | |   \ '/ /_/ /   \ \_  
'  [___||__]'.__.' '.___.'\__/  \__/\__/  [___]   [___||__][\_:  /|____| |____| 
'                          __       _______                 \__.'       ___     
'                         [  |     |_   __ \                          .' ..]    
'   _ .--.   .--.    .--.  | |.--.   | |__) |_ .--.   .--.    .--.   _| |_      
'  [ `.-. |/ .'`\ \/ .'`\ \| '/'`\ \ |  ___/[ `/'`\]/ .'`\ \/ .'`\ \'-| |-'     
'   | | | || \__. || \__. ||  \__/ |_| |_    | |    | \__. || \__. |  | |       
'  [___||__]'.__.'  '.__.'[__;.__.'|_____|  [___]    '.__.'  '.__.'  [___]      
'                                                                              
/////////////////////////////////////////////////////////////////////////
//	 	I (noctwrnyA) provide support for the Script, u can reachme at //
//	  	Discord - noctwrnyA#5797									   //
//	  	EPIC 	- noctwrnyA											   //
//	  	PSN		- noctwrnyA											   //
//	  	E-mail 	- noctwrny@gmail.com								   //
/////////////////////////////////////////////////////////////////////////

 					Credits To :
 - SS_Nikolai for sharin some codes n knowledge.
 - DoNotAtMe For Polar Aim Assist
 - TaylorDrift For Customizing DNAM Polar With Shapes
 - Sweet_Evil for his Polar Aim Assist
 - Me lol! noctwrnyA. 

			F	E	A	T	U	R	E	S
========================FORT9===============================
TRACKINMODES V8 ----------------------- [PICKAXE/COMBAT/INVENTORY/MAPVIEW/OPTION]
DEADZONE ---(Circular_Outter)---------- LEFT/RIGHT STICKS
NO-INPUT-LAG -------------------------- DOUBLE SEND ANY INPUT AT THE SAME TIME. (kinda like a "hairBUTTONS").
AIM SENS CORRECTION ------------------- FORT9 OPTIMIZED (u can set different sens for each mode)
HAIR TRIGGERS ------------------------- ADS/FIRE (ADS adjusted for SCOPES WEAPONS)
AIM ASSIST(SHAPE SHIFTER) ------------	ADS-WIDEOVAL / ADS+FIRE-TALLOVAL / FIRE-HELIX (it also track enemies while in combat)
3 AIM ABUSE	--------------------------- only-ADS / ADS+FIRE   -note: for ADS AIM ABUSE, press ADS more than half way-
HEAD SHOT ASSIST ---------------------- flick the aim stick up in search for a headshot
TURN OFF WIRELESS CONTROLLER ---------- R3 + PS (need to power circle the ZEN to reconnect)
BLOCK RUMBLE -------------------------- Block Controller's VIBRATION

// COMBAT || PICKAXE MODS ===========================================
-AIM ABUSE TOGGLE (**)----------------- R1+tapJUMP //AIM ABUSE TOGGLE ON/OFF
-ANTI-RECOIL (**)---------------------- ON by default *adjustment on the fly. //HoldJUMP+tapRIGHT/LEFT/UP/DOWN on the DPAD.
-GHOST SHAKE (**)---------------------- ADS+tapLEFT (releasin ADS will stop it)
-SINGLE-SHOT|RapidFire+AIM-Abuse (**)-- ADS+tapNEXT_WEAPON=Single//ADS+HoldNEXT_WEAPON=RapidFire
-PRIME_SHOT (**)--((NEW))-------------- NEXT_WEAPON+SQUARE //Auto Reload After First Shot
-AUTOPICKUP (*)------------------------ pressSQUARE while in PICKAXE (Auto Pick Up Loot).
-INSTA_PICK (*)------------------------ FIRE+tapSQUARE will go to COMBAT .
//--(**) = ONLY COMBAT MODS -/  ---   /- (*) = ONLY PICKAXE MODS -----\\
		
			- 10-60 PING. (tested)
			- RUNNING AT ( 5 ms ).
		  
////////////////////////////////////////////____________________________________
/////////////////////////////////////////////////////////////////////////////////
						THE SCRIPT START AS ((OFF))

			IF FORT9  // ADS + OPTIONS to turn ON	*PICKAXE mode will display 
	
				TO TURN OFF EVERYTHIN  // ADS + MAPVIEW_B.    (( KILLSWITCH ))
				When SCRIPT OFF (KILLSWITCH)/////////////////////////////////
				-- OLED SCREEN OFF after 8s
				-- CONTROLLER BATTERY NOTIFICATION --
					Green(Bright) 		= When Charging
					Green(Bright/Dim) 	= FULLYCHARGED
					Blue(Dim)  	  		= Excellent|70-100%
					Blue(Dim/Light) 	= Good|40-70%
					Purple(Dim)	  		= Low|20-40% 
					Red(Dim)   	  		= Dying|20% or Less *will rumble*  .

		
*/
////////////////////////////////////MATCH IN-GAME///////////////////////////////////////////////
//COMBAT LAYOUT
define ADS     		= PS4_L2;		//in-game ADS BUTTON
define FIRE     	= PS4_R2;		//in-game FIRE BUTTON
define NEXT_WEAPON 	= PS4_R1;		//in-game NEXT_WEAPON BUTTON
define PREV_WEAPON 	= PS4_L1;		//in-game PREV_WEAPON BUTTON

//MISCELLANEOUS
define PICKAXE 		= PS4_TRIANGLE; //in-game PICKAXE BUTTON
define JUMP     	= PS4_CROSS;	//in-game JUMP BUTTON
define CROUCH   	= PS4_R3;		//in-game CROUCH BUTTON
define INTERACT 	= PS4_SQUARE;	//in-game INTERACT BUTTON
define MAPVIEW_B	= PS4_TOUCH;    //in-game MAP BUTTON
define CIRCLE 		= PS4_CIRCLE; 	//DO NOT CHANGE
define R3		   	= PS4_R3;		//DO NOT CHANGE
define L3		   	= PS4_L3;		//DO NOT CHANGE
init{_NoInputLag();}

//////////////////////////////////////////////////////
///////////////////DO NOT CHANGE /////////////////////
//LAYOUT  
define On  = TRUE;
define Off = FALSE;

define UP     = PS4_UP;    
define DOWN   = PS4_DOWN;   
define LEFT   = PS4_LEFT; 
define RIGHT  = PS4_RIGHT;

define OPTIONS	= PS4_OPTIONS;  
define TOUCHPAD = PS4_TOUCH;
define SHARE 	= PS4_SHARE;
define PS 		= PS4_PS;

    define AIM_X 	= PS4_RX;
    define AIM_Y 	= PS4_RY;
    define LX 		= PS4_LX;
    define LY 		= PS4_LY;
//////////////////////////////////////////////////////
// AIM ASSIST SHAPES variables
// 1 = Circular, 2 = Tall Oval, 3 = Wide Oval, 4 = Spiral, 5 = Helix
int DNAM_Polar; 
define ADS_DNAM_Polar = 2;
define HIPFIRE_DNAM_Polar = 5;
define ADS_FIRE_DNAM_Polar = 3;

define ADS_polar_Values = 35;//21
define ADS_angle_Values = 36;//21

define HIPFIRE_polar_Values = 26;//12
define HIPFIRE_angle_Values = 27;//12

define ADS_FIRE_polar_Values = 40;//28
define ADS_FIRE_angle_Values = 41;//28

define TAP_FIRE_polar_Values = 37;//26
define TAP_FIRE_angle_Values = 38;//26

define Radius_Min = 6;

define Angular_Direction  = Off;
	int _RX,
		_RY, 
		angleee, 
		CosAngle, 
		SinAngle, 
		OuterSpiral, 
		ActualMagnitude,
		AngleDirection,
		SpiralPosition1,
		SpiralPosition2,
		MaxMagnitude, 
		InnerSpiral,
		Polar_Radius,
		Polar_Angle,
		Position;
	const int32 DNAMPolarArray16[] 	  = { 100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100};	
	const int32 DNAMPolarArray8[] 	  = {-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100};


//ENEMY TRACKER
int ENEMY_TRACKER = On;
int _v 		= 17; //Aim Assist STRENGTH Value (Screen Shake)
int Delay 	= 8; //How fast Aim Assist Run
int Release = 18; //Must be 1 higher than STRENGTH
int _strafe = 20;  //STRAFIN for ROTATIONAL Aim Assit
////////////////////////////////////////////////////

//AA ROTATIONAL WHEN FIRE
int ROTATIONAL_AIM = On;
int aa_r_ST = 90; //STRENGH
int aa_r_sp = 8; //SPEED
int tapR = On;
//////////////////_______

//////////////////
//HEAD SHOT ASSIST
int HEADSHOT = On;
int HeadShotStrength = 3;
int HeadShotHoldTime = 1300;
//////////////////__________

////////////////////////
//FOTRT9 - ANTI-RECOIL//
int Anti_Recoil 	= On;
int R2Vertical_v   	= 25; 
int R2Horizontal_v  = -28;
int SmartRumble, 
	AntirecoilStrength;
////////////////////////_______

/////////////////////
//INSTA-PICK
int INSTA_PICK = On;		//WILL GO TO COMBAT AFTER RELEASIN FIRE
////////////////////______

//////////////////////////////////////
//AIM ABUSE
int abADSv 			= 8;// ADS Aim Abuse values 
int Aab1_release 	= 8;

int abFIREv 		= 110;// FIRE Aim Abuse values 
int Aab2_release 	= 30;

int abANFv	 		= 30;// ADS+FIRE Aim Abuse values
int Aab3_release 	= 30;
////////////////////////////////_______________

////////////////////////////////
//GHOST SHAKE
int GHOSTSHAKE;		// help dodge bullets.
int dsdown = 30;     // Time you are down
int dsup   = 115;    // Time you are up
//////////////////////////_______________

///////////////////////////
// BLOCK RUMBLE
int Block_Rumble  = On; 
//Block Controller VIBRATION
//////////////////////______

//////////////////////////////
//FORT9 OPTIMIZED
//AIM SENS CORRECTION
int Sens,
	Actual_Sens = 88,
	AimSensCorrections = On;
define ADS_Sens 		= 66;//ADJUST TO UR LIKIN
define ADS_FIRE_Sens 	= 68;//ADJUST TO UR LIKIN
define ADS_tapFIRE_Sens	= 58;//ADJUST TO UR LIKIN
define HIPFIRE_Sens 	= 76;//ADJUST TO UR LIKIN
define PICK_Sens		= 81;//ADJUST TO UR LIKIN
//////////////////////_________

///////////////////////////
//DEADZONE values//////////////
int DEADZONE	= On;
define DZ_L 	= 8;
define invDZ_L 	= -8;

define DZ_R 	= 8;
define invDZ_R 	= -8;
//////////////////////////________

///////////////////////////////
//HAIR TRIGGERS
int HAIR_TRIGGERS = On;
//////////////////////////_____
//------------------------------------------------------------------------------------------
/////////////////////////////////////////////
//ADS + Hold_R1 RapidFire
  int presses_per_sec    = 40; 
	  /*Higher Number = Slower Rapid Fire
    	Lower Number = Faster Rapid Fire*/
//////////////////////////////////////////////   	  
    	  
//MODES
int PickAxeMode,
	PICKtap;

int CombatMode,
	COMBATtap;

int INVENT,
	P_INVENT,
	C_INVENT,
	B_INVENT,
	E_INVENT,
	SIDEGRADE;

int OPTION,
	OPTIONStap,
	OPTIONStap2,
	P_OPTION,
	C_OPTION;

int MAPVIEW,
	MAPtap,
	P_MAP,
	C_MAP;

//--  --//
int Fort9,
	F_AimAssist,
	AIM_ABUSE,
	F_MACRO1,
	//F_MACROS,
	PRIMESHOT,
	goCOMBAT,
	AutoPickUp,
	SmartF, SmartF2;


///////////////////////////////////////////////////////////////////////
	int Display_Black,
		count_black;
	int ZENOLED = On; //Only for Cronus ZEN. turn OFF for Cronus Max, TITAN 1 ....
	
// Text to display
	const string TITLE = "noctwrnyA's";
	const string Script = "ScriptV15"; 
	const string NoBUILD = "noBUILD";
	const string KillSwitch = " OFF";
	//Action Trackin
		const string CombatModeOLED = "COMBAT";
		const string PickAxeModeOLED = "PICKAXE";
		const string INVENT_OLED = "INVENTO";
		const string MAPVIEW_OLED = "MAPVIEW";
		const string OPTIONS_OLED = "OPTIONS";
		
////////////////////////////////////////////////////////////////////////// 

main {
    
      vm_tctrl(-5);
     _MODMENUTOGGLE();
     _ledBATTERY(); //LED BATTERY NOTIFICATION END
     if(ZENOLED) { _ZENOLED(); }
     if(DEADZONE){_DEADZONE();}
     if(Fort9 && AimSensCorrections){_AimSensCorrections();}
     if(get_ival(TOUCHPAD) && event_press(PS)){set_val(PS,0);turn_off();Fort9=Off;}
     if(Fort9 && Block_Rumble){block_rumble();}
	 if(get_console() == PIO_XB360 && get_controller() == PIO_PS4) {    
        swap(PS4_TOUCH,PS4_SHARE);}
        	 
     
//IF FORT9 
if(Fort9) {
	
	_TrackinMODESv8();

if(!PickAxeMode && CombatMode){
	
	AutoPickUp = Off;
	
////////////////////////////////////
if(HAIR_TRIGGERS){

//HAIR TRIGGERS
	//LEFT TRIGGER
	if(abs(get_ival(ADS)) > 10){
		set_val(ADS, 40);}
		if(abs(get_ival(ADS)) > 80){
			set_val(ADS, 100);
}
	//RIGHT TRIGGER
	if(abs(get_ival(FIRE)) > 10){
		set_val(FIRE, 40);}
		if(abs(get_ival(FIRE)) > 80){
			set_val(FIRE, 100);
}
}//IF HAIRTRIGGERS END
/////////////////////////////////////

//ENEMY TRACKER ////////////////////////////////////
	if(ENEMY_TRACKER){
		combo_run(cENEMY_TRACKER);
		}
		if(get_ival(INTERACT) || get_ival(FIRE) || 
			abs(get_ival(AIM_Y)) > 25 || abs(get_ival(AIM_X)) > 25){
			combo_stop(cENEMY_TRACKER);
			
}//ENEMY TRACKER END /////////////////////////////////
	
if(F_AimAssist){
		
		if(abs(get_val(AIM_X)) <= 10)
			set_val(AIM_X, 0); 
		if(abs(get_val(AIM_Y)) <= 10)
			set_val(AIM_Y, 0);

		if(Angular_Direction)	{
			AngleDirection = (get_val(AIM_X) > 0);
			}

		_RX = get_val(AIM_X);
		_RY = get_val(AIM_Y);
		
		ActualMagnitude = isqrt(pow(_RX, 2) + pow(_RY, 2));
		MaxMagnitude    = (ActualMagnitude < 100);

		angleee += Polar_Angle;
		angleee = angleee % 360;
		CosAngle = DNAMPolarArray8[(angleee + 270) % 360];
		SinAngle = DNAMPolarArray16[angleee % 360];
	
	//ADS POLAR AIM ASSIST
	if(get_ival(ADS) && !get_ival(NEXT_WEAPON) || 
		get_ival(ADS) && !get_ival(FIRE)) {
		
		DNAM_Polar = ADS_DNAM_Polar;
		Polar_Radius = ADS_polar_Values;
		Polar_Angle  = ADS_angle_Values;
		if(ActualMagnitude < Polar_Radius)
			{
				SinAngle -= _RY;
				CosAngle -= _RX;
			}
			else
			{
				SinAngle = (SinAngle * (200 - ((abs(_RY) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
				CosAngle = (CosAngle * (200 - ((abs(_RX) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
			}
		GetShapes(Polar_Radius);
		
/////////////////////////////////////////////////		
	if(AIM_ABUSE && !get_val(FIRE) && 
		!get_val(NEXT_WEAPON) && get_ival(ADS) >= 96){
			
		combo_run(cAAbuseADS);
		}
		else {combo_stop(cAAbuseADS);}
//////////////////////////////////////////////////	

}//IF ADS POLAR END

/////////////////////////////////////////////
	//ADS N' FIRE POLAR AIM ASSIST
	if(get_ival(ADS) && get_ival(FIRE) && !get_ival(NEXT_WEAPON)) {
		
		DNAM_Polar = ADS_FIRE_DNAM_Polar;
		Polar_Radius = ADS_FIRE_polar_Values;
		Polar_Angle  = ADS_FIRE_angle_Values;
		
		if(ActualMagnitude < Polar_Radius)
			{
				SinAngle -= _RY;
				CosAngle -= _RX;
			}
			else
			{
				SinAngle = (SinAngle * (200 - ((abs(_RY) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
				CosAngle = (CosAngle * (200 - ((abs(_RX) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
			}
		GetShapes(Polar_Radius);
/////////////////////////////////////////////////		
	if(AIM_ABUSE && !get_val(NEXT_WEAPON) && 
		get_val(ADS) && get_ival(FIRE) >= 96){
			
		combo_run(cAAbuseADS_FIRE);
		combo_stop(cAAbuseADS);
		}
		else {combo_stop(cAAbuseADS_FIRE);}
//////////////////////////////////////////////////		
}//IF FIRE POLAR END


/////////////////////////////////////////////
	//HIPFIRE POLAR AIM ASSIST
	if(get_ival(FIRE) && !get_ival(ADS)) {
		
		DNAM_Polar = HIPFIRE_DNAM_Polar;
		Polar_Radius = HIPFIRE_polar_Values;
		Polar_Angle  = HIPFIRE_angle_Values;
		
		if(ActualMagnitude < Polar_Radius)
			{
				SinAngle -= _RY;
				CosAngle -= _RX;
			}
			else
			{
				SinAngle = (SinAngle * (200 - ((abs(_RY) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
				CosAngle = (CosAngle * (200 - ((abs(_RX) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
			}
		GetShapes(Polar_Radius);
////////////////////////////////////////////_________

///////////////////////////////////////////////////////		
		if(ROTATIONAL_AIM && tapR){
			combo_stop(cAA_ROTATIONAL_FIRE2);
			combo_run(cAA_ROTATIONAL_FIRE1);
			}
			else{combo_stop(cAA_ROTATIONAL_FIRE1);
				 combo_run(cAA_ROTATIONAL_FIRE2);
				 }
////////////////////////////////////////////////////_____
		
/////////////////////////////////////////////////		
	if(AIM_ABUSE && !get_ival(ADS) && 
		get_ival(FIRE) >= 96){
			
		combo_run(cAAbuseFIRE);
		combo_stop(cAAbuseADS_FIRE);
		}
		else {combo_stop(cAAbuseFIRE);}
/////////////////////////////////////////_______
}//IF HIPFIRE POLAR END
	
	
}//IF F_AimAssist END


if(F_MACRO1) {
//SINGLE / RAPID FIRE * aka 100% accuracy * plus AIM Assist & AIM Abuse.
	if(get_val(ADS)){
		
		set_val(NEXT_WEAPON, 0);
			
		if(get_ival(NEXT_WEAPON)) {
	
			DNAM_Polar = ADS_FIRE_DNAM_Polar;
			Polar_Radius = TAP_FIRE_polar_Values;
			Polar_Angle  = TAP_FIRE_angle_Values;
			
			SmartF  = 35; //40
			SmartF2 = 120; //100
					
			combo_run(cPerfectAccuracy);
			combo_suspend(cRapidFire);
			
			if(AIM_ABUSE){combo_run(cAAbuseFIRE);}
		}		
		if(combo_running(cPerfectAccuracy) && event_press(NEXT_WEAPON) 
			&& get_ptime(NEXT_WEAPON) > 18){ 
			
				set_val(NEXT_WEAPON, 0);
		
				DNAM_Polar = ADS_FIRE_DNAM_Polar;
				Polar_Radius = TAP_FIRE_polar_Values;
				Polar_Angle  = TAP_FIRE_angle_Values;
				
				combo_suspend(cPerfectAccuracy);
				combo_stop(cAAbuseADS);
				combo_run(cRapidFire);
				if(AIM_ABUSE){combo_run(cAAbuseFIRE);}
				}

	}//IF ADS END
	
////////////////////////////////////////////////////

//ANTIRECOIL - START
	if(Anti_Recoil){
	
		if(get_ival(ADS) && event_press(NEXT_WEAPON) && 
				get_ptime(NEXT_WEAPON) < 15){
				set_val(NEXT_WEAPON, 0);
				R2Horizontal_v = -18;
				}
		if(get_ival(ADS) && get_ival(FIRE) ||
			get_ival(ADS) && event_press(NEXT_WEAPON) && 
			get_ptime(NEXT_WEAPON) <= 90){
		
			SmartRumble = get_rumble(RumbleToUse());

		if(SmartRumble > 10 && SmartRumble < 80){
			AntirecoilStrength = R2Vertical_v + SmartRumble / 2;
          	}

       	if(SmartRumble < 10){
	        Set_Val(AIM_Y, R2Vertical_v);
	        Set_Val(AIM_X, R2Horizontal_v);
	        }
          	else{
	             Set_Val(AIM_Y, AntirecoilStrength);
	             Set_Val(AIM_X, R2Horizontal_v);
	             }
    	}
     	AntirecoilStrength  = 0;
     	SmartRumble         = 0;
      	
	//ANTI-RECOIL CHANGE ON FLY
	if (get_ival(JUMP) && get_ptime(JUMP) >= 600) {
                
        set_val(UP, 0);
        set_val(DOWN, 0);
        set_val(LEFT, 0);
        set_val(RIGHT, 0);
                
	    if (event_press(DOWN)) {
	            	
	         R2Vertical_v = clamp(R2Vertical_v++,1,50);
	         combo_run(cRumbleTwice);
	         }
	    if (event_press(UP)) {
	            	
	         R2Vertical_v = clamp(R2Vertical_v--,1,50);
	         combo_run(cRumbleOnce);
	         }
	    if (event_press(RIGHT)) {
	            	
	         R2Horizontal_v = clamp(R2Horizontal_v++,1,50);
	         combo_run(cRumbleTwice);
	         }
	    if (event_press(LEFT)) {
	            	
	         R2Horizontal_v = clamp(R2Horizontal_v--,1,50);
	         combo_run(cRumbleOnce);
	         }
                
}	//ANTI-RECOIL CHANGE ON FLY
}	//ANTIRECOIL - END

////////////////////////////////////////
//--HEADSHOT ASSIST - START
	if(HEADSHOT){
	   
		_RY = inv(HeadShotStrength);

		if(get_ival(FIRE) && get_ptime(FIRE) < HeadShotHoldTime){
			
			Set_Val(AIM_Y, _RY);	
			}
	}//--HEADSHOT ASSIST - END
/////////////////////////////////////////

//GHOST SHAKE 
		if(CombatMode && get_val(ADS) && get_val(LEFT)) {	
    		GHOSTSHAKE = On;
    		set_val(LEFT,0); 
    		combo_run(cENEMYPING);
		}
    	  	if(GHOSTSHAKE) { 
    	  	
    	  		combo_run(cGHOSTSHAKE);
    	  		if(GHOSTSHAKE && event_release(ADS)) {
		
					GHOSTSHAKE = Off;
					combo_stop(cGHOSTSHAKE);
					}
			}
////////////////////////////////////////
	
		//////////////////////////////////
		//PRIME SHOTGUN MOD
    	if(get_ival(NEXT_WEAPON) && event_press(INTERACT)) {	
    
    		set_val(INTERACT,0);
        	PRIMESHOT = On;
		} 
		else if(PRIMESHOT && event_press(PREV_WEAPON) || 
				event_press(NEXT_WEAPON) || event_press(PICKAXE) || 
				event_press(CIRCLE)){
				PRIMESHOT = Off;
				}
		//PRIME SHOTGUN MOD //////////////////////////////////////
		if(PRIMESHOT && get_val(FIRE)){combo_run(cPRIMESHOT);}
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////

		//AIM ABUSE TOGGLE
		if(get_val(NEXT_WEAPON) && event_press(JUMP)) {	
    
    		AIM_ABUSE = !AIM_ABUSE;
} 
/////////////////////////////////////////////////////////
			
} //IF F_MACRO1 END

}	//IF COMBATMODE END

////////////////////////
//IF ONLY PICKAXE MODE
if(F_MACRO1 && !CombatMode && PickAxeMode){

	////////////////////////////
	//AUTO PICK UP LOOT
	if(!get_ival(FIRE) && get_ival(INTERACT)) {AutoPickUp = On;}
		
		if(AutoPickUp && event_release(INTERACT)) {combo_run(cAutoPickUp);}
		
		if(!PickAxeMode && event_press(PREV_WEAPON) || 
			event_press(NEXT_WEAPON)) {
	 
		 	AutoPickUp = Off;
		 	combo_stop(cAutoPickUp);
		 	}
/////////////////////////////////////////////////////////////_____________		 	

///////////////////////////////////////////////
//INSTA PICK
if(INSTA_PICK) {
                    
    if(PickAxeMode && get_ival(FIRE) && event_press(INTERACT)) {
        set_val(INTERACT, 0);
        goCOMBAT = On;
        }
        if(PickAxeMode && goCOMBAT &&
            event_release(FIRE)){
                combo_run(cgoCOMBAT);
                
            if(event_press(CIRCLE) || 
            	event_press(PICKAXE) || 
            	event_press(NEXT_WEAPON) || 
            	event_press(PREV_WEAPON)) { 
                goCOMBAT = Off;
                }
                
         }
         
}//IF INSTA-PICK END
/////////////////////////////////////

}//IF ONLY F_MACRO1 PICKAXE MODE
/////////////////////////_________________


}//IF FORT9 END

} //IF MAIN END

combo cENEMY_TRACKER { 
	    
	  	set_val(AIM_Y,xy_val(AIM_Y, _v)); 
		wait(Delay);
		set_val(AIM_X,xy_val(AIM_X, _v)); 
		set_val(LX,xy_val(LX, _strafe));
		wait(5);
		set_val(LY,xy_val(LY, _strafe));
		wait(Delay); 
		set_val(AIM_Y,xy_val(AIM_Y, _v * -1)); 
		wait(Delay);
		set_val(AIM_X,xy_val(AIM_X, _v * -1)); 
		set_val(LX,xy_val(LX, _strafe * -1)); 
		wait(5);
		set_val(LY,xy_val(LY, _strafe * -1)); 
		wait(Delay);
}

combo cAAbuseADS {		
	
	set_val(ADS, 0);
	wait(abADSv);
	wait(450);
	set_val(ADS, 100);
	wait(Aab1_release);
}
combo cAAbuseFIRE {		
	
	set_val(ADS, 100);
	wait(abFIREv);
	set_val(ADS, 0);
	wait(Aab2_release);
}
combo cAAbuseADS_FIRE {		
	
		call(cWAIT);
	set_val(ADS, 0);
	wait(abANFv);
	wait(450);
	set_val(ADS, 100);
	wait(Aab3_release);
}

combo cAA_ROTATIONAL_FIRE1 {
	Set_Val(LX, aa_r_ST); //to the RIGHT
	wait(aa_r_sp);
	Set_Val(LY, aa_r_ST); //to the BACK
	wait(aa_r_sp);
	Set_Val(LX, -aa_r_ST); //to the LEFT
	wait(aa_r_sp);
	Set_Val(LY, -aa_r_ST); //to the FRONT
	wait(aa_r_sp);
	tapR = Off;
}
combo cAA_ROTATIONAL_FIRE2 {
	Set_Val(LX, -aa_r_ST); //to the LEFT
	wait(aa_r_sp);
	Set_Val(LY, -aa_r_ST); //to the RIGHT
	wait(aa_r_sp);
	Set_Val(LX, aa_r_ST); //to the RIGHT
	wait(aa_r_sp);
	Set_Val(LY, aa_r_ST); //to the RIGHT
	wait(aa_r_sp);
	tapR = On;
}

combo cRapidFire {
    set_val(FIRE, 100);
    wait(560 / presses_per_sec);
    set_val(FIRE, 0);
    wait(560 / presses_per_sec - get_rtime());
    set_val(FIRE, 0);
}

combo cPerfectAccuracy {
	
	set_val(FIRE,100);
	wait(SmartF);
	wait(SmartF2);
}


combo cPRIMESHOT {
	wait(100);
    set_val(INTERACT,100);
    wait(40);
}

//////////////////
//End of Aim Combo

combo cgoCOMBAT {
    
    wait(12);
    set_val(PICKAXE, 100);
    wait(12);
    set_val(PICKAXE, 0);
    CombatMode = On;
    COMBATtap = On;
}

combo cENEMYPING {

	set_val(LEFT, 100);		//ENEMY PING
    wait(8);
    set_val(LEFT, 0);
    wait(8);
    set_val(LEFT, 100);
}

combo cGHOSTSHAKE{
	
	set_val(CROUCH,100);
	wait(dsdown);
	wait(dsup);
	set_val(CROUCH,0);
}

combo cAutoPickUp {               

	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
	set_val(INTERACT, 100);
	wait(8);
	set_val(INTERACT, 0);
	wait(8);
}

combo cWAIT {
	
	wait(8);
	wait(8);
}

//////////////////////////////////////////
//RUMBLE
combo cRumbleOnce {
    
    set_rumble(RUMBLE_A, 100);
    wait(250);
    reset_rumble();
}
combo cRumbleTwice {
    
    set_rumble(RUMBLE_A, 100);
    wait(250);
    set_rumble(RUMBLE_A, 0);
    wait(250);
    set_rumble(RUMBLE_A, 100);
    wait(250);
    reset_rumble();
}
combo cBatteryRumble {
    
    set_rumble(RUMBLE_A, 5);
    set_rumble(RUMBLE_B, 5);
    wait(250);
    reset_rumble();
}
//////////////////////////////


function _MODMENUTOGGLE () {
//FORTNITE ADS+OPTIONS
	if(get_val(ADS)) {
		
		if(get_val(OPTIONS)) {
			set_val(OPTIONS, 0);
			set_led(LED_1, 1);
			set_led(LED_2, 0);
			set_led(LED_3, 0);
			set_led(LED_4, 0);	
			Fort9 = On;
			PickAxeMode = On;
			PICKtap = On;
			ZENOLED = On;
			combo_run(cRumbleOnce);
			//printf("PICKAXE-Mode");
			}
		//ADS+TOUCH ((KILLSWITCH))
		if(get_val(MAPVIEW_B)) {
			set_val(MAPVIEW_B, 0);
			Fort9 = Off;
			PickAxeMode = Off;
			PICKtap = Off;
			CombatMode = Off;
			COMBATtap = Off;
			INVENT = Off;
			P_INVENT = Off;
			C_INVENT = Off;
			B_INVENT = Off;
			E_INVENT = Off;
			OPTION = Off;
			C_OPTION = Off;
			P_OPTION = Off;
			OPTIONStap = Off;
			MAPVIEW = Off;
			MAPtap = Off;
			ZENOLED = On;
			combo_run(cRumbleTwice);
			//printf("KillSwitch - SCRIPT is OFF");
			}
}//IF ADS END
}// Function _MODMENUTOGGLE END

function _TrackinMODESv8() {
	
if(!MAPVIEW && !INVENT && !OPTION){
///////////////////////////////////
//// PICKAXE || COMBAT MENU //////////

 	if(PickAxeMode  && PICKtap && event_press(PICKAXE)){
		
		set_val(PICKAXE,0);
		PickAxeMode = Off;
		PICKtap = Off;
		goCOMBAT = Off;
		CombatMode = On;
		COMBATtap = On;
		//printf("COMBAT-Mode");
		}
		else if(CombatMode && COMBATtap && event_press(PICKAXE)){
		
				set_val(PICKAXE,0);
				CombatMode = Off;
				COMBATtap = Off;
				goCOMBAT = Off;
				PickAxeMode = On;
				PICKtap = On;
				if(AimSensCorrections){
					Sens = PICK_Sens;}
				//printf("PICKAXE-Mode");
				}
				else if(PickAxeMode && goCOMBAT && event_release(FIRE)){
			
						combo_run(cgoCOMBAT);
						PickAxeMode = Off;
						PICKtap = Off;
						goCOMBAT = Off;
						CombatMode = On;
						COMBATtap = On;
						//printf("COMBAT-Mode");
						}

///////////////////////////////////////////////////////////////
if(PickAxeMode || CombatMode) {
 
	if(event_press(PREV_WEAPON) || event_press(NEXT_WEAPON)) {

		PickAxeMode = Off;
		PICKtap = Off;
		CombatMode = On;
		COMBATtap = On;
		//printf("COMBAT-Mode");
		} 
		
}//IF PickAxeMode || CombatMode END


}//IF !MAPVIEW && !INVENT && !OPTION END

//// MAPVIEW MENU ////////////////////
if(PickAxeMode && !P_MAP && !MAPtap && event_press(MAPVIEW_B)){
	
	PickAxeMode = Off;
	PICKtap = Off;
	MAPVIEW = On;
    MAPtap = On;
    P_MAP = On;
	//printf("MAPVIEW-Mode");
    }
    else if(MAPVIEW && MAPtap && P_MAP && event_press(MAPVIEW_B)){
     		
     		MAPVIEW = Off;
		    MAPtap = Off;
		    P_MAP = Off;
		    PickAxeMode = On;
     		PICKtap = On;
     		if(AimSensCorrections){
				Sens = PICK_Sens;}
			//printf("PICKAXE-Mode");
     		}
	     	else if(MAPVIEW && P_MAP && event_press(CIRCLE)){
		     		
		     		MAPVIEW = Off;
				    MAPtap = Off;
				    P_MAP = Off;
				    PickAxeMode = On;
		     		PICKtap = On;
		     		if(AimSensCorrections){
						Sens = PICK_Sens;}
					//printf("PICKAXE-Mode");
		     		}
	if(CombatMode && !C_MAP && !MAPtap && event_press(MAPVIEW_B)){
     	
     	CombatMode = Off;
     	COMBATtap = Off;
     	MAPVIEW = On;
     	MAPtap = On;
     	C_MAP = On;
		//printf("MAPVIEW-Mode");
     	}
     	else if(MAPVIEW && C_MAP && MAPtap && event_press(MAPVIEW_B)){
     			MAPVIEW = Off;
		     	MAPtap = Off;
		     	C_MAP = Off;
		     	CombatMode = On;
     			COMBATtap = On;
				//printf("COMBAT-Mode");
     			}
	     		else if(MAPVIEW && C_MAP && event_press(CIRCLE)){
		     			MAPVIEW = Off;
				     	MAPtap = Off;
				     	C_MAP = Off;
				     	CombatMode = On;
		     			COMBATtap = On;
						//printf("COMBAT-Mode");
		     			}
 // MAPVIEW MENU END
///////////////////////////

//////////////////////////////////////////
/////////////INVENTORY MENU////////////
if(!OPTION && !get_val(JUMP)){
		
	if(PickAxeMode && !P_INVENT && event_press(UP)){
		
		PickAxeMode = Off;
		PICKtap = Off;
		INVENT = On;
     	P_INVENT = On;
		SIDEGRADE = Off;
		//printf("INVENTORY-Mode");
     	}
     	else if(INVENT && P_INVENT && event_press(CIRCLE)){
     			
     			INVENT = Off;
     			P_INVENT = Off;
     			PickAxeMode = On;
     			PICKtap = On;
     			if(AimSensCorrections){
					Sens = PICK_Sens;}
				//printf("PICKAXE-Mode");
     			}
	if(CombatMode && COMBATtap && !C_INVENT && event_press(UP)){
     	
     	CombatMode = Off;
     	COMBATtap = Off;
     	INVENT = On;
     	C_INVENT = On;
		SIDEGRADE = Off;
		//printf("INVENTORY-Mode");
     	}
     	else if(INVENT && C_INVENT && event_press(CIRCLE)){
     			
     			INVENT = Off;
     			C_INVENT = Off;
     			CombatMode = On;
     			COMBATtap = On;
				//printf("COMBAT-Mode");
     			}
		if(INVENT && event_release(NEXT_WEAPON)){
			SIDEGRADE = On;
			INVENT = On;
			}
			if(SIDEGRADE){
				if(INVENT && C_INVENT || INVENT && P_INVENT){
					if(event_press(INTERACT)){
						SIDEGRADE = Off;
						INVENT = Off;
						P_INVENT = Off;
						C_INVENT = Off;
						CombatMode = On;
						COMBATtap = On;
						//printf("COMBAT-Mode");
						}
					}
				}
	
} //!PickAxeMode && !OPTION && !CROSS END
////////////////////////////////////////////////////

//////////////////////////////////////////
///////////// OPTION MENU ////////////
if(!get_val(ADS)){
		
	if(PickAxeMode && PICKtap && !P_OPTION && !OPTIONStap2 && event_press(OPTIONS)){
		
     	PickAxeMode = Off;
     	PICKtap = Off;
     	P_OPTION = On;
     	OPTION = On;
     	OPTIONStap2 = On;
     	OPTIONStap = Off;
		//printf("OPTIONS-Mode");
	    }
     	else if(OPTION && OPTIONStap2 && P_OPTION && event_press(OPTIONS) || 
     				OPTION && OPTIONStap && P_OPTION && event_press(OPTIONS) || 
     				OPTION && !OPTIONStap2 && P_OPTION && event_press(CIRCLE)) {
     			
     			OPTION = Off;
	     		OPTIONStap = Off;
	     		OPTIONStap2 = Off;
	     		P_OPTION = Off;
	     		PickAxeMode = On;
	     		PICKtap = On;
				//printf("PICKAXE-Mode");
	     		}
	     		else if(OPTION && OPTIONStap2 && P_OPTION && event_press(CIRCLE) ||
	     				OPTION && OPTIONStap2 && P_OPTION && event_press(JUMP)) {
	
						OPTIONStap2 = Off;
				     	OPTION = On;
				     	OPTIONStap = On;
				     	P_OPTION = On;
						//printf("OPTIONS-Mode");
				     	}
	if(CombatMode && COMBATtap && !C_OPTION && !OPTIONStap2 && event_press(OPTIONS)){
     	
     	CombatMode = Off;
     	COMBATtap = Off;
     	C_OPTION = On;
     	OPTION = On;
     	OPTIONStap2 = On;
		//printf("OPTIONS-Mode");
     	}
     	else if(OPTION && OPTIONStap2 && C_OPTION && event_press(OPTIONS) || 
     				OPTION && OPTIONStap && C_OPTION && event_press(OPTIONS) || 
     				OPTION && !OPTIONStap2 && C_OPTION && event_press(CIRCLE)) {
     			
     			OPTION = Off;
	     		OPTIONStap = Off;
	     		OPTIONStap2 = Off;
	     		C_OPTION = Off;
	     		CombatMode = On;
	     		COMBATtap = On;
				//printf("COMBAT-Mode");
	     		}
				else if(OPTION && OPTIONStap2 && C_OPTION && event_press(CIRCLE) ||
						OPTION && OPTIONStap2 && C_OPTION && event_press(JUMP)) {
		
					OPTION = On;
			     	OPTIONStap = On;
			     	OPTIONStap2 = Off;
			     	C_OPTION = On;
					//printf("OPTIONS-Mode");
			     	}
		
} //!ADS END
   
}//FUNCTION TRACKINMODES END

function _ledBATTERY() {

//BATTERY LEVEL START
//1 blue	//0			//0			//0
//0			//1 red		//0			//0
//0			//0			//1 green	//0
//0			//0			//0			//1 purple

if( get_battery() >= 11 )  { // equal or greater than  100% battery (CHARGING)
        // GREEN bright
        set_led(LED_1, 0);
        set_led(LED_2, 0);
        set_led(LED_3, 3);
        set_led(LED_4, 0);
}
else if( get_battery() >= 9 && get_battery() < 10)  { // greater than  90% battery (FULLYCHARGED)
	        // GREEN
	        set_led(LED_1, 0);
	        set_led(LED_2, 0);
	        set_led(LED_3, 1);
	        set_led(LED_4, 0);
}
else if( get_battery() >= 7 && get_battery() < 9 )  { // greater than or equal to 70|90% battery (EXCELLENT)
	        // BLUE
	        set_led(LED_1, 1);
	        set_led(LED_2, 0);
	        set_led(LED_3, 0);
	        set_led(LED_4, 0);
}
else if( get_battery() >= 4 && get_battery() < 7 ) { // between 40|70% battery (GOOD)
	        // SKYBLUE
	        set_led(LED_1, 1); 
	        set_led(LED_2, 0);
	        set_led(LED_3, 1);  
	        set_led(LED_4, 0);
}
else if( get_battery() > 2 && get_battery() < 4 ) { // between 20|40% battery (LOW)
	        // PURPLE
	        set_led(LED_1, 0);
	        set_led(LED_2, 0);
	        set_led(LED_3, 0);
	        set_led(LED_4, 1);
        
}
if( get_battery() <= 2 ) { // less than or equal to 20% battery (DYING)
	        // RED
	        set_led(LED_1, 0);
	        set_led(LED_2, 1);
	        set_led(LED_3, 0);
	        set_led(LED_4, 0);
        
        if( get_battery() <= 1 ) {

            combo_run(cBatteryRumble);
} 
} //BATTERY LEVEL END

}

function _ZENOLED (){

					//PICKAXEMODE ON
					if(PickAxeMode == On) {
						PickAxeMode = On;
						PICKtap = On;
						//F_MACROS 	= On;
						set_led(LED_1, 2);//BLUE
						set_led(LED_2, 0);
						set_led(LED_3, 0);
						set_led(LED_4, 0);
						
						cls_oled(0);	// clear OLED screen
    					print(8, 25, 2, 1, PickAxeModeOLED[0]);
						
}
					//COMBATMODE
				else if(CombatMode == On) {
						CombatMode = On;
						COMBATtap = On;
						F_AimAssist = On;
						//F_MACROS 	= On;
						F_MACRO1 	= On;
						set_led(LED_1, 0);
						set_led(LED_2, 1);//BRIGHT
						set_led(LED_3, 2);//GREEN
						set_led(LED_4, 0);
						
						cls_oled(0);	// clear OLED screen
    					print(16, 25, 2, 1, CombatModeOLED[0]);
   						
}

					//INVENT ON
				else if(P_INVENT || C_INVENT || B_INVENT || E_INVENT) {
						INVENT = On;
						set_led(LED_1, 0);
						set_led(LED_2, 1);
						set_led(LED_3, 0);
						set_led(LED_4, 0);
						
						cls_oled(0);	// clear OLED screen
    					print(6, 25, 2, 1, INVENT_OLED[0]);
}
					//MAPVIEW ON
				else if(P_MAP || C_MAP) {
						MAPVIEW = On;
						MAPtap = On;
						set_led(LED_1, 0);
						set_led(LED_2, 1);
						set_led(LED_3, 0);
						set_led(LED_4, 0);
						
						cls_oled(0);	// clear OLED screen
    					print(8, 25, 2, 1, MAPVIEW_OLED[0]);
}

					//OPTIONS ON
				else if(C_OPTION || P_OPTION) {
						OPTION = On;
						OPTIONStap = On;
						set_led(LED_1, 0);
						set_led(LED_2, 2);
						set_led(LED_3, 0);
						set_led(LED_4, 2);
						
						cls_oled(0);	// clear OLED screen
    					print(6, 25, 2, 1, OPTIONS_OLED[0]);
}
          			
					
				if(Fort9 == Off) {
	    				F_AimAssist = Off;
						//F_MACROS 	= Off;
						F_MACRO1 	= Off;
						
	    				cls_oled(0);	// clear OLED screen
	    				print(5, 5, 1, 1, TITLE[0]);
	   					print(65, 28, 0, 1, Script[0]);
	    		    	print(70, 40, 0, 0, NoBUILD[0]);
	    		    	print(0, 27, 2, 1, KillSwitch[0]);
	    		    	_ledBATTERY();
                                                       
						Display_Black = On;
    		    		if(Display_Black){                            
         					count_black += get_rtime();

							if(count_black >= 9000){ 
								ZENOLED = Off;
								cls_oled(0);         
								count_black = 0; 	      	      
          		      
}} //DISPLAY BLACK END
} //IF FORTNITE IS OFF END (KILLSWITCH)

}

//ANTI-RECOIL FUCTIONS ////////////////////////////////////
function Set_Val(Stick, Value) {
    set_val(Stick, clamp(Value * (100 - abs(get_val(Stick)))
    	/ 100 + get_val(Stick), -100, 100));
        return;
}

function RumbleToUse() {
    if(get_rumble(RUMBLE_A) == get_rumble(RUMBLE_B)){
       return RUMBLE_A;
    }
    if(get_rumble(RUMBLE_A) == 100){
       return RUMBLE_B;
    }
    if(get_rumble(RUMBLE_B) == 100){
       return RUMBLE_A;
    }
    if(get_rumble(RUMBLE_A) > get_rumble(RUMBLE_B)){
       return RUMBLE_A;
    }
    if(get_rumble(RUMBLE_B) > get_rumble(RUMBLE_A)){
       return RUMBLE_B;
    }
    return 0;
}
//////////////////////////////////////////////

function xy_val(f_axis,f_val) { 
	
	if(abs(get_val(f_axis)) < Release) 
	
		return f_val; 
		return get_val(f_axis); 
} 

function GetShapes(f_var) {
    if(!SpiralPosition1)
	{
		InnerSpiral -= 1;
		if(InnerSpiral < Radius_Min)
			SpiralPosition1 = TRUE;
	}
	else
	{
	    InnerSpiral += 1;
		if(InnerSpiral > f_var)
			SpiralPosition1 = FALSE;
	}
	if(!SpiralPosition2)
	{
		OuterSpiral -= 1;
		if(OuterSpiral < Radius_Min)
			SpiralPosition2 = TRUE;
	}
	else
	{
		OuterSpiral += 1;
		if(OuterSpiral >  f_var)
			SpiralPosition2 = FALSE;
	}
	if(DNAM_Polar == 1) {
        
        if(AngleDirection) {

        	_RX = (get_val(AIM_X))  + ( (SinAngle * f_var) ) / 100;
            _RY = (get_val(AIM_Y))  + ( (CosAngle * f_var) ) / 100;
        	}
        else {
        		_RY = (get_val(AIM_Y))  + ( (SinAngle * f_var) ) / 100;
        		_RX = (get_val(AIM_X))  + ( (CosAngle * f_var) ) / 100;
				}
	}
	if(DNAM_Polar == 2) {
        
        if(AngleDirection) {

        	_RX = (get_val(AIM_X))  + ( (SinAngle * Radius_Min) ) / 100;
            _RY = (get_val(AIM_Y))  + ( (CosAngle * f_var) ) / 100;
        	}
        else {
        		_RY = (get_val(AIM_Y))  + ( (SinAngle * f_var) ) / 100;
        		_RX = (get_val(AIM_X))  + ( (CosAngle * Radius_Min) ) / 100;
				}
	}
	if(DNAM_Polar == 3) {
        
        if(AngleDirection) {

        	_RY = (get_val(AIM_Y))  + ( (CosAngle * Radius_Min) ) / 100;
        	_RX = (get_val(AIM_X))  + ( (SinAngle * f_var) ) / 100;
            }
        else {
        		_RX = (get_val(AIM_X))  + ( (CosAngle * f_var) ) / 100;
        		_RY = (get_val(AIM_Y))  + ( (SinAngle * Radius_Min) ) / 100;
				}
	}
	if(DNAM_Polar == 4) {
        
        if(AngleDirection) {

        	_RX = (get_val(AIM_X))  + ( (SinAngle * OuterSpiral) ) / 100;
            _RY = (get_val(AIM_Y))  + ( (CosAngle * InnerSpiral) ) / 100;
        }
        else {
        		_RY = (get_val(AIM_Y))  + ( (SinAngle * InnerSpiral) ) / 100;
        		_RX = (get_val(AIM_X))  + ( (CosAngle * OuterSpiral) ) / 100;
				}
	}
    if(DNAM_Polar == 5)
	{
		if(Position == 0 || Position == 1)
    	{
		    _RX = (get_val(AIM_X))  + ( (CosAngle * f_var) ) / 100;
		}
	    if(Position == 2 || Position == 3)
		{
		    _RY = (get_val(AIM_Y))  + ( (SinAngle * f_var) ) / 100;
		}
			Position++;

		if(Position == 4)
		{
			Position = 0;
		}
    }
    set_val(AIM_X, _RX);
	set_val(AIM_Y, _RY);
}


////////////////////////
//AIM SENS CORRECTION 
function _AimSensCorrections(){
	//AIM SENS CORRECTION - START
	
		
		if(!PickAxeMode){
		if(CombatMode){
		if(!get_ival(ADS) && !get_ival(FIRE) && 
			!get_ival(NEXT_WEAPON) && !get_ival(PREV_WEAPON)){
			
			Sens = Actual_Sens;
			}
		else if(get_ival(ADS) && !get_ival(FIRE)){
				
				Sens = ADS_Sens;
				}
		else if(!get_ival(ADS) && get_ival(FIRE)){
				
				Sens = HIPFIRE_Sens;
				}
		else if(get_ival(ADS) && get_ival(FIRE)){
				
				Sens = ADS_FIRE_Sens;
				}
		else if(get_ival(ADS) && get_ival(NEXT_WEAPON)){
				
				Sens = ADS_tapFIRE_Sens;
				}		
		else if(get_ival(PREV_WEAPON) || 
				!get_ival(ADS) && get_ival(NEXT_WEAPON)){
				
				Sens = Actual_Sens - 5;
				}
		}//IF COMBAT MODE END
		}//IF !PICKAXE MODE END

			if(Sens > 100)
				Sens = 100;
/*sensitivity*/	sensitivity(AIM_X, NOT_USE, Sens); 
 /*stickize*/	sensitivity(AIM_Y, NOT_USE, Sens);
		
		
}//AIM SENS CORRECTION - END

///////////////////
//NO INPUT LAG
function _NoInputLag() {

   if(get_ival(PS4_UP)){set_val(PS4_UP, 100)}//DPAD
   if(get_ival(PS4_DOWN)){set_val(PS4_DOWN, 100)}//DPAD
   if(get_ival(PS4_LEFT)){set_val(PS4_LEFT, 100)}//DPAD
   if(get_ival(PS4_RIGHT)){set_val(PS4_RIGHT, 100)}//DPAD
   
   if(get_ival(PS4_SQUARE)){set_val(PS4_SQUARE, 100)}//BUTTONS
   if(get_ival(PS4_TRIANGLE)){set_val(PS4_TRIANGLE, 100)}//BUTTONS
   if(get_ival(PS4_CIRCLE)){set_val(PS4_CIRCLE, 100)}//BUTTONS
   if(get_ival(PS4_CROSS)){set_val(PS4_CROSS, 100)}//BUTTONS
   
   if(get_ival(PS4_L1)){set_val(PS4_L1, 100)}//BUMPERS
   if(get_ival(PS4_R1)){set_val(PS4_R1, 100)}//BUMPERS
   
   //if(get_ival(PS4_L2)){set_val(PS4_L2, 100)}//TRIGGERS      **I GUESS WE DONT NEED IT ON TRIGGERS**
   //if(get_ival(PS4_R2)){set_val(PS4_R2, 100)}//TRIGGERS    *JUST IN CASE U DONT WANT/NEED HAIRTRIGGERS*
   
   if(get_ival(PS4_L3)){set_val(PS4_L3, 100)}//STICK CLICK
   if(get_ival(PS4_R3)){set_val(PS4_R3, 100)}//STICK CLICK
   
   if(!get_ival(ADS)){
   if(get_ival(PS4_SHARE)){set_val(PS4_SHARE, 100)}//MISCELLANEOUS
   if(get_ival(PS4_TOUCH)){set_val(PS4_TOUCH, 100)}//MISCELLANEOUS
   if(get_ival(PS4_OPTIONS)){set_val(PS4_OPTIONS, 100)}//MISCELLANEOUS
   }
   if(!get_ival(TOUCHPAD)){
   		if(get_ival(PS4_PS)){set_val(PS4_PS, 100)}//MISCELLANEOUS
   }
   else {
		   if(event_release(PS4_UP)){set_val(PS4_UP, 0)}//DPAD
		   if(event_release(PS4_DOWN)){set_val(PS4_DOWN, 0)}//DPAD
		   if(event_release(PS4_LEFT)){set_val(PS4_LEFT, 0)}//DPAD
		   if(event_release(PS4_RIGHT)){set_val(PS4_RIGHT, 0)}//DPAD
		   
		   if(event_release(PS4_SQUARE)){set_val(PS4_SQUARE, 0)}//BUTTONS
		   if(event_release(PS4_TRIANGLE)){set_val(PS4_TRIANGLE, 0)}//BUTTONS
		   if(event_release(PS4_CIRCLE)){set_val(PS4_CIRCLE, 0)}//BUTTONS
		   if(event_release(PS4_CROSS)){set_val(PS4_CROSS, 0)}//BUTTONS
		   
		   if(event_release(PS4_L1)){set_val(PS4_L1, 0)}//BUMPERS
		   if(event_release(PS4_R1)){set_val(PS4_R1, 0)}//BUMPERS
		   if(event_release(PS4_L2)){set_val(PS4_L2, 0)}//TRIGGERS     **BUT WE NEED THE RELEASE**
		   if(event_release(PS4_R2)){set_val(PS4_R2, 0)}//TRIGGERS      *SO IT CAN GO TO 0 QUICK*
		   
		   if(event_release(PS4_L3)){set_val(PS4_L3, 0)}//STICK CLICK
		   if(event_release(PS4_R3)){set_val(PS4_R3, 0)}//STICK CLICK
		   
		   
		   if(event_release(PS4_SHARE)){set_val(PS4_SHARE, 0)}//MISCELLANEOUS
		   if(event_release(PS4_TOUCH)){set_val(PS4_TOUCH, 0)}//MISCELLANEOUS
		   if(event_release(PS4_OPTIONS)){set_val(PS4_OPTIONS, 0)}//MISCELLANEOUS
		   if(event_release(PS4_PS)){set_val(PS4_PS, 0)}//MISCELLANEOUS
		   }
		   
}

/////////////////////////////////
//DEADZONE
function _DEADZONE (){
//DEAD ZONE CORECTION\\
   // DEAD ZONE CORECTION : LEFT STICK                                 
   if(abs(get_val(LY)) < DZ_L && abs(get_val(LX)) < DZ_L || abs(get_val(LY)) < invDZ_L && abs(get_val(LX)) < invDZ_L){        
        set_val(LY, 0);                                                
        set_val(LX, 0);                                                
}
   // DEAD ZONE CORECTION : RIGHT STICK                                 
    if(abs(get_val(AIM_Y)) < DZ_R && abs(get_val(AIM_X)) < DZ_R || abs(get_val(AIM_Y)) < invDZ_R && abs(get_val(AIM_X)) < invDZ_R){         
        set_val(_RY,0);                                                 
        set_val(_RX,0);                                                
}
/////////////////////
//CIRCULAR DEADZONE INNER && OUTTER EDGE
 //Apply Right Stick
    currRX = get_val(AIM_X);
    currRY = get_val(AIM_Y);
    if(prevRX != currRX || prevRY != currRY){
 
        if(get_val(useAlternate) > 0){
            _applyStick(deadZoneA, antiCircleDeadZoneA, antiSquareDeadZoneA, 
            					   outerDeadZoneInA, outerDeadZoneOutA, midPointXA, 
            					   midPointYA, uncapValuesA, 1);
        }
        else if(get_val(useAlternate2) > 0){
            	 _applyStick(deadZoneA2, antiCircleDeadZoneA2, antiSquareDeadZoneA2, 
            	 						 outerDeadZoneInA2, outerDeadZoneOutA2, midPointXA2, 
            	 						 midPointYA2, uncapValuesA2, 1);
        								 }
 
        else{
            	_applyStick(deadZone, antiCircleDeadZone, antiSquareDeadZone, 
            						  outerDeadZoneIn, outerDeadZoneOut, midPointX, 
            						  midPointY, uncapValues, 1);
        							  }
 									  prevRX = currRX;
								      prevRY = currRY;
    }
 
    set_val(AIM_X, stickRX);
    set_val(AIM_Y, stickRY);
 
 
    //Apply Left Stick
    currLX = get_val(LX);
    currLY = get_val(LY);
    if(prevLX != currLX || prevLY != currLY){
 
        if(get_val(useAlternateL) > 0){
            _applyStick(deadZoneLA, antiCircleDeadZoneLA, antiSquareDeadZoneLA, 
            						outerDeadZoneInLA, outerDeadZoneOutLA, midPointXLA, 
            						midPointYLA, uncapValuesLA, 2);
        }
        else if(get_val(useAlternateL2) > 0){
            	 _applyStick(deadZoneLA2, antiCircleDeadZoneLA2, antiSquareDeadZoneLA2, 
            							  outerDeadZoneInLA2, outerDeadZoneOutLA2, midPointXLA2, 
            							  midPointYLA2, uncapValuesLA2, 2);
        }
        else{
            	 _applyStick(deadZoneL, antiCircleDeadZoneL, antiSquareDeadZoneL,
            	 						outerDeadZoneInL, outerDeadZoneOutL, midPointXL, 
            	 						midPointYL, uncapValuesL, 2);
        								}
								        prevLX = currLX;
								        prevLY = currLY;
		}
 
	    set_val(LX, stickLX);
	    set_val(LY, stickLY);

}////////////////////////_____________
function _applyStick(dead, antiCDead, antiSDead, outerDeadIn, outerDeadOut, midX, midY, uncap, stick){
 
    if(stick == 1){
        x = get_val(AIM_X);
        y = get_val(AIM_Y);
    }
    else{
        x = get_val(LX);
        y = get_val(LY);
    }
 
    magnitude = isqrt(x*x + y*y);
 
    smallValue = 0;
 
    //precision
    if(magnitude <= 10){
        smallValue = 1;
 
        x = x*10;
        y = y*10;
        magnitude = isqrt(x*x + y*y);
    }
 
 
 
    if(smallValue == 0){
 
        //Increasing antiCircleDeadZone to counter shrinkage with antiSquareDeadzone scaling below
        antiCDead = (antiCDead*((antiCDead*(100 - antiSDead))/((antiCDead*(100 - (antiSDead*100)/outerDeadOut))/100)) )/100;
 
        normX = (x*100)/magnitude;
        normY = (y*100)/magnitude;
 
 
        if(uncapValues == FALSE){
            if(magnitude > outerDeadIn){magnitude = outerDeadIn}
        }
 
        //DeadZone and antiCircleDeadZone scaling
        outputMagnitude = 0;
        if(magnitude > dead){
            outputMagnitude = (((magnitude - dead)*(100))/(outerDeadIn - dead));  //Converting to 0-100 range
 
            //Piece-wise curve customization
            if(outputMagnitude < midX ){
                outputMagnitude = (outputMagnitude*midY)/midX;
            }
            else{
                outputMagnitude = (((outputMagnitude - midX)*(100 - midY))/(100 - midX)) + midY;
            }
 
            //AntiDeadzone conversion
            outputMagnitude = (((outputMagnitude)*(outerDeadZoneOut - antiCDead))/(100)) + antiCDead;
 
 
            newX = (normX*outputMagnitude)/100;
            newY = (normY*outputMagnitude)/100;
 
            //antiSquareDeadZone scaling
            outputX = (abs(newX)*(100 - (antiSDead*100)/outerDeadOut))/100 + antiSDead;
            if(x < 0){outputX = outputX*(-1)}
            if(x == 0){outputX = 0;}
 
            outputY = (abs(newY)*(100 -(antiSDead*100)/outerDeadOut))/100 + antiSDead;
            if(y < 0){outputY = outputY*(-1)}
            if(y == 0){outputY = 0;}
 
            if(stick == 1){
                stickRX = outputX;
                stickRY = outputY;
            }
            else{
                stickLX = outputX;
                stickLY = outputY;
            }
 
        }
        else{
            if(stick == 1){
                stickRX = 0;
                stickRY = 0;
            }
            else{
                stickLX = 0;
                stickLY = 0;
            }
        }
    }
 
///////////////////PRECISION//////////////////////
 
    else{
 
        //Increasing antiCircleDeadZone to counter shrinkage with antiSquareDeadzone scaling below
        antiCDead = (antiCDead*((antiCDead*(100 - antiSDead))/((antiCDead*(100 - (antiSDead*100)/outerDeadOut))/100)) )/100;
 
        normX = (x*100)/magnitude;
        normY = (y*100)/magnitude;
 
 
 
        //if(uncapValues == FALSE){
        //    if(magnitude > outerDeadIn){magnitude = outerDeadIn};
        //}
 
        //DeadZone and antiCircleDeadZone scaling
        outputMagnitude = 0;
        if(magnitude > dead*10){
            outputMagnitude = (((magnitude - dead*10)*(100))/(outerDeadIn - dead));  //Converting to 0-1000 range
 
 
 
        //Piece-wise curve customization
        if(outputMagnitude < midX*10 ){
            outputMagnitude = (outputMagnitude*midY)/midX;
        }
        else{
            outputMagnitude = (((outputMagnitude - midX*10)*(1000 - midY))/(1000 - midX*10)) + midY*10;
        }
 
 
        //AntiDeadzone conversion 0 - 1000
        outputMagnitude = (((outputMagnitude)*(outerDeadZoneOut - antiCDead))/(100)) + (antiCDead*10);
        
 
            newX = ((normX/10)*outputMagnitude)/100;
            newY = ((normY/10)*outputMagnitude)/100;
 
 
 
            //antiSquareDeadZone scaling
            outputX = (abs(newX)*(100 - (antiSDead*100)/outerDeadOut))/100 + antiSDead;
            if(x < 0){outputX = outputX*(-1)}
            if(x == 0){outputX = 0;}
 
            outputY = (abs(newY)*(100 -(antiSDead*100)/outerDeadOut))/100 + antiSDead;
            if(y < 0){outputY = outputY*(-1)}
            if(y == 0){outputY = 0;}
 
 
            if(stick == 1){
                stickRX = outputX;
                stickRY = outputY;
            }
            else{
                stickLX = outputX;
                stickLY = outputY;
            }
 
        }
        else{
            if(stick == 1){
                stickRX = 0;
                stickRY = 0;
            }
            else{
                stickLX = 0;
                stickLY = 0;
            }
        }
    }
 }
 /*DEADZONE AND ANTIDEADZONE*/
 
//This script will let you set a circular deadzone, counter circular and square
//deadzones, and set inner and outer deadzones.
//Note: The circular antideadzone is relative to the remaining range of the
//square antideadzone.  I.E, both at 50 will give you a 75 antideadzone, since
//25 is half of the remaining 50.  
//Use values 0 to 100.  Avoid using deadzones/antideadzones larger than the
//outerdeadzones.
 
//A simpler conversion of the TitanTwo script, using previous fixes from ME/DontAtMe.
 
//https://www.desmos.com/calculator/ofrurlpwox
//Graph demonstration on the output values(using 0-1 instead of 0 -100).
//The other values are exclusive to the TitanTwo version.
 
 
//CHANGE THESE VALUES
 
//RIGHT STICK SETTINGS
int  deadZone              = 0;      //Set the circular deadzone the player wants to use
int  antiCircleDeadZone    = 0;      //Set the value of the game's circular deadzone the player wishes to counter
int  antiSquareDeadZone    = 0;      //The value of the game's square deadzone the player wishes to counter
int  outerDeadZoneIn       = 100;    //The value that the play will input that will be considered 100% stick tilt
int  outerDeadZoneOut      = 100;    //The maximum value that will be output to the game
int  midPointX             = 50;     //Curve control.  Edit horizontal position of X-node.
int  midPointY             = 50;     //Curve control.  Edit vertical position of X-node.
int  uncapValues           = FALSE;  //Allows diagonal values to exceed the outerDeadZoneOut distance
                                     //set to TRUE if unable to trigger maximum game movements
int  useAlternate          = 30;     //Choose to use alternate settings when a button is held down.  Use the identifier
int  useAlternate2         = 30;     //value of the button.  This can be found in Help > GPC Language Reference >
                                     //Device API > API Reference at the bottom.
 
//RIGHT STICK ALTERNATE SETTINGS
int  deadZoneA             = 0;
int  antiCircleDeadZoneA   = 0;
int  antiSquareDeadZoneA   = 0;
int  outerDeadZoneInA      = 100;
int  outerDeadZoneOutA     = 100;
int  midPointXA            = 50;
int  midPointYA            = 50;
int  uncapValuesA          = FALSE;  
 
//RIGHT STICK ALTERNATE 2 SETTINGS
int  deadZoneA2             = 0;
int  antiCircleDeadZoneA2   = 0;
int  antiSquareDeadZoneA2   = 0;
int  outerDeadZoneInA2      = 100;
int  outerDeadZoneOutA2     = 100;
int  midPointXA2            = 50;
int  midPointYA2            = 50;
int  uncapValuesA2          = FALSE;                                     
 
 
//````````````````````````````````````````````//
 
//LEFT STICK SETTINGS
int  deadZoneL              = 0;      //Set the circular deadzone the player wants to use
int  antiCircleDeadZoneL    = 0;      //Set the value of the game's circular deadzone the player wishes to counter
int  antiSquareDeadZoneL    = 0;      //The value of the game's square deadzone the player wishes to counter
int  outerDeadZoneInL       = 100;    //The value that the play will input that will be considered 100% stick tilt
int  outerDeadZoneOutL      = 100;    //The maximum value that will be output to the game
int  midPointXL             = 50;     //Curve control.  Edit horizontal position of X-node.
int  midPointYL             = 50;     //Curve control.  Edit vertical position of X-node.
int  uncapValuesL           = FALSE;  //Allows diagonal values to exceed the outerDeadZoneOut distance
                                      //set to TRUE if unable to trigger maximum game movements
int  useAlternateL          = 30;     //Choose to use alternate settings when a button is held down.  Use the identifier
int  useAlternateL2         = 30;     //value of the button.  This can be found in Help > GPC Language Reference >
                                      //Device API > API Reference at the bottom.
 
//LEFT STICK ALTERNATE SETTINGS
int  deadZoneLA             = 0;
int  antiCircleDeadZoneLA   = 0;
int  antiSquareDeadZoneLA   = 0;
int  outerDeadZoneInLA      = 100;
int  outerDeadZoneOutLA     = 100;
int  midPointXLA            = 50;
int  midPointYLA            = 50;
int  uncapValuesLA          = FALSE; 
 
//LEFT STICK ALTERNATE 2 SETTINGS
int  deadZoneLA2            = 0;
int  antiCircleDeadZoneLA2  = 0;
int  antiSquareDeadZoneLA2  = 0;
int  outerDeadZoneInLA2     = 100;
int  outerDeadZoneOutLA2    = 100;
int  midPointXLA2           = 50;
int  midPointYLA2           = 50;
int  uncapValuesLA2         = FALSE; 
 
int x, y, newX, newY, outputX, outputY;
int magnitude, outputMagnitude;
int normX, normY;
 
int currRX, currRY;
int prevRX, prevRY;
int currLX, currLY;
int prevLX, prevLY;
 
int stickRX, stickRY;
int stickLX, stickLY;
int smallValue;
//////////////////////////________
 