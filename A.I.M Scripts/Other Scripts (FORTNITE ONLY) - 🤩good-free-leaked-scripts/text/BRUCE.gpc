/*

 _______  ______    __   __  _______  _______ 
|  _    ||    _ |  |  | |  ||       ||       |
| |_|   ||   | ||  |  | |  ||       ||    ___|
|       ||   |_||_ |  |_|  ||       ||   |___ 
|  _   | |    __  ||       ||      _||    ___|
| |_|   ||   |  | ||       ||     |_ |   |___ 
|_______||___|  |_||_______||_______||_______|

*/
// Official Script of Dhruvski from A.I.M Scripts 

// Linear only script 

// contact me on discord username: dhruvski#0246

// I hope you enjoy this script.

// Vouches and clips are appreciated

// Thank you for sticking with me I hope you enjoy your present <3
 
 

// Credits to noctwrnyA,Niko,Dogz,Exploit, and many more for helping with the script

// ðŸ…¼ðŸ…°ðŸ†ƒðŸ…²ðŸ…· ðŸ…¸ðŸ…½ ðŸ…¶ðŸ…°ðŸ…¼ðŸ…´ ðŸ…±ðŸ†„ðŸ†ƒðŸ†ƒðŸ…¾ðŸ…½ðŸ†‚                                             PS4 COMMANDS
// ðŸ…²ðŸ…¾ðŸ…¼ðŸ…±ðŸ…°ðŸ†ƒ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define ADS     		= XB1_LT;		//in-game ADS BUTTON                       //PS4_L2
define FIRE     	= XB1_RT;		//in-game FIRE BUTTON                      //PS4_R2
define NEXT_WEAPON 	= XB1_RB;		//in-game NEXT_WEAPON BUTTON               //PS4_R1
define PREV_WEAPON 	= XB1_LB;		//in-game PREV_WEAPON BUTTON               //PS4_L1
define PICKAXE 		= XB1_RIGHT;    //in-game PICKAXE BUTTON                   //PS4_RIGHT
define JUMP     	= XB1_A;	   //in-game JUMP BUTTON                       //PS4_CROSS
define CROUCH   	= XB1_RS;		//in-game CROUCH BUTTON                    //PS4_R3
define INTERACT 	= XB1_X;	    //in-game INTERACT BUTTON                  //PS4_SQUARE
define MAPVIEW_B	= XB1_DOWN;    //in-game MAP BUTTON                        //PS4_DOWN
define INVENTORY    = XB1_UP;      // in-game INVENTORY BUTTON                 //PS4_UP

// ðŸ…±ðŸ†„ðŸ…¸ðŸ…»ðŸ…³ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define BUILD     	= XB1_Y;	//in-game SWITCH BUTTON                       //PS4_TRIANGLE
define STAIRS  		= XB1_LT;		//in-game STAIRS BUTTON                   //PS4_L2
define WALL    	 	= XB1_RT;		//in-game WALL BUTTON                     //PS4_R2           
define FLOOR  		= XB1_RB;		//in-game FLOOR BUTTON                    //PS4_R1
define ROOF   		= XB1_LB;		//in-game ROOF BUTTON                     //PS4_L1
define TRAP         = XB1_X;   //in-game TRAP BUTTON                          //PS4_SQUARE
// ðŸ…´ðŸ…³ðŸ…¸ðŸ†ƒ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define EDIT 		= XB1_B;	//in-game EDIT BUTTON                         //PS4_CIRCLE
define SELECT 		= XB1_RT; 		//in-game SELECT BUTTON                   //PS4_R2
define CONFIRM 		= XB1_RB;	//in-game CONFIRM BUTTON                      //PS4_R1
define RESET 		= XB1_LT;	//in-game RESET BUTTON                        //PS4_L2
define On  = TRUE;
define Off = FALSE;

// ðŸ…¼ðŸ…¾ðŸ†…ðŸ…´ðŸ…¼ðŸ…´ðŸ…½ðŸ†ƒ & ðŸ…°ðŸ…¸ðŸ…¼ ðŸ†‚ðŸ†ƒðŸ…¸ðŸ…²ðŸ…ºðŸ†‚

define AimY     = XB1_RY;  // Vertical Aim Axis In Game                      //PS4_RY
define AimX     = XB1_RX;  // Horizontal Aim Axis In Game                    //PS4_RX
define Strafe   = XB1_LX;  // Horizontal Walk Axis In Game                   //PS4_LX
define Walk     = XB1_LY;  // Vertical Walk Axis In Game                     //PS4_LY

// dont touch
define TOUCHPAD = PS4_TOUCH;

// IGNORE THIS !!!
define PS       = POLAR_RS;// Polar Stick In Use [LS/RS]



int deadzone = 10;// right stick deadzone

define  LSDeadZone = 10;
int     BraveAimHeadLock             = TRUE;
int     BraveAimHeadAssist           = TRUE;
int     BraveAimMagnet               = TRUE;
int     BraveAimAA                   = TRUE;
int     BraveAimCA                   = TRUE;
define  BraveAimHeadAssistPower      = 10;
define  BraveAimHeadShotAssistPower  = -5;
define  BraveAimStickyRange          = 10;

int BHFRR = FALSE;
int InputTime,X,Y,M,MM,T,A,SA,CA,AxisR,SAV,AH,AV,AR,VA,ARH,ARV;
define BAPD = 1;
int BraveAimAA1 = 4;int BraveAimAABooster5 = 4;int BraveAimAA3 = 4;int BraveAimAARelease = 5;
int BRAV = 6;
int K    = 6;
define BARRHP = 0;define BAHHAP = 0;
define YCX  = 5;define YCY  = 6;define YCX2 = 4;define YCY2 = 4;define YCX3 = 3;define YCY3 = 4;define YCX4 = 3;define YCY4 = 5;
define BACAPX  = YCX; define BACAPY  = YCY; define BACAPX2 = YCX2; define BACAPY2 = YCY2; define BACAPX3 = YCX3; define BACAPY3 = YCY3; 
define BACAPX4 = YCX4; define BACAPY4 = YCY4;int Nine,Ten,Cos,Sin,PolarSD;int BraveAimAARX = 5;int BraveAimAALX = 5;
int BACAD = 10; int BACA2D = 8; int BACA3D = 16; int BACA4D = 12;  int BAPS = 32767; int BAPP = 32767;
define  BraveAimStickyRangeSpeed     = 24;


int EVILDEADZONE = 10;
int EVILDEADZONEl = 10;
int EVILAIM1 = 8;int EVILAIM2 = 8;
int EVILAIM3 = 8;int EVILAIM4 = 8;
int EVILAIM_MOVEMENT_TRACK;
int EVILDELAY = 0;
int EVILANTIRECOIL = 19;
int D = 0;


// DUSTEEEEEEEEE AA //
define DUSTE   =   TRUE; // keep this true dont touch at all 
define PXS     =   3396;  				    	
define PXSE    =    200;				    
define PVSI    =     200;    				
define PVS     =      0;
define PYS     =   -200;				
define PYSE    =    200;		    	
int    PPFX    =    PXS;
int    PPFY    =    PYS;				  	  
int    PVID;
int    PFD     =      1;		    
int    PPFD    =      1;
int    RX;
int    RY;

// BrUcE TiMeD AiM AsSiSt (LEAVE THIS ALONE)
int DoGzTimeZ = TRUE;     
int Power = 1;           
int AATime = 2000;        
int AATimed = TRUE;        
int AimAssistHip = TRUE;    

int cAAlostAA8 = TRUE;
int Sum = 8;
int ThreeTimes = 6;
int OneThird = 2;
int DeadZone = 10;
int cAAlostAA7 = TRUE;
int cAAlostAA7HipFire = TRUE;
int cAAlostAA7Time = 1000;
int cAAlostAA7Delay = 70;
int cAAlostAA7Power = 7;
int cAAlostAA7Power2 = 8;
int cAAlostPolarAA4 = TRUE;
int cAAlostPolarAA4Speed = 35;
int cAAlostPolarAA4Power = 8;
int cAAlostConstantAA = TRUE;
define cAAlostConstantAssistPower = 7;
define cAAlostConstantAP = cAAlostConstantAssistPower;
int cAAlostConstantAssistDelay = 10;
int cAAlostPolarAA3 = TRUE;
int cAAlostPolarAA3Range = 8;
int cAAlostPolarAA3Speed = 35;
int cAAlostTracking = TRUE;
int cAAlostTrackingSpeed = 35;
int cAAlostAA6 = TRUE;
int cAAlostAA6Power = 7;
int cAAlostAA6PowerPlusOne = 8;
int cAAlostAA6Speed = 100;
int cAAlostAA5 = TRUE;
int cAAlostAA5Power = 7;
int cAAlostAA5Delay = 20;
int cAAlostAA5Limit = 40;
int cAAlostAA5Range = 8;
int cAAlostAA5Speed = 35;
int cAAlostShapeBoosts = FALSE;
int cAAlostShapeSpeed = 35;
int cAAlostShapeRange = 6;
int cAAlostShapeRangeMin = 2;
int cAAlostShapeSpeedBoost = 0;
int cAAlostShapeRangeBoost = 0;
int cAAlostShape = Helix;
int cAAlostAA4 = TRUE;
int cAAlostAA4Power = 8;
int cAAlostAA3 = TRUE;
int cAAlostAA3Power = 7;
int cAAlostAA3Delay = 10;
int cAAlostAA3Limit = 45;
int cAAlostPolarAA2 = TRUE;
int cAAlostPolarAA2Range = 7;
int cAAlostPolarAA2Range2 = 8;
int cAAlostPolarAA2Speed = 35;
int cAAlostPolarAA2Speed2 = 35;
int cAAlostPolarAA = TRUE;
int cAAlostPolarAAHipFire = TRUE;
int cAAlostPolarAATimed = FALSE;
int cAAlostPolarAAPower = 2.3;
int cAAlostPolarAATime = 5000;
int cAAlostAA2 = TRUE;
int cAAlostAA2HipFire = TRUE;
int cAAlostAA2Power = 7;
int cAAlostAA2Delay = 10;
int cAAlostAA = TRUE;
int cAAlostAAHipFire = TRUE;
int cAAlostAAPower = 8;
int cAAlostAADelay = 10;
int cAAlostAAIntervals = 2;
int cAAlostRecoilReducer = TRUE;
int VerticalStrength = 27;
int HorizontalStrength = 0;

// NIKO AIM // 
define SS_Nikolai_Aim = TRUE; 
define AimAssistWaitTime = 10;// right stick deadzone  
define AimAssistStrength = 10;// right stick deadzone 

//DhruvShapes
int DHruVskiACE           = TRUE; // [LEAVE THIS ALONE]
define DhRuvsKii  = 0; //  

// Batt's Sticky Aim Assist
int BattsStickyAim = On; 
int BattStickyPower = 10; // right stick deadzone
int BattStickyTime = 10;  // right stick deadzone
int BattsAAHip = On;      

// NOT's Sticky AIM
define sticky_aim_assist = TRUE;
define _v                =   10; // right stick deadzone

// AIM Correction
define aim_sens_corrections = 1;   
int in_game_menu_sens       = 12;  // PICK 3 HIGHER THEN YOUR REGULAR SENSITIVITY! IF IT FEELS WEIRD DESCREASE BY 1 !!!!

//Aim Assist Stick Linear - Umbrella V2  (LEAVE THIS ALONE) 
define AimStickLinear  = TRUE; 
define Ads_Assist      = TRUE;  
define Fire_Assist     = TRUE; 
define RADIUS          = 7;    
define STEPS           = 30;   
define STEP_INTERVAL   = 1;    

// AIM ASSIST EXPLOIT LINEAR V4  (LEAVE THIS ALONE)
int Aim_Exploit_Linear  = TRUE; 
int Strength_Linear     = 180;// {INCREASE THE VALUE FOR THIS FOR MORE AA}
int Wait_Linear         = 100;
int AimBoost            = FALSE; 
int ExploitRadiusBoost  = 6;  
int ExploitAngleBoost   = 10;
int AimAAHip            = TRUE; 

// Progression Head Shot Assist
define HeadAssist    = TRUE; 
define HeadHipAssist = TRUE; 

define HeadStep = 1;  // HeadMax /  10 = HEADSTEP  *FOR EXAMPLE 10/10 = 1  *HEADSTEP =1
define HeadMax  = 10; // Right Stick Deadzone                               


// RAPID FIRE (ONLY CAN HAVE 1 ON)
// OPTION 1:
int RapidFire       =  Off;
int RapidFireHold = 30;
int RapidFireWait = 30;
define RapidFireHip = Off;

// OPTION 2:
int SmartRapidFire  = On;
int SmartFireHold = 40;
int SmartFireWait = 350;
define SmartFireHip = On;


//HEAD SHOT ASSIST 2.0
int HEADSHOT = TRUE;
define HeadShotStrength = 10;  // right stickdeadzone
define HeadShotHoldTime = 1300;

// Triple Sticky
define Triple_Sticky    =   TRUE;
//--ADS Value
	int ADS_Size            =  	  10; // rightstick deadzone
	int ADS_Wait_Value      =     40;

//--ADS + FIRE Value
	int ADS_FIRE_Size       =     10; // rightstick deadzone
	int ADS_FIRE_Wait_Value =     30;

//--HIPFIRE Value
	int HIPFIRE_Size        =     26;
	int HIPFIRE_Wait_Value  =     20;


// DoGz Polar Version XIII [Real Zen Polar {STAGE 1 of 2}] (LEAVE THIS ALONE UNLESS YOU HAVE VALUES FOR THIS)
int DoGzZenPolar = On;        
int PolarOrientation = On;    
int PolarCoil = On;           
int ZenPolarRadius = 3;     
int ZenPolarAngle = 11;       
int RotateCounter = 150; 	  
int Increment = 2;            
int ZenPolarChangeSpeed = 10 
int ZenPolarRelease = 12; 	   
// DAM POLAR/DoGz Reducer {STAGE 2 of 2}
int DoGzReleasMode = DoGzDamPolar; 
// DamPolar
int DamAdsRadius = 3;		  
int DamAdsAngle = 11;         
int DamFireRadius =	3;		 
int DamFireAngle = 30;        
// DoGzReducer                
int ReducerPower = 3;		  
int ReducerTime = 10;		  

//DhruvTrackerV3
define DhruvTrackerV3 = TRUE;
int Dhruvski7 = FALSE;
int CRYptoACE8 = FALSE;
int CheckersNoTChess4 = FALSE;
int SEWEYY27 = FALSE;
int DHRUVBOT5 = 10; // right stick deadzone
int LIGMA28 = 10;   // right stick deadzone
int LIGMA18 = 10;   // right stick deadzone
int LIGMA20 = 13;
int LIGMA22 = 19;
int LIGMA19 = -10;  // right stick deadzone
int LIGMA21 = -13;
int LIGMA6 = 7;
int MONKEY23 = 21;


// NightmareXVII's AA
int AALinearExpo			=  10; // right stick deadzone
int NegativeAALinearExpo	= -10; // right stick deadzone
int Delay					=  8; 
int Release					=  11;	// -> This should always be +1 more than Aim Assist values

// Instant Edit + Reset 
define InstaEditReset = FALSE; 	
define EditHold       = FALSE; 	
define EditHoldTime   = 100;  	

//Build Tracker
int BuildTracker  =  TRUE; 
int BuildSyncTime = 4000; 

// Playstation On PC/Xbox
define PlayStationOnXbox = TRUE; 

// Hair Triggers
define HairTriggers = TRUE; 

// Fast Reset
int InstaFastReset  =  TRUE;
define FastReset = XB1_LT;

//Deadzone optimizer
int DEADZONE	= FALSE; // ONLY TURN THIS ON IF YOU HAVE DRIFT
define DZ_L 	= 10; //left stick deadzone
define invDZ_L 	= -10;//left stick deadzone

define DZ_R 	= 10;//right stick deadzone
define invDZ_R 	= -10;//right stick deadzone

// DONT TOUCH AT ALL

int Edit1,Edit2,EditT,Shunt,BuildTrack,BuildCount;
int power,Ypower,Xpower,CountPower,AxisXY;int AxisT,AAT;
int display_title = TRUE;int goCOMBAT;int WaitStrength, AimStrength;
int display_black;int EditAst, EDIThold; int Head;int TimeValue,OutPut,
RumValue,RecoilTimer,BoostAR,AxisCY,AxisLY;int actual_X, actual_Y, 
actual_Magnitude, max_Magnitude,time,angle, cos_angle, sin_angle;int _RX,_RY;
define StandardAHip =  On;int ExploAngle,ExploCos,ExploSin,ExploX,ExploY,
ActualMagnitude,MaxMagnitude,RadiusExploit,AngleExploit,AdaptAbuse;
int _Polar_Process_Done;int _Increment;int X_JOY_OFFSET  		  =    1;
int Y_JOY_OFFSET  		  =    1;int MAX_MAGNITUDE 		  =   10;int Radius__; 
int Angle_Increment;int PolarRadius;int PolarAngle;int PolarRBoost;
int PolarABoost;int RX_Polar;int RY_Polar;int _Angle;int X_Magnitude;int Y_Magnitude;
int Sinus;int Cosinus;int Aim_Val, Wait_Val;int SnapShot_hold; int SnapShot_rest;
int interval_t,angle2;int x_stick, y_stick;int ads_grenade_sens, ads_fire_sens, Sens;
define DoGzDamPolar = 0,DoGzReducer = 1;int Rotation,Count,Counter,Inverter,Axis,
Angle,DamRadius,DamAngle;define PolarValue = 327;
define Circular= 1;define Reducer = On;
define TallOval= 2;
define WideOval= 3;
define Spiral= 4;
define Helix= 5;
int RS_Gradient,stick_input,rnd;
int mn = 528, mx = 550;
int RXT,RYT,SpiralPosition1,SpiralPosition2,InnerSpiral,OuterSpiral,SmartRumble,Time,MaxM,YRSpeed,YROutput,YRValueX,YRValueY,YRAxisX,YRAxisY,YRAngle,Radius,PolarStrength,PositionT,CosAngle,SinAngle;
int PX,PY,Angle1;
//Main
main {
vm_tctrl(-9);
block_rumble();
_NoInputLag();
 if (DEADZONE){
 _DEADZONE();
 }
	if (PlayStationOnXbox && get_console() == PIO_XB360 && get_controller() == PIO_PS4) { 
	
		swap(PS4_TOUCH,PS4_SHARE);
	}
	if (HairTriggers) { 
   		
   		deadzone(PS4_L2,PS4_R2,100,100);
   	}
    	
  if (InstaFastReset && !get_ival(ADS) && event_press(FastReset)) { 
       
      
        
        	Shunt = FastReset;
        	combo_run(FastReset);
    }

    if (InstaEditReset) {
        if (EditHold && get_ival(EDIT) && get_ptime(EDIT) > EditHoldTime || !EditHold && event_press(EDIT)) {
                Edit1 = On;
                Edit2 = On;
                BuildTrack = On;
        
        }

        if (Edit2) {
            if (event_release(SELECT)) {  
                Edit1 = Off;
                Edit2 = Off;
                BuildTrack = Off;
    		}

        }
    }

    if (Edit1 || Edit2) {

            if (event_press(RESET)) {  
                combo_run (InstantReset);
                Edit1 = Off;
                Edit2 = Off; 
            }

                if (event_press(PICKAXE) || event_press(BUILD) || event_press(ADS)) {
                    Edit1 = Off;
                    Edit2 = Off;
                    BuildTrack = Off;
                }
    }
    
	if (BuildTracker) {
        
        if (event_press(BUILD)) {
            BuildTrack = !BuildTrack;
            
        }
    
        if (BuildTrack) {
            BuildCount += get_rtime();
            
            if (event_press(PICKAXE) || BuildCount == BuildSyncTime) {
                BuildTrack = Off;
                BuildCount = Off;
            }
            
                if (get_ival(ROOF) || get_ival(FLOOR) || get_ival(STAIRS) || get_ival(WALL)) 
                    BuildCount = Off;
        }
    }
    if(!BuildTracker) {
    stick_input = (isqrt(pow(get_ival(PS4_RX), 2) + pow(get_ival(PS4_RY), 2)));
	if(cAAlostPolarAA3) {
		if(get_ival(PS4_L2) || (get_ival(PS4_R2))) {
			if (stick_input <= cAAlostPolarAA3Range) {
				rnd = random(mn, mx);
				RS_Gradient = (RS_Gradient + cAAlostPolarAA3Speed) % 360;
				set_polar(POLAR_RS, RS_Gradient, (cAAlostPolarAA3Range * rnd));
							}
					}
			}
	if(cAAlostPolarAA4) {
		if (get_ival(ADS) || get_ival(FIRE)) {
			YRAxisX  = isqrt(abs(get_ival(AimX)) * abs(get_ival(AimX)));
			YRAxisY  = isqrt(abs(get_ival(AimY)) * abs(get_ival(AimY)));
			if (cAAlostPolarAA4) {
				YRAngle = YRSpeed;
				Radius = cAAlostPolarAA4Power;
				YRSpeed = YRSpeed + cAAlostPolarAA4Speed;
				if (YRSpeed < 0) YRSpeed += 360;
				YRSpeed = YRSpeed % 360;
							}
			else {
				YRAngle = Off;
				cAAlostPolarAA4Power = Off;
							}
			if(cAAlostRecoilReducer) {
				if (get_ival(ADS) && get_ival(FIRE)) {
					if (YRAxisX <= abs(HorizontalStrength)) {
						YRValueX = HorizontalStrength;
											}
					else {
						YRValueX = Off;
											}
					if (YRAxisY <= abs(VerticalStrength)) {
						YRValueY = VerticalStrength;
											}
					else {
						YRValueY = Off;
											}
									}
				else {
					YRValueY = Off;
					YRValueX = Off;
									}
							}
			calostPolarity(YRAngle,Radius);
					}
			}
	if(cAAlostAA3){
		if (get_ival(ADS)){
			combo_run(cAAlostAA3);
			Polar();
					}
		if (abs(get_ival(AimX)) > cAAlostAA3Limit || abs(get_ival(AimY)) > cAAlostAA3Limit) {
			combo_stop(cAAlostAA3);
					}
			}
	X = get_ival(RX);
	Y = get_ival(RY);
	M = isqrt(pow(X, 2) + pow(Y, 2));
	MaxM = (M < 100);
	if (!(Time++ % cAAlostAAIntervals)) {
		Angle += cAAlostPolarAA2Speed2;
			}
	Angle = Angle % 360;
	Sin = Polar_Array[Angle % 360];
	Cos = Polar_Array[(Angle + 270) % 360];
	Cos = (Cos * cAAlostPolarAA2Range) / 100;
	Sin = (Sin * cAAlostPolarAA2Range) / 100;
	if((cAAlostPolarAA2 && get_ival(ADS)) || (cAAlostPolarAAHipFire && get_ival(FIRE))) {
		if (M <= cAAlostPolarAA2Range) {
			Sin -= Y;
			Cos -= X;
					}
		else {
			Sin = (Sin * (200 - ((abs(Y) + M) / 10) * 10) / 200) * MaxM;
			Cos = (Cos * (200 - ((abs(X) + M) / 10) * 10) / 200) * MaxM;
					}
		set_val(RX, clamp(X + Cos, -100, 100));
		set_val(RY, clamp(Y + Sin, -100, 100));
			}
	if(cAAlostAA2) {
		if (get_ival(ADS) || (cAAlostAA2HipFire && get_ival(FIRE))) {
			combo_run(cAAlostAA2);
					}
		else {
			combo_stop(cAAlostAA2);
					}
			}
	if(cAAlostAA8) {
		if (event_press(ADS)) {
			Power = On;
					}
		else if (!get_ival(ADS) && event_press(FIRE)) {
			Power = On;
					}
		if (get_ival(ADS) || get_ival(FIRE)) {
			AxisXY = isqrt(abs(get_ival(AimX)) * abs(get_ival(AimX)) + abs(get_ival(AimY)) * abs(get_ival(AimY)));
			if (Sum == 1)AimAssist(ThreeTimes,OneThird);
					}
		else {
			CountPower = 0;
			power = Off;
					}
			}
	if(cAAlostPolarAA) {
		if (cAAlostPolarAATimed) {
			if (get_ival(ADS) && get_ptime(ADS) <= cAAlostPolarAATime || cAAlostPolarAAHipFire && get_ival(FIRE) && get_ptime(FIRE) <= cAAlostPolarAATime) {
				AimAssistY();
							}
					}
		else if (get_ival(ADS)|| cAAlostPolarAAHipFire && get_ival(FIRE)) {
			AimAssistY();
					}
		if (!get_ival(ADS) && !get_ival(FIRE)) {
			AAT = 0;
			Axis = 0;
					}
			}
	if(cAAlostTracking){
		if(get_val(XB1_LT) && get_val(XB1_RT)){
			sensitivity(XB1_RX,43,cAAlostTrackingSpeed);
			sensitivity(XB1_RY,43,cAAlostTrackingSpeed);
					}
			}
	if(cAAlostConstantAA){
		if(!get_val(FIRE) || get_val(ADS) && get_val(FIRE)){
			combo_run(cAAlostAA4);
			if(abs(get_val(AimY)) > 36 || abs(get_val(AimX)) > 36 ){
				combo_stop(cAAlostAA4);
							}
					}
			}
	if(cAAlostAA6){
		if(get_val(ADS)> 1){
			combo_run(cAAlostAA6);
			AA1Shake();
					}
		if(abs(get_val(AimY)) > 36 || abs(get_val(AimX)) > 36) {
			combo_stop(cAAlostAA6);
					}
			}
	if(cAAlostAA4){
		if(get_val(FIRE)> 1){
			combo_run(cAAlostAA8);
					}
		if(abs(get_val(AimY)) > 19 || abs(get_val(AimX)) > 19) {
			combo_stop(cAAlostAA8);
					}
			}
	if(cAAlostAA7){
		if ((get_ival(ADS)) || (get_ival(FIRE) && cAAlostAA7HipFire)) {
			if (abs(get_ival(AimX)) <= cAAlostAA7Time && abs(get_ival(AimY)) <= cAAlostAA7Time) {
				combo_run(cAAlostAA7);
							}
					}
		else {
			combo_stop(cAAlostAA7);
					}
			}
	if(cAAlostAA5){
		if (get_ival(ADS)){
			combo_run(cAAlostAA5);
			P();
					}
		if (abs(get_ival(AimX)) > cAAlostAA5Limit || abs(get_ival(AimY)) > cAAlostAA5Limit) {
			combo_stop(cAAlostAA5);
					}
			}
	if(cAAlostAA) {
		if (get_ival(ADS) || (cAAlostAAHipFire && get_ival(FIRE))) {
			combo_run(cAAlostPolarAssist3);
					}
		else {
			combo_stop(cAAlostPolarAssist3);
					}
			}
	if(cAAlostShape) {
		RXT = get_val(AimX);
		RYT = get_val(AimY);
		ActualMagnitude = isqrt(pow(RXT,2) + pow(RYT,2));
		MaxMagnitude = (ActualMagnitude < 100);
		angle += cAAlostShapeSpeed + Angle;
		angle = angle % 360;
		CosAngle = Polar_Array[(angle + 270) % 360];
		SinAngle = Polar_Array[angle % 360];
		if (cAAlostShapeBoosts) {
			if (get_ival(FIRE)) {
				Angle = cAAlostShapeSpeedBoost;
				if (SmartRumble > 10 && SmartRumble < 90) {
					PolarStrength = (cAAlostShapeRange + cAAlostShapeRangeBoost + cAAlostShapeSpeedBoost + SmartRumble / 4);
					SmartRumble   = Off;
									}
							}
					}
		if (get_ival(ADS) || get_ival(FIRE)) {
			if (ActualMagnitude < cAAlostShapeRange) {
				SinAngle -= RYT;
				CosAngle -= RXT;
							}
			else {
				SinAngle = (SinAngle * (200 - ((abs(RYT) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
				CosAngle = (CosAngle * (200 - ((abs(RXT) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude;
							}
			
					}
		PolarStrength = On;
		SmartRumble   = On;
			}
    if (BraveAimHeadAssist) {
        if (get_ival(ADS) && get_ival(FIRE) || BHFRR && get_ival(FIRE)) {
                combo_run(BraveAimHeadAssist);
        }
}
if (BraveAimMagnet) {
        if (get_ival(FIRE)) {
                combo_run(BraveAimMagnet);
        }
}
if (BraveAimCA) {
        combo_run(BraveAimConstantAimBooster1);
        combo_run(BraveAimConstantAimBooster2);
        combo_run(BraveAimConstantAimBooster3);
        combo_run(BraveAimConstantAimBooster4);
}
InputTime += get_rtime();
if (BraveAimAA) {
        X = get_val(AimX);
        Y = get_val(AimY);
        M = isqrt(pow(X, 2) + pow(Y, 2));
        MM = (M < 100);
        if (!(T++ % BAPD)) {
                A += BraveAimStickyRangeSpeed;
        }
        A = A % 360;
        SA = BraveAimData[A % 360];
        CA = BraveAimData[(A + 270) % 360];
        CA = (CA * BraveAimStickyRange) / 100;
        SA = (SA * BraveAimStickyRange) / 100;
        if ((get_val(ADS)) || get_val(FIRE)) {
                if (M <= BraveAimStickyRange) {
                        SA -= Y;
                        CA -= X;
                } else {
                        SA = (SA * (200 - ((abs(Y) + M) / 10) * 10) / 200) * MM;
                        CA = (CA * (200 - ((abs(X) + M) / 10) * 10) / 200) * MM;
                }
                set_val(AimX, clamp(X + CA, -100, 100));
                set_val(AimY, clamp(Y + SA, -100, 100));
        }
}
combo_run(BraveAimAABooster1);
if (get_val(AimX) < -BraveAimAA1 || get_val(AimX) > BraveAimAA1 || get_val(AimY) < -BraveAimAA1 || get_val(AimY) > BraveAimAA1 || get_val(AimX) < -BraveAimAA1 || get_val(AimX) > BraveAimAA1 || get_val(AimY) < -BraveAimAA1 || get_val(AimY) > BraveAimAA1) {
        combo_stop(BraveAimAABooster1);
}
combo_run(BraveAimAABooster2);
combo_run(BraveAimAABooster5);
combo_run(BraveAimAABooster4);
AxisR = isqrt(abs(event_press(AimX)) * abs(event_press(AimX)) + abs(event_press(AimY)) * abs(event_press(AimY)));
if (event_press(AimX) || event_press(AimY) && event_press(AimY) && AxisR <= BraveAimAARelease || event_press(AimY) && AxisR > BraveAimAARelease) {
        combo_run(BraveAimAABooster3);
}
if (BraveAimHeadLock) {
        if (get_val(ADS) && (get_val(FIRE))) {
                combo_run(BraveAimHeadLock);
        }
        if (abs(get_val(XB1_LX)) > LSDeadZone || abs(get_val(XB1_LY)) > LSDeadZone) {
                combo_stop(BraveAimHeadLock);
        }
}
combo_run(B);
combo_run(R);
combo_run(A);
combo_run(V);
    combo_run(AS);
 combo_run(EVIL1)combo_run(EVIL2)combo_run(EVIL3)combo_run(EVIL4)
combo_run(EVIL_movement_finder)
EVIL1()EVIL2()EVIL3()EVIL4()EVILMOVEMENTX()ANTIRECOIL()   
    if (BattsStickyAim) {
            
                if (get_ival(ADS) || (BattsAAHip && get_ival(FIRE))) {
                
                    combo_run(BattsStickyAssist);
                
                } else {
                
                    combo_stop(BattsStickyAssist); 
                }
            }
    if(Triple_Sticky) {
		if(get_ival(ADS) || get_ival(FIRE)) {
	combo_run(Sticky_AA);
		Aim_Val  = ADS_Size;
		Wait_Val = ADS_Wait_Value;
	} else if(get_ival(ADS) || get_ival(FIRE)) {
	combo_run(Sticky_AA);
		Aim_Val  = ADS_FIRE_Size;
		Wait_Val = ADS_FIRE_Wait_Value;
	} else if(!get_ival(ADS) || get_ival(FIRE)) {
	combo_run(Sticky_AA);
		Aim_Val  = HIPFIRE_Size;
		Wait_Val = HIPFIRE_Wait_Value;
	} else {
	combo_stop(Sticky_AA);
		}
	}
	if (sticky_aim_assist) {
   if(get_val(PS4_L2)) combo_run(STICKY_AIM);
        else combo_stop(STICKY_AIM);}
    if(DHruVskiACE)
  {
		if(abs(get_val(AimX)) <= DZ_R)
			set_val(AimX, 0); 
		if(abs(get_val(AimY)) <= DZ_R)
			set_val(AimY, 0);

	if(get_ival(ADS) || get_ival(FIRE))
	{
		if(_Polar_Process_Done == TRUE)
		{
			_Polar_Process_Done = FALSE;
					       	
			if(get_lval(AimX) <= get_val(AimX))
			{
				_Angle = 360;  	// add right boost mvt
				_Increment = FALSE;
			}
			else
			{
				_Angle = 180;  // add lest boost mvt  
				_Increment = TRUE;
			}
		}
		
		X_Magnitude = isqrt(pow((get_lval(AimX) - get_val(AimX)), 2));
		
		if(DhRuvsKii )
		{
    		Y_Magnitude = isqrt(pow((get_lval(AimY) - get_val(AimY)), 2));
    	}
		
		if((X_Magnitude <= MAX_MAGNITUDE) && (Y_Magnitude <= MAX_MAGNITUDE))
		{
			Set_Polar(_Angle);
		                
			if(_Increment == TRUE)
			{
				_Angle+= Angle_Increment; 
		        	
				if(_Angle >= 360)
				{
					_Angle -= 360;
				}
	        		
					if((_Angle <= 180 + (Angle_Increment / 2)) && (_Angle > (180 - (Angle_Increment + (Angle_Increment / 2)))))
					{
						_Polar_Process_Done = TRUE;
					}
				}
				else
				{
					_Angle-= Angle_Increment;
		        	
					if( (_Angle <= 0))
					{
						_Polar_Process_Done = TRUE;
					}
				}
			}
			else
			{
				_Polar_Process_Done = TRUE;		
			}
		}
		else
		{
			_Angle = 360;
			_Increment = FALSE;
			_Polar_Process_Done = TRUE;
		}
	}
	if(aim_sens_corrections) {
    ads_grenade_sens=100-(in_game_menu_sens); ads_fire_sens=96-(in_game_menu_sens); 
    if (get_val (PS4_L2)) {
    if(get_val(PS4_R2) && get_val(PS4_L2)) {
    Sens = ads_fire_sens; }
    if(!get_val(PS4_R2) && !get_val(PS4_L2) || get_val (PS4_R2) &&!get_val(PS4_L2)) {
    Sens = 100; //--sens and hip fire sens
    }   
    if(!get_val(PS4_R2) && get_val(PS4_L2)) {
    Sens = ads_grenade_sens; }
    if(Sens > 100) Sens = 100;  
    sensitivity(PS4_RX, NOT_USE, Sens);
    sensitivity(PS4_RY, NOT_USE, Sens); }
    }
     if (DoGzTimeZ) {
	        	
	        	if (AATimed) {
	        	
	        		if (get_ival(ADS) && get_ptime(ADS) <= AATime || AimAssistHip && get_ival(FIRE) && get_ptime(FIRE) <= AATime) {
	            	
	            		DoGzTimeZ();
	            	}
	            	
	            } else if (get_ival(ADS)|| AimAssistHip && get_ival(FIRE)) {
	            	
	            		DoGzTimeZ();
	            }
	            
	            if (!get_ival(ADS) && !get_ival(FIRE)) {
	            
	            	AAT = 0;
	            	AxisT = 0;
	            }
	        }        
if (SS_Nikolai_Aim)
		{
			if(get_ival(ADS) || get_ival(FIRE))
			{
				combo_run(cNikoAim);
			}

			if(event_release(ADS) || event_release(FIRE))
			{
				combo_stop(cNikoAim)
			}
		}
		 if (Aim_Exploit_Linear) {

        if (get_ival(ADS)) {

            combo_run(Aim_Linear);
    }
}

  if (Aim_Exploit_Linear) {
    
        if (get_ival(ADS) || (AimAAHip && get_ival(FIRE))) {
        
            ExploX = get_ival(PS4_LX);   
            ExploY = get_ival(PS4_LY);           
            ActualMagnitude = isqrt(pow(ExploX,2) + pow(ExploY,2));  
            MaxMagnitude = (ActualMagnitude < 100);                      
        
            if (AimBoost && get_ival(FIRE)) {
                    
                RadiusExploit = Strength_Linear + ExploitRadiusBoost;
                AngleExploit = ExploitAngleBoost;
                
            } else {
                    
                RadiusExploit = Strength_Linear;
                AngleExploit = 0;
            }
            
            ExploAngle += Wait_Linear + AngleExploit;                                                 
            ExploAngle = ExploAngle % 360;                                            
            ExploSin = ExploitPolar[ExploAngle % 360];                           
            ExploCos = ExploitPolar[(ExploAngle + 270) % 360];                  
            ExploCos = (ExploCos * RadiusExploit) / 100;                         
            ExploSin = (ExploSin * RadiusExploit) / 100;                          
        
            if (ActualMagnitude <= 10) {                                                      
                
                ExploSin -= ExploY;                                                              
                ExploCos -= ExploX;                                                                 
            
            } else {                                                                                       
                    
                ExploSin = (ExploSin * (200 - ((abs(ExploY) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude; 
                ExploCos = (ExploCos * (200 - ((abs(ExploX) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude; 
            }                                                  
            
            set_val(PS4_LX,clamp(ExploX + ExploCos, -100,100));
            set_val(PS4_LY,clamp(ExploY + ExploSin, -100,100)); 
    }
}
 if (CheckersNoTChess4) {
    if (get_val(PS4_L2)) {
      combo_run(LIGMA37);
    }
    if ((get_val(PS4_RX)) > DHRUVBOT5 || (get_val(PS4_RX)) < DHRUVBOT5 * (-1)) {
      combo_stop(LIGMA37);
    }
  }
  if (Dhruvski7) {
    if (get_val(PS4_L2)) {
      combo_run(LIGMA40);
    }
    if (CRYptoACE8) {
      if (get_val(PS4_R2)) combo_run(LIGMA41);
    }
  }
if (DhruvTrackerV3) {
    SEWEYY27 = !SEWEYY27;
    Dhruvski7 = !Dhruvski7;
    CRYptoACE8 = !CRYptoACE8;
    CheckersNoTChess4 = !CheckersNoTChess4;
  }
  if (SEWEYY27) {
    if (get_val(PS4_L2) > 95) {
      combo_run(LIGMA46);
    }
    if (abs(get_val(PS4_RX)) > 21 || abs(get_val(PS4_RY)) > 21) combo_stop(LIGMA46);
}   
    if (HeadAssist) {
	        
	        if (get_ival(ADS) && get_ival(FIRE) || HeadHipAssist && get_ival(FIRE)) {
	        
	        	if (abs(get_ival(PS4_RY)) < HeadMax) { 
	        		
	        		Head += HeadStep;
	        		combo_run(HeadAssist);
	        	}	
	        }
	        
	        if (!get_ival(FIRE)) Head = 0;
	        	
	        if (Head >= HeadMax) combo_stop(HeadAssist);
	    }
	    if(HEADSHOT){
	   
		_RY = inv(HeadShotStrength);

		if(get_ival(FIRE) && get_ptime(FIRE) < HeadShotHoldTime){
			
			Set_Val(AimY, _RY);	
			}
	}
	if ((RapidFire && RapidFireHip && get_ival(ADS) && get_ival(FIRE)) || (RapidFire && !RapidFireHip && get_ival(FIRE))) {
            combo_run(RapidFire);
        }    
            else {
                combo_stop(RapidFire);
            }

        if ((SmartRapidFire && SmartFireHip && get_ival(ADS) && get_ival(FIRE)) || (SmartRapidFire && !SmartFireHip && get_ival(FIRE))) {
            combo_run(SmartFire);
        }    
            else {
                combo_stop(SmartFire);
            }
      if (DoGzZenPolar) {
		    
		        if ((get_ival(ADS) || get_ival(FIRE)) && Axis < ZenPolarRelease) {
	            
	                if (PolarOrientation) {
	                
	                    if (Count < RotateCounter) {
	                    	
	                    	Rotation += ZenPolarAngle;
	                    
	                    	if (Rotation > 359) { 
	                    		
	                    		Rotation = 0;
	                    	}
	                    	Count++;
	                    }
	                    
	                    if (Count >= RotateCounter) {
	                    
	                    	Rotation -= ZenPolarAngle;
	                    
	                    	if (Rotation < 0) { 
	                    
	                    		Rotation = 359;
	                    	}	
	                    	Count++;
	                    }
	                    
	                    if (Count == RotateCounter * 2) { 
	                    
	                    	Count = 0;
	                    }	
	                } else {
	                
	                		Rotation += ZenPolarAngle;
	                
	                	if (Rotation > 359) { 
	                		
	                		Rotation = 0;
	                	}
	                }
	                	    
	                set_polar(PS,Rotation,(Axis * PolarValue / 3) + (ZenPolarRadius * PolarValue) + Counter);
	                
	                if (PolarCoil) {
	                
	                	if (Inverter) {
	                		
	                		Counter += ZenPolarChangeSpeed;
	                	
	                	} else {
	                	
	                		Counter -= ZenPolarChangeSpeed;
                        }
                        
	                	if (Counter > Increment * PolarValue) {
	                		
	                		Inverter = !Inverter;
	                	}
	                
	                	if (Counter < inv(Increment) * PolarValue) {
	                		
	                		Inverter = !Inverter;
	                	}
	                }
		        }
		    
		        if ((get_ival(ADS) || get_ival(FIRE)) && Axis >= ZenPolarRelease) {
                    
                    if (DoGzReleasMode == DoGzDamPolar) {    
		            	
		            	if (get_ival(FIRE)) {
                            
                     		DamRadius = DamFireRadius;
                        	DamAngle  = DamFireAngle;
                    	
                    	} else {
                                
                     		DamRadius = DamAdsRadius;
                        	DamAngle  = DamAdsAngle;
                        }
		            	
		            	Angle += DamAngle;
                    	Angle = Angle % 360;
                    	Sin = DamPolarArray[Angle % 360];
                    	Cos = DamPolarArray[(Angle + 270) % 360];
                    	Cos = (Cos * DamRadius) / 100;
                    	Sin = (Sin * DamRadius) / 100;
		            
                    	Set_Val(AimX,Cos);
                    	Set_Val(AimY,Sin); 
    	            
    	            } else if (DoGzReleasMode == DoGzReducer) {
    	        
    	        		combo_run(DoGzReducer);
    	        	}	
		        } else {
		        	
		        	combo_stop(DoGzReducer);
		        }
		    }
    
	    if (DUSTE) {
            RX = PS4_RX;
			RY = PS4_RY;
			RX =   PPFX;
			RY =   PPFY;
    	if(get_val(PS4_L2) > 80){
    	if(abs(get_val(XB1_RX) < deadzone)) 
    	if(abs(get_val(XB1_RY) < deadzone)) 
    	if(abs(get_val(XB1_RX) > deadzone)) 
    	if(abs(get_val(XB1_RY) > deadzone)){
   			PPFX = PolarFlow(PPFX,PXS,PXSE,PVSI,PFD,1);
        	PPFY = PolarFlow(PPFY,PYS,PYSE,PVS,PPFD,2);
       	    set_polar(POLAR_RS,30,PPFX);
    		set_polar(POLAR_RS,30,PPFY);}
}
}
}
     if (Shunt) {
        
        if (event_release(Shunt)) {
            Shunt = Off;
        }
            else {
            set_val (Shunt,Off);
         }
     }
   }
 
//Combos
combo V {
        set_val(Strafe, BRAV1(Strafe, BRAV + 1));
        set_val(Strafe, BRAV1(Strafe, BRAV - 2));
        set_val(Walk, BRAV1(Walk, BRAV + 1));
        set_val(Strafe, BRAV1(Strafe, BRAV + 1));
        set_val(Walk, BRAV1(Walk, BRAV - 2));
        set_val(Strafe, BRAV1(Strafe, BRAV + 1));
        set_val(Walk, BRAV1(Walk, BRAV + 1));
}
combo A {
        set_val(Strafe, BRAV2(Strafe, BRAV + 1));
        set_val(Strafe, BRAV2(Strafe, BRAV - 2));
        set_val(Walk, BRAV2(Walk, BRAV + 1));
        set_val(Strafe, BRAV2(Strafe, BRAV + 1));
        set_val(Walk, BRAV2(Walk, BRAV - 2));
        set_val(Strafe, BRAV2(Strafe, BRAV + 1));
        set_val(Walk, BRAV2(Walk, BRAV + 1));
}
combo R {
        set_val(AimX, BRAV3(AimX, K + 1));
        set_val(AimX, BRAV3(AimX, K - 2));
        set_val(AimY, BRAV3(AimY, K + 1));
        set_val(AimX, BRAV3(AimX, K + 1));
        set_val(AimY, BRAV3(AimY, K - 2));
        set_val(AimX, BRAV3(AimX, K + 1));
        set_val(AimY, BRAV3(AimY, K + 1));
}
combo B {
        set_val(AimX, BRAV4(AimX, K + 1));
        set_val(AimX, BRAV4(AimX, K - 2));
        set_val(AimY, BRAV4(AimY, K + 1));
        set_val(AimX, BRAV4(AimX, K + 1));
        set_val(AimY, BRAV4(AimY, K - 2));
        set_val(AimX, BRAV4(AimX, K + 1));
        set_val(AimY, BRAV4(AimY, K + 1));
}
function EVIL1() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > EVILDEADZONE || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -EVILDEADZONE)
combo_stop(EVIL1)return;}

function EVIL2() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > EVILDEADZONE + 1 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -EVILDEADZONE + 1)
combo_stop(EVIL2)return;}

function EVIL3() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > EVILDEADZONE + 2 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -EVILDEADZONE + 2)
combo_stop(EVIL3)return;}

function EVIL4() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > EVILDEADZONE + 3 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -EVILDEADZONE + 3)
combo_stop(EVIL4)return;}
function EVILMOVEMENTX() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > EVILDEADZONE + 4 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -EVILDEADZONE + 4)
combo_stop(EVIL_movement_finder)return;}
function ANTIRECOIL() {
if(get_val(PS4_L2) && get_val(PS4_R2))combo_run(EVILAntiRecoil)if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) >EVILANTIRECOIL -100 + 100)
combo_stop(EVILAntiRecoil)}
combo EVIL1 {
set_val(PS4_RX,EVILAIM1)wait(EVILDELAY)
set_val(PS4_RY,EVILAIM1)wait(EVILDELAY)
set_val(PS4_RX,-EVILAIM1)wait(EVILDELAY)
set_val(PS4_RY,-EVILAIM1)wait(EVILDELAY)
set_val(PS4_RY,-EVILAIM1)wait(EVILDELAY)
}
combo EVIL2 {
set_val(PS4_RX,EVILAIM2)wait(EVILDELAY)
set_val(PS4_RY,EVILAIM2)wait(EVILDELAY)
set_val(PS4_RX,-EVILAIM2)wait(EVILDELAY)
set_val(PS4_RY,-EVILAIM2)wait(EVILDELAY)}
combo EVIL3 {
set_val(PS4_RX,EVILAIM3)wait(EVILDELAY)
set_val(PS4_RY,EVILAIM3)wait(EVILDELAY)
set_val(PS4_RX,-EVILAIM3)wait(EVILDELAY)
set_val(PS4_RY,-EVILAIM3)wait(EVILDELAY)}
combo EVIL4 {
set_val(PS4_RX,EVILAIM4)wait(EVILDELAY)
set_val(PS4_RY,EVILAIM4)wait(EVILDELAY)
set_val(PS4_RX,-EVILAIM4)wait(EVILDELAY)
set_val(PS4_RY,-EVILAIM4)wait(EVILDELAY)}

combo EVIL_movement_finder {
EVILAIM_MOVEMENT_TRACK = 1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
EVILAIM_MOVEMENT_TRACK = 1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
EVILAIM_MOVEMENT_TRACK = -1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
EVILAIM_MOVEMENT_TRACK = -1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
EVILAIM_MOVEMENT_TRACK = (-EVILAIM_MOVEMENT_TRACK + EVILAIM_MOVEMENT_TRACK)
}
   combo EVILAntiRecoil { 
 D = get_ival(PS4_RY) +  EVILANTIRECOIL;
 if(D>  100 + 100 - 100 )EVILANTIRECOIL = 100 -100 + 100;
set_val(PS4_RY,D)}
combo BraveAimHeadLock {
        set_val(XB1_LX, -34);
        wait(50);
        set_val(XB1_LY, 17);
        wait(30);
        set_val(XB1_LX, 34);
        wait(50);
        set_val(XB1_LY, -17);
        wait(30);
}
combo BraveAimHeadAssist {
        ARV = get_val(PS4_RY) + BraveAimHeadAssistPower;
        if (ARV > 100) ARV = 100;
        if (abs(get_val(PS4_RY)) < abs(BraveAimHeadAssistPower) + 5) set_val(PS4_RY, (ARV));
        ARH = get_val(PS4_RX) + BARRHP;
        if (ARH > 100) ARH = 100;
        if (abs(get_val(PS4_RX)) < abs(BARRHP) + 5) set_val(PS4_RX, ARH);
}
combo BraveAimMagnet {
        AV = get_val(PS4_RY) + BraveAimHeadShotAssistPower;
        if (AV > 100) AV = 100;
        if (abs(get_val(PS4_RY)) < abs(BraveAimHeadShotAssistPower) + 5) set_val(PS4_RY, (AV));
        AH = get_val(PS4_RX) + BAHHAP;
        if (AH > 100) AH = 100;
        if (abs(get_val(PS4_RX)) < abs(BAHHAP) + 5) set_val(PS4_RX, AH);
}
combo BraveAimConstantAimBooster1 {
        set_val(AimY, y_val(AimY, BACAPY));
        wait(BACAD);
        set_val(AimX, x_val(AimX, BACAPX));
        wait(BACAD);
        set_val(AimY, y_val(AimY, BACAPY * -1));
        wait(BACAD);
        set_val(AimX, x_val(AimX, BACAPX * -1));
        wait(BACAD);
}
combo BraveAimConstantAimBooster2 {
        set_val(AimY, y_val(AimY, BACAPY2));
        wait(BACA2D);
        set_val(AimX, x_val(AimX, BACAPX2));
        wait(BACA2D);
        set_val(AimY, y_val(AimY, BACAPY2 * -1));
        wait(BACA2D);
        set_val(AimX, x_val(AimX, BACAPX2 * -1));
        wait(BACA2D);
}
combo BraveAimConstantAimBooster3 {
        set_val(AimY, y_val(AimY, BACAPY3));
        wait(BACA3D);
        set_val(AimX, x_val(AimX, BACAPX3));
        wait(BACA3D);
        set_val(AimY, y_val(AimY, BACAPY3 * -1));
        wait(BACA3D);
        set_val(AimX, x_val(AimX, BACAPX3 * -1));
        wait(BACA3D);
}
combo BraveAimConstantAimBooster4 {
        set_val(AimY, y_val(AimY, BACAPY4));
        wait(BACA4D);
        set_val(AimX, x_val(AimX, BACAPX4));
        wait(BACA4D);
        set_val(AimY, y_val(AimY, BACAPY4 * -1));
        wait(BACA4D);
        set_val(AimX, x_val(AimX, BACAPX4 * -1));
        wait(BACA4D);
}
combo BraveAimAABooster1 {
        set_val(AimY, (BraveAimAA1));
        wait(1) set_val(AimX, (BraveAimAA1));
        wait(1) set_val(AimY, (-BraveAimAA1));
        wait(1) set_val(AimX, (-BraveAimAA1));
        wait(1) set_val(AimY, (BraveAimAA1));
        wait(1) set_val(AimX, (BraveAimAA1));
        wait(1) set_val(AimY, (-BraveAimAA1));
        wait(1) set_val(AimX, (-BraveAimAA1));
        wait(1);
}
combo BraveAimAABooster2 {
        BraveAimAABooster5 = random(-1, 1) set_val(AimY, get_ival(AimY) + BraveAimAABooster5);
        wait(2);
        set_val(AimX, get_ival(AimX) + BraveAimAABooster5);
        set_val(Strafe, get_ival(Strafe) + BraveAimAABooster5);
        wait(2);
        set_val(AimY, get_ival(AimY) + BraveAimAABooster5 * -1);
        wait(2);
        set_val(AimX, get_ival(AimX) + BraveAimAABooster5 * -1);
        set_val(Strafe, get_ival(Strafe) + BraveAimAABooster5 * -1);
        wait(2);
}
combo BraveAimAABooster3 {
        offset(AimX, BraveAimAA3);
        offset(AimY, BraveAimAA3);
        wait(6);
        offset(AimX, BraveAimAA3 * -1);
        offset(AimY, BraveAimAA3 * -1);
        wait(6);
}
combo BraveAimAABooster4 {
        if (!(InputTime++ % 4)) BraveAimSP(POLAR_RS, PolarSD = (PolarSD + BAPS) % 360, BAPP * 359);
        InputTime = 0;
}
combo BraveAimAABooster5 {
        set_val(AimX, SetVal(AimX, BraveAimAARX + 1));
        wait(3);
        set_val(AimX, SetVal(AimX, BraveAimAARX - 1));
        wait(3);
}
combo STICKY_AIM {
	set_val(PS4_RY,xy_val(PS4_RY, _v));
	wait(10);
	set_val(PS4_RX,xy_val(PS4_RX, _v));
	set_val(PS4_LX,xy_val(PS4_LX, _v));
	wait(10);
	set_val(PS4_RY,xy_val(PS4_RY, _v * -1));
	wait(10);
	set_val(PS4_RX,xy_val(PS4_RX, _v * -1));
	set_val(PS4_LX,xy_val(PS4_LX, _v * -1));
	wait(10);
}
combo Sticky_AA {
	set_val(AimY,  XY_Val (AimY,  Aim_Val));
	wait(Wait_Val);
	set_val(AimX,  XY_Val (AimX,  Aim_Val));
	wait(Wait_Val);
	set_val(AimY,  XY_Val (AimY,  Aim_Val  * -1));
	wait(Wait_Val);
	set_val(AimX,  XY_Val (AimX,  Aim_Val  * -1));
	wait(Wait_Val);
}
function GetShapes(f_var) {
	if (!SpiralPosition1) {
		InnerSpiral -= 1;
		if (InnerSpiral < cAAlostShapeRangeMin)SpiralPosition1 = On;
			}
	else {
		InnerSpiral += 1;
		if (InnerSpiral > f_var)SpiralPosition1 = Off;
			}
	if (!SpiralPosition2) {
		OuterSpiral -= 1;
		if (OuterSpiral < cAAlostShapeRangeMin)SpiralPosition2 = On;
			}
	else {
		OuterSpiral += 1;
		if (OuterSpiral > f_var)SpiralPosition2 = Off;
			}
	if (cAAlostShape == Circular) {
		RYT = (get_val(RY)) + ((SinAngle * f_var))/100;
		RXT = (get_val(RX)) + ((CosAngle * f_var))/100;
			}
	if (cAAlostShape == TallOval) {
		RYT = (get_val(RY)) + ((SinAngle * f_var))/100;
		RXT = (get_val(RX)) + ((CosAngle * cAAlostShapeRangeMin))/100;
			}
	if (cAAlostShape == WideOval) {
		RXT = (get_val(RX)) + ((CosAngle * f_var))/100;
		RYT = (get_val(RY)) + ((SinAngle * cAAlostShapeRangeMin))/100;
			}
	if (cAAlostShape == Spiral) {
		RYT = (get_val(RY)) + ((SinAngle * InnerSpiral))/100;
		RXT = (get_val(RX)) + ((CosAngle * OuterSpiral))/100;
			}
	if (cAAlostShape == Helix) {
		if (PositionT <= 1) {
			RXT = (get_val(RX)) + ((CosAngle * f_var))/100;
					}
		if (PositionT > 1) {
			RYT = (get_val(RY)) + ((SinAngle * f_var))/100;
					}
		PositionT++;
		if (PositionT == 4) PositionT = Off;
			}
	set_val(RX,RXT);
	set_val(RY,RYT);
	}
function AxisRelease(AxisXY,AxisVal) {
	if (abs(get_ival(AxisXY)) <= cAAlostAAPower) return AxisVal;
	return get_ival(AxisXY);
	}
combo cAAlostPolarAssist3 {
	set_val(RY,AxisRelease(RY,cAAlostAAPower));
	wait(cAAlostAADelay);
	set_val(RX,AxisRelease(RX,cAAlostAAPower));
	wait(cAAlostAADelay);
	set_val(RY,AxisRelease(RY,inv(cAAlostAAPower)));
	wait(cAAlostAADelay);
	set_val(RX,AxisRelease(RX,inv(cAAlostAAPower)));
	wait(cAAlostAADelay);
	}
combo cAAlostAA5 {
	set_val(AimY,cAAlostAA5Power);
	wait(cAAlostAA5Delay);
	set_val(AimX,cAAlostAA5Power);
	wait(cAAlostAA5Delay);
	set_val(AimY,cAAlostAA5Power * -1);
	wait(cAAlostAA5Delay);
	set_val(AimX,cAAlostAA5Power * -1);
	wait(cAAlostAA5Delay);
	}
function P() {
	cAAlostPolarAA2Speed2 = (cAAlostPolarAA2Speed2 + cAAlostAA5Speed) % 360;
	SP(cAAlostPolarAA2Speed2,cAAlostAA5Range);
	}
function SP(cAAlostAA5Speed,cAAlostAA5Range){
	RX = AimX;
	RY = AimY;
	if(cAAlostAA5Speed < 0) cAAlostAA5Speed = 360 + (cAAlostAA5Speed % 360);
	cAAlostAA5Speed = (cAAlostAA5Speed + 90) % 360;
	cAAlostAA5Range = clamp(cAAlostAA5Range, 0, 100);
	Sin = Polar_Array[cAAlostAA5Speed];
	Cos = Polar_Array[(cAAlostAA5Speed + 90) % 360];
	Sv(RX,inv(cAAlostAA5Range * Cos / 100));
	Sv(RY,inv(cAAlostAA5Range * Sin / 100));
	return;
	}
function Sv(Input,Output) {
	set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
	return;
	}
function SV(Input,Output) {
	set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
	return;
	}
combo cAAlostAA7 {
	SV(RY,cAAlostAA7Power);
	wait(cAAlostAA7Delay);
	SV(RX,cAAlostAA7Power2);
	SV(RY,cAAlostAA7Power * -1);
	wait(cAAlostAA7Delay);
	SV(RX,cAAlostAA7Power2 * -1);
	wait(cAAlostAA7Delay);
	}
function calostPolarV3 (Current,Received) {
	YROutput = Current / 10 + Received / 10;
	if(YROutput <= -3276) return -32768;
	if(YROutput >=  3276) return  32767;
	return Current + Received;
	}
function calostPolarity (Rotation,Radial) {
	set_polar(PS,Rotation,Radial * 327);
	set_val(PX,calostPolarV3(get_val(PX) + YRValueX * 327,get_ival(PX)));
	set_val(PY,calostPolarV3(get_val(PY) + YRValueY * 327,get_ival(PY)));
	}
combo cAAlostAA6 {
	set_val(10, (cAAlostAA6Power));
	wait(10)set_val(9, (cAAlostAA6Power));
	wait(10)set_val(10, cAAlostAA6Power * -1);
	wait(10)set_val(9, cAAlostAA6Power * -1);
	wait(10)
}
function AA1Shake() {
	Angle1 = (Angle1 + cAAlostAA6Speed) % 360;
	Set_polar1(2,Angle1, cAAlostAA6PowerPlusOne);
	}
combo cAAlostAA8 {
	set_val(10, (cAAlostAA4Power));
	wait(10)set_val(9, (cAAlostAA4Power));
	wait(10)set_val(10, cAAlostAA4Power * -1);
	wait(10)set_val(9, cAAlostAA4Power * -1);
	wait(10)
}
function Set_polar1(stick, angle, cAAlostPolarAA2Range){
	x_stick = 8 + stick;
	y_stick = 9 + stick;
	if(angle < 0) angle = 360 + (angle % 360);
	angle = (angle + 90) % 360;
	cAAlostPolarAA2Range = clamp(cAAlostPolarAA2Range, 0, 100);
	sin_angle = Polar_Array[angle];
	cos_angle = Polar_Array[(angle + 90) % 360];
	offset(x_stick, inv(cAAlostPolarAA2Range * cos_angle / 100));
	offset(y_stick, inv(cAAlostPolarAA2Range * sin_angle / 100));
	return;
	}
function offset(int axis, int offset_val) {
	set_val(axis, clamp(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));
	return
}
combo cAAlostAA4 {
	set_val(AimY,xy_val1(AimY, cAAlostConstantAP));
	wait(cAAlostConstantAssistDelay);
	set_val(AimX,xy_val1(AimX, cAAlostConstantAP));
	wait(cAAlostConstantAssistDelay);
	set_val(AimY,xy_val1(AimY, cAAlostConstantAP * -1));
	wait(cAAlostConstantAssistDelay);
	set_val(AimX,xy_val1(AimX, cAAlostConstantAP * -1));
	wait(cAAlostConstantAssistDelay);
	}
function xy_val1(f_axis,f_val) {
	if(abs(get_val(f_axis)) < (cAAlostConstantAP + 1))  return f_val;
	return get_val(f_axis);
	}
combo cAAlostAA3 {
	set_val(AimY,cAAlostAA3Power);
	wait(cAAlostAA3Delay);
	set_val(AimX,cAAlostAA3Power);
	wait(cAAlostAA3Delay);
	set_val(AimY,cAAlostAA3Power * -1);
	wait(cAAlostAA3Delay);
	set_val(AimX,cAAlostAA3Power * -1);
	wait(cAAlostAA3Delay);
	}
function Polar() {
	cAAlostPolarAA2Speed2 = (cAAlostPolarAA2Speed2 + cAAlostPolarAA2Speed) % 360;
	Set_polarA(cAAlostPolarAA2Speed2,cAAlostPolarAA2Range2);
	}
function Set_polarA(angle,cAAlostPolarAA2Range){
	RX = AimX;
	RY = AimY;
	if(angle < 0) angle = 360 + (angle % 360);
	angle = (angle + 90) % 360;
	cAAlostPolarAA2Range = clamp(cAAlostPolarAA2Range, 0, 100);
	Sin = Polar_Array[angle];
	Cos = Polar_Array[(angle + 90) % 360];
	sV(RX,inv(cAAlostPolarAA2Range * Cos / 100));
	sV(RY,inv(cAAlostPolarAA2Range * Sin / 100));
	return;
	}
combo cAAlostBloomReducer {
	set_val(XB1_LX,-35);
	wait(BloomReducerDelay);
	set_val(XB1_LX, 35);
	wait(BloomReducerDelay);
	if(BloomReducerDelay < 160){
		BloomReducerDelay = BloomReducerDelay + 10;
			}
	else {
		BloomReducerDelay = 100;
			}
	}
combo cAAlostAA2 {
	set_val(AimY,AxisR(AimY,cAAlostAA2Power));
	wait(cAAlostAA2Delay);
	set_val(AimX,AxisR(AimX,cAAlostAA2Power));
	wait(cAAlostAA2Delay);
	set_val(AimY,AxisR(AimY,inv(cAAlostAA2Power)));
	wait(cAAlostAA2Delay);
	set_val(AimX,AxisR(AimX,inv(cAAlostAA2Power)));
	wait(cAAlostAA2Delay);
	}
function AimAssist (Strength,Step) {
	if (Power) {
		Ypower = Strength;
		Xpower = Strength * -1;
		Increment = Step;
		Power = Off;
			}
	if (!power) {
		Xpower += Increment;
		Ypower -= Increment;
			}
	else {
		Xpower -= Increment;
		Ypower += Increment;
			}
	CountPower ++;
	if (CountPower >= (Strength / Increment)) {
		power = !power;
		CountPower = 0;
			}
	if (AxisXY > DeadZone) {
		if (Reducer) {
			set_val(RY,(Ypower - Strength / 2));
			set_val(RX,(Xpower - Strength / 2 * -1));
					}
		else {
			set_val(RY,(Ypower - Strength / 2) + get_ival(RY));
			set_val(RX,(Xpower - Strength / 2 * -1) + get_ival(RX));
					}
			}
	else {
		if (Reducer) {
			set_val(RY,(Ypower - Strength / 2));
			set_val(RX,(Xpower - Strength / 2 * -1));
					}
		else {
			set_val(RY,(Ypower - Strength / 2));
			set_val(RX,(Xpower - Strength / 2 * -1));
					}
			}
	}
function AimAssistY() {
	AAT += get_rtime();
	if (!Axis) sV(RY,AAT * cAAlostPolarAAPower / 10);
	if (Axis == 1) sV(RX,AAT * cAAlostPolarAAPower / 10);
	if (Axis == 2) sV(RY,inv(AAT * cAAlostPolarAAPower / 10));
	if (Axis == 3) {
		sV(RX,inv(AAT * cAAlostPolarAAPower / 10));
		if (AAT > 50) {
			AAT = 0;
			Axis = 0;
					}
			}
	else if (AAT > 50) {
		AAT = 0;
		Axis += 1;
			}
	}
function sV(Input,Output) {
	set_val(Input,clamp(Output * (100 - abs(get_ival(Input))) / 100 + get_ival(Input),-100,100));
	return;
	}
function AxisR(AxisXY,AxisVal) {
	if (abs(get_ival(AxisXY)) <= Power) return AxisVal;
	return get_ival(AxisXY);
	}
combo LIGMA46 {
  set_val(PS4_RY, LIGMA28 * -1);
  wait(10) set_val(PS4_RX, LIGMA28);
  wait(10) set_val(PS4_RY, LIGMA28);
  wait(10) set_val(PS4_RX, LIGMA28 * -1);
  wait(10)
}
combo LIGMA40 {
  set_val(PS4_RY, a_f(PS4_RY, LIGMA18));
  wait(LIGMA22) set_val(PS4_RX, a_f(PS4_RX, LIGMA18));
  wait(LIGMA22) set_val(PS4_RY, a_f(PS4_RY, LIGMA19));
  wait(LIGMA22) set_val(PS4_RX, a_f(PS4_RX, LIGMA19));
  wait(LIGMA22)
}
combo LIGMA41 {
  set_val(PS4_RY, a_f(PS4_RY, LIGMA20));
  wait(LIGMA22) set_val(PS4_RX, a_f(PS4_RX, LIGMA20));
  wait(LIGMA22) set_val(PS4_RY, a_f(PS4_RY, LIGMA21));
  wait(LIGMA22) set_val(PS4_RX, a_f(PS4_RX, LIGMA21));
  wait(LIGMA22)
}
combo LIGMA37 {
  wait(4) set_val(PS4_RX, DHRUVBOT5);
  wait(LIGMA6);
  set_val(PS4_RX, DHRUVBOT5 * (-1));
  wait(LIGMA6);
}
combo DoGzReducer {

	set_Ival(AimX,ReducerPower);
	set_Ival(AimY,ReducerPower);
	wait(ReducerTime);
	set_Ival(AimX,inv(ReducerPower));
	set_Ival(AimY,inv(ReducerPower));
	wait(ReducerTime);
}
combo RapidFire {

    set_val(FIRE,100);
    wait(RapidFireHold);
    set_val(FIRE,0);
    wait(RapidFireWait);
}
combo SmartFire {

    set_val(FIRE,100);
    wait(SmartFireHold);
    set_val(FIRE,0);
    wait(SmartFireWait);
}
combo AS { 
	set_val(AimY,	AxisRelease(AimY,	AALinearExpo));
	wait(Delay);
	set_val(AimX,	AxisRelease(AimX,	AALinearExpo));
	wait(Delay);
	set_val(AimY,	AxisRelease(AimY,	NegativeAALinearExpo));
	wait(Delay);
	set_val(AimX,	AxisRelease(AimX,	NegativeAALinearExpo));
	wait(Delay);
}
combo BattsStickyAssist {
   
   set_val(AimY,AxisRelease(AimY,BattStickyPower));
   wait(BattStickyTime);
   set_val(AimX,AxisRelease(AimX,BattStickyPower));
   set_val(Strafe,AxisRelease(Strafe,BattStickyPower));
   wait(BattStickyTime);
   set_val(AimY,AxisRelease(AimY,inv(BattStickyPower)));
   wait(BattStickyTime);
   set_val(AimX,AxisRelease(AimX,inv(BattStickyPower)));
   set_val(Strafe,AxisRelease(Strafe,inv(BattStickyPower)));
   wait(BattStickyTime);
}
combo cNikoAim {
	WaitStrength	= random(AimAssistWaitTime / 2 , AimAssistWaitTime);
	AimStrength		= random(inv(AimAssistStrength), AimAssistStrength);

	Set_Val(AimY,	AimStrength);
	wait(WaitStrength);
	Set_Val(AimX,	AimStrength);
	wait(WaitStrength);
	Set_Val(AimY,	inv(AimStrength));
	wait(WaitStrength);
	Set_Val(AimX,	inv(AimStrength));
	wait(WaitStrength);
}
combo HeadAssist{

	set_val(AimY,inv(Head) + get_val(AimY));
}
combo Aim_Linear {

    set_val(Strafe,inv(Strength_Linear));
    wait(Wait_Linear);
    set_val(Strafe,Strength_Linear);
    wait(Wait_Linear);
}
combo Confirm {

    set_val(CONFIRM,100);
    wait(50);
    set_val(CONFIRM,0);
    wait(100);
}
combo FastReset {

 
    wait(50)
    set_val(RESET,100);        
    wait(50);
    combo_run(Confirm);
}

combo InstantReset {

    wait(20)
    combo_run(Confirm);
}

//Functions
function BRAV3(BRAVAIMBOT, SOFTAIM) {
        if (abs(get_val(BRAVAIMBOT)) < (K - 1)) return SOFTAIM;
        return get_val(BRAVAIMBOT);
}

function BRAV2(BRAVAIMBOT, SOFTAIM) {
        if (abs(get_val(BRAVAIMBOT)) < (BRAV - 1)) return SOFTAIM;
        return get_val(BRAVAIMBOT);
}

function BRAV4(BRAVAIMBOT, SOFTAIM) {
        if (abs(get_val(BRAVAIMBOT)) < (K + 1)) return SOFTAIM;
        return get_val(BRAVAIMBOT);
}

function BRAV1(BRAVAIMBOT, SOFTAIM) {
        if (abs(get_val(BRAVAIMBOT)) < (BRAV + 1)) return SOFTAIM;
        return get_val(BRAVAIMBOT);
}
function x_val(f_axis, f_val) {
        if (abs(get_val(f_axis)) < (BACAPX + 1)) return f_val;
        return get_val(f_axis);
}

function y_val(f_axis, f_val) {
        if (abs(get_val(f_axis)) < (BACAPY + 1)) return f_val;
        return get_val(f_axis);
}
function SetVal(Axis1, Value1) {
        if (abs(get_val(Axis1)) < (BraveAimAARX - 1)) return Value1;
        return get_val(Axis1);
}
function BraveAimSP(Axis, bRave, Axis5) {
        Nine = 9 + Axis;
        Ten = 10 + Axis;
        if (bRave < 0) bRave = 360 + (bRave % 360);
        bRave = (bRave + 90) % 360;
        Axis5 = clamp(Axis5, 0, 100);
        Sin = BraveAimData[bRave];
        Cos = BraveAimData[(bRave + 90) % 360];
        offset(Nine, inv(Axis5 * Cos / 100));
        offset(Ten, inv(Axis5 * Sin / 100)) return;
}
function Set_polar(stick, angle, radius){
x_stick = deadzone + stick; 
y_stick = deadzone + stick;
if(angle < 0) angle = 360 + (angle % 360);
angle = (angle + 90) % 360;
radius = clamp(radius, 0, 100);
sin_angle = Polar_Array[angle];
cos_angle = Polar_Array[(angle + 90) % 360];
offset1(x_stick, inv(radius * cos_angle / 100));
offset1(y_stick, inv(radius * sin_angle / 100));
return;}

function Shake() { 
angle2 = (angle2 + SPEED) % 360;
Set_polar(2,angle2, aaValue);
} 

function xy_val(f_axis,f_val) {
if(abs(get_val(f_axis)) < (_v + 1))  
return f_val;    
return get_val(f_axis);
}

function offset1(int axis, int offset_val) {
set_val(axis, clamp(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));
return}

function XY_Val(f_Axis, f_Val) {
    if(abs(get_val(f_Axis)) < 25)
		return f_Val;
			return get_ival(f_Axis);
}

function a_f(p, m) {
  if (abs(get_val(p)) < MONKEY23) return m;
  return get_val(p);
}
function Set_Polar(Angle) {   
    if(Angle <= 90)
    {        
        Cosinus = (Lookup_Table[90 - Angle]);
        Sinus = (Lookup_Table[Angle]);
    }
    else if (Angle <= 180)
    {
        Cosinus = (-Lookup_Table[Angle - 90]);
        Sinus = (Lookup_Table[180 - Angle]);
    }
    else if (Angle <= 270)
    {
        Cosinus = (-Lookup_Table[270 - Angle]);
        Sinus = (-Lookup_Table[Angle - 180]);
    }
    else if (Angle <= 360)
    {
        Cosinus = (Lookup_Table[Angle - 270]);
        Sinus   = (-Lookup_Table[360 - Angle]);
    }
	RX_Polar = (get_lval(AimX)) - X_JOY_OFFSET + ( (Cosinus * Radius__) )/100;
	    
	if( RX_Polar > 100)
	{
	   RX_Polar = 100;
	}    
	else if( RX_Polar < -100)
	{
	   RX_Polar = -100;
	}
	if(DhRuvsKii )
	{
		RY_Polar = (get_lval(AimY)) - Y_JOY_OFFSET + ( (Sinus   * Radius__) )/100;
	 	
	    if( RY_Polar > 100)
	    {
	        RY_Polar = 100;
	    }    
	    else if( RY_Polar < -100)
	    {
	        RY_Polar = -100;
	   
	   	}
	}
    if(DhRuvsKii )
    {
    	set_val(AimX, RX_Polar);
    	set_val(AimY, RY_Polar);
    }
    else
    {
    	set_val(AimX, RX_Polar);
    } 
    }
function DoGzTimeZ() {

	AAT += get_rtime();
	
	if (!AxisT) 
		
		set_Ival(AimY,AAT * Power / 10);
		
	if (AxisT == 1)  
		
		set_Ival(AimX,AAT * Power / 10);
	
	if (AxisT == 2)  
		
		set_Ival(AimY,inv(AAT * Power / 10));

	if (AxisT == 3) {
		
		set_Ival(AimX,inv(AAT * Power / 10));
	
		if (AAT > 50) {
		
			AAT = 0;
			AxisT = 0;
		}
	
	} else if (AAT > 50) {
		
		AAT = 0;
		AxisT += 1;
	}
}
function PolarFlow(PFB,PSV,PFV,PV,PF,PID) {
    	if(PF) {
       		PFB += PV;
    	if(PFB <= PFV)  
    	return PFB;
    	if(PFB > PFV) {
        	PVID[PID] = 0;
    	return PFB - PV;}
}
		else{
        	PFB -= PV;    
    	if(PFB >= PSV)  
    	return PFB;
    	if(PFB < PSV) {
    		PVID[PID] = 1; 
        return PFB + PV;}
} 
       {return FALSE;
}
   		
 	   
}
function EditAssist () {

    EditT += get_rtime();
        
        if (get_ival(EditAssist)) {
            
            if (EditT >= EditDelay)
                  
           		Press(SELECT);
        }
}

function Press (Button) {

    if (get_ival(Button))
        
   		return;
            
            set_val(Button,100);
}
function Set_Val(Input,Output) {
	
	set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
	
	return;
}

function set_Ival(Input,Output) {

      set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
        
      return; 
}

function _DEADZONE (){                               
   if(abs(get_val(Walk)) < DZ_L && abs(get_val(Strafe)) < DZ_L || abs(get_val(Walk)) < invDZ_L && abs(get_val(Strafe)) < invDZ_L){        
        set_val(Walk, 0);                                                
        set_val(Strafe, 0);                                                
}                                
    if(abs(get_val(AimY)) < DZ_R && abs(get_val(AimX)) < DZ_R || abs(get_val(AimY)) < invDZ_R && abs(get_val(AimX)) < invDZ_R){         
        set_val(AimY,0);                                                 
        set_val(AimX,0);                                                
}
}
function _NoInputLag() {

   if(get_ival(PS4_UP)){set_val(PS4_UP, 100)}//DPAD
   if(get_ival(PS4_DOWN)){set_val(PS4_DOWN, 100)}//DPAD
   if(get_ival(PS4_LEFT)){set_val(PS4_LEFT, 100)}//DPAD
   if(get_ival(PS4_RIGHT)){set_val(PS4_RIGHT, 100)}//DPAD
   if(get_ival(PS4_SQUARE)){set_val(PS4_SQUARE, 100)}//BUTTONS
   if(get_ival(PS4_TRIANGLE)){set_val(PS4_TRIANGLE, 100)}//BUTTONS
   if(get_ival(PS4_CIRCLE)){set_val(PS4_CIRCLE, 100)}//BUTTONS
   if(get_ival(PS4_CROSS)){set_val(PS4_CROSS, 100)}//BUTTONS
   if(get_ival(PS4_L1)){set_val(PS4_L1, 100)}//BUMPERS
   if(get_ival(PS4_R1)){set_val(PS4_R1, 100)}//BUMPERS
   //if(get_ival(PS4_L2)){set_val(PS4_L2, 100)}//TRIGGERS      **I GUESS WE DONT NEED IT ON TRIGGERS**
   //if(get_ival(PS4_R2)){set_val(PS4_R2, 100)}//TRIGGERS    *JUST IN CASE U DONT WANT/NEED HAIRTRIGGERS*
   if(get_ival(PS4_L3)){set_val(PS4_L3, 100)}//STICK CLICK
   if(get_ival(PS4_R3)){set_val(PS4_R3, 100)}//STICK CLICK
   if(!get_ival(ADS)){
   if(get_ival(PS4_SHARE)){set_val(PS4_SHARE, 100)}//MISCELLANEOUS
   if(get_ival(PS4_TOUCH)){set_val(PS4_TOUCH, 100)}//MISCELLANEOUS
   if(get_ival(PS4_OPTIONS)){set_val(PS4_OPTIONS, 100)}//MISCELLANEOUS
   }
   if(!get_ival(TOUCHPAD)){
   if(get_ival(PS4_PS)){set_val(PS4_PS, 100)}//MISCELLANEOUS
   }
   else {
   if(event_release(PS4_UP)){set_val(PS4_UP, 0)}//DPAD
   if(event_release(PS4_DOWN)){set_val(PS4_DOWN, 0)}//DPAD
   if(event_release(PS4_LEFT)){set_val(PS4_LEFT, 0)}//DPAD
   if(event_release(PS4_RIGHT)){set_val(PS4_RIGHT, 0)}//DPAD
   if(event_release(PS4_SQUARE)){set_val(PS4_SQUARE, 0)}//BUTTONS
   if(event_release(PS4_TRIANGLE)){set_val(PS4_TRIANGLE, 0)}//BUTTONS
   if(event_release(PS4_CIRCLE)){set_val(PS4_CIRCLE, 0)}//BUTTONS
   if(event_release(PS4_CROSS)){set_val(PS4_CROSS, 0)}//BUTTONS
   if(event_release(PS4_L1)){set_val(PS4_L1, 0)}//BUMPERS
   if(event_release(PS4_R1)){set_val(PS4_R1, 0)}//BUMPERS
   if(event_release(PS4_L2)){set_val(PS4_L2, 0)}//TRIGGERS     **BUT WE NEED THE RELEASE**
   if(event_release(PS4_R2)){set_val(PS4_R2, 0)}//TRIGGERS      *SO IT CAN GO TO 0 QUICK*
   if(event_release(PS4_L3)){set_val(PS4_L3, 0)}//STICK CLICK
   if(event_release(PS4_R3)){set_val(PS4_R3, 0)}//STICK CLICK
   if(event_release(PS4_SHARE)){set_val(PS4_SHARE, 0)}//MISCELLANEOUS
   if(event_release(PS4_TOUCH)){set_val(PS4_TOUCH, 0)}//MISCELLANEOUS
   if(event_release(PS4_OPTIONS)){set_val(PS4_OPTIONS, 0)}//MISCELLANEOUS
   if(event_release(PS4_PS)){set_val(PS4_PS, 0)}//MISCELLANEOUS
		   }		   
}
const int16 BraveAimData[] = {100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100};
const int16 Lookup_Table[]  = { 0, 1, 3, 5, 6, 8, 10, 12, 13, 15, 17, 19, 20, 22, 24, 25, 27, 29, 30, 32, 34, 35, 37, 39, 40, 42, 43, 45, 46, 48, 50, 51, 52, 54, 55, 57, 58, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 90, 91, 92, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 100 };
const int8 ExploitPolar[]= {
    100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,
    71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,
    -8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,
    -65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,
    -97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,
    -94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,
    -56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,
    11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,
    81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100
};
const int8 DamPolarArray[]= { 100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100};
const char Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; ú¹ˆ¾†·ƒ´‚´†¿‰½‹³