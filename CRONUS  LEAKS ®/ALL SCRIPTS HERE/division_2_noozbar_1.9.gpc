// GPC Online Library
// the_division_2_-_cronuszen_only.gpc

/*

Game: The Division 2
Version 1.9
Device: CronusZEN ONLY
Controller tested: DS4 - Elite 2
Author: noozbar

____________________________________________________________________________________________________________________________________________________

◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸

											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
							
							
Features which can be activated (ON or OFF) independently on each of the three profiles (for example; AntiRecoil is ON on profile 1, OFF on profile 2 and ON on profile 3)

	3 Profiles (weapon) with:
			Antirecoil (progressive, scaled by Time) - with editable values and toggles for each of the profiles
				- while fireing
					Antirecoil Start
					Antirecoil End 
					Antirecoil Time 
					Antirecoil Horizontal
					
			RapidFire - with editable value and toggles for each of the profile
				- while fireing
					Rounds Per Minute / Bullets Per Minute
	  	
			BurstFire - with editable values and toggle for each of the profile 
				- while fireing
					Hold time 
					Release time 
		*** RapidFire and BurstFire can't be enable at the same time on the same profile
			
			AIM Assist - with editable values and toggle for each of the profile
				- while aiming
					Motion size 
					Motion speed 
			
			Strafe Shot - with editable values and toggle for of the each profile
				- while fireing
					Strafe time 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
	General features which can be activated or deactivated on all profiles at the same time (three bars displayed on the OLED screen)
			
			DynaSens - with editable values and toggle
				- while aiming and also when you deploy a skill
			
			Reload - with editable value and toggle 
				- double tap reload to start reload, cut reload and switch weapon, with the right timer, your weapon will be reloaded
					Reload time
			
			AutoRun - with toggle
				- push forward Left stick
					- Elite controller: hold PR1 (Paddle Right 1) to temporarily stop running, release to run agaim
			
			Easy Medkit - with toggle
				- double tap Dpad RIGHT
				
			Quick Nade - with toggle
				- hold aiming button and tap LEFT to throw grenade
				- hold LEFT more than 200 ms to throw grenade
					- Elite controller: hold PL1 (Paddle Left 1) to take a grenade and release PL1 to throw the nade
			
			Skill Destroy - with toggle
				- double tap skill button right or left to destroy the corresponding skill
			
			Easy Roll - with toggle
				- tap CROSS/A to roll, HOLD to take cover (it's good to change also the game settings "hold to cover")
					- Elite Controller: quick tap PR1 (Paddle Right 1) to roll
			
			Parkour - with toggle
				- auto parkour
			
			Swap Trigger/bumper - with toggle
				- swap L1/LB with L2/LT and R1/RB with R2/RT (don't set alternate or I don't know what in game settings)
			
			Inverted Y for vertical antirecoil - with toggle
				- invert Y axis (in game, inverted must be ON)
			
			Easy HeadShot
				- hold PR1 while aiming to move your crosshair to the UP
				
			(and Hair Trigger but always ON)
						
						
◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺		
____________________________________________________________________________________________________________________________________________________

											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
____________________________________________________________________________________________________________________________________________________

◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸											
	
	OLED screen indications: 
                              ———————————————————————————————
		                      |        G   A   M   E        |
		                      |      T   I   T   L   E      |  
		                      |       Current profile    num| ▻▻▻  num indicate on which ZEN slot you are
                              ———————————————————————————————
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

	OLED screen indications in ModMenu: 
                              ———————————————————————————————
		- First line:         |       Active Mod Name       |
		- Second line:        |       Current profile       | ▻▻▻  indicate on which profile/weapon we are acting 
		- Third line          |       ON / OFF status       |
                              ———————————————————————————————
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

	OLED screen indications in ModEdit: 
                              ———————————————————————————————
		- First line:         |      Active Value Name      |
		- Second line:        |       Current profile       | ▻▻▻  indicate on which profile/weapon we are acting 
		- Third line          |       Editable  Value       |
                              ———————————————————————————————
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜		

	OLED screen indications in KillSwitch: 
                              ———————————————————————————————
                              |         SCRIPT OFF          | ▻▻▻  indicate that the script is muted 
                              |                             | 
                              |   Hold CIRCLE/B to turn ON  | 
                              ———————————————————————————————
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

	Enter and Exit ModMenu
		- Hold L2/LT and tap OPTIONS/MENU 
		
		Navigate between every mods and toogles
			- Tap LEFT or RIGHT on the D-PAD
			
		Enable or disable the displayed mod
			- Tap UP to turn ON
			- Tap DOWN to turn OFF
			
		Switch (weapon) Profile 1, 2 or 3 (in ModMenu) 
			- Tap TRIANGLE/Y
						
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
			
	Enter ModEdit (only available for some mods and only if you are in ModMenu)
		While in ModMenu,
			- Tap CROSS/A to enter ModEdit on the current/displayed mod (if the mod have editable values)
			- Tap CIRCLE/B to exit ModEdit
			
		Navigate between every values available for this mod (if there is more than one value for this mod)
			- Tap LEFT or RIGHT 
			
		Edit values
			- Hold SQUARE/X   + RIGHT for +1 (or +10 depending value type)
				              + LEFT for -1 (or -10 depending value type)
				              + UP for +10 (or +100 depending value type)
				              + DOWN for -10 (or -100 depending value type)

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
				           
	Save every values (only available if you are in ModMenu or ModEdit)		
		- Tap PS/XBOX to save EVERY values and toggles and independently for EVERY profiles 

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Speed toggles (outside Mod Menu/Edit)
		- Hold aiming button and hold 300ms UP, DOWN, RIGHT or LEFT
			- UP for	RapidFire
			- DOWN for	BurstFire
			- RIGHT for	AIM Assist
			- LEFT for	Strafe Shot

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	
	Switch profiles
		- In Game:
			- Tap TRIANGLE/Y to switch profile 1 and 2 (primary and secondary)
			- Double tap to switch to profile 3 (handgun) (tap again to go back to the previous profile)
			- Hold TRIANGLE so switch to special weapon (every "assist" disabled)
		- In modMenu
			- Tap TRIANGLE/Y to loop profile 1, 2, 3, 1, 2, 3 ...

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Kill Switch (disable everything)
		- Turn ON to OFF or OFF to ON
			- Hold aiming button and tap SHARE/VIEW 
			- Tap PS/XBOX 
		- Turn ON (disable everything)
			- Tap OPTIONS/MENU
			- Tap Map button
		- Turn OFF (enable everything)
			- Double tap CIRCLE/B
			- Hold CIRCLE/B more than 600ms
			- Hold SQUARE/X more than 1000ms while on the map only (for fast travel)
		
____________________________________________________________________________________________________________________________________________________

				
How to use the ModMenu:

	Open ModMenu and press TRIANGLE/Y to change profile/weapon, Zen's eyes will change color
		If you see a bar on the left,   ZEN eyes are blue,    you're on the primary weapon
		If you see a bar in the middle, ZEN eyes are pink,    you're on the secondary weapon
		If you see a bar on the right,  ZEN eyes are skyblue, you're on the handgun

		If there are all three bars, the mod you set to ON or OFF will be activated for all profiles/weapons (like AutoRun for example)

	If the mod name has a star like that:  * 
		like AntiRecoil* and RapidFire*, this means that each profile/weapon has its own values for this mod

	If the mod name has something like this:  ' 
		like BurstFire' (and other mods), this means that the values you set for BurstFire will be the same on all profiles/weapons where you have enabled BurstFire
		
	If the mod name has nothing, 
		like AutoRun (and other mods), this means that there is no editable value, it's just a mod with a toggle only
		

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜		

Dynamic sensitivity (while aiming with weapons or skill): 

	DYNASENS_INITIAL_SENS displayed on OLED screen "DS Ini Sens" is your initial X and Y sensitivity (value range 0 - 100)
		While aiming, I want my sensitivity which is set to 100% in my game to be reduced by half as long as the stick input does not exceed DYNASENS_LIMIT
		So "DS Ini Sens" = 50 on the OLED screen

	DYNASENS_LIMIT displayed on OLED screen "DS Limit" is the stick input point from which the sensitivity increases (value range 0 - 100)
		When the stick input exceeds 65 (my DYNASENS_LIMIT value), it gradually increases the sensitivity from 50 (my DYNASENS_INITIAL_SENS value) to 100 (my DYNASENS_MAX_SENS value)
		The sensitivity increase rate is defined by DYNASENS_INCREASE_RATE

	DYNASENS_RESTART displayed on OLED screen "DS Restart" stick input point where sensitivity will reset back to initial sens (value range 0 - 100)
		When stick input goes down below 30 (my DYNASENS_RESTART value), stick sensitivity return to 50 (my DYNASENS_INITIAL_SENS value)

	DYNASENS_MAX_SENS displayed on OLED screen "DS Max Sens" is the maximum sensitivity value you want
		100 means that your maximum "DynaSens" sensitivity will be the one you set in your game

	DYNASENS_INCREASE_RATE displayed on OLED screen "DS Inc Rate" sensitivity increase rate
		1 = 10ms delay between increase


															THANK YOU FOR READING
															THANK YOU FOR READING
															THANK YOU FOR READING
											
											
◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺	
____________________________________________________________________________________________________________________________________________________



 	Text info:
			Almost every text are displayed in MEDIUM size because I'm far from my Zen and I can't read small texts
			"SAVED" is displayed in LARGE, you can replace SAVED text by something with 7 chars max
			"Profile x" is displayed in SMALL, ..... 18 chars max
			For the others text, they are displayed in MEDIUM, can be replaced by 11 chars max
*/

	const string TITLE = ""; // 11 char max
	//const string TITLE = "BulletK + M1A"; // Slot 1
	//const string TITLE = "Meca + Harmony"; // Slot 2
	//const string TITLE = "M4 + M1A"; // Slot 3
// Text to display 
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE= "SAVED";
	const string PROFILE_1 = "Primary";   // or primary weapon
	const string PROFILE_2 = "Secondary"; // or secondary weapon
	const string PROFILE_3 = "Handgun";   // or handgun
	const string SPECIAL = "Special weapon"; // or special weapon
	const string ALL = "Every Profiles";
	const string MUTE = "Script OFF";
	const string HOLD = "Hold CIRCLE/B";
	const string ACTIVE = "to turn ON"
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mod Name
	const string ANTIRECOIL = "AntiRecoil";   // modName_idx =  0
	const string RAPIDFIRE = "RapidFire";     // modName_idx =  1
	const string BURSTFIRE = "BurstFire";     // modName_idx =  2
	const string AIMASSIST = "AIM Assist";    // modName_idx =  3 		
	const string STRAFE_SHOT = "StrafeShot'";  // modName_idx =  4
	const string DYNASENS = "DynaSens";	   // modName_idx =  5
	const string RELOAD = "Reload";           // modName_idx =  6	
	
	const string AUTORUN = "AutoRun";	       // modName_idx =  7	    
	const string MEDKIT = "Easy MedKit";       // modName_idx =  8		    
	const string NADE = "Quick Nade";	       // modName_idx =  9	    
	const string SKILL = "Sk Destroy";	       // modName_idx = 10
	const string ROLL = "Easy Roll";           // modName_idx = 11
	const string PARKOUR = "Parkour";          // modName_idx = 12
	const string SWAP = "Swap Tr/Bu";          // modName_idx = 13
	const string INVERTED = "Inverted Y";      // modName_idx = 14

// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;

// modName_idx # of the last Mod Name string - Used for cycle modName_idx
	define LAST_MODNAME_STRING = 14;
	
// # of the last modName_idx that has a value that can be edited
	define LAST_EDITABLE_STRING = 6;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	// modName_idx = 0 = ANTIRECOIL string
	const string ANTIRECOIL_START = "AR Start"; 	    // valName_idx = 0  
	const string ANTIRECOIL_END = "AR End";				// valName_idx = 1
	const string ANTIRECOIL_TIME = "AR Time";			// valName_idx = 2
	const string ANTIRECOIL_HORIZONTAL = "AR Horiz";	// valName_idx = 3
	// modName_idx = 1
	const string RATE_OF_FIRE = "RPM / BPM";			// valName_idx = 4
	// modName_idx = 2
	const string BURSTFIRE_HOLD = "BF Hold";			// valName_idx = 5
	const string BURSTFIRE_RELEASE = "BF Release";		// valName_idx = 6
	// modName_idx = 3 = AIMASSIST string
	const string AIMASSIST_SIZE = "MotionSize";			// valName_idx = 7 MotionSize
	const string AIMASSIST_TIME = "MotionSpeed";		// valName_idx = 8 MotionSpeed
	// modName_idx = 4
	const string STRAFESHOT_TIME = "S.Shot Time";		// valName_idx = 9 
	// modName_idx = 5 = DYNASENS string
	const string DYNASENS_INITIAL_SENS = "DS Ini Sens"; // valName_idx = 10  
	const string DYNASENS_LIMIT = "DS Limit";			// valName_idx = 11
	const string DYNASENS_RESTART = "DS Restart";		// valName_idx = 12
	const string DYNASENS_MAX_SENS = "DS Max Sens";		// valName_idx = 13
	const string DYNASENS_INCREASE_RATE = "DS Inc Rate";// valName_idx = 14
	// modName_idx = 6 = RELOAD string
	const string RELOAD_TIME = "Reload Time"; 		    // valName_idx = 15  
	
// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;

	define AMOUNT_OF_VALNAME_IDX = 15;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// /!\ DO NOT CHANGE RATE OF FIRE VALUE IN THE ARRAY
// Constant bytes - VALUES array (mods with value and toggle) - VALUES[line][column]
	const uint8 VALUES[][] = { 		
/* Profile 1 */	{    45,                20,                5,                   0,                  40      },		// profile_idx = 0 
/* Profile 2 */	{     0,                10,               15,                   0,                  40      }, 		// profile_idx = 1 
/* Profile 3 */ {    12,                32,               10,                   0,                  40      }};		// profile_idx = 2 
/*		     antirecoil_start[]  antirecoil_end[]  antirecoil_time[]  antirecoil_horizontal[]  rate_of_fire[]           
                 AntiRecoil          AntiRecoil       AntiRecoil            AntiRecoil          RapidFire  
val_col_idx          = 0               = 1               = 2                  = 3                 = 4       */

// VALUES array column number - Buffer to add or substract edited value to corresponding value in VALUES array
	int antirecoil_start[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
	int antirecoil_end[3];
	int antirecoil_time[3];
	int antirecoil_horizontal[3];
	int rate_of_fire[3];
	
	define AMOUNT_OF_MULTI_VAL = 5;

/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
	int profile_idx; 
	
// Index to find VALUES array column - Follow valName_idx to edit the right value (that is in VALUES array or not like Strafe_t value)
	int val_col_idx;

// # of the last column - used in display_edit() function 
	define LAST_EDITABLE_COLUMN = 4;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Multi toggles
	int toggle_antirecoil[3];  // for 3 Profiles: profile_idx = 0, 1 and 2
	int toggle_rapidfire[3];  
	int toggle_burstfire[3];
	int toggle_aimassist[3];
	int toggle_strafeShot[3]; 
	
// Amount of profiles - Used for switch profiles cycle
	define AMOUNT_OF_PROFILES = 3;  
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 5;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mods (toggles and values) that activates for all profiles at the same time (if toggled ON)
// BurstFire
	int burstfire_hold; // BurstFire have toggle for each profiles BUT the same values for each
	int burstfire_release;
// AIM Assist
	int aimassist_size; // AIM Assist have toggle for each profiles BUT the same values for each
	int aimassist_time;
// Strafe Shot
	int strafeShot_time; // StrafeShot have toggle for each profiles BUT the same value for each
// DynaSens
	int dynasens_initial_sens;    // initial RX/RY sentitivity
	int dynasens_limit;           // stick input point where RX/RY sens increases
	int dynasens_restart;         // stick input point where RX/RY sens will reset back to initial value dynasens_initial_sens
	int dynasens_max_sens;        // maximum sensitivity value 
	int dynasens_increase_rate;   // rate sensitivity increased (8 = 80ms delay between increase)
// Reload Switch 
	int reload_time;              // amount of time before you cut reload animation and switch weapon
	
// Toggles
	int dynasens_on;
	int reload_on;
	int autorun_on;
	int medkit_on;
	int nade_on;
	int skill_on;
	int roll_on;
	int parkour_on;
	int swap_on;
	int inverted_on;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};

// Buffer to display converted values 
	//int display_val;  
	
// Variables for function number_to_string() 
	int i;
	int c,c_val;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_black;
    
// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil                                                 
	int i_val;                                                        
	int i_pnt;                                                        
	int i_num;                                                        
	int i_cnt;                                                        
	int v,ar_y;
	int ar_x;
	int x_ref;
	int invert; // -1 for inverted, 1 for standard
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter
	int count_black;  // for screen saver
	
// Double Tap
	int double_tap;
	
// Profiles
	int profile_1or2;   // Profile 1 and 2
	int profile_3;      // Profile 3
	int special_weapon; // Special weapon
 	
// DynaSens
	int sens_x;
	int sens_y;
	int sens_xcnt,sens_ycnt;

//Misc
	int button;
	int map_btn;
	int map;
	int currentSlot;
	int nade_wait;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
init{
// Profile 1
	// Toggles                                                  // Values
	toggle_antirecoil[0] = get_pvar(SPVAR_1, 0, 1, 0 );         antirecoil_start[0]      = get_pvar(SPVAR_6, -99,  99, 0);         
	toggle_rapidfire[0]  = get_pvar(SPVAR_2, 0, 1, 0 );         antirecoil_end[0]        = get_pvar(SPVAR_7, -99,  99, 0);         
	toggle_burstfire[0]  = get_pvar(SPVAR_3, 0, 1, 0 );         antirecoil_time[0]       = get_pvar(SPVAR_8, -99,  99, 0);      
	toggle_aimassist[0]  = get_pvar(SPVAR_4, 0, 1, 0 );         antirecoil_horizontal[0] = get_pvar(SPVAR_9, -99,  99, 0);
	toggle_strafeShot[0] = get_pvar(SPVAR_5, 0, 1, 0 );         rate_of_fire[0]          = get_pvar(SPVAR_10,  0, 750, 0);
// Profile 2
	// Toggles                                                  // Values
	toggle_antirecoil[1] = get_pvar(SPVAR_11, 0, 1, 0 );        antirecoil_start[1]      = get_pvar(SPVAR_16, -99,  99, 0);         
	toggle_rapidfire[1]  = get_pvar(SPVAR_12, 0, 1, 0 );        antirecoil_end[1]        = get_pvar(SPVAR_17, -99,  99, 0);         
	toggle_burstfire[1]  = get_pvar(SPVAR_13, 0, 1, 0 );        antirecoil_time[1]       = get_pvar(SPVAR_18, -99,  99, 0);        
	toggle_aimassist[1]  = get_pvar(SPVAR_14, 0, 1, 0 );        antirecoil_horizontal[1] = get_pvar(SPVAR_19, -99,  99, 0);
	toggle_strafeShot[1] = get_pvar(SPVAR_15, 0, 1, 0 );	    rate_of_fire[1]          = get_pvar(SPVAR_20,   0, 750, 0);
// Profile 3
	// Toggles                                                  // Values
	toggle_antirecoil[2] = get_pvar(SPVAR_21, 0, 1, 0 );        antirecoil_start[2]      = get_pvar(SPVAR_26, -99,  99, 0);         
	toggle_rapidfire[2]  = get_pvar(SPVAR_22, 0, 1, 0 );        antirecoil_end[2]        = get_pvar(SPVAR_27, -99,  99, 0);         
	toggle_burstfire[2]  = get_pvar(SPVAR_23, 0, 1, 0 );        antirecoil_time[2]       = get_pvar(SPVAR_28, -99,  99, 0);         
	toggle_aimassist[2]  = get_pvar(SPVAR_24, 0, 1, 0 );        antirecoil_horizontal[2] = get_pvar(SPVAR_29, -99,  99, 0);
	toggle_strafeShot[2] = get_pvar(SPVAR_25, 0, 1, 0 );	    rate_of_fire[2]          = get_pvar(SPVAR_30,   0, 750, 0);
	
// Misc values
	burstfire_hold       = get_pvar(SPVAR_31, 1, 999, 120);		dynasens_initial_sens    = get_pvar(SPVAR_36, 1, 327, 60 );     reload_time = get_pvar(SPVAR_41, 1, 9999, 800);
	burstfire_release    = get_pvar(SPVAR_32, 1, 999, 120);		dynasens_limit           = get_pvar(SPVAR_37, 1, 100, 60 );
	aimassist_size       = get_pvar(SPVAR_33, 1, 50 , 20 );		dynasens_restart         = get_pvar(SPVAR_38, 1, 100, 40 );
	aimassist_time       = get_pvar(SPVAR_34, 1, 999, 40 );		dynasens_max_sens        = get_pvar(SPVAR_39, 1, 327, 100);
	strafeShot_time      = get_pvar(SPVAR_35, 1, 999, 500);		dynasens_increase_rate   = get_pvar(SPVAR_40, 1, 50 , 1  );
	
// Misc toggles 
	dynasens_on  = get_pvar(SPVAR_42, 0, 1, 0 );    		skill_on    = get_pvar(SPVAR_47, 0, 1, 0 );    
	reload_on    = get_pvar(SPVAR_43, 0, 1, 0 );    		parkour_on  = get_pvar(SPVAR_48, 0, 1, 0 );    
	autorun_on   = get_pvar(SPVAR_44, 0, 1, 0 );    		swap_on     = get_pvar(SPVAR_49, 0, 1, 0 );    
	medkit_on    = get_pvar(SPVAR_45, 0, 1, 0 );    		inverted_on = get_pvar(SPVAR_50, 0, 1, 0 );    
	nade_on      = get_pvar(SPVAR_46, 0, 1, 0 );    		roll_on     = get_pvar(SPVAR_51, 0, 1, 0 );    

	currentSlot = get_slot();
}

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                                     MAIN SECTION                                                      |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
main {
	//set_val(TRACE_1, count_black);
	set_val(TRACE_1, hold_time);
	//set_val(TRACE_3, KillSwitch);
// Debug - Device Monitor
	set_val(TRACE_2, rest_time); 
	//set_val(TRACE_2, valName_idx); 
	set_val(TRACE_3, profile_idx);
	set_val(TRACE_4, ModMenu); 
	set_val(TRACE_5, ModEdit);
/*	
	// Antirecoil values	
	set_val(TRACE_3, VALUES[profile_idx][0] + antirecoil_start[profile_idx]); // ar start
	set_val(TRACE_4, VALUES[profile_idx][1] + antirecoil_end[profile_idx]); // ar end
	set_val(TRACE_5, VALUES[profile_idx][2] + antirecoil_time[profile_idx]); // ar time
	set_val(TRACE_6, VALUES[profile_idx][3] + antirecoil_horizontal[profile_idx]); // ar horizontal
	
	// RapidFire + BurstFire values
	set_val(TRACE_4, VALUES[profile_idx][4] + rate_of_fire[profile_idx]);  // rof value
	set_val(TRACE_5, VALUES[profile_idx][5] + burstfire_hold[profile_idx]); // ar time
	set_val(TRACE_6, VALUES[profile_idx][6] + burstfire_release[profile_idx]); // ar horizontal
	
	// RapidFire toggle values
	set_val(TRACE_1, toggle_rapidfire[0]); // RapidFire toggle Profile 1
	set_val(TRACE_2, toggle_rapidfire[1]); // RapidFire toggle Profile 2
	set_val(TRACE_3, toggle_rapidfire[2]); // RapidFire toggle Profile 3
	
	// BurstFire toggle values
	set_val(TRACE_4, toggle_burstfire[0]); // BurstFire toggle Profile 1
	set_val(TRACE_5, toggle_burstfire[1]); // BurstFire toggle Profile 2
	set_val(TRACE_6, toggle_burstfire[2]); // BurstFire toggle Profile 3
*/

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
// Double Tap
    if(double_tap) 
        double_tap -= get_rtime();
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
    	// If PS4 console:
        if(get_console() == PIO_PS4)
        { 
        	if(get_ival(PS4_SHARE))
        	{
        		if(get_ival(PS4_R3)) // RS + View =  ScreenShot
        		{
					set_val(PS4_SHARE,100);
                	set_val(PS4_TOUCH,0);
                	set_val(PS4_R3,0);
        			map_btn = PS4_TOUCH;
        		}
        		else // View only = PS4_TOUCH
        		{
        			set_val(PS4_TOUCH, 100);
        			set_val(PS4_SHARE, 0);
        			map_btn = PS4_SHARE;
        		}
        	}
        }
        else
            map_btn = PS4_SHARE;
	}
    else // If PS4 controller
        map_btn = PS4_TOUCH;

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     DISPLAY TITLE                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

// Display Script Title    
    if(display_title)
    {
    	cls_oled(0);	// clear OLED screen
    	count_black = 0;// reset screen saver timer
    	
    	if(KillSwitch)
    	{
    		printf(center_x(sizeof(MUTE) - 1, OLED_FONT_MEDIUM_WIDTH),8,OLED_FONT_MEDIUM,OLED_WHITE,MUTE[0]); 
    		printf(center_x(sizeof(HOLD) - 1, OLED_FONT_SMALL_WIDTH),38,OLED_FONT_SMALL,OLED_WHITE,HOLD[0]);
    		printf(center_x(sizeof(ACTIVE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,ACTIVE[0]);
    	}
    	else
    	{
    	// Display Division(2) logo
    		logo();
    		printf(center_x(sizeof(TITLE) - 1, OLED_FONT_SMALL_WIDTH),53,OLED_FONT_SMALL,OLED_WHITE,TITLE[0]);	// display TITLE centered in X 
    	// Display # slot
    		display_edit(NOT_USE, NOT_USE, NOT_USE, NOT_USE);
    	
    	// Display profile name
    		if(special_weapon)
    			printf(center_x(sizeof(SPECIAL) - 1, OLED_FONT_SMALL_WIDTH),34,OLED_FONT_SMALL,OLED_WHITE,SPECIAL[0]);
    		else 
    		{
    		if(profile_idx == 0)
    			printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),34,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); 
    		if(profile_idx == 1)
    			printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),34,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]);
    		if(profile_idx == 2)
    			printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_SMALL_WIDTH),34,OLED_FONT_SMALL,OLED_WHITE,PROFILE_3[0]);
    		}
    	
    		display_black = TRUE;	// screen saver
    	}
    	
    	display_title = FALSE;
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
    	count_black += get_rtime();
    	if(count_black >= 10000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    	}
    }

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                      KILL SWITCH                                                      |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
  
// Kill Switch
	if(!ModMenu && !ModEdit)
	{
	// KillSwitch ON or OFF method
		if( (get_val(PS4_L2) && event_press(PS4_SHARE)) || event_press(PS4_PS)	)
		{			
			KillSwitch = !KillSwitch;
			
			if(KillSwitch) 
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				
			else
				combo_run(RUMBLE_ON);	// rumble and LED blink
		
			display_title = TRUE;
		}

	// KillSwitch always ON method (TRUE)
		if(!KillSwitch)
		{
			if(!get_ival(PS4_L2) && event_press(PS4_OPTIONS))
			{
				KillSwitch = TRUE;
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				display_title = TRUE;
			}
			if(!get_ival(PS4_L2) && event_press(map_btn))
			{
				KillSwitch = TRUE;
				map = TRUE;
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				display_title = TRUE;
			}
		}
		
	// Exit KillSwitch (hold 600ms or double tap CIRCLE/B)
		if(KillSwitch) 
		{
			// Exit KillSwitch for fast travel while on the map
			if(map)
			{
				if(get_val(PS4_SQUARE) && get_ptime(PS4_SQUARE) > 1000) // Hold SQUARE/X 
				{
					KillSwitch = FALSE;
					map = FALSE;
					combo_run(RUMBLE_ON);
					display_title = TRUE;
				}
			
				if(event_press(PS4_OPTIONS))
					map = FALSE;
			}
			
			else // if NOT map
			{
				if(event_release(map_btn))
					map = FALSE;
			}
		
			if(get_val(PS4_CIRCLE) && get_ptime(PS4_CIRCLE) > 600)
			{
				KillSwitch = FALSE;
				map = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE;
			}
	
			if(event_press(PS4_CIRCLE))
			{
				if(double_tap)
				{
					KillSwitch = FALSE;
					map = FALSE;
					combo_run(RUMBLE_ON);
					display_title = TRUE;
				}
				else
					double_tap = 200;
			}
		}
	}
	
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       MOD MENU                                                        |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
	if(get_ival(PS4_L2))
	{
	// toggle ModMenu ON/OFF
		if(event_release(PS4_OPTIONS) && !KillSwitch && !special_weapon)
		{
			ModMenu = !ModMenu;
			
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
		}
		set_val(PS4_SHARE, 0);		    // block
		set_val(PS4_OPTIONS, 0);		// block
	} // L2 end

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
if(!KillSwitch)
{
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
// ModMenu
	if(ModMenu)
	{
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            MOD EDIT                                               |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

	// toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
		if(modName_idx <= LAST_EDITABLE_STRING)	// if ANTIRECOIL (so modName_idx = 0) or AIMASSIST or RAPIDFIRE or BURSTFIRE or StrafeShot or Dynasens or Reload is diplayed 
		{
			if(event_press(PS4_CROSS) && !ModEdit) // Turn ModEdit ON
			{
				valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
				ModEdit = TRUE;
				combo_run(RUMBLE_ON);
				display_new = TRUE;
			}
			
			if(event_press(PS4_CIRCLE) && ModEdit) // Turn ModEdit OFF
			{
				ModEdit = FALSE;
				combo_run(RUMBLE_OFF);
				display_new = TRUE;
			}
		}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                          EDIT VALUES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
            
	// ModEdit ON
		if(ModEdit)
		{
			if(get_val(PS4_SQUARE)) // Edit value: hold SQUARE/X + UP (+1 or +10) or DOWN (-1 or -10) or RIGHT (+10 or +100) or LEFT (-10 or -100)
			{
			// Mods that can have different values depending the active Profile
			
    		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], range min , range max, increase/decrease by X, increase/decrease by X); 	
				antirecoil_start[profile_idx]      = edit_val( 0 , antirecoil_start[profile_idx]     , 0 ,  99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
				antirecoil_end[profile_idx]        = edit_val( 1 , antirecoil_end[profile_idx]       , 0 ,  99 , 1 , 10   ); // the 2 last numbers are range min and range max
				antirecoil_time[profile_idx]       = edit_val( 2 , antirecoil_time[profile_idx]      , 0 ,  99 , 1 , 10   ); // only antirecoil_time display value x100 (real time in ms) - so 99 display 9,900 so 9.9 seconds 
				antirecoil_horizontal[profile_idx] = edit_val( 3 , antirecoil_horizontal[profile_idx], 99,  99 , 1 , 10   );
				rate_of_fire[profile_idx]          = edit_val( 4 , rate_of_fire[profile_idx]         , 0 , 750 , 1 , 10   ); // max 1500 RPM / BPM
				
			// Mods that have same value on every Profiles
			
			  //val_I_want_to_edit = edit_val( corresponding valName_idx , val_I_want_to_edit, range min , range max, increase/decrease by X, increase/decrease by X);
				burstfire_hold         = edit_val( 5 , burstfire_hold         , 0 , 990  , 10 , 100 );
				burstfire_release      = edit_val( 6 , burstfire_release      , 0 , 990  , 10 , 100 );
				aimassist_size         = edit_val( 7 , aimassist_size         , 0 , 50   , 1  , 10  );
				aimassist_time         = edit_val( 8 , aimassist_time         , 0 , 990  , 1  , 10  ); 
				strafeShot_time        = edit_val( 9 , strafeShot_time        , 0 , 9990 , 10 , 100 );
				dynasens_initial_sens  = edit_val( 10, dynasens_initial_sens  , 0 , 327  , 1  , 10  );
				dynasens_limit         = edit_val( 11, dynasens_limit         , 0 , 100  , 1  , 10  );
				dynasens_restart       = edit_val( 12, dynasens_restart       , 0 , 100  , 1  , 10  );
				dynasens_max_sens      = edit_val( 13, dynasens_max_sens      , 0 , 327  , 1  , 10  );
				dynasens_increase_rate = edit_val( 14, dynasens_increase_rate , 1 , 50   , 1  , 10  );
				reload_time            = edit_val( 15, reload_time            , 0 , 9990 , 10 , 100 );
			}  

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        VALUES AVAILABLE                                           |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

			else // NOT SQUARE/X (if not editing value)
			{
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
					display_new = TRUE; // Display value name and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
					display_new = TRUE;
				}
				
			// Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
			 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
				if(modName_idx == 0) vals_available( 0 , 3  );// Anti-Recoil		
				if(modName_idx == 1) vals_available( 4 , 4  );// RapidFire            				
				if(modName_idx == 2) vals_available( 5 , 6  );// If BurstFire was displayed before I enter ModEdit, I can only edit all BurstFire values			
				if(modName_idx == 3) vals_available( 7 , 8  );// AIM Assist				
				if(modName_idx == 4) vals_available( 9 , 9  );// StrafeShot				
				if(modName_idx == 5) vals_available( 10, 14 );// DynaSens				
				if(modName_idx == 6) vals_available( 15, 15 );// Reload Switch	
			} // NOT SQUARE/X (if not editing value) end
		} // ModEdit end

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            TOGGLES                                                |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

		else // if NOT ModEdit BUT if ModMenu
		{
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx += 1;
				display_new = TRUE;
			}
			if(event_press(PS4_LEFT))
			{
				modName_idx -= 1;
				display_new = TRUE;
			}
			
		// Cycle mods name
			if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
				modName_idx = 0;
			if(modName_idx < 0)
				modName_idx = LAST_MODNAME_STRING;
				
		// Switch profiles	
			if(event_press(PS4_TRIANGLE))
			{
				profile_idx += 1;
				display_new = TRUE;
			}
		// Cycle profiles	
			if(profile_idx > (AMOUNT_OF_PROFILES - 1))
				profile_idx = 0;
			
		// Toggles (UP to turn ON, DOWN to turn OFF)
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			toggle_antirecoil[profile_idx] = toggle( 0, toggle_antirecoil[profile_idx]);
			toggle_rapidfire[profile_idx]  = toggle( 1, toggle_rapidfire[profile_idx] );
			toggle_burstfire[profile_idx]  = toggle( 2, toggle_burstfire[profile_idx] );
			toggle_aimassist[profile_idx]  = toggle( 3, toggle_aimassist[profile_idx] );
			toggle_strafeShot[profile_idx] = toggle( 4, toggle_strafeShot[profile_idx]);
		
			// Mods that have same ON/OFF status on every Profiles
    		
		  //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
			dynasens_on = toggle( 5 , dynasens_on );
			reload_on   = toggle( 6 , reload_on   );
			autorun_on  = toggle( 7 , autorun_on  );
			medkit_on   = toggle( 8 , medkit_on   );
			nade_on     = toggle( 9 , nade_on     );
			skill_on    = toggle( 10, skill_on    );
			roll_on     = toggle( 11, roll_on     );
			parkour_on  = toggle( 12, parkour_on  );
			swap_on     = toggle( 13, swap_on     );
			inverted_on = toggle( 14, inverted_on );
		} // if NOT ModEdit BUT if ModMenu end
		
	// If ModMenu AND ModEdit
		if(event_press(PS4_PS))
			save ();
			
		block_btn (); // block ALL inputs (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
		//block_all_inputs();
		
	} // ModMenu ON end


							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                              NOT MOD MENU AND NOT MOD EDIT                                             |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — */	 
	if(!ModMenu)
	{	
	
	/* Swap triggers and bumpers */
		if(swap_on) // (13)
		{
			swap(PS4_R1, PS4_R2);
			swap(PS4_L1, PS4_L2);
		}
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        SPEED TOGGLES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	// Speed Toggles
	
	  //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2, hold time, toggle_I_want_to_edit([profile]) , corresponding modName_idx );
		toggle_rapidfire[profile_idx]  = speed_toggle( PS4_L2, PS4_UP   , 500 , toggle_rapidfire[profile_idx] , 1 );
		toggle_burstfire[profile_idx]  = speed_toggle( PS4_L2, PS4_DOWN , 500 , toggle_burstfire[profile_idx] , 2 );
		toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT, 500 , toggle_aimassist[profile_idx] , 3 );
		toggle_strafeShot[profile_idx] = speed_toggle( PS4_L2, PS4_LEFT , 500 , toggle_strafeShot[profile_idx], 4 );
		// We can add as many speed toogle as we need		

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 


	/* Special Weapon (Anti-Recoil, RapidFire, BurstFire, AIM Assist, Strafe Shot, Reload disable)
    Hold TRIANGLE/Y (Led color turn OLED_WHITE)*/
    if(get_val(PS4_TRIANGLE) && get_ptime(PS4_TRIANGLE) > 500)
    {
        special_weapon = TRUE;
        display_title = TRUE;
    }
    
    if(special_weapon && event_press(PS4_TRIANGLE))
         special_weapon = FALSE;
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  
	// Hair Trigger
   	 	deadzone(PS4_L2,PS4_R2,99,99);
    	
 	 /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
 	 |                                                      AIM ASSIST (3)                                                   |
 	 ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// If AIM Assist is enable for the curent profile
		if(toggle_aimassist[profile_idx] == 1 && !special_weapon)
		{
			if(get_val(PS4_L2)  && !get_val(PS4_R2)) 
				combo_run(AIM_ASSIST);
			else 
				combo_stop(AIM_ASSIST); 
		}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      STRAFE SHOT (4)                                                  |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
  
	// If Strafe Shot is enable for the curent profile
		if(toggle_strafeShot[profile_idx] == 1 && !special_weapon)
		{
		// Run combo
			if(get_val(PS4_R2))
				combo_run(STRAFESHOT);
			else
				combo_stop(STRAFESHOT);
		}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                       DYNASENS (5)                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
			
    	if(dynasens_on)
    	{	
    		if(get_val(PS4_L2) || get_val(PS4_R1) || get_val(PS4_L1))
    		{
    			if(abs(get_val(PS4_RX)) <= abs(dynasens_limit) && abs(get_val(PS4_RY)) <= abs(dynasens_limit) && !get_val(PS4_R2))
					deadzone(PS4_RX, PS4_RY, 15, 15);
    				
    			set_sens();
    		}
    		else if(!get_ival(PS4_DOWN) && get_ival(PS4_LY) > -15) //  DOWN to not interfere with Emote
    		{
    			sensitivity(PS4_RX, 80, 100);
    			sensitivity(PS4_RY, 80, 100);
    		}
    	}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                    RELOAD SWITCH (6)                                                  |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/


    if(reload_on && event_press(PS4_SQUARE) && !special_weapon) 
    {
        if(double_tap) 
        {
            combo_run(RELOAD);
            profile_1or2=!profile_1or2;
        }
            else
                double_tap = 300; 
    }

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      OTHER MODS                                                       |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* AutoRun press sensitive (Work better when in game option "Press to Sprint" is turned OFF)
       Push your stick to more than 60% to run automatically */
		if(autorun_on) // (7)
		{
    		if(get_val(PS4_L2) || (!get_val(PS4_L2) && (get_ival(XB1_PR1) && get_ptime(XB1_PR1) > 200)))
    	    	combo_stop(AUTORUN);
    	    	
    	    else if(get_val(PS4_LY) < -60)
    	    	combo_run(AUTORUN);
		}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    /* Easy MedKit
       Double tap D pad Right to change your armor piece, move Left analog to cancel */
		if(medkit_on) // (8)
		{
    		if(event_press(PS4_RIGHT)) 
    		{
        		if(double_tap)
        		{
           			button = PS4_RIGHT;
            		combo_run(HOLD);
        		}
        
            	else
                	double_tap = 200;
    		}
		/* Cancel Easy MedKit */    
			if(button == PS4_RIGHT && (abs(get_val(PS4_LX)) > 90 || abs(get_val(PS4_LY)) > 90))
				combo_stop(HOLD);
        }
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    /*Quick GRENADE
	  Hold ADS button and press D Pad LEFT or only hold D Pad LEFT to throw a grenade */
		if(nade_on) // (9)
		{
			if(get_ival(PS4_LEFT))
			{
				if(get_val(PS4_L2) && get_ptime(PS4_LEFT) < 200 || !get_val(PS4_L2) && get_ptime(PS4_LEFT) > 200)
				{
					nade_wait = 1000;
					combo_run(GRENADE);
				}
			}
			
			/* Elite Controller hold PL1 (as long as you want) to take a nade and throw the nade when you release PL1 
								hold PL1 more than 150ms and release to take and throw your nade */
					
			if(get_ival(XB1_PL1) && get_ptime(XB1_PL1) >= 150)
				set_val(PS4_LEFT, 100);
					
			if(event_release(XB1_PL1) && get_ptime(XB1_PL1) > 150)
			{
				nade_wait = 1150 - get_ptime(XB1_PL1);
				combo_run(GRENADE);
			}
		}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* Skill Destroy
       Double tap R1/RB or L1/LB to destroy the active skill assigned to this button */
		if(skill_on) // (10)
		{
			SkillDestroy (PS4_R1, PS4_R2);
			SkillDestroy (PS4_L1, PS4_L2);
    	}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* Easy Roll */
		if(roll_on) // (11)
		{
		//PS4 Controller tap Cross to roll
			if(get_controller() == PIO_PS4)
			{
				if(event_release(PS4_CROSS) && get_ptime(PS4_CROSS) < 200)
					combo_run(ROLL);
			}
		// Elite Controller tap PR1 to roll
			else if(!get_ival(PS4_L2) && (event_release(XB1_PR1) && get_ptime(XB1_PR1) < 200))
				combo_run(ROLL);
		}	
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	/* Parkour */
		if(parkour_on) // (12)
		{
			if(!get_val(PS4_L2) && get_val(PS4_LY) < -70)  // Press sensitive
			set_val(PS4_CIRCLE, 100);
		}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* Inverted Y for antirecoil */
		if(inverted_on) // (14)
			invert = -1;
		else
			invert = 1;
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* Easy HeadShot test
		Hold PR1 while aiming */
		if(get_val(PS4_L2))
    	{
    		if(get_val(XB1_PR1))
    		{
    			set_val(PS4_RY, -60);
    			set_val(PS4_RX, 0);
    		}
    	}
	
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                     SWITCH PROFILE                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
  
	// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold R3/RS + tap for sync color

    	if(!get_val(PS4_DOWN) && event_press(PS4_TRIANGLE) || (get_val(PS4_L3) && event_press(PS4_TRIANGLE)))
    	{
    	    profile_1or2=!profile_1or2; 
    	    profile_3 = FALSE;
        
    	    if(double_tap) 
    	    { 
    	     	profile_3 = TRUE ; 
    	    	profile_1or2 = !profile_1or2;
    	    }
			else
            	double_tap = 200;
    
    		if(ModMenu)
				display_new = TRUE;
			else
				display_title = TRUE;
    	}
		if(get_lval(PS4_L3))
			set_val(PS4_TRIANGLE, 0);
		
    // If Profile 3
    	if(profile_3)
    		profile_idx = 2;
    	
    	else
    	{    
    	// If Profile 2
    		if(profile_1or2)
    			profile_idx = 1;
    		
    	// If Profile 1
    		else	
    			profile_idx = 0;
		}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	} // ModMenu OFF end

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                      FEATURES THAT WORK EVERYTIME (MOD MENU/EDIT OR NOT) BUT NOT WITH SPECIAL WEAPON                  |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
	if(!special_weapon)
	{
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    ANTI RECOIL (0)                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// If Anti-Recoil is enable for the active profile
		if(toggle_antirecoil[profile_idx] == 1)
		{
			ar_x = (VALUES[profile_idx][3] + antirecoil_horizontal[profile_idx]);
		
		// Antirecoil vertical by Batts		
    		if((VALUES[profile_idx][0] + antirecoil_start[profile_idx]) < (VALUES[profile_idx][1] + antirecoil_end[profile_idx]))
    	   		i_val = 1; 
    		else
    	    	i_val = -1;
    		i_pnt = ((VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10) / (abs((VALUES[profile_idx][0] + antirecoil_start[profile_idx]) - (VALUES[profile_idx][1] + antirecoil_end[profile_idx]))); 
    	
    		if(!get_val(PS4_R2)) 
    		{
				ar_y = VALUES[profile_idx][0] + antirecoil_start[profile_idx];
    	    	i_cnt = 0;
    	    	i_num = 0;
    		}     
    		
    	// Run antirecoil
    		if(toggle_burstfire[profile_idx] != 1 && get_val(PS4_L2) && get_val(PS4_R2) || toggle_burstfire[profile_idx] == 1 && get_val(PS4_R2) && get_ptime(PS4_R2) <= hold_time)
    		{		
				combo_run(X_VAL);
			
    	    	if(!p_complete())  
					ar_y = p_val();
    	    	else
    	        	ar_y = VALUES[profile_idx][1] + antirecoil_end[profile_idx];
            
				if(y_val() < 100)
           			set_val(PS4_RY,y_val()); 	
    		}
    	
    		if(abs(get_val(PS4_RX)) > abs(ar_x) + 5)
  	  			combo_stop(X_VAL);
		}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    RAPID FIRE (1)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/  
  
	// If RapidFire is enable for the active profile
		if(toggle_rapidfire[profile_idx] == 1)
		{
		// Rate of Fire Calculation
    		rest_time = 5000 / (((VALUES[profile_idx][4] + rate_of_fire[profile_idx]) * 10) / 60); 
   			hold_time = rest_time - get_rtime();
    		if(rest_time < 0) rest_time = 0;
    
    	// Run combo
    		if(get_val(PS4_R2))
    			combo_run(RAPIDFIRE);
    		else
    			combo_stop(RAPIDFIRE);
    		
    		led_on = 150;
    		led_off = 300;
    		combo_run(BLINK);
		}
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    BURST FIRE (2)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/ 
      	
// If BurstFire is enable for the active profile
		if(toggle_burstfire[profile_idx] == 1) 
		{
    	// Hold and Release
			hold_time = burstfire_hold;
			rest_time = burstfire_release;
			
    	// Run combo
    		if(get_val(PS4_R2))	
    			combo_run(BURSTFIRE);

    		led_on = 200;
    		led_off = 1000;
    		combo_run(BLINK);
		} 
		if(event_release(PS4_R2))
    		combo_stop(BURSTFIRE);

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	} // MOT Special weapon end	
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    REFRESH DISPLAY                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(display_new) 
	{
	// Clear OLED screen	
		cls_oled(0);
		count_black = 0;
		
		if(ModEdit)
		{
	    // Display Value Name and value
    		// Mods that can have different values depending the active Profile
    		
		    // Display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
			display_edit( 0 , center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH)      , ANTIRECOIL_START[0]      , antirecoil_start[profile_idx]      );
			display_edit( 1 , center_x(sizeof(ANTIRECOIL_END) - 1, OLED_FONT_MEDIUM_WIDTH)        , ANTIRECOIL_END[0]        , antirecoil_end[profile_idx]        );
			display_edit( 2 , center_x(sizeof(ANTIRECOIL_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)       , ANTIRECOIL_TIME[0]       , antirecoil_time[profile_idx]       );
			display_edit( 3 , center_x(sizeof(ANTIRECOIL_HORIZONTAL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_HORIZONTAL[0] , antirecoil_horizontal[profile_idx] );
			display_edit( 4 , center_x(sizeof(RATE_OF_FIRE) - 1, OLED_FONT_MEDIUM_WIDTH)          , RATE_OF_FIRE[0]          , rate_of_fire[profile_idx]          );
			
			// Mods that have same value on every Profile
			display_edit( 5 , center_x(sizeof(BURSTFIRE_HOLD) - 1, OLED_FONT_MEDIUM_WIDTH)         , BURSTFIRE_HOLD[0]         , burstfire_hold         );
			display_edit( 6 , center_x(sizeof(BURSTFIRE_RELEASE) - 1, OLED_FONT_MEDIUM_WIDTH)      , BURSTFIRE_RELEASE[0]      , burstfire_release      );
			display_edit( 7 , center_x(sizeof(AIMASSIST_SIZE) - 1, OLED_FONT_MEDIUM_WIDTH)         , AIMASSIST_SIZE[0]         , aimassist_size         );
			display_edit( 8 , center_x(sizeof(AIMASSIST_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)         , AIMASSIST_TIME[0]         , aimassist_time         );
			display_edit( 9 , center_x(sizeof(STRAFESHOT_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)        , STRAFESHOT_TIME[0]        , strafeShot_time        );
			display_edit( 10, center_x(sizeof(DYNASENS_INITIAL_SENS) - 1, OLED_FONT_MEDIUM_WIDTH)  , DYNASENS_INITIAL_SENS[0]  , dynasens_initial_sens  );
			display_edit( 11, center_x(sizeof(DYNASENS_LIMIT) - 1, OLED_FONT_MEDIUM_WIDTH)         , DYNASENS_LIMIT[0]         , dynasens_limit         );
			display_edit( 12, center_x(sizeof(DYNASENS_RESTART) - 1, OLED_FONT_MEDIUM_WIDTH)       , DYNASENS_RESTART[0]       , dynasens_restart       );
			display_edit( 13, center_x(sizeof(DYNASENS_MAX_SENS) - 1, OLED_FONT_MEDIUM_WIDTH)      , DYNASENS_MAX_SENS[0]      , dynasens_max_sens      );
			display_edit( 14, center_x(sizeof(DYNASENS_INCREASE_RATE) - 1, OLED_FONT_MEDIUM_WIDTH) , DYNASENS_INCREASE_RATE[0] , dynasens_increase_rate );
			display_edit( 15, center_x(sizeof(RELOAD_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)            , RELOAD_TIME[0]            , reload_time            );
			
			// Display Profile only on mods that may have a different value depending on the Profile
			if(valName_idx < AMOUNT_OF_MULTI_VAL)  // idx from 0 to 4 are mods that can have different values depending the active Profile
			{
				if(profile_idx == 0) // profile_idx = profile_idx = Profile
    				printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
    			else if(profile_idx == 1)
    				printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
    			else if(profile_idx == 2)
    				printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
			}
			else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    			printf(center_x(sizeof(ALL) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,ALL[0]); // print AllProfiles
		}
		else
		{
	    // Display Mod Name and ON/OFF
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		   // Display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
			display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOIL[0]  , toggle_antirecoil[profile_idx]);
			display_mod( 1 ,  center_x(sizeof(RAPIDFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)   , RAPIDFIRE[0]   , toggle_rapidfire[profile_idx] );
			display_mod( 2 ,  center_x(sizeof(BURSTFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)   , BURSTFIRE[0]   , toggle_burstfire[profile_idx] );
			display_mod( 3 ,  center_x(sizeof(AIMASSIST) - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMASSIST[0]   , toggle_aimassist[profile_idx] );
			display_mod( 4 ,  center_x(sizeof(STRAFE_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH) , STRAFE_SHOT[0] , toggle_strafeShot[profile_idx]);
			
			// Mods that have same ON/OFF status on every Profile
			display_mod( 5 ,  center_x(sizeof(DYNASENS) - 1, OLED_FONT_MEDIUM_WIDTH)    , DYNASENS[0]    , dynasens_on);
			display_mod( 6 ,  center_x(sizeof(RELOAD) - 1, OLED_FONT_MEDIUM_WIDTH)      , RELOAD[0]      , reload_on  );
			display_mod( 7 ,  center_x(sizeof(AUTORUN) - 1, OLED_FONT_MEDIUM_WIDTH)     , AUTORUN[0]     , autorun_on );
			display_mod( 8 ,  center_x(sizeof(MEDKIT) - 1, OLED_FONT_MEDIUM_WIDTH)      , MEDKIT[0]      , medkit_on  );
			display_mod( 9 ,  center_x(sizeof(NADE) - 1, OLED_FONT_MEDIUM_WIDTH)        , NADE[0]        , nade_on    );
			display_mod( 10,  center_x(sizeof(SKILL) - 1, OLED_FONT_MEDIUM_WIDTH)       , SKILL[0]       , skill_on   );
			display_mod( 11,  center_x(sizeof(ROLL) - 1, OLED_FONT_MEDIUM_WIDTH)        , ROLL[0]        , roll_on    );
			display_mod( 12,  center_x(sizeof(PARKOUR) - 1, OLED_FONT_MEDIUM_WIDTH)     , PARKOUR[0]     , parkour_on );
			display_mod( 13,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)        , SWAP[0]        , swap_on    );
			display_mod( 14,  center_x(sizeof(INVERTED) - 1, OLED_FONT_MEDIUM_WIDTH)    , INVERTED[0]    , inverted_on);
			
			// Display Profile only on mods that may have a different value depending on the Profile
			if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
			{
				if(profile_idx == 0) // profile_idx = profile_idx = Profile
    				printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
    			else if(profile_idx == 1)
    				printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
    			else if(profile_idx == 2)
    				printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
			}
			else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    			printf(center_x(sizeof(ALL) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,ALL[0]); // print AllProfiles
		}
		

    	
		display_black = TRUE;
        display_new = FALSE;
    } // display_new end
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
} // NOT KillSwitch end

	if(KillSwitch)
		led(7);
	else if(special_weapon)
		led(4);
	else
		led(profile_idx);

} // main end
 
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     COMBO SECTION                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo SAVE { 
	cls_oled(0);						// clear OLED screen 
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	wait(10)
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times								
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_new = TRUE;				   // display mods
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
combo X_VAL { // Antirecoil Horizontal
	x_ref = get_val(PS4_RX) + ar_x;
    if(x_ref > 100) x_ref = 100;
    set_val(PS4_RX, x_ref);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo AIM_ASSIST { // AIM Assist
    set_val(PS4_RY,aimassist(PS4_RY, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RX,aimassist(PS4_RX, aimassist_size));
    set_val(PS4_LX,aimassist(PS4_LX, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RY,aimassist(PS4_RY,inv(aimassist_size))); 
    wait(aimassist_time);
    set_val(PS4_RX,aimassist(PS4_RX,inv(aimassist_size)));
    set_val(PS4_LX,aimassist(PS4_LX,inv(aimassist_size)));
    wait(aimassist_time);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo STRAFESHOT { // StrafeShot
    set_val(PS4_LX, 100);
    wait(strafeShot_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafeShot_time);
    wait(50);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RELOAD {
    wait(reload_time); 
    set_val(PS4_TRIANGLE,100);
    wait(15);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo AUTORUN {
	set_val(PS4_LY, -100);
	set_val(PS4_L3, 100);
}
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo HOLD {
    set_val(button, 100);
    wait(2900);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo GRENADE {
    wait(nade_wait);
    set_val(PS4_R2, 100);
    wait(100);
    set_val(PS4_L2, 0);
    wait(500);
    }
  
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo ROLL {
	set_val(PS4_CROSS, 100);
	wait(50);
	wait(100);
	set_val(PS4_CROSS, 100);
	wait(50);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
    }

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       FUNCTIONS                                                       |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	


// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods
	
	if(valName_idx < f_min)
		valName_idx = f_max;
	if(valName_idx > f_max)
		valName_idx = f_min;
		
// Match the # of value names index with the right column in VALUES array
	val_col_idx = valName_idx;	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
					
	if(valName_idx == f_idx)
	{
    // +1 or -1															 // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2

	// We can also add (f_ref)
	// Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_start[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;	
	}
	// Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
	if(rate_of_fire[profile_idx] < 0)
		rate_of_fire[profile_idx] = 0;

	//return f_ref;

	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function speed_toggle(f_hold, f_press, f_time, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(get_val(f_press) && get_ptime(f_press) == f_time) // Hold second button 300ms or more
		{
			modName_idx = f_string;
			
			if(f_val == 0)
			{
				if(f_string == 1) // If RapidFire is enable, 
					toggle_burstfire[profile_idx] = 0; // disable BurstFire
				else if(f_string == 2) // If BurstFire is enable, 
					toggle_rapidfire[profile_idx] = 0; // disable RapidFire
					
				f_val = 1;
				combo_run(RUMBLE_ON);
			}
			else
			{
				f_val = 0;
				combo_run(RUMBLE_OFF);
			}
			display_new = TRUE;
		} 
	set_val(f_press, 0)
	}
		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == 1) // If RapidFire is enable, 
				toggle_burstfire[profile_idx] = 0; // disable BurstFire
			else if(f_idx == 2) // If BurstFire is enable, 
				toggle_rapidfire[profile_idx] = 0; // disable RapidFire
				
			f_val = 1;
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			f_val = 0;
			combo_run(RUMBLE_OFF);
		}		
		display_new = TRUE;
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);
	
	if(display_title)
		number_to_string(currentSlot, find_digits(currentSlot)); // display current # slot 
	else
	{
    	if(valName_idx == f_idx)
    	{
		// Display value name and value
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    		
    	// Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
    		if(f_idx == 2) 
    			number_to_string((VALUES[profile_idx][val_col_idx] + f_val) * 100, find_digits((VALUES[profile_idx][val_col_idx] + f_val) * 100));
    	
    	// Display all editable values in VALUES array
    		else if(f_idx <= LAST_EDITABLE_COLUMN) 
    			number_to_string(VALUES[profile_idx][val_col_idx] + f_val, find_digits(VALUES[profile_idx][val_col_idx] + f_val));
    	
    	// Display editable values that are not in the array (burstfire_hold for exemple)
    		else 
    			number_to_string(f_val, find_digits(f_val));
    	}
    }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 2, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);
    	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
    // Values that are not in the array (aimassist_time for exemple)
		if(valName_idx > LAST_EDITABLE_COLUMN)
		{
    	// Substract    
        	if(f_val < inv(f_rng_min)) 
        		f_val = inv(f_rng_min); 
   		// Add   
       		if(f_val > f_rng_max) 
        		f_val = f_rng_max;
		}
		
    // Values that are in the array 
		else
		{
    // Substract    
        if((f_val + VALUES[profile_idx][val_col_idx]) < inv(f_rng_min)) 
        	f_val = inv(f_rng_min + VALUES[profile_idx][val_col_idx]); 
    // Add   
        if((f_val + VALUES[profile_idx][val_col_idx]) > f_rng_max) 
        	f_val = f_rng_max - VALUES[profile_idx][val_col_idx]; 
        }
        display_new = TRUE;
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function p_complete() { // Antirecoil

    i_cnt++;
    if(i_cnt > (VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10) 
    {
        i_cnt = (VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10;
        return 1;
    }    
    return 0;
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function p_val() { // Antirecoil

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function y_val() { // Antirecoil

    v = get_val(10);
    
    if(abs(v) < 10)
        v = 0;
        
    if(abs(v) > ar_y + 5)
        return v;
        
    return v + (ar_y * invert);           
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function aimassist(f_axis,f_val) { // AIM Assist

    if(abs(get_val(f_axis)) < aimassist_size + 1) // + 1 is release
        return f_val;
        
    return get_val(f_axis); 
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }
    if(display_title)
    	//puts_oled(120, 53, OLED_FONT_SMALL, i - 1, OLED_WHITE); // display current # slot - Small
    	puts_oled(116, 45, OLED_FONT_MEDIUM, i - 1, OLED_WHITE); // display current # slot - Medium
    else
    	puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function find_digits(f_num) {
//  find_digits(value)  
//	    return Number of Digits in Value Passed  

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//	    return X for Centering String Horizontally

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {
//  center_y(font size);  
//	    return Y for Centering String Vertically

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function press_hold(f_btn) { 
//  return TRUE - event_press()   
//			    - every 250ms when button is held

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// DynaSens by Batts
function set_sens () {
    if(abs(get_lval(PS4_RX)) >= dynasens_limit) 
    {
	    sens_xcnt += 1;
	    
		if(sens_xcnt >= dynasens_increase_rate && sens_x < dynasens_max_sens) 
		{ 
		    sens_x += 1; 
		    sens_xcnt = 0; 
		} 
			else if(sens_x >= dynasens_max_sens) 
				sens_xcnt = 0;  
	}
	
    else if(abs(get_val(PS4_RX)) < dynasens_restart) 
    {
	    sens_xcnt = 0; 
	    sens_x = dynasens_initial_sens;    		    
	} 
	
    if(abs(get_val(PS4_RY)) >= dynasens_limit) 
    {
	    sens_ycnt += 1;
		if(sens_ycnt >= dynasens_increase_rate && sens_y < dynasens_max_sens) 
		{ 
		    sens_y += 1; 
		    sens_ycnt = 1; 
		} 
			else if(sens_y >= dynasens_max_sens) 
				sens_ycnt = 0; 
	}
	
    else if(abs(get_val(PS4_RY)) < dynasens_restart) 
    {
	    sens_y = dynasens_initial_sens; 
	    sens_ycnt = 0;
	}
	
	sensitivity(PS4_RX,NOT_USE,sens_x);
    sensitivity(PS4_RY,NOT_USE,sens_y);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function SkillDestroy (f_btn1, f_btn2){
    if(!swap_on && event_press(f_btn1) || swap_on && event_press(f_btn2)) 
    {
        if(double_tap)
        {
			button = f_btn1;
			combo_run(HOLD);
       	}
		else
		{
			double_tap = 200;
			combo_stop(HOLD);
		}
    }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function save () {
	combo_run(SAVE);
	
// Profile 1
	// Toggles                                      // Values
	set_pvar(SPVAR_1,toggle_antirecoil[0]);         set_pvar(SPVAR_6 ,antirecoil_start[0]     );         
	set_pvar(SPVAR_2,toggle_rapidfire[0] );         set_pvar(SPVAR_7 ,antirecoil_end[0]       );        
	set_pvar(SPVAR_3,toggle_burstfire[0] );         set_pvar(SPVAR_8 ,antirecoil_time[0]      );     
	set_pvar(SPVAR_4,toggle_aimassist[0] );         set_pvar(SPVAR_9 ,antirecoil_horizontal[0]);
	set_pvar(SPVAR_5,toggle_strafeShot[0]);         set_pvar(SPVAR_10,rate_of_fire[0]         );
// Profile 2
	// Toggles                                       // Values
	set_pvar(SPVAR_11,toggle_antirecoil[1]);         set_pvar(SPVAR_16,antirecoil_start[1]     );       
	set_pvar(SPVAR_12,toggle_rapidfire[1] );         set_pvar(SPVAR_17,antirecoil_end[1]       );      
	set_pvar(SPVAR_13,toggle_burstfire[1] );         set_pvar(SPVAR_18,antirecoil_time[1]      );     
	set_pvar(SPVAR_14,toggle_aimassist[1] );         set_pvar(SPVAR_19,antirecoil_horizontal[1]);
	set_pvar(SPVAR_15,toggle_strafeShot[1]);	     set_pvar(SPVAR_20,rate_of_fire[1]         );
// Profile 3
	// Toggles                                       // Values
	set_pvar(SPVAR_21,toggle_antirecoil[2]);         set_pvar(SPVAR_26,antirecoil_start[2]     );       
	set_pvar(SPVAR_22,toggle_rapidfire[2] );         set_pvar(SPVAR_27,antirecoil_end[2]       );      
	set_pvar(SPVAR_23,toggle_burstfire[2] );         set_pvar(SPVAR_28,antirecoil_time[2]      );      
	set_pvar(SPVAR_24,toggle_aimassist[2] );         set_pvar(SPVAR_29,antirecoil_horizontal[2]);
	set_pvar(SPVAR_25,toggle_strafeShot[2]);         set_pvar(SPVAR_30,rate_of_fire[2]         );
// Misc values
	set_pvar(SPVAR_31, burstfire_hold   );			 set_pvar(SPVAR_36, dynasens_initial_sens );		set_pvar(SPVAR_41, reload_time);
	set_pvar(SPVAR_32, burstfire_release);			 set_pvar(SPVAR_37, dynasens_limit        );
	set_pvar(SPVAR_33, aimassist_size   );			 set_pvar(SPVAR_38, dynasens_restart      );
	set_pvar(SPVAR_34, aimassist_time   );			 set_pvar(SPVAR_39, dynasens_max_sens     );
	set_pvar(SPVAR_35, strafeShot_time  );			 set_pvar(SPVAR_40, dynasens_increase_rate);
//Misc toggles
	set_pvar(SPVAR_42, dynasens_on);				 set_pvar(SPVAR_47, skill_on   );
	set_pvar(SPVAR_43, reload_on  );				 set_pvar(SPVAR_48, parkour_on );
	set_pvar(SPVAR_44, autorun_on );				 set_pvar(SPVAR_49, swap_on    );
	set_pvar(SPVAR_45, medkit_on  );				 set_pvar(SPVAR_50, inverted_on);
	set_pvar(SPVAR_46, nade_on    );                 set_pvar(SPVAR_51, roll_on    );
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
/*set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);*/
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function logo() {
		pixel_oled(110, 3, 1);	pixel_oled(111, 3, 1);	pixel_oled(112, 3, 1);	pixel_oled(113, 3, 1);	pixel_oled(114, 3, 1);
		pixel_oled(115, 3, 1);	pixel_oled(107, 4, 1);	pixel_oled(108, 4, 1);	pixel_oled(109, 4, 1);	pixel_oled(110, 4, 1);
		pixel_oled(115, 4, 1);	pixel_oled(116, 4, 1);	pixel_oled(117, 4, 1);	pixel_oled(118, 4, 1);	pixel_oled(105, 5, 1);
		pixel_oled(106, 5, 1);	pixel_oled(107, 5, 1);	pixel_oled(118, 5, 1);	pixel_oled(119, 5, 1);	pixel_oled(120, 5, 1);
		pixel_oled(104, 6, 1);	pixel_oled(105, 6, 1);	pixel_oled(120, 6, 1);	pixel_oled(121, 6, 1);	pixel_oled(103, 7, 1);
		pixel_oled(104, 7, 1);	pixel_oled(121, 7, 1);	pixel_oled(122, 7, 1);	pixel_oled(102, 8, 1);	pixel_oled(103, 8, 1);	
		pixel_oled(122, 8, 1);	pixel_oled(123, 8, 1);	pixel_oled(123, 9, 1);	pixel_oled(124, 9, 1);	pixel_oled(2, 10, 1);
		pixel_oled(3, 10, 1);	pixel_oled(4, 10, 1);	pixel_oled(5, 10, 1);	pixel_oled(6, 10, 1);	pixel_oled(8, 10, 1);
		pixel_oled(11, 10, 1);	pixel_oled(13, 10, 1);	pixel_oled(14, 10, 1);	pixel_oled(15, 10, 1);	pixel_oled(16, 10, 1);
		pixel_oled(17, 10, 1);	pixel_oled(21, 10, 1);	pixel_oled(22, 10, 1);	pixel_oled(23, 10, 1);	pixel_oled(24, 10, 1);
		pixel_oled(25, 10, 1);	pixel_oled(32, 10, 1);	pixel_oled(33, 10, 1);
		pixel_oled(34, 10, 1);	pixel_oled(35, 10, 1);	pixel_oled(38, 10, 1);	pixel_oled(39, 10, 1);	pixel_oled(40, 10, 1);
		pixel_oled(47, 10, 1);	pixel_oled(48, 10, 1);	pixel_oled(49, 10, 1);	pixel_oled(51, 10, 1);	pixel_oled(52, 10, 1);
		pixel_oled(53, 10, 1);	pixel_oled(54, 10, 1);	pixel_oled(59, 10, 1);	pixel_oled(60, 10, 1);	pixel_oled(61, 10, 1);
		pixel_oled(62, 10, 1);	pixel_oled(63, 10, 1);	pixel_oled(64, 10, 1);	pixel_oled(65, 10, 1);	pixel_oled(70, 10, 1);
		pixel_oled(71, 10, 1);	pixel_oled(72, 10, 1);	pixel_oled(73, 10, 1);	pixel_oled(79, 10, 1);	pixel_oled(80, 10, 1);
		pixel_oled(81, 10, 1);	pixel_oled(82, 10, 1);	pixel_oled(83, 10, 1);	pixel_oled(84, 10, 1);	pixel_oled(90, 10, 1);
		pixel_oled(91, 10, 1);	pixel_oled(92, 10, 1);	pixel_oled(93, 10, 1);	pixel_oled(99, 10, 1);	pixel_oled(100, 10, 1);
		pixel_oled(101, 10, 1);	pixel_oled(110, 10, 1);	pixel_oled(111, 10, 1);	pixel_oled(112, 10, 1);	pixel_oled(113, 10, 1);
		pixel_oled(114, 10, 1);	pixel_oled(115, 10, 1);	pixel_oled(124, 10, 1);	pixel_oled(4, 11, 1);	pixel_oled(8, 11, 1);
		pixel_oled(11, 11, 1);	pixel_oled(13, 11, 1);	pixel_oled(21, 11, 1);	pixel_oled(22, 11, 1);	pixel_oled(23, 11, 1);
		pixel_oled(24, 11, 1);	pixel_oled(25, 11, 1);	pixel_oled(26, 11, 1);	pixel_oled(27, 11, 1);	pixel_oled(28, 11, 1);
		pixel_oled(32, 11, 1);	pixel_oled(33, 11, 1);	pixel_oled(34, 11, 1);	pixel_oled(35, 11, 1);	pixel_oled(38, 11, 1);
		pixel_oled(39, 11, 1);	pixel_oled(40, 11, 1);	pixel_oled(47, 11, 1);	pixel_oled(48, 11, 1);	pixel_oled(49, 11, 1);
		pixel_oled(51, 11, 1);	pixel_oled(52, 11, 1);	pixel_oled(53, 11, 1);	pixel_oled(54, 11, 1);	pixel_oled(58, 11, 1);
		pixel_oled(59, 11, 1);	pixel_oled(60, 11, 1);	pixel_oled(61, 11, 1);	pixel_oled(62, 11, 1);	pixel_oled(63, 11, 1);
		pixel_oled(64, 11, 1);	pixel_oled(65, 11, 1);	pixel_oled(66, 11, 1);	pixel_oled(70, 11, 1);	pixel_oled(71, 11, 1);	
		pixel_oled(72, 11, 1);	pixel_oled(73, 11, 1);	pixel_oled(77, 11, 1);	pixel_oled(78, 11, 1);	pixel_oled(79, 11, 1);
		pixel_oled(80, 11, 1);	pixel_oled(81, 11, 1);	pixel_oled(82, 11, 1);	pixel_oled(83, 11, 1);	pixel_oled(84, 11, 1);
		pixel_oled(85, 11, 1);	pixel_oled(90, 11, 1);	pixel_oled(91, 11, 1);	pixel_oled(92, 11, 1);	pixel_oled(93, 11, 1);
		pixel_oled(99, 11, 1);	pixel_oled(100, 11, 1);	pixel_oled(101, 11, 1);	pixel_oled(109, 11, 1);	pixel_oled(110, 11, 1);
		pixel_oled(111, 11, 1);	pixel_oled(112, 11, 1);	pixel_oled(113, 11, 1);	pixel_oled(114, 11, 1);	pixel_oled(115, 11, 1);
		pixel_oled(116, 11, 1);	pixel_oled(124, 11, 1);	pixel_oled(125, 11, 1);	pixel_oled(4, 12, 1);	pixel_oled(8, 12, 1);
		pixel_oled(9, 12, 1);	pixel_oled(10, 12, 1);	pixel_oled(11, 12, 1);	pixel_oled(13, 12, 1);	pixel_oled(14, 12, 1);
		pixel_oled(15, 12, 1);	pixel_oled(16, 12, 1);	pixel_oled(20, 12, 1);	pixel_oled(21, 12, 1);	pixel_oled(22, 12, 1);
		pixel_oled(23, 12, 1);	pixel_oled(24, 12, 1);	pixel_oled(25, 12, 1);	pixel_oled(26, 12, 1);	pixel_oled(27, 12, 1);
		pixel_oled(28, 12, 1);	pixel_oled(29, 12, 1);	pixel_oled(32, 12, 1);	pixel_oled(33, 12, 1);	pixel_oled(34, 12, 1);
		pixel_oled(35, 12, 1);	pixel_oled(38, 12, 1);	pixel_oled(39, 12, 1);	pixel_oled(40, 12, 1);	pixel_oled(41, 12, 1);
		pixel_oled(46, 12, 1);	pixel_oled(47, 12, 1);	pixel_oled(48, 12, 1);	pixel_oled(49, 12, 1);	pixel_oled(51, 12, 1);
		pixel_oled(52, 12, 1);	pixel_oled(53, 12, 1);	pixel_oled(54, 12, 1);	pixel_oled(57, 12, 1);	pixel_oled(58, 12, 1);
		pixel_oled(59, 12, 1);	pixel_oled(60, 12, 1);	pixel_oled(61, 12, 1);	pixel_oled(62, 12, 1);	pixel_oled(63, 12, 1);
		pixel_oled(64, 12, 1);	pixel_oled(65, 12, 1);	pixel_oled(66, 12, 1);	pixel_oled(67, 12, 1);	pixel_oled(70, 12, 1);
		pixel_oled(71, 12, 1);	pixel_oled(72, 12, 1);	pixel_oled(73, 12, 1);	pixel_oled(76, 12, 1);	pixel_oled(77, 12, 1);
		pixel_oled(78, 12, 1);	pixel_oled(79, 12, 1);	pixel_oled(80, 12, 1);	pixel_oled(81, 12, 1);	pixel_oled(82, 12, 1);
		pixel_oled(83, 12, 1);	pixel_oled(84, 12, 1);	pixel_oled(85, 12, 1);	pixel_oled(86, 12, 1);	pixel_oled(90, 12, 1);
		pixel_oled(91, 12, 1);	pixel_oled(92, 12, 1);	pixel_oled(93, 12, 1);	pixel_oled(94, 12, 1);	pixel_oled(99, 12, 1);
		pixel_oled(100, 12, 1);	pixel_oled(101, 12, 1);	pixel_oled(108, 12, 1);	pixel_oled(109, 12, 1);	pixel_oled(110, 12, 1);
		pixel_oled(111, 12, 1);	pixel_oled(112, 12, 1);	pixel_oled(113, 12, 1);	pixel_oled(114, 12, 1);	pixel_oled(115, 12, 1);
		pixel_oled(116, 12, 1);	pixel_oled(117, 12, 1);	pixel_oled(125, 12, 1);	pixel_oled(4, 13, 1);	pixel_oled(8, 13, 1);
		pixel_oled(11, 13, 1);	pixel_oled(13, 13, 1);	pixel_oled(20, 13, 1);	pixel_oled(21, 13, 1);	pixel_oled(25, 13, 1);
		pixel_oled(26, 13, 1);	pixel_oled(27, 13, 1);	pixel_oled(28, 13, 1);	pixel_oled(29, 13, 1);	pixel_oled(32, 13, 1);
		pixel_oled(33, 13, 1);	pixel_oled(34, 13, 1);	pixel_oled(35, 13, 1);	pixel_oled(39, 13, 1);	pixel_oled(40, 13, 1);
		pixel_oled(41, 13, 1);	pixel_oled(46, 13, 1);	pixel_oled(47, 13, 1);	pixel_oled(48, 13, 1);	pixel_oled(51, 13, 1);
		pixel_oled(52, 13, 1);	pixel_oled(53, 13, 1);	pixel_oled(54, 13, 1);	pixel_oled(57, 13, 1);	pixel_oled(58, 13, 1);
		pixel_oled(59, 13, 1);	pixel_oled(60, 13, 1);	pixel_oled(64, 13, 1);	pixel_oled(65, 13, 1);	pixel_oled(66, 13, 1);
		pixel_oled(67, 13, 1);	pixel_oled(70, 13, 1);	pixel_oled(71, 13, 1);	pixel_oled(72, 13, 1);	pixel_oled(73, 13, 1);
		pixel_oled(76, 13, 1);	pixel_oled(77, 13, 1);	pixel_oled(78, 13, 1);	pixel_oled(79, 13, 1);	pixel_oled(83, 13, 1);
		pixel_oled(84, 13, 1);	pixel_oled(85, 13, 1);	pixel_oled(86, 13, 1);	pixel_oled(87, 13, 1);	pixel_oled(90, 13, 1);
		pixel_oled(91, 13, 1);	pixel_oled(92, 13, 1);	pixel_oled(93, 13, 1);	pixel_oled(94, 13, 1);	pixel_oled(95, 13, 1);
		pixel_oled(99, 13, 1);	pixel_oled(100, 13, 1);	pixel_oled(101, 13, 1);	pixel_oled(108, 13, 1);	pixel_oled(109, 13, 1);
		pixel_oled(110, 13, 1);	pixel_oled(114, 13, 1);	pixel_oled(115, 13, 1);	pixel_oled(116, 13, 1);	pixel_oled(117, 13, 1);
		pixel_oled(125, 13, 1);	pixel_oled(126, 13, 1);	pixel_oled(4, 14, 1);	pixel_oled(8, 14, 1);	pixel_oled(11, 14, 1);
		pixel_oled(13, 14, 1);	pixel_oled(19, 14, 1);	pixel_oled(20, 14, 1);	pixel_oled(21, 14, 1);	pixel_oled(26, 14, 1);
		pixel_oled(27, 14, 1);	pixel_oled(28, 14, 1);	pixel_oled(29, 14, 1);	pixel_oled(30, 14, 1);	pixel_oled(32, 14, 1);
		pixel_oled(33, 14, 1);	pixel_oled(34, 14, 1);	pixel_oled(35, 14, 1);	pixel_oled(39, 14, 1);	pixel_oled(40, 14, 1);
		pixel_oled(41, 14, 1);	pixel_oled(42, 14, 1);	pixel_oled(45, 14, 1);	pixel_oled(46, 14, 1);	pixel_oled(47, 14, 1);
		pixel_oled(48, 14, 1);	pixel_oled(51, 14, 1);	pixel_oled(52, 14, 1);	pixel_oled(53, 14, 1);	pixel_oled(54, 14, 1);
		pixel_oled(57, 14, 1);	pixel_oled(58, 14, 1);	pixel_oled(59, 14, 1);	pixel_oled(60, 14, 1);	pixel_oled(70, 14, 1);
		pixel_oled(71, 14, 1);	pixel_oled(72, 14, 1);	pixel_oled(73, 14, 1);	pixel_oled(75, 14, 1);	pixel_oled(76, 14, 1);
		pixel_oled(77, 14, 1);	pixel_oled(78, 14, 1);	pixel_oled(84, 14, 1);	pixel_oled(85, 14, 1);	pixel_oled(86, 14, 1);
		pixel_oled(87, 14, 1);	pixel_oled(90, 14, 1);	pixel_oled(91, 14, 1);	pixel_oled(92, 14, 1);	pixel_oled(93, 14, 1);
		pixel_oled(94, 14, 1);	pixel_oled(95, 14, 1);	pixel_oled(99, 14, 1);	pixel_oled(100, 14, 1);	pixel_oled(101, 14, 1);
		pixel_oled(108, 14, 1);	pixel_oled(109, 14, 1);	pixel_oled(110, 14, 1);	pixel_oled(114, 14, 1);	pixel_oled(115, 14, 1);
		pixel_oled(116, 14, 1);	pixel_oled(117, 14, 1);	pixel_oled(126, 14, 1);	pixel_oled(4, 15, 1);	pixel_oled(8, 15, 1);
		pixel_oled(11, 15, 1);	pixel_oled(13, 15, 1);	pixel_oled(14, 15, 1);	pixel_oled(15, 15, 1);	pixel_oled(19, 15, 1);
		pixel_oled(20, 15, 1);	pixel_oled(21, 15, 1);	pixel_oled(27, 15, 1);	pixel_oled(28, 15, 1);	pixel_oled(29, 15, 1);
		pixel_oled(30, 15, 1);	pixel_oled(32, 15, 1);	pixel_oled(33, 15, 1);	pixel_oled(34, 15, 1);	pixel_oled(35, 15, 1);
		pixel_oled(39, 15, 1);	pixel_oled(40, 15, 1);	pixel_oled(41, 15, 1);	pixel_oled(42, 15, 1);	pixel_oled(45, 15, 1);
		pixel_oled(46, 15, 1);	pixel_oled(47, 15, 1);	pixel_oled(48, 15, 1);	pixel_oled(51, 15, 1);	pixel_oled(52, 15, 1);
		pixel_oled(53, 15, 1);	pixel_oled(54, 15, 1);	pixel_oled(58, 15, 1);	pixel_oled(59, 15, 1);	pixel_oled(60, 15, 1);
		pixel_oled(61, 15, 1);	pixel_oled(62, 15, 1);	pixel_oled(63, 15, 1);	pixel_oled(70, 15, 1);	pixel_oled(71, 15, 1);
		pixel_oled(72, 15, 1);	pixel_oled(73, 15, 1);	pixel_oled(75, 15, 1);	pixel_oled(76, 15, 1);	pixel_oled(77, 15, 1);
		pixel_oled(78, 15, 1);	pixel_oled(84, 15, 1);	pixel_oled(85, 15, 1);	pixel_oled(86, 15, 1);	pixel_oled(87, 15, 1);
		pixel_oled(90, 15, 1);	pixel_oled(91, 15, 1);	pixel_oled(92, 15, 1);	pixel_oled(93, 15, 1);	pixel_oled(94, 15, 1);
		pixel_oled(95, 15, 1);	pixel_oled(96, 15, 1);	pixel_oled(99, 15, 1);	pixel_oled(100, 15, 1);	pixel_oled(101, 15, 1);
		pixel_oled(113, 15, 1);	pixel_oled(114, 15, 1);	pixel_oled(115, 15, 1);	pixel_oled(116, 15, 1);	pixel_oled(126, 15, 1);
		pixel_oled(112, 16, 1);	pixel_oled(113, 16, 1);	pixel_oled(114, 16, 1);	pixel_oled(115, 16, 1);	pixel_oled(111, 17, 1);
		pixel_oled(112, 17, 1);	pixel_oled(113, 17, 1);	pixel_oled(114, 17, 1);	pixel_oled(18, 18, 1);	pixel_oled(19, 18, 1);
		pixel_oled(20, 18, 1);	pixel_oled(21, 18, 1);	pixel_oled(27, 18, 1);	pixel_oled(28, 18, 1);	pixel_oled(29, 18, 1);
		pixel_oled(30, 18, 1);	pixel_oled(32, 18, 1);	pixel_oled(33, 18, 1);	pixel_oled(34, 18, 1);	pixel_oled(35, 18, 1);
		pixel_oled(40, 18, 1);	pixel_oled(41, 18, 1);	pixel_oled(42, 18, 1);	pixel_oled(43, 18, 1);	pixel_oled(44, 18, 1);
		pixel_oled(45, 18, 1);	pixel_oled(46, 18, 1);	pixel_oled(47, 18, 1);	pixel_oled(51, 18, 1);	pixel_oled(52, 18, 1);
		pixel_oled(53, 18, 1);	pixel_oled(54, 18, 1);	pixel_oled(61, 18, 1);	pixel_oled(62, 18, 1);	pixel_oled(63, 18, 1);
		pixel_oled(64, 18, 1);	pixel_oled(65, 18, 1);	pixel_oled(66, 18, 1);	pixel_oled(70, 18, 1);	pixel_oled(71, 18, 1);
		pixel_oled(72, 18, 1);	pixel_oled(73, 18, 1);	pixel_oled(75, 18, 1);	pixel_oled(76, 18, 1);	pixel_oled(77, 18, 1);
		pixel_oled(78, 18, 1);	pixel_oled(84, 18, 1);	pixel_oled(85, 18, 1);	pixel_oled(86, 18, 1);	pixel_oled(87, 18, 1);
		pixel_oled(90, 18, 1);	pixel_oled(91, 18, 1);	pixel_oled(92, 18, 1);	pixel_oled(93, 18, 1);	pixel_oled(95, 18, 1);
		pixel_oled(96, 18, 1);	pixel_oled(97, 18, 1);	pixel_oled(98, 18, 1);	pixel_oled(99, 18, 1);	pixel_oled(100, 18, 1);
		pixel_oled(101, 18, 1);	pixel_oled(110, 18, 1);	pixel_oled(111, 18, 1);	pixel_oled(112, 18, 1);	pixel_oled(113, 18, 1);
		pixel_oled(126, 18, 1);	pixel_oled(18, 19, 1);	pixel_oled(19, 19, 1);	pixel_oled(20, 19, 1);	pixel_oled(21, 19, 1);
		pixel_oled(26, 19, 1);	pixel_oled(27, 19, 1);	pixel_oled(28, 19, 1);	pixel_oled(29, 19, 1);	pixel_oled(30, 19, 1);
		pixel_oled(32, 19, 1);	pixel_oled(33, 19, 1);	pixel_oled(34, 19, 1);	pixel_oled(35, 19, 1);	pixel_oled(41, 19, 1);
		pixel_oled(42, 19, 1);	pixel_oled(43, 19, 1);	pixel_oled(44, 19, 1);	pixel_oled(45, 19, 1);	pixel_oled(46, 19, 1);
		pixel_oled(51, 19, 1);	pixel_oled(52, 19, 1);	pixel_oled(53, 19, 1);	pixel_oled(54, 19, 1);	pixel_oled(64, 19, 1);
		pixel_oled(65, 19, 1);	pixel_oled(66, 19, 1);	pixel_oled(67, 19, 1);	pixel_oled(70, 19, 1);	pixel_oled(71, 19, 1);
		pixel_oled(72, 19, 1);	pixel_oled(73, 19, 1);	pixel_oled(75, 19, 1);	pixel_oled(76, 19, 1);	pixel_oled(77, 19, 1);
		pixel_oled(78, 19, 1);	pixel_oled(84, 19, 1);	pixel_oled(85, 19, 1);	pixel_oled(86, 19, 1);	pixel_oled(87, 19, 1);
		pixel_oled(90, 19, 1);	pixel_oled(91, 19, 1);	pixel_oled(92, 19, 1);	pixel_oled(93, 19, 1);	pixel_oled(96, 19, 1);
		pixel_oled(97, 19, 1);	pixel_oled(98, 19, 1);	pixel_oled(99, 19, 1);	pixel_oled(100, 19, 1);	pixel_oled(101, 19, 1);
		pixel_oled(109, 19, 1);	pixel_oled(110, 19, 1);	pixel_oled(111, 19, 1);	pixel_oled(112, 19, 1);	pixel_oled(126, 19, 1);
		pixel_oled(17, 20, 1);	pixel_oled(18, 20, 1);	pixel_oled(19, 20, 1);	pixel_oled(20, 20, 1);	pixel_oled(21, 20, 1);
		pixel_oled(25, 20, 1);	pixel_oled(26, 20, 1);	pixel_oled(27, 20, 1);	pixel_oled(28, 20, 1);	pixel_oled(29, 20, 1);
		pixel_oled(32, 20, 1);	pixel_oled(33, 20, 1);	pixel_oled(34, 20, 1);	pixel_oled(35, 20, 1);	pixel_oled(41, 20, 1);
		pixel_oled(42, 20, 1);	pixel_oled(43, 20, 1);	pixel_oled(44, 20, 1);	pixel_oled(45, 20, 1);	pixel_oled(46, 20, 1);
		pixel_oled(51, 20, 1);	pixel_oled(52, 20, 1);	pixel_oled(53, 20, 1);	pixel_oled(54, 20, 1);	pixel_oled(57, 20, 1);
		pixel_oled(58, 20, 1);	pixel_oled(59, 20, 1);	pixel_oled(60, 20, 1);	pixel_oled(64, 20, 1);	pixel_oled(65, 20, 1);
		pixel_oled(66, 20, 1);	pixel_oled(67, 20, 1);	pixel_oled(70, 20, 1);	pixel_oled(71, 20, 1);	pixel_oled(72, 20, 1);
		pixel_oled(73, 20, 1);	pixel_oled(76, 20, 1);	pixel_oled(77, 20, 1);	pixel_oled(78, 20, 1);	pixel_oled(79, 20, 1);
		pixel_oled(84, 20, 1);	pixel_oled(85, 20, 1);	pixel_oled(86, 20, 1);	pixel_oled(87, 20, 1);	pixel_oled(90, 20, 1);
		pixel_oled(91, 20, 1);	pixel_oled(92, 20, 1);	pixel_oled(93, 20, 1);	pixel_oled(96, 20, 1);	pixel_oled(97, 20, 1);
		pixel_oled(98, 20, 1);	pixel_oled(99, 20, 1);	pixel_oled(100, 20, 1);	pixel_oled(101, 20, 1);	pixel_oled(108, 20, 1);
		pixel_oled(109, 20, 1);	pixel_oled(110, 20, 1);	pixel_oled(111, 20, 1);	pixel_oled(125, 20, 1);	pixel_oled(126, 20, 1);
		pixel_oled(17, 21, 1);	pixel_oled(18, 21, 1);	pixel_oled(19, 21, 1);	pixel_oled(20, 21, 1);	pixel_oled(21, 21, 1);
		pixel_oled(22, 21, 1);	pixel_oled(23, 21, 1);	pixel_oled(24, 21, 1);	pixel_oled(25, 21, 1);	pixel_oled(26, 21, 1);
		pixel_oled(27, 21, 1);	pixel_oled(28, 21, 1);	pixel_oled(29, 21, 1);	pixel_oled(32, 21, 1);	pixel_oled(33, 21, 1);
		pixel_oled(34, 21, 1);	pixel_oled(35, 21, 1);	pixel_oled(42, 21, 1);	pixel_oled(43, 21, 1);	pixel_oled(44, 21, 1);
		pixel_oled(45, 21, 1);	pixel_oled(51, 21, 1);	pixel_oled(52, 21, 1);	pixel_oled(53, 21, 1);	pixel_oled(54, 21, 1);
		pixel_oled(57, 21, 1);	pixel_oled(58, 21, 1);	pixel_oled(59, 21, 1);	pixel_oled(60, 21, 1);	pixel_oled(61, 21, 1);
		pixel_oled(62, 21, 1);	pixel_oled(63, 21, 1);	pixel_oled(64, 21, 1);	pixel_oled(65, 21, 1);	pixel_oled(66, 21, 1);
		pixel_oled(67, 21, 1);	pixel_oled(70, 21, 1);	pixel_oled(71, 21, 1);	pixel_oled(72, 21, 1);	pixel_oled(73, 21, 1);	
		pixel_oled(76, 21, 1);	pixel_oled(77, 21, 1);	pixel_oled(78, 21, 1);	pixel_oled(79, 21, 1);	pixel_oled(80, 21, 1);
		pixel_oled(81, 21, 1);	pixel_oled(82, 21, 1);	pixel_oled(83, 21, 1);	pixel_oled(84, 21, 1);	pixel_oled(85, 21, 1);
		pixel_oled(86, 21, 1);	pixel_oled(90, 21, 1);	pixel_oled(91, 21, 1);	pixel_oled(92, 21, 1);	pixel_oled(93, 21, 1);
		pixel_oled(97, 21, 1);	pixel_oled(98, 21, 1);	pixel_oled(99, 21, 1);	pixel_oled(100, 21, 1);	pixel_oled(101, 21, 1);
		pixel_oled(107, 21, 1);	pixel_oled(108, 21, 1);	pixel_oled(109, 21, 1);	pixel_oled(110, 21, 1);	pixel_oled(111, 21, 1);
		pixel_oled(112, 21, 1);	pixel_oled(113, 21, 1);	pixel_oled(114, 21, 1);	pixel_oled(115, 21, 1);	pixel_oled(116, 21, 1);
		pixel_oled(117, 21, 1);	pixel_oled(125, 21, 1);	pixel_oled(16, 22, 1);	pixel_oled(17, 22, 1);	pixel_oled(18, 22, 1);
		pixel_oled(19, 22, 1);	pixel_oled(20, 22, 1);	pixel_oled(21, 22, 1);	pixel_oled(22, 22, 1);	pixel_oled(23, 22, 1);
		pixel_oled(24, 22, 1);	pixel_oled(25, 22, 1);	pixel_oled(26, 22, 1);	pixel_oled(27, 22, 1);	pixel_oled(28, 22, 1);
		pixel_oled(32, 22, 1);	pixel_oled(33, 22, 1);	pixel_oled(34, 22, 1);	pixel_oled(35, 22, 1);	pixel_oled(42, 22, 1);
		pixel_oled(43, 22, 1);	pixel_oled(44, 22, 1);	pixel_oled(45, 22, 1);	pixel_oled(51, 22, 1);	pixel_oled(52, 22, 1);
		pixel_oled(53, 22, 1);	pixel_oled(54, 22, 1);	pixel_oled(58, 22, 1);	pixel_oled(59, 22, 1);	pixel_oled(60, 22, 1);
		pixel_oled(61, 22, 1);	pixel_oled(62, 22, 1);	pixel_oled(63, 22, 1);	pixel_oled(64, 22, 1);	pixel_oled(65, 22, 1);
		pixel_oled(66, 22, 1);	pixel_oled(70, 22, 1);	pixel_oled(71, 22, 1);	pixel_oled(72, 22, 1);	pixel_oled(73, 22, 1);
		pixel_oled(77, 22, 1);	pixel_oled(78, 22, 1);	pixel_oled(79, 22, 1);	pixel_oled(80, 22, 1);	pixel_oled(81, 22, 1);	
		pixel_oled(82, 22, 1);	pixel_oled(83, 22, 1);	pixel_oled(84, 22, 1);	pixel_oled(85, 22, 1);	pixel_oled(90, 22, 1);
		pixel_oled(91, 22, 1);	pixel_oled(92, 22, 1);	pixel_oled(93, 22, 1);	pixel_oled(98, 22, 1);	pixel_oled(99, 22, 1);
		pixel_oled(100, 22, 1);	pixel_oled(101, 22, 1);	pixel_oled(107, 22, 1);	pixel_oled(108, 22, 1);	pixel_oled(109, 22, 1);
		pixel_oled(110, 22, 1);	pixel_oled(111, 22, 1);	pixel_oled(112, 22, 1);	pixel_oled(113, 22, 1);	pixel_oled(114, 22, 1);
		pixel_oled(115, 22, 1);	pixel_oled(116, 22, 1);	pixel_oled(117, 22, 1);	pixel_oled(124, 22, 1);	pixel_oled(125, 22, 1);
		pixel_oled(16, 23, 1);	pixel_oled(17, 23, 1);	pixel_oled(18, 23, 1);	pixel_oled(19, 23, 1);	pixel_oled(20, 23, 1);
		pixel_oled(21, 23, 1);	pixel_oled(22, 23, 1);	pixel_oled(23, 23, 1);	pixel_oled(24, 23, 1);	pixel_oled(25, 23, 1);
		pixel_oled(26, 23, 1);	pixel_oled(32, 23, 1);	pixel_oled(33, 23, 1);	pixel_oled(34, 23, 1);	pixel_oled(35, 23, 1);
		pixel_oled(43, 23, 1);	pixel_oled(44, 23, 1);	pixel_oled(51, 23, 1);	pixel_oled(52, 23, 1);	pixel_oled(53, 23, 1);
		pixel_oled(54, 23, 1);	pixel_oled(59, 23, 1);	pixel_oled(60, 23, 1);	pixel_oled(61, 23, 1);	pixel_oled(62, 23, 1);
		pixel_oled(63, 23, 1);	pixel_oled(64, 23, 1);	pixel_oled(65, 23, 1);	pixel_oled(70, 23, 1);	pixel_oled(71, 23, 1);
		pixel_oled(72, 23, 1);	pixel_oled(73, 23, 1);	pixel_oled(78, 23, 1);	pixel_oled(79, 23, 1);	pixel_oled(80, 23, 1);
		pixel_oled(81, 23, 1);	pixel_oled(82, 23, 1);	pixel_oled(83, 23, 1);	pixel_oled(84, 23, 1);	pixel_oled(90, 23, 1);
		pixel_oled(91, 23, 1);	pixel_oled(92, 23, 1);	pixel_oled(93, 23, 1);	pixel_oled(98, 23, 1);	pixel_oled(99, 23, 1);
		pixel_oled(100, 23, 1);	pixel_oled(101, 23, 1);	pixel_oled(107, 23, 1);	pixel_oled(108, 23, 1);	pixel_oled(109, 23, 1);
		pixel_oled(110, 23, 1);	pixel_oled(111, 23, 1);	pixel_oled(112, 23, 1);	pixel_oled(113, 23, 1);	pixel_oled(114, 23, 1);
		pixel_oled(115, 23, 1);	pixel_oled(116, 23, 1);	pixel_oled(117, 23, 1);	pixel_oled(124, 23, 1);	pixel_oled(123, 24, 1);	
		pixel_oled(124, 24, 1);	pixel_oled(102, 25, 1);	pixel_oled(103, 25, 1);	pixel_oled(122, 25, 1);	pixel_oled(123, 25, 1);
		pixel_oled(103, 26, 1);	pixel_oled(104, 26, 1);	pixel_oled(121, 26, 1);	pixel_oled(122, 26, 1);	pixel_oled(104, 27, 1);	
		pixel_oled(105, 27, 1);	pixel_oled(120, 27, 1);	pixel_oled(121, 27, 1);	pixel_oled(105, 28, 1);	pixel_oled(106, 28, 1);	
		pixel_oled(107, 28, 1);	pixel_oled(118, 28, 1);	pixel_oled(119, 28, 1);	pixel_oled(120, 28, 1);	pixel_oled(107, 29, 1);
		pixel_oled(108, 29, 1);	pixel_oled(109, 29, 1);	pixel_oled(110, 29, 1);	pixel_oled(115, 29, 1);	pixel_oled(116, 29, 1);	
		pixel_oled(117, 29, 1);	pixel_oled(118, 29, 1);	pixel_oled(110, 30, 1);	pixel_oled(111, 30, 1);	pixel_oled(112, 30, 1);
		pixel_oled(113, 30, 1);	pixel_oled(114, 30, 1);	pixel_oled(115, 30, 1);
} 