// Deyy Script Madde By Sujay (EDITED BY DHRUVSKI) ....... 

// SHOUTOUT TO THE FOLLOWING PEOPLE
// Cryptoace,noctwrnyA,Dogz, TD21, Nikokai, Exploit, and everyone in my script 

// â€œQuit all the gossip, Iâ€™m simply a product of people I rock withâ€

//Binds
// ðŸ…¼ðŸ…°ðŸ†ƒðŸ…²ðŸ…· ðŸ…¸ðŸ…½ ðŸ…¶ðŸ…°ðŸ…¼ðŸ…´ ðŸ…±ðŸ†„ðŸ†ƒðŸ†ƒðŸ…¾ðŸ…½ðŸ†‚
// ðŸ…²ðŸ…¾ðŸ…¼ðŸ…±ðŸ…°ðŸ†ƒ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define ADS     		= PS4_L2;		//in-game ADS BUTTON
define FIRE     	= PS4_R2;		//in-game FIRE BUTTON
define NEXT_WEAPON 	= PS4_R1;		//in-game NEXT_WEAPON BUTTON
define PREV_WEAPON 	= PS4_L1;		//in-game PREV_WEAPON BUTTON
define PICKAXE 		= PS4_TRIANGLE; //in-game PICKAXE BUTTON
define JUMP     	= PS4_CROSS;	//in-game JUMP BUTTON
define CROUCH   	= PS4_R3;		//in-game CROUCH BUTTON
define INTERACT 	= PS4_SQUARE;	//in-game INTERACT BUTTON
define MAPVIEW_B	= PS4_TOUCH;    //in-game MAP BUTTON
define INVENTORY    = PS4_UP;      // in-game INVENTORY BUTTON

// ðŸ…±ðŸ†„ðŸ…¸ðŸ…»ðŸ…³ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define BUILD     	= PS4_CIRCLE;	//in-game BUILD BUTTON
define STAIRS  		= PS4_L2;		//in-game STAIRS BUTTON
define WALL    	 	= PS4_R2;		//in-game WALL BUTTON
define FLOOR  		= PS4_R1;		//in-game FLOOR BUTTON
define ROOF   		= PS4_L1;		//in-game ROOF BUTTON
define TRAP         = PS4_SQUARE;   //in-game TRAP BUTTON
// ðŸ…´ðŸ…³ðŸ…¸ðŸ†ƒ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define EDIT 		= PS4_L3;	//in-game EDIT BUTTON
define SELECT 		= PS4_R2; 		//in-game SELECT BUTTON
define CONFIRM 		= PS4_CIRCLE;	//in-game CONFIRM BUTTON
define RESET 		= PS4_L2;	//in-game RESET BUTTON
define On  = TRUE;
define Off = FALSE;

// ðŸ…¼ðŸ…¾ðŸ†…ðŸ…´ðŸ…¼ðŸ…´ðŸ…½ðŸ†ƒ & ðŸ…°ðŸ…¸ðŸ…¼ ðŸ†‚ðŸ†ƒðŸ…¸ðŸ…²ðŸ…ºðŸ†‚

define AimY     = XB1_RY;  // Vertical Aim Axis In Game
define AimX     = XB1_RX;  // Horizontal Aim Axis In Game
define Strafe   = XB1_LX;  // Horizontal Walk Axis In Game
define Walk     = XB1_LY;  // Vertical Walk Axis In Game
define PS       = POLAR_RS;// Polar Stick In Use [LS/RS]


// DUSTEEEEEEEEE AA //
define DUSTE   =   TRUE; // keep this on for stickiness purposes
define PXS     =   3150;  				    	
define PXSE    =    200;				    
define PVSI    =     200;    				
define PVS     =      0;
define PYS     =   -200;				
define PYSE    =    200;		    	
int    PPFX    =    PXS;
int    PPFY    =    PYS;				  	  
int    PVID;
int    PFD     =      1;		    
int    PPFD    =      1;
int    RX;
int    RY;

// Crypto's Dhur AA //
int SHAKEX = -10;// deadzone 
int STRAFEX = -10;// deadzone 
int SHAKEY = -10; // deadzone 
int STRAFEY = -10;// deadzone 

// BrUcE TiMeD AiM AsSiSt
int DoGzTimeZ = TRUE;      // BrUcE TimeZ Aim Assist
int Power = 1;            // [1 - 10] =  DoGz TimeZ Aim Assist Power [1,2,3,4,5] ==> (>> 1 = 5 , 2 = 10 , 3 = 15 , 4 = 20 , 5 = 25 etc  <<) [LINEAR USE VALUE 1]
int AATime = 2000;        // [1000 - 5000] =  DoGz TimeZ Aim Assist Will Cut Out After Time [1000] = 1 Second, [2000] = 2 Second
int AATimed = TRUE;        // [(On) or (Off)] = Aim Assist Will Cut Out After 2 seconds By Default (Change Below)
int AimAssistHip = TRUE;    // [(On) or (Off)] = {Operates on [Ads Alone (Off)] Or [Ads or Fire Alone (On)]}

// Batts STICKY AA // 
define BattsStickyAA = TRUE;
define BattsAAHip    = TRUE;
define BattStickyPower = 9;// deadzone
define BattStickyWait  = 9;//  deadzone

// NIKO AIM // 
define SS_Nikolai_Aim = TRUE;
define AimAssistWaitTime = 9;// deadzone
define AimAssistStrength = 9;// deadzone

//Aim Assist Linear - Semjases V2
int AimAssist_LINEAR  = TRUE; 
int Strength  = 20; //Examples 13-4, 17-5, 20-5, 10-3
int Increment = 5; 

//Aim Assist Stick Linear - Umbrella V2 
define AimStickLinear  = TRUE; // Help with aiming moving the jyostick linear
define Ads_Assist      = TRUE; // Aim Assist Ads only 
define Fire_Assist     = TRUE; // Aim Assist Fire only
define RADIUS          = 7;    // Radius/strength/value
define STEPS           = 30;   // Step/speed
define STEP_INTERVAL   = 1;    // time

// AIM ASSIST EXPLOIT LINEAR LEXICO - Lexicon V2
int Aim_Exploit_Linear = TRUE; // [(On) or (Off)] = {Aim Assist Linear Toggle On/Off By Default}
int Strength_Linear    = 150; // AIM ASSIST STRENGTH // THE MAXIMUM VALUE IS 150
int Wait_Linear        = 9;  // AIM ASSIST WAIT     //IF YOU SEE THE CHARACTER MOVES A LITTLE, YOU CAN LOWER THE VALUE.

// Progression Head Shot Assist
define HeadAssist    = TRUE; // Main Toggle ON/OFF
define HeadHipAssist = TRUE;  // Operate on Fire Only [If Off It Will Only Run On ADS & FIRE]

define HeadStep = 3;  // Step Increment Increasing Until Its Reached HeadMax
define HeadMax  = 30; // Max Head Assist Value

//Dhruvski's Tracker v1
int DhruvAimV1 = TRUE

int Moongraal = 21; 
int SolitarialEXE = 18; 
int ZUSER = -18;
int ELSCAMMER = 19;
int KoolKene = 14;
int NotKoolKene = -14;
int WE_LOVE_FREE_SCRIPTS = 14;
int DhRuvSkII = FALSE;
int DUstEE = FALSE; 
int CRYptoACE = FALSE;
int YEwiFySuCks = FALSE;

int deadzone = 10;

//Deadzone optimizer
int DEADZONE	= On;
define DZ_L 	= 10; //left stick deadzone
define invDZ_L 	= -10;//left stick deadzone

define DZ_R 	= 10;//right stick deadzone
define invDZ_R 	= -10;//right stick deadzone

// RIGHT STICK DEADZONE OPTIMIZER
int JoyStick_Calibration = On; //OPTIMIZED Deadzone for RIGHT STICK
define _Rv = 10; //deadzone

// 100% Accuracy
int PerfectAccuracy = On;
int PerfectAccuracyTime = 350;
define PerfectAccuracyHold  = PS4_R3;  /*Btn1 : Button 1*/ 
define PerfectAccuracyPress = PS4_L2;  /*Btn2 : Button 2*/
int PerfectAccuracyActive = Btn1Hold_Btn2Press; // MOD TRIGGER STATE == { Btn2Press[1]  or  Btn1Hold_Btn2Press[2]  or  Btn2Hold[3]  or  Btn1Hold_Btn2Hold[4] }


// Instant Edit + Reset 
define InstaEditReset = TRUE; 	// [ON / OFF] Normal Instant Edit/Reset
define EditHold       = FALSE; 	// [ON / OFF] SET On WHEN USING EDIT HOLD TIME TO EDIT ( MATCH TO IN GAME SETUP ) [Off = INSTANT PRESS]
define EditHoldTime   = 100;  	// Time If Using Hold to Edit In game [Setting To Be Matched To In Game Time]


// Fast Reset (One Button)
define InstaFastReset = TRUE;        // Fast Reset [ON / OFF]
define FastReset      = PS4_L2;     // FAST RESET BUTTON 


// Quick Edit Assist
define QuickEditAssist = FALSE;   	 // [ON / OFF] Edit Assist
define EditDelay       = 20;     // Edit Assist Hold Delay On Select
define EditAssist      = PS4_RIGHT; // EDIT ASSIST + FAST RESET EDIT BUTTON (Edit In Game [ NO HOLD TIME!!! ])

//Build Tracker
int BuildTracker  =  TRUE;
int BuildSyncTime = 4000;
  
  
//Block Rumble
int BlockRumble     =  TRUE;


// Playstation On PC/Xbox
define PlayStationOnXbox = FALSE; // [ON / OFF] DS4/5 On PC/Xbox [Touchpad Button Fix]


// Hair Triggers
define HairTriggers = TRUE; // Instant Triggers [100%]


//Input Delay Reducer
int DelayBuster = -5;					// LEAVE AS (-5) FOR NORMAL; (-9) for 1ms Delay


int Edit1,Edit2,EditT,Shunt,BuildTrack,BuildCount;
int power,Ypower,Xpower,CountPower,AxisXY;int AxisT,AAT;
int display_title = TRUE;int goCOMBAT;int WaitStrength, AimStrength;
int display_black;int MAPVIEW,MAPtap,P_MAP,C_MAP;int EditSensitivity =  Off;      
int count_black; int Head;define AdsFireTrigger = 0,AnyFireTrigger = 1,FireOnlyTrigger = 2;
int TimeValue,OutPut,RumValue,RecoilTimer,BoostAR,AxisCY,AxisLY;define Btn2Press = 1,
Btn1Hold_Btn2Press = 2,Btn2Hold = 3,Btn1Hold_Btn2Hold = 4;int EditAst,EDIThold;
int actual_X, actual_Y, actual_Magnitude, max_Magnitude,time,angle, cos_angle, sin_angle;
int DZ = 100;int TargetList[2];int targetLoop;int index;int i;int TIME = 1;
int RIZ = 5;int deltax,deltay;int hyp;int anglesx,anglesy;int RIGHTOFFSETY,RIGHTOFFSETX;
int LEFTOFFSETX,LEFTOFFSETY;int ry;int rx; int lx; int ly; int RAXIS;

//Main
main {

vm_tctrl(DelayBuster);
block_rumble();
	if (PlayStationOnXbox && get_console() == PIO_XB360 && get_controller() == PIO_PS4) { 
	
		swap(PS4_TOUCH,PS4_SHARE);
	}
	if (HairTriggers) { 
   		
   		deadzone(PS4_L2,PS4_R2,100,100);
   	}
	if(EditAssist){
		
		if(get_ival(EDIT) && get_ptime(EDIT) > 10){
			
			EditAssist();
			EditAst = On;
		}

		if(event_release(EDIT)){	
			
			EDIThold = 0;	
			EditAst = Off;
		}
		
		
	}
	
	if (InstaFastReset && !get_ival(ADS) && event_press(FastReset)) { 
       
      
        
        	Shunt = FastReset;
        	combo_run(FastReset);
    }
    if (InstaEditReset) {
        if (EditHold && get_ival(EDIT) && get_ptime(EDIT) > EditHoldTime || !EditHold && event_press(EDIT)) {
                Edit1 = On;
                Edit2 = On;
                BuildTrack = On;
        
        }

        if (Edit2) {
            if (event_release(SELECT)) {  
                Edit1 = Off;
                Edit2 = Off;
                BuildTrack = Off;
    		}

        }
    }
     if (Edit1 || Edit2) {
        if (EditSensitivity) {    
          
        }

            if (event_press(RESET)) {  
                combo_run (InstantReset);
                Edit1 = Off;
                Edit2 = Off; 
            }

                if (event_press(PICKAXE) || event_press(BUILD) || event_press(ADS)) {
                    Edit1 = Off;
                    Edit2 = Off;
                    BuildTrack = Off;
                }
    }
  
	if (BuildTracker) {
        
        if (event_press(BUILD)) {
            BuildTrack = !BuildTrack;
            
        }
    
        if (BuildTrack) {
            BuildCount += get_rtime();
            
            if (event_press(PICKAXE) || BuildCount == BuildSyncTime) {
                BuildTrack = Off;
                BuildCount = Off;
            }
            
                if (get_ival(ROOF) || get_ival(FLOOR) || get_ival(STAIRS) || get_ival(WALL)) 
                    BuildCount = Off;
        }
    }
    if(!BuildTrack && get_val(ADS) && get_val(FIRE)){
	
     if (DoGzTimeZ) {
	        	
	        	if (AATimed) {
	        	
	        		if (get_ival(ADS) && get_ptime(ADS) <= AATime || AimAssistHip && get_ival(FIRE) && get_ptime(FIRE) <= AATime) {
	            	
	            		DoGzTimeZ();
	            	}
	            	
	            } else if (get_ival(ADS)|| AimAssistHip && get_ival(FIRE)) {
	            	
	            		DoGzTimeZ();
	            }
	            
	            if (!get_ival(ADS) && !get_ival(FIRE)) {
	            
	            	AAT = 0;
	            	AxisT = 0;
	            }
	        }
   	 if (BattsStickyAA) {
if (get_ival(ADS) || (BattsAAHip && get_ival(FIRE))) {
combo_run(BattsStickyAssist);
} else {
combo_stop(BattsStickyAssist); 
}
}
if (SS_Nikolai_Aim)
		{
			if(get_ival(ADS) || get_ival(FIRE))
			{
				combo_run(cNikoAim);
			}

			if(event_release(ADS) || event_release(FIRE))
			{
				combo_stop(cNikoAim)
			}
		}
		 if (Aim_Exploit_Linear) {

        if (get_ival(ADS)) {

            combo_run(Aim_Linear);
    }
}

if(AimStickLinear) {
  
       actual_X = get_val(RX);
       actual_Y = get_val(RY);
       actual_Magnitude = isqrt(pow(actual_X, 2) + pow(actual_Y, 2));                                                                                                                                                                                              //CREATED BY EXPLOIT YT
       max_Magnitude = (actual_Magnitude < 100);
  
     if(!(time++ % STEP_INTERVAL)){
       
       angle += STEPS;
}
       angle = angle % 360;
       sin_angle = Polar_Array[angle % 360];
       cos_angle = Polar_Array[(angle + 270) % 360];                   
       cos_angle = (cos_angle * RADIUS) / 100;
       sin_angle = (sin_angle * RADIUS) / 100;
  
  if((Ads_Assist && get_val(ADS)) || (Fire_Assist && get_val(FIRE))){
 
    if(actual_Magnitude <= RADIUS){
  
       sin_angle -= actual_Y;
       cos_angle -= actual_X;
       }else {
       sin_angle = (sin_angle * (200 - ((abs(actual_Y) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
       cos_angle = (cos_angle * (200 - ((abs(actual_X) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
}
  
       set_val(RX, clamp(actual_X + cos_angle, -100, 100));
       set_val(RY, clamp(actual_Y + sin_angle, -100, 100));
      }
   } 

        
     if (AimAssist_LINEAR) {
	 
	    if (event_press(ADS)) { 
	    	
	    	Power = On;
}
	    
	    else if (!get_ival(ADS) && event_press(FIRE)) {
	    	
	    	Power = On;
}
	    
	    if (get_ival(ADS) || get_ival(FIRE)) {
	    	
	    	AxisXY = isqrt(abs(get_ival(PS4_RX)) * abs(get_ival(PS4_RX)) + abs(get_ival(PS4_RY)) * abs(get_ival(PS4_RY)));
	    	
	    	if (AssistProfile == 1)
	    		
	    		AimAssist(Strength,Increment);
	    		
         } else {
	    	
	    	CountPower = 0;
	    	power = Off;
        }
}
    
    if (HeadAssist) {
	        
	        if (get_ival(ADS) && get_ival(FIRE) || HeadHipAssist && get_ival(FIRE)) {
	        
	        	if (abs(get_ival(PS4_RY)) < HeadMax) { 
	        		
	        		Head += HeadStep;
	        		combo_run(HeadAssist);
	        	}	
	        }
	        
	        if (!get_ival(FIRE)) Head = 0;
	        	
	        if (Head >= HeadMax) combo_stop(HeadAssist);
	    }
	    if (DUSTE) {
            RX = PS4_RX;
			RY = PS4_RY;
			RX =   PPFX;
			RY =   PPFY;
    	if(get_val(PS4_L2) > 80){
    	if(abs(get_val(XB1_RX) < 10)) 
    	if(abs(get_val(XB1_RY) < 10)) 
    	if(abs(get_val(XB1_RX) > -10)) 
    	if(abs(get_val(XB1_RY) > -10)){
   			PPFX = PolarFlow(PPFX,PXS,PXSE,PVSI,PFD,1);
        	PPFY = PolarFlow(PPFY,PYS,PYSE,PVS,PPFD,2);
       	    set_polar(POLAR_RS,30,PPFX);
    		set_polar(POLAR_RS,30,PPFY);}
}
}

Aimbot();
	CalcAngle()
	valuefinder()
	Ais();
	combo_run(Ais)
	RAXIS = get_polar(POLAR_RS, POLAR_ANGLE);
	combo_run(u);
	combo_run(w);
	combo_run(A);
	combo_run(c)
Y(PS4_RX,(POLAR_RADIUS * POLAR_RADIUS / 180));
Y(PS4_RY,(POLAR_RADIUS * POLAR_RADIUS / 180));

if(DhruvAimV1) {
DhRuvSkII=!DhRuvSkII;
DUstEE=!DUstEE;
CRYptoACE=!CRYptoACE;
YEwiFySuCks=! YEwiFySuCks;
if((DhRuvSkII) && (DUstEE) && (CRYptoACE)&& (YEwiFySuCks)) { 
combo_run(Flash_ON); } 
else combo_run(Flash_OFF); }

if (DhRuvSkII) { 
if (get_val(PS4_L2)> 95){ 
combo_run(MoOnGrAAAL_Has_NOB1TChes);} 
if (abs(get_val(PS4_RX)) > deadzone || abs(get_val(PS4_RY)) > deadzone) combo_stop(MoOnGrAAAL_Has_NOB1TChes); }

if (DUstEE || CRYptoACE ) { 
combo_run(ScarletSpiderMan); 
}
if (DUstEE) { 
if(get_val(PS4_L2)){
combo_run(AIM);} 

if(CRYptoACE){ 
if(get_val(PS4_R2)) combo_run(LucidNightmareSUCKS);}}

if (YEwiFySuCks){ 
if (get_val(PS4_L2)){ combo_run(I_SHOW_SPED); } 

if ((get_val(PS4_RX)) > deadzone +(1)|| (get_val(PS4_RX)) < deadzone +(1)*(-1)){ 
combo_stop(I_SHOW_SPED); } } 

}
     if (Shunt) {
        
        if (event_release(Shunt)) {
            Shunt = Off;
        }
            else {
            set_val (Shunt,Off);
         }
     }
   }
 
//Combos 
combo MoOnGrAAAL_Has_NOB1TChes { 
set_val(PS4_RY, WE_LOVE_FREE_SCRIPTS * -1); 
wait(PS4_RY) set_val(PS4_RX, WE_LOVE_FREE_SCRIPTS);
wait(PS4_RY) set_val(PS4_RY, WE_LOVE_FREE_SCRIPTS); 
wait(PS4_RY) set_val(PS4_RX, WE_LOVE_FREE_SCRIPTS * -1); 
wait(PS4_RY) }
combo ScarletSpiderMan { 
CRYptoACE = FALSE; 
DUstEE = FALSE; 
wait(30000); 
DUstEE = TRUE; 
CRYptoACE = TRUE; }
combo AIM { 
set_val(PS4_RY,a_f(PS4_RY,KoolKene));
wait(ELSCAMMER) set_val(PS4_RX,a_f(PS4_RX,KoolKene));
wait(ELSCAMMER) set_val(PS4_RY,a_f(PS4_RY,NotKoolKene));
wait(ELSCAMMER) set_val(PS4_RX,a_f(PS4_RX,NotKoolKene)); 
wait(ELSCAMMER)}
combo LucidNightmareSUCKS { 
set_val(PS4_RY,a_f(PS4_RY,SolitarialEXE));
wait(ELSCAMMER) set_val(PS4_RX,a_f(PS4_RX,SolitarialEXE));
wait(ELSCAMMER) set_val(PS4_RY,a_f(PS4_RY,ZUSER));
wait(ELSCAMMER) set_val(PS4_RX,a_f(PS4_RX,ZUSER)); 
wait(ELSCAMMER)}
combo I_SHOW_SPED { 
wait(PS4_R2) set_val(PS4_RX, 20); 
wait(7); 
set_val(PS4_RX, 20*(-1)); 
wait(7); }
combo Flash_ON { 
LED(0,0,2,0); 
wait(400);
reset_leds();
} 
combo Flash_OFF { 
LED(0,2,0,0);  
wait(200);  
LED(0,0,0,0); 
wait(100);  
LED(0,2,0,0);
wait(200); 
reset_leds();
} 
combo u {
	Y(RX,rx)wait(TIME)Y(RX,0)wait(TIME)Y(RX,-rx)wait(TIME)Y(RX,0)wait(TIME)
}
combo w {
	Y(RY,0)wait(TIME)Y(RY,ry)wait(TIME)Y(RY,0)wait(TIME)Y(RY,-ry)wait(TIME)
}
combo A{
	Y(Strafe,lx)wait(TIME)Y(Strafe,0)wait(TIME)Y(Strafe,-lx)wait(TIME)Y(Strafe,0)wait(TIME)
}
combo c{
	Y(Walk,0)wait(TIME)Y(Walk,ly)wait(TIME)Y(Walk,0)wait(TIME)Y(Walk,-ly)wait(TIME)
}
combo Ais {
		Y(RY,RIZ)
		Y(RX,-RIZ)
		wait(1)
		Y(RY,-RIZ)
		Y(RX,RIZ)
		wait(1)
		} 
combo BattsStickyAssist {
 set_val(AimY,AxisRelease(AimY,BattStickyPower));
   wait(BattStickyWait);
   set_val(AimX,AxisRelease(AimX,BattStickyPower));
   set_val(Strafe,AxisRelease(Strafe,BattStickyPower));
   wait(BattStickyWait);
   set_val(AimY,AxisRelease(AimY,inv(BattStickyPower)));
   wait(BattStickyWait);
   set_val(AimX,AxisRelease(AimX,inv(BattStickyPower)));
   set_val(Strafe,AxisRelease(Strafe,inv(BattStickyPower)));
   wait(BattStickyWait);
}
combo Rapid_Fire {
    
    set_val(Fire,100); 
    wait(Hold);        
    set_val(Fire,0);   
    wait(Release);    
}
combo cNikoAim {
	WaitStrength	= random(AimAssistWaitTime / 2 , AimAssistWaitTime);
	AimStrength		= random(inv(AimAssistStrength), AimAssistStrength);

	Set_Val(AimY,	AimStrength);
	wait(WaitStrength);
	Set_Val(AimX,	AimStrength);
	wait(WaitStrength);
	Set_Val(AimY,	inv(AimStrength));
	wait(WaitStrength);
	Set_Val(AimX,	inv(AimStrength));
	wait(WaitStrength);
}
combo HeadAssist{

	set_val(AimY,inv(Head) + get_val(AimY));
}
combo Aim_Linear {

    set_val(Strafe,inv(Strength_Linear));
    wait(Wait_Linear);
    set_val(Strafe,Strength_Linear);
    wait(Wait_Linear);
}
combo Confirm {

    set_val(CONFIRM,100);
    wait(50);
    set_val(CONFIRM,0);
    wait(100);
}

combo FastReset {

    set_val(EditAssist,100);
    wait(50)
    set_val(RESET,100);        
    wait(50);
    combo_run(Confirm);
}

combo InstantReset {

    wait(10)
    combo_run(Confirm);
}

combo AimExpo{          
     
     set_val(10, (AimAssist_Strength)); wait(10)
     set_val(9, (AimAssist_Strength)); wait(10)
     set_val(10, AimAssist_Strength * -1); wait(10)
     set_val(9, AimAssist_Strength * -1); wait(10)
}



//Functions
function Ais () {

		Y(RX,RIZ)
		}   
int AssistProfile = 1; 
function AimAssist (Strength,Step) {

	if (Power) {
		
		Ypower = Strength;
		Xpower = Strength * -1;
		Increment = Step;
		Power = Off;
	}
	
	if (!power) {
	
		Xpower += Increment;
		Ypower -= Increment;
	
	} else {
		
		Xpower -= Increment;
		Ypower += Increment;
	}
	
	CountPower ++;
	
	if (CountPower >= (Strength / Increment)) {
		
		power = !power;
		CountPower = 0;
	}	
	
	if (AxisXY > 10) {
		
}
}
function DoGzTimeZ() {

	AAT += get_rtime();
	
	if (!AxisT) 
		
		set_Ival(AimY,AAT * Power / 10);
		
	if (AxisT == 1)  
		
		set_Ival(AimX,AAT * Power / 10);
	
	if (AxisT == 2)  
		
		set_Ival(AimY,inv(AAT * Power / 10));

	if (AxisT == 3) {
		
		set_Ival(AimX,inv(AAT * Power / 10));
	
		if (AAT > 50) {
		
			AAT = 0;
			AxisT = 0;
		}
	
	} else if (AAT > 50) {
		
		AAT = 0;
		AxisT += 1;
	}
}
function AxisRelease(AxisXY,AxisVal) {
    
    if (abs(get_ival(AxisXY)) <= BattStickyPower) 
        
        return AxisVal;
    
    return get_ival(AxisXY); 
}
function PolarFlow(PFB,PSV,PFV,PV,PF,PID) {
    	if(PF) {
       		PFB += PV;
    	if(PFB <= PFV)  
    	return PFB;
    	if(PFB > PFV) {
        	PVID[PID] = 0;
    	return PFB - PV;}
}
		else{
        	PFB -= PV;    
    	if(PFB >= PSV)  
    	return PFB;
    	if(PFB < PSV) {
    		PVID[PID] = 1; 
        return PFB + PV;}
} 
       {return FALSE;
}
   		
 	   
}

function block_all_outputs() {
	set_val(PS4_L2      , 0);
	set_val(PS4_R2      , 0);
	set_val(PS4_L1      , 0);
	set_val(PS4_R1      , 0);
	set_val(PS4_L3      , 0);
	set_val(PS4_R3      , 0);
	set_val(PS4_UP      , 0);
	set_val(PS4_DOWN    , 0);
	set_val(PS4_LEFT    , 0);
	set_val(PS4_RIGHT   , 0);
	set_val(PS4_CROSS   , 0);
	set_val(PS4_SQUARE  , 0);
	set_val(PS4_CIRCLE  , 0);
	set_val(PS4_TRIANGLE, 0);
}

function EditAssist () {

    EditT += get_rtime();
        
        if (get_ival(EditAssist)) {
            
            if (EditT >= EditDelay)
                  
           		Press(SELECT);
        }
}

function Press (Button) {

    if (get_ival(Button))
        
   		return;
            
            set_val(Button,100);
}
function set_Val(Input,Output) {

	set_val(Input,clamp(Output * (100 - abs(get_ival(Input))) / 100 + get_ival(Input),-100,100));
    return; 
}

function Set_Val(Input,Output) {
	
	set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
	
	return;
}

function set_Ival(Input,Output) {

      set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
        
      return; 
}
function valuefinder(){
RIGHTOFFSETX = -1
RIGHTOFFSETY = -1
if ( RX > 0 ) {
RIGHTOFFSETX = 1
}
if ( RY > 0 ) {
RIGHTOFFSETY = 1
}
rx = (RX + SHAKEX) * RIGHTOFFSETX
ry = (RY + SHAKEY) * RIGHTOFFSETY
LEFTOFFSETX = -1
LEFTOFFSETY = -1
if ( Strafe > 0 ) {
LEFTOFFSETX = 1
}
if ( Walk > 0 ) {
LEFTOFFSETY = 1
}
lx =  (Strafe + STRAFEX) * LEFTOFFSETX
ly =  (Walk + STRAFEY) * LEFTOFFSETY

}
function Y( axis,  offset_val) {
  set_val(axis, clamp(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));
  return;
}	
function atan(){
	if (anglesx != anglesx){
		anglesx = 0;
			}
	if (anglesy != anglesy){
		anglesy = 0;
			}
	if (anglesx > 89){
		anglesx = 89;
			}
	if (anglesx < -89){
		anglesx = -89;
			}
	if (anglesy > 180){
		anglesy -= 360;
			}
	if (anglesy < -180){
		anglesy += 180;
			}
	return anglesx;
	return anglesy;
	}


int radianval
function tan(tanValue){
  radianval = atan() * (POLAR_RADIUS / 180);
  tanValue = atan ();
  return   ANGLEVAL[(radianval/tanValue)];
  return   POLAR_RADIUSVAL[(radianval/tanValue)];
  return 0;
}
int val;

function sin (x){
   x = atan();
   val = POLAR_RADIUS / 180;
   return   ANGLEVAL[(x * val)];
   return   POLAR_RADIUSVAL[(x * val)];
   return 0;
}

int sign,sum,PI;	
int n;
function PI(){
sign = sign*(-1) 
n = n + 2;
sum = sum +(sign *(4 / ((n) * (n + 1)*(n + 2))))
PI = sum;
   return sum;
   return ANGLEVAL[POLAR_RADIUS];}
function Get3dDistance(){
	return isqrt(pow(get_ival(RY), 2) + pow(get_ival(RX), 2));
}
function Aimbot(){
	TargetList = targetLoop * TargetList;
	targetLoop = 0;
	for( i = 0;
	i < PI();
	i ++){
		if (index == -1 || i < POLAR_RADIUS) {
			index = i;
					}
		continue;
		set()
		gr()
		CalcAngle();
		targetLoop = Get3dDistance();
		targetLoop++;
			}
	if(targetLoop > 0){
				targetLoop = 0;
				TargetList = 0;
							}
					}
			
function CalcAngle(){
	deltax = RX;
	deltay = RY;
	hyp = isqrt(deltax * deltax + deltay * deltay);
if(RAXIS < 45) {
		    anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  0x721804; // / 
		    anglesy = ( deltay * sin(135 + deltax / hyp)) * 57 +  0x721804; 
		} 
		else if(RAXIS <  89) { 
			anglesx = ( deltax/2 * tan(deltax / hyp)) * 57 +  0x721804; // | 
		    anglesy = ( deltay   * sin(deltay / hyp)) * 57 +  0x721804;
		} 
		else if(RAXIS < 135) { 
			anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  0x721804; 
		    anglesy = ( deltay * sin(225 + deltax / hyp)) * 57 +  0x721804; 
		}  
		else if(RAXIS < 180) {
		    anglesx = ( deltax * tan(deltax / hyp))  * 57 +  0x721804;
		    anglesy = ( deltay/2 * sin(deltay / hyp)) * 57 +  0x721804; 
		}
		else if(RAXIS < 225) { 
		    anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  0x721804;  
		    anglesy = ( deltay * sin(135 + deltax / hyp)) * 57 +  0x721804; 
		}  
		else if(RAXIS < 270) { 
		    anglesx = ( deltax/2 * tan(deltax / hyp)) * 57 +  0x721804;
		    anglesy = ( deltay * sin(deltay / hyp))* 57 +  0x721804; 
		}
		else if(RAXIS < 315) { 
		    anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  0x721804; 
		    anglesy = ( deltay * sin(225 + deltax / hyp)) * 57 +  0x721804; 
		}
		else { 
		  	anglesx = ( deltax *   tan(deltax / hyp)) * 57 +  0x721804;
		    anglesy = ( deltay/2 * sin(deltay / hyp)) * 57 +  0x721804; 
		}}
	function gr()
{
power = POLAR_RS;

    if(power >= 0 && power <= 100 )
        power = power;
    else
        power = 100;

}
function LED(a,b,c,d) {
set_led(LED_1,a);
set_led(LED_2,b); 
set_led(LED_3,c); 
set_led(LED_4,d);
} 

function a_f(p,m) { if(abs(get_val(p)) < Moongraal) return m; return get_val(p);} ÃºÂ¸Ë†Â¼Å Â¾â€ Â´â€žÂ°Æ’Â³â€žÂ±ÂÂ²

function set()
{
angle = POLAR_RS;
    if(angle >= 0 && angle <= 359 )
      angle = angle;
    else
       angle = 0;

}
function _DEADZONE (){                               
   if(abs(get_val(LY)) < DZ_L && abs(get_val(LX)) < DZ_L || abs(get_val(LY)) < invDZ_L && abs(get_val(LX)) < invDZ_L){        
        set_val(LY, 0);                                                
        set_val(LX, 0);                                                
}                                
    if(abs(get_val(_RY)) < DZ_R && abs(get_val(_RX)) < DZ_R || abs(get_val(_RY)) < invDZ_R && abs(get_val(_RX)) < invDZ_R){         
        set_val(_RY,0);                                                 
        set_val(_RX,0);                                                
}
}

function _JoyStick_Calibration() {

/*	 This script eliminates stick drift while avoiding a deadzone.
	 Apex Legends, for example, has a setting that allows you to alter your deadzone for smaller, more precise movements with the right stick.
	 That isn't to say that this script is limited to Apex Legends.
	 This script will fix your issue if you discover that you have stick drift in a game and are unable to alter your deadzone.
	 
	 First and foremost, some values in this script must be adjusted.
	 Because no one else's stick drift is the same as yours.
	 Wear on the joysticks can cause stick drift.
	 Keep in mind that if your controller has stick drift due to wear, this script may not be able to remove all of it.
	 
	 If you replaced the joystick modules on your controller, this script will completely solve your stick drift.
	 When you solder on a new joystick, you'll see that it has stick drift because the controllers are calibrated in the factory.
	
	 This script was written to eliminate stick drift on my Xbox Elite V1 controller, which is equipped with brand new Kailh JP1311 joysticks. 
	 
	 How do I get these values to put into the script?
	 In your Cronus software you have a tool called Device Monitor
	 With that tool you can read all values that your controller is sending to your Cronus Device
	 
	 For example, if you pull your right stick all the way to the right you see a value +96
	 And if you pull your right stick all the way up you see a value -98
	 Now we know the value of RX_Plus that is 96
	 You need to fill in the list like this 
	 int RX_dk_max=  96;
	 int RX_dk_min= -98;
	 
	 If the controller value is +100 or -100 just fill in 100 to cancel any correction */
/////////////////////////////////////////////////////////////////////////////////////////////////	 

	
  do { o[i] = get_val(9 + i);
  } while (i = (i + 1) % 4);
  
  do {
    ValInY[i] = get_oval(STICK_Y[i]);
    ValInX[i] = get_oval(STICK_X[i]); 
    if (isqrt(pow(get_val(STICK_X[i]), 2) + pow(get_val(STICK_Y[i]), 2)) <  StickDZ[i]) {
      if (ValInY[i] != ValPrevY[i] || ValInX[i] != ValPrevX[i]) {
        ValPrevX[i] = ValInX[i];
        ValPrevY[i] = ValInY[i];
        XY[i]  = 100;
      }
      if (XY[i]) {
        XY[i] -= get_rtime();
        if (XY[i] <= 0) {
          OffsetX[i] = inv(ValInX[i]);
          OffsetY[i] = inv(ValInY[i]);
          offset(STICK_X[i], OffsetX[i]);
          offset(STICK_Y[i], OffsetY[i]);
          ValOutX[i] = inv(get_val(STICK_X[i]));
          ValOutY[i] = inv(get_val(STICK_Y[i]));
        }
      }
    }
    offset(STICK_X[i], OffsetX[i] + ValOutX[i]);
    offset(STICK_Y[i], OffsetY[i] + ValOutY[i]);
  } while(i = (i + 1) % 2);
  
  do {
    temp = (i / 2) + PS4_RX;
    i_val = get_val(temp);
    
     if(i_val >= RX_dk_max[i]) set_val(temp, 100);
     if(i_val <= RX_dk_max[i + 1]) set_val(temp, -100);
  
  }while((i + 2) % 8 == i );
}
int StickDZ[2],
	STICK_X[2],
	STICK_Y[2],
	OffsetX[2],
	OffsetY[2],
	ValOutX[2], 
	ValOutY[2],
	ValPrevX[2],
	ValPrevY[2],
	XY[2],
	ValInY[2],
	ValInX[2],
	o[4],
	I;

init {
  STICK_X = 9;  STICK_X[1] = 11; 
  STICK_Y = 10; STICK_Y[1] = 12; 
  StickDZ = dk_max(abs(get_val(9)), abs(get_val(10))) + 5;
  StickDZ[1]  = dk_max(abs(get_val(11)), abs(get_val(12))) + 5;
}
// Joystick outer edge adjustment
int RX_dk_max=  100;
int RX_dk_min= -100;
int RY_dk_max=  100;
int RY_dk_min= -100;
int LX_dk_max=  100;
int LX_dk_min= -100;
int LY_dk_max=  100;
int LY_dk_min= -100;

int temp, i_val;

function dk_min(a, b) { if(a<=b) return a; return b; }
function dk_max(a, b) { if(a>=b) return a; return b; }
function dk_clamp(v, lo, hi) { return dk_min(hi, dk_max(v, lo)); }
function get_oval(io) { return o[io- 9]; }
function offset(axis, offset_val) { 
  set_val(axis, dk_clamp(offset_val * (100 - abs(get_oval(axis))) / 100 + get_oval(axis), -100, 100));
  if(abs(get_val(axis)) < _Rv ) set_val(axis, 0); 
  return;
}
const int8 POLAR_RADIUSVAL[] = { 100,-100,-99,-98,-97,-96,-95,-94,-93,-91,-90,-89,-88,-87,-86,-85,-84,-82,-81,-80,-79,-78,-77,-76,-75,-73,-72,-71,-70,-69,-68,-67,-66,-64,-63,-62,-61,-60,-59,-58,-57,-55,-54,-53,-52,-51,-50,-49,-48,-46,-45,-44,-43,-42,-41,-40,-39,-37,-36,-35,-34,-33,-32,-31,-30,-28,-27,-26,-25,-24,-23,-22,-21,-19,-18,-17,-16,-15,-14,-13,-12,-10,-9,-8,-7,-6,-5,-4,-3,-11,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,55,56,57,58,59,60,61,62,64,65,66,67,68,69,70,71,73,74,75,76,77,78,79,80,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98,100,100,100,99,98,97,96,95,94,93,91,90,89,88,87,86,85,84,82,81,80,79,78,77,76,75,73,72,71,70,69,68,67,66,64,63,62,61,60,59,58,57,55,54,53,52,51,50,49,48,46,45,44,43,42,41,40,39,37,36,35,34,33,32,31,30,28,27,26,25,24,23,22,21,19,18,17,16,15,14,13,12,10,9,8,7,6,5,4,3,1,-1,-1,-2,-3,-4,-5,-6,-7,-8,-10,-11,-12,-13,-14,-15,-16,-17,-19,-20,-21,-22,-23,-24,-25,-26,-28,-29,-30,-31,-32,-33,-34,-35,-37,-38,-39,-40,-41,-42,-43,-44,-46,-47,-48,-49,-50,-51,-52,-53,-55,-56,-57,-58,-59,-60,-61,-62,-64,-65,-66,-67,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-82,-83,-84,-85,-86,-87,-88,-89,-91,-92,-93,-94,-95,-96,-97,-98,-100};   
const int8 ANGLEVAL[] = { -100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100};
const char Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; ú¹ˆ¾†·ƒ´‚´†¿‰½‹³