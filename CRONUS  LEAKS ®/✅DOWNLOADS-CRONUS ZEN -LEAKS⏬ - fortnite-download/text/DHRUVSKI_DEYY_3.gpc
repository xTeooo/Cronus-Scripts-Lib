// Deyy Script Madde By Sujay (EDITED BY DHRUVSKI) ....... 

//Binds
// ðŸ…¼ðŸ…°ðŸ†ƒðŸ…²ðŸ…· ðŸ…¸ðŸ…½ ðŸ…¶ðŸ…°ðŸ…¼ðŸ…´ ðŸ…±ðŸ†„ðŸ†ƒðŸ†ƒðŸ…¾ðŸ…½ðŸ†‚
// ðŸ…²ðŸ…¾ðŸ…¼ðŸ…±ðŸ…°ðŸ†ƒ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define ADS     		= PS4_L2;		//in-game ADS BUTTON
define FIRE     	= PS4_R2;		//in-game FIRE BUTTON
define NEXT_WEAPON 	= PS4_R1;		//in-game NEXT_WEAPON BUTTON
define PREV_WEAPON 	= PS4_L1;		//in-game PREV_WEAPON BUTTON
define PICKAXE 		= PS4_L3; //in-game PICKAXE BUTTON
define JUMP     	= PS4_CROSS;	//in-game JUMP BUTTON
define CROUCH   	= PS4_R3;		//in-game CROUCH BUTTON
define INTERACT 	= PS4_SQUARE;	//in-game INTERACT BUTTON
define MAPVIEW_B	= PS4_TOUCH;    //in-game MAP BUTTON
define INVENTORY    = PS4_UP;      // in-game INVENTORY BUTTON

// ðŸ…±ðŸ†„ðŸ…¸ðŸ…»ðŸ…³ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define BUILD     	= PS4_CIRCLE;	//in-game BUILD BUTTON
define STAIRS  		= PS4_L2;		//in-game STAIRS BUTTON
define WALL    	 	= PS4_R2;		//in-game WALL BUTTON
define FLOOR  		= PS4_R1;		//in-game FLOOR BUTTON
define ROOF   		= PS4_L1;		//in-game ROOF BUTTON
define TRAP         = PS4_SQUARE;   //in-game TRAP BUTTON
// ðŸ…´ðŸ…³ðŸ…¸ðŸ†ƒ ðŸ…¼ðŸ…¾ðŸ…³ðŸ…´
define EDIT 		= PS4_TRIANGLE;	//in-game EDIT BUTTON
define SELECT 		= PS4_R2; 		//in-game SELECT BUTTON
define CONFIRM 		= PS4_L2;	//in-game CONFIRM BUTTON
define RESET 		= PS4_L1;	//in-game RESET BUTTON
define On  = TRUE;
define Off = FALSE;

// ðŸ…¼ðŸ…¾ðŸ†…ðŸ…´ðŸ…¼ðŸ…´ðŸ…½ðŸ†ƒ & ðŸ…°ðŸ…¸ðŸ…¼ ðŸ†‚ðŸ†ƒðŸ…¸ðŸ…²ðŸ…ºðŸ†‚

define AimY     = XB1_RY;  // Vertical Aim Axis In Game
define AimX     = XB1_RX;  // Horizontal Aim Axis In Game
define Strafe   = XB1_LX;  // Horizontal Walk Axis In Game
define Walk     = XB1_LY;  // Vertical Walk Axis In Game
define PS       = POLAR_RS;// Polar Stick In Use [LS/RS]


// DUSTEEEEEEEEE AA //
define DUSTE   =   TRUE;
define PXS     =   3150;  				    	
define PXSE    =    200;				    
define PVSI    =     200;    				
define PVS     =      0;
define PYS     =   -200;				
define PYSE    =    200;		    	
int    PPFX    =    PXS;
int    PPFY    =    PYS;				  	  
int    PVID;
int    PFD     =      1;		    
int    PPFD    =      1;
int    RX;
int    RY;

// BrUcE TiMeD AiM AsSiSt
int DoGzTimeZ = TRUE;      // DoGz TimeZ Aim Assist
int Power = 1;            // [1 - 10] =  DoGz TimeZ Aim Assist Power [1,2,3,4,5] ==> (>> 1 = 5 , 2 = 10 , 3 = 15 , 4 = 20 , 5 = 25 etc  <<) [LINEAR USE VALUE 1]
int AATime = 2000;        // [1000 - 5000] =  DoGz TimeZ Aim Assist Will Cut Out After Time [1000] = 1 Second, [2000] = 2 Second
int AATimed = TRUE;        // [(On) or (Off)] = Aim Assist Will Cut Out After 2 seconds By Default (Change Below)
int AimAssistHip = TRUE;    // [(On) or (Off)] = {Operates on [Ads Alone (Off)] Or [Ads or Fire Alone (On)]}

// Batts STICKY AA // 
define BattsStickyAA = FALSE;
define BattsAAHip    = TRUE;
define BattStickyPower = 9;// ads value 
define BattStickyWait  = 9;// ads value 

// NIKO AIM // 
define SS_Nikolai_Aim = TRUE;
define AimAssistWaitTime = 9;// ads value 
define AimAssistStrength = 9;// ads value 

//Aim Assist Linear - Semjases V2
int AimAssist_LINEAR  = TRUE; 
int Strength  = 17; //Examples 13-4, 17-5, 20-5, 10-3
int Increment = 5; 

//Aim Assist Stick Linear - Umbrella V2 
define AimStickLinear  = TRUE; // Help with aiming moving the jyostick linear
define Ads_Assist      = TRUE; // Aim Assist Ads only 
define Fire_Assist     = TRUE; // Aim Assist Fire only
define RADIUS          = 4;    // Radius/strength/value
define STEPS           = 30;   // Step/speed
define STEP_INTERVAL   = 1;    // time

// AIM ASSIST EXPLOIT LINEAR V4
int Aim_Exploit_Linear  = On; // [(On) or (Off)] = {Aim Assist Linear Toggle On/Off By Default}
int Strength_Linear     = 170;// AIM ASSIST STRENGTH LINEAR 
int Wait_Linear         = 100;// AIM ASSIST STRENGTH LINEAR
int AimBoost            = Off; // AIM BOOST STICK RX/RY
int ExploitRadiusBoost  = 6;  // STRENGTH BOOST
int ExploitAngleBoost   = 10; // ANGLE BOOSR
int AimAAHip            = On; // [(On) or (Off)] = Operate on Fire Only [If FALSE It Will Only Run On ADS & FIRE]

// Progression Head Shot Assist
define HeadAssist    = FALSE // Main Toggle ON/OFF
define HeadHipAssist = TRUE;  // Operate on Fire Only [If Off It Will Only Run On ADS & FIRE]

define HeadStep = 3;  // Step Increment Increasing Until Its Reached HeadMax
define HeadMax  = 30; // Max Head Assist Value

// FIRE ASSIST EXPLOIT
int Assist_Fire_Exploit  = Off; // [(On) or (Off)] = {Fire Assist Exploit Toggle On/Off By Default}
int Fire_Assist_Strength = 120; // FIRE ASSIST STRENGTH

//HEAD SHOT ASSIST 2.0
int HEADSHOT = Off;
define HeadShotStrength = 5;
define HeadShotHoldTime = 1300;

int DhruvTrackerV2 = TRUE;
//                                        FOLLOW THIS!!!!!
int CANCERous = FALSE; //27               keep this as is
int KoolKene = FALSE;  //7                keep this as is
int DeVv = FALSE;  // 8                   keep this as is
int Dhruvski = FALSE; // 4                keep this as is
int YeWsHit = 9;  //5                    deadzone
int EmoLucid = 7; //6                     [ keep this as is ]
int Gru = 9; //18                        {right stick deadzone}
int Bob = -9; //19                       {right stick deadzone}
int Kevin = 9; //20                      {right stick deadzone}
int Stewart = -09; //21                   {right stick deadzone} 
int ScarletSpiderMan = 19; //22           [ keep this as is ]
int mxmdul = 9; //28                     {right stick deadzone}
int Moongraal = 9; //23                  {deadzone}


// Lemon ãƒ„ AA
int LemonStickyAA   =  TRUE;
int LemonAARX     = 9; // right stick deadzone
int LemonAARY     = 9; // right stick deadzone
int LemonAAWait   = 10;
int LemonRel = 10;

//Deadzone optimizer
int DEADZONE	= On;
define DZ_L 	= 9; //left stick deadzone
define invDZ_L 	= -9;//left stick deadzone

define DZ_R 	= 9;//right stick deadzone
define invDZ_R 	= -9;//right stick deadzone

// RIGHT STICK DEADZONE OPTIMIZER
int JoyStick_Calibration = Off; //OPTIMIZED Deadzone for RIGHT STICK
define _Rv = 10; //right stick deadzone

// 100% ACCURACY EXPLOIT (1 BUTTON)
int Accuracy_Exploit   = FALSE;  // [(On) or (Off)] = {Accuracy 100% 1 Button Toggle On/Off By Default} ON = WHEN YOU  PRESS YOUR FIRE BUTTON YOU WILL GET LONG RANGE AA
int Spam_Accuracy      = 20; // VALUE OF HOW LONG WE WANT YOU TO HOLD THE AIM BUTTON WHEN WE SHOOT.

// Instant Edit + Reset 
define InstaEditReset = FALSE; 	// [ON / OFF] Normal Instant Edit/Reset
define EditHold       = FALSE; 	// [ON / OFF] SET On WHEN USING EDIT HOLD TIME TO EDIT ( MATCH TO IN GAME SETUP ) [Off = INSTANT PRESS]
define EditHoldTime   = 100;  	// Time If Using Hold to Edit In game [Setting To Be Matched To In Game Time]


// Fast Reset (One Button)
define InstaFastReset = FALSE;        // Fast Reset [ON / OFF]
define FastReset      = PS4_L2; // FAST RESET BUTTON 


// Quick Edit Assist
define QuickEditAssist = FALSE;   	 // [ON / OFF] Edit Assist
define EditDelay       = 20;     // Edit Assist Hold Delay On Select
define EditAssist      = PS4_RIGHT; // EDIT ASSIST + FAST RESET EDIT BUTTON (Edit In Game [ NO HOLD TIME!!! ])

//Build Tracker
int BuildTracker  =  TRUE;
int BuildSyncTime = 4000; 
  
//Block Rumble
int BlockRumble     =  FALSE;


// Playstation On PC/Xbox
define PlayStationOnXbox = TRUE; // [ON / OFF] DS4/5 On PC/Xbox [Touchpad Button Fix]
// Hair Triggers
define HairTriggers = TRUE; // Instant Triggers [100%]


//Input Delay Reducer
int DelayBuster = -5;					// LEAVE AS (-5) FOR NORMAL; (-9) for 1ms Delay



// DONT TOUCH AT ALL

int Edit1,Edit2,EditT,Shunt,BuildTrack,BuildCount;
int power,Ypower,Xpower,CountPower,AxisXY;int AxisT,AAT;
int display_title = TRUE;int goCOMBAT;int WaitStrength, AimStrength;
int display_black;int MAPVIEW,MAPtap,P_MAP,C_MAP;int EditSensitivity =  Off;      
int count_black; int EditAst, EDIThold; int Head;define AdsFireTrigger = 0,
AnyFireTrigger = 1,FireOnlyTrigger = 2;int TimeValue,OutPut,RumValue,RecoilTimer,
BoostAR,AxisCY,AxisLY;define Btn2Press = 1,Btn1Hold_Btn2Press = 2,Btn2Hold = 3,
Btn1Hold_Btn2Hold = 4;int actual_X, actual_Y, actual_Magnitude, max_Magnitude,
time,angle, cos_angle, sin_angle;int _RX,_RY;define StandardAHip =  On;
int ExploAngle,ExploCos,ExploSin,ExploX,ExploY,ActualMagnitude,MaxMagnitude,
RadiusExploit,AngleExploit,AdaptAbuse;

//Main
main {

vm_tctrl(DelayBuster);
block_rumble();
	if (PlayStationOnXbox && get_console() == PIO_XB360 && get_controller() == PIO_PS4) { 
	
		swap(PS4_TOUCH,PS4_SHARE);
	}
	if (HairTriggers) { 
   		
   		deadzone(PS4_L2,PS4_R2,100,100);
   	}
	if(EditAssist){
		
		if(get_ival(EDIT) && get_ptime(EDIT) > 10){
			
			EditAssist();
			EditAst = On;
		}

		if(event_release(EDIT)){	
			
			EDIThold = 0;	
			EditAst = Off;
		}
		
		
	}
	if (InstaFastReset && !get_ival(ADS) && event_press(FastReset)) { 
       
      
        
        	Shunt = FastReset;
        	combo_run(FastReset);
    }
    if (InstaEditReset) {
        if (EditHold && get_ival(EDIT) && get_ptime(EDIT) > EditHoldTime || !EditHold && event_press(EDIT)) {
                Edit1 = On;
                Edit2 = On;
                BuildTrack = On;
        
        }

        if (Edit2) {
            if (event_release(SELECT)) {  
                Edit1 = Off;
                Edit2 = Off;
                BuildTrack = Off;
    		}

        }
    }
     if (Edit1 || Edit2) {
        if (EditSensitivity) {    
          
        }

            if (event_press(RESET)) {  
                combo_run (InstantReset);
                Edit1 = Off;
                Edit2 = Off; 
            }

                if (event_press(PICKAXE) || event_press(BUILD) || event_press(ADS)) {
                    Edit1 = Off;
                    Edit2 = Off;
                    BuildTrack = Off;
                }
    }
  
	if (BuildTracker) {
        
        if (event_press(BUILD)) {
            BuildTrack = !BuildTrack;
            
        }
    
        if (BuildTrack) {
            BuildCount += get_rtime();
            
            if (event_press(PICKAXE) || BuildCount == BuildSyncTime) {
                BuildTrack = Off;
                BuildCount = Off;
            }
            
                if (get_ival(ROOF) || get_ival(FLOOR) || get_ival(STAIRS) || get_ival(WALL)) 
                    BuildCount = Off;
        }
    }
    if(!BuildTrack && get_val(ADS) && get_val(FIRE)){
     if (DoGzTimeZ) {
	        	
	        	if (AATimed) {
	        	
	        		if (get_ival(ADS) && get_ptime(ADS) <= AATime || AimAssistHip && get_ival(FIRE) && get_ptime(FIRE) <= AATime) {
	            	
	            		DoGzTimeZ();
	            	}
	            	
	            } else if (get_ival(ADS)|| AimAssistHip && get_ival(FIRE)) {
	            	
	            		DoGzTimeZ();
	            }
	            
	            if (!get_ival(ADS) && !get_ival(FIRE)) {
	            
	            	AAT = 0;
	            	AxisT = 0;
	            }
	        }
	     if (Assist_Fire_Exploit) {

        if (get_ival(FIRE) && !get_ival(ADS)) {

            if (abs(get_ival(Strafe)) <= 40 && abs(get_ival(Walk)) <= 35) {

                combo_run(FireAssist);
            
            } else {

                combo_stop(FireAssist);
        }
    }    
	        
   	 if (BattsStickyAA) {
if (get_ival(ADS) || (BattsAAHip && get_ival(FIRE))) {
combo_run(BattsStickyAssist);
} else {
combo_stop(BattsStickyAssist); 
}
}
if (SS_Nikolai_Aim)
		{
			if(get_ival(ADS) || get_ival(FIRE))
			{
				combo_run(cNikoAim);
			}

			if(event_release(ADS) || event_release(FIRE))
			{
				combo_stop(cNikoAim)
			}
		}
		 if (Aim_Exploit_Linear) {

        if (get_ival(ADS)) {

            combo_run(Aim_Linear);
    }
}

 if (LemonStickyAA){        
        
            if ((get_ival(ADS)) || (get_ival(FIRE) && StandardAHip)) {
                if (abs(get_ival(AimX)) <= LemonRel && abs(get_ival(AimY)) <= LemonRel) {
                
                    combo_run(LemonSticky);
                }
            }
                    else {
                        combo_stop(LemonSticky);
                    }
        }


 if (Aim_Exploit_Linear) {
    
        if (get_ival(ADS) || (AimAAHip && get_ival(FIRE))) {
        
            ExploX = get_ival(PS4_LX);   
            ExploY = get_ival(PS4_LY);           
            ActualMagnitude = isqrt(pow(ExploX,2) + pow(ExploY,2));  
            MaxMagnitude = (ActualMagnitude < 100);                      
        
            if (AimBoost && get_ival(FIRE)) {
                    
                RadiusExploit = Strength_Linear + ExploitRadiusBoost;
                AngleExploit = ExploitAngleBoost;
                
            } else {
                    
                RadiusExploit = Strength_Linear;
                AngleExploit = 0;
            }
            
            ExploAngle += Wait_Linear + AngleExploit;                                                 
            ExploAngle = ExploAngle % 360;                                            
            ExploSin = ExploitPolar[ExploAngle % 360];                           
            ExploCos = ExploitPolar[(ExploAngle + 270) % 360];                  
            ExploCos = (ExploCos * RadiusExploit) / 100;                         
            ExploSin = (ExploSin * RadiusExploit) / 100;                          
        
            if (ActualMagnitude <= 10) {                                                      
                
                ExploSin -= ExploY;                                                              
                ExploCos -= ExploX;                                                                 
            
            } else {                                                                                       
                    
                ExploSin = (ExploSin * (200 - ((abs(ExploY) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude; 
                ExploCos = (ExploCos * (200 - ((abs(ExploX) + ActualMagnitude) / 10) * 10) / 200) * MaxMagnitude; 
            }                                                  
            
            set_val(PS4_LX,clamp(ExploX + ExploCos, -100,100));
            set_val(PS4_LY,clamp(ExploY + ExploSin, -100,100)); 
    }
} 

        
     if (AimAssist_LINEAR) {
	 
	    if (event_press(ADS)) { 
	    	
	    	Power = On;
}
	    
	    else if (!get_ival(ADS) && event_press(FIRE)) {
	    	
	    	Power = On;
}
	    
	    if (get_ival(ADS) || get_ival(FIRE)) {
	    	
	    	AxisXY = isqrt(abs(get_ival(PS4_RX)) * abs(get_ival(PS4_RX)) + abs(get_ival(PS4_RY)) * abs(get_ival(PS4_RY)));
	    	
	    	if (AssistProfile == 1)
	    		
	    		AimAssist(Strength,Increment);
	    		
         } else {
	    	
	    	CountPower = 0;
	    	power = Off;
        }
}
    
    if (HeadAssist) {
	        
	        if (get_ival(ADS) && get_ival(FIRE) || HeadHipAssist && get_ival(FIRE)) {
	        
	        	if (abs(get_ival(PS4_RY)) < HeadMax) { 
	        		
	        		Head += HeadStep;
	        		combo_run(HeadAssist);
	        	}	
	        }
	        
	        if (!get_ival(FIRE)) Head = 0;
	        	
	        if (Head >= HeadMax) combo_stop(HeadAssist);
	    }
	    if(HEADSHOT){
	   
		_RY = inv(HeadShotStrength);

		if(get_ival(FIRE) && get_ptime(FIRE) < HeadShotHoldTime){
			
			Set_Val(AimY, _RY);	
			}
	}
	    
	    if (DUSTE) {
            RX = PS4_RX;
			RY = PS4_RY;
			RX =   PPFX;
			RY =   PPFY;
    	if(get_val(PS4_L2) > 80){
    	if(abs(get_val(XB1_RX) < 10)) 
    	if(abs(get_val(XB1_RY) < 10)) 
    	if(abs(get_val(XB1_RX) > -10)) 
    	if(abs(get_val(XB1_RY) > -10)){
   			PPFX = PolarFlow(PPFX,PXS,PXSE,PVSI,PFD,1);
        	PPFY = PolarFlow(PPFY,PYS,PYSE,PVS,PPFD,2);
       	    set_polar(POLAR_RS,30,PPFX);
    		set_polar(POLAR_RS,30,PPFY);}
}
}
if(DhruvTrackerV2) { 
CANCERous=!CANCERous; 
KoolKene=!KoolKene;
DeVv=!DeVv; 
Dhruvski=!Dhruvski;
if((CANCERous) && (KoolKene) && (DeVv)&& (Dhruvski)) { combo_run(Flash_ON); } 
else combo_run(Flash_OFF); } 
if (Dhruvski){ 
if (get_val(XB1_LT)){ 
combo_run(M37); } 
if ((get_val(XB1_RX)) > YeWsHit || (get_val(XB1_RX)) < YeWsHit*(-1)){ 
combo_stop(M37); } } 

if (KoolKene) { 
if(get_val(XB1_LT)){combo_run(C40);}
if(DeVv){ if(get_val(XB1_RT)) combo_run(K41);}} 

if (CANCERous) { 
if (get_val(XB1_LT)> 95){ combo_run(H46);} if (abs(get_val(XB1_RX)) > 21 || abs(get_val(XB1_RY)) > 21) combo_stop(H46); }

if (Accuracy_Exploit) {

        if (event_press(FIRE)) {

            combo_run(Accuracy100);
    }
}


}
     if (Shunt) {
        
        if (event_release(Shunt)) {
            Shunt = Off;
        }
            else {
            set_val (Shunt,Off);
         }
     }
   }
   }
 
//Combos 
combo BattsStickyAssist {
 set_val(AimY,AxisRelease(AimY,BattStickyPower));
   wait(BattStickyWait);
   set_val(AimX,AxisRelease(AimX,BattStickyPower));
   set_val(Strafe,AxisRelease(Strafe,BattStickyPower));
   wait(BattStickyWait);
   set_val(AimY,AxisRelease(AimY,inv(BattStickyPower)));
   wait(BattStickyWait);
   set_val(AimX,AxisRelease(AimX,inv(BattStickyPower)));
   set_val(Strafe,AxisRelease(Strafe,inv(BattStickyPower)));
   wait(BattStickyWait);
}
combo FireAssist {

    set_val(Strafe,-100);
    wait(Fire_Assist_Strength);
    set_val(Strafe,100);
    wait(Fire_Assist_Strength);
}
combo Accuracy100 {

    set_val(ADS,100);
    wait(Spam_Accuracy);
}
combo Rapid_Fire {
    
    set_val(Fire,100); 
    wait(Hold);        
    set_val(Fire,0);   
    wait(Release);    
}
combo cNikoAim {
	WaitStrength	= random(AimAssistWaitTime / 2 , AimAssistWaitTime);
	AimStrength		= random(inv(AimAssistStrength), AimAssistStrength);

	Set_Val(AimY,	AimStrength);
	wait(WaitStrength);
	Set_Val(AimX,	AimStrength);
	wait(WaitStrength);
	Set_Val(AimY,	inv(AimStrength));
	wait(WaitStrength);
	Set_Val(AimX,	inv(AimStrength));
	wait(WaitStrength);
}
combo LemonSticky {
    
    Set_Val(AimY,LemonAARY);
    wait(LemonAAWait);
    Set_Val(AimX,LemonAARX);
    
    if (abs(get_ival(Strafe)) < 20)
        Set_Val(Strafe,LemonAARX);
        wait(LemonAAWait);
        Set_Val(AimY,LemonAARY * -1);
        wait(LemonAAWait);
        Set_Val(AimY,LemonAARX * -1);
        
        if (abs(get_ival(Strafe)) < 20)
            Set_Val(Strafe,LemonAARX * -1);
            wait(LemonAAWait);
}
combo HeadAssist{

	set_val(AimY,inv(Head) + get_val(AimY));
}
combo Aim_Linear {

    set_val(Strafe,inv(Strength_Linear));
    wait(Wait_Linear);
    set_val(Strafe,Strength_Linear);
    wait(Wait_Linear);
}
combo Confirm {

    set_val(CONFIRM,100);
    wait(50);
    set_val(CONFIRM,0);
    wait(100);
}

combo FastReset {

    set_val(EditAssist,100);
    wait(50)
    set_val(RESET,100);        
    wait(50);
    combo_run(Confirm);
}

combo InstantReset {

    wait(10)
    combo_run(Confirm);
}

combo AimExpo{          
     
     set_val(10, (AimAssist_Strength)); wait(10)
     set_val(9, (AimAssist_Strength)); wait(10)
     set_val(10, AimAssist_Strength * -1); wait(10)
     set_val(9, AimAssist_Strength * -1); wait(10)
}
combo M37 { 
wait(XB1_RT) 
set_val(XB1_RX, YeWsHit);
wait(EmoLucid);
set_val(XB1_RX, YeWsHit*(-1)); 
wait(EmoLucid);
}

combo K41 { 
set_val(XB1_RY,a_f(XB1_RY,Kevin));
wait(ScarletSpiderMan) 
set_val(XB1_RX,a_f(XB1_RX,Kevin)); 
wait(ScarletSpiderMan) 
set_val(XB1_RY,a_f(XB1_RY,Stewart)); 
wait(ScarletSpiderMan) 
set_val(XB1_RX,a_f(XB1_RX,Stewart)); 
wait(ScarletSpiderMan)
} 

combo C40 { 
set_val(XB1_RY,a_f(XB1_RY,Gru)); 
wait(ScarletSpiderMan) 
set_val(XB1_RX,a_f(XB1_RX,Gru)); 
wait(ScarletSpiderMan)
set_val(XB1_RY,a_f(XB1_RY,Bob)); 
wait(ScarletSpiderMan) 
set_val(XB1_RX,a_f(XB1_RX,Bob)); 
wait(ScarletSpiderMan)
}

combo H46 { 
set_val(XB1_RY, mxmdul * -1); 
wait(10) 
set_val(XB1_RX, mxmdul);
wait(10) 
set_val(XB1_RY, mxmdul);
wait(10) 
set_val(XB1_RX, mxmdul * -1); 
wait(10) }

combo Flash_ON { 
LED(0,0,2,0); 
wait(400);
reset_leds();} 
combo Flash_OFF { 
LED(0,2,0,0);  
wait(200);  
LED(0,0,0,0); 
wait(100);  
LED(0,2,0,0);
wait(200); 
reset_leds();} 

function LED(a,b,c,d) {
set_led(LED_1,a);
set_led(LED_2,b); 
set_led(LED_3,c); 
set_led(LED_4,d);
} 
//Functions
function a_f(p,m) { if(abs(get_val(p)) < Moongraal) return m; return get_val(p);} ÃºÂ¸Ë†Â¼Å Â¾â€ Â´â€žÂ°Æ’Â³â€žÂ±ÂÂ²

int AssistProfile = 1; 
function AimAssist (Strength,Step) {

	if (Power) {
		
		Ypower = Strength;
		Xpower = Strength * -1;
		Increment = Step;
		Power = Off;
	}
	
	if (!power) {
	
		Xpower += Increment;
		Ypower -= Increment;
	
	} else {
		
		Xpower -= Increment;
		Ypower += Increment;
	}
	
	CountPower ++;
	
	if (CountPower >= (Strength / Increment)) {
		
		power = !power;
		CountPower = 0;
	}	
	
	if (AxisXY > 10) {
		
}
}
function DoGzTimeZ() {

	AAT += get_rtime();
	
	if (!AxisT) 
		
		set_Ival(AimY,AAT * Power / 10);
		
	if (AxisT == 1)  
		
		set_Ival(AimX,AAT * Power / 10);
	
	if (AxisT == 2)  
		
		set_Ival(AimY,inv(AAT * Power / 10));

	if (AxisT == 3) {
		
		set_Ival(AimX,inv(AAT * Power / 10));
	
		if (AAT > 50) {
		
			AAT = 0;
			AxisT = 0;
		}
	
	} else if (AAT > 50) {
		
		AAT = 0;
		AxisT += 1;
	}
}
function AxisRelease(AxisXY,AxisVal) {
    
    if (abs(get_ival(AxisXY)) <= BattStickyPower) 
        
        return AxisVal;
    
    return get_ival(AxisXY); 
}
function PolarFlow(PFB,PSV,PFV,PV,PF,PID) {
    	if(PF) {
       		PFB += PV;
    	if(PFB <= PFV)  
    	return PFB;
    	if(PFB > PFV) {
        	PVID[PID] = 0;
    	return PFB - PV;}
}
		else{
        	PFB -= PV;    
    	if(PFB >= PSV)  
    	return PFB;
    	if(PFB < PSV) {
    		PVID[PID] = 1; 
        return PFB + PV;}
} 
       {return FALSE;
}
   		
 	   
}

function block_all_outputs() {
	set_val(PS4_L2      , 0);
	set_val(PS4_R2      , 0);
	set_val(PS4_L1      , 0);
	set_val(PS4_R1      , 0);
	set_val(PS4_L3      , 0);
	set_val(PS4_R3      , 0);
	set_val(PS4_UP      , 0);
	set_val(PS4_DOWN    , 0);
	set_val(PS4_LEFT    , 0);
	set_val(PS4_RIGHT   , 0);
	set_val(PS4_CROSS   , 0);
	set_val(PS4_SQUARE  , 0);
	set_val(PS4_CIRCLE  , 0);
	set_val(PS4_TRIANGLE, 0);
}

function EditAssist () {

    EditT += get_rtime();
        
        if (get_ival(EditAssist)) {
            
            if (EditT >= EditDelay)
                  
           		Press(SELECT);
        }
}

function Press (Button) {

    if (get_ival(Button))
        
   		return;
            
            set_val(Button,100);
}
function set_Val(Input,Output) {

	set_val(Input,clamp(Output * (100 - abs(get_ival(Input))) / 100 + get_ival(Input),-100,100));
    return; 
}

function Set_Val(Input,Output) {
	
	set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
	
	return;
}

function set_Ival(Input,Output) {

      set_val(Input,clamp(Output * (100 - abs(get_val(Input))) / 100 + get_val(Input),-100,100));
        
      return; 
}

function _DEADZONE (){                               
   if(abs(get_val(LY)) < DZ_L && abs(get_val(LX)) < DZ_L || abs(get_val(LY)) < invDZ_L && abs(get_val(LX)) < invDZ_L){        
        set_val(LY, 0);                                                
        set_val(LX, 0);                                                
}                                
    if(abs(get_val(_RY)) < DZ_R && abs(get_val(_RX)) < DZ_R || abs(get_val(_RY)) < invDZ_R && abs(get_val(_RX)) < invDZ_R){         
        set_val(_RY,0);                                                 
        set_val(_RX,0);                                                
}
}

function _JoyStick_Calibration() {

/*	 This script eliminates stick drift while avoiding a deadzone.
	 Apex Legends, for example, has a setting that allows you to alter your deadzone for smaller, more precise movements with the right stick.
	 That isn't to say that this script is limited to Apex Legends.
	 This script will fix your issue if you discover that you have stick drift in a game and are unable to alter your deadzone.
	 
	 First and foremost, some values in this script must be adjusted.
	 Because no one else's stick drift is the same as yours.
	 Wear on the joysticks can cause stick drift.
	 Keep in mind that if your controller has stick drift due to wear, this script may not be able to remove all of it.
	 
	 If you replaced the joystick modules on your controller, this script will completely solve your stick drift.
	 When you solder on a new joystick, you'll see that it has stick drift because the controllers are calibrated in the factory.
	
	 This script was written to eliminate stick drift on my Xbox Elite V1 controller, which is equipped with brand new Kailh JP1311 joysticks. 
	 
	 How do I get these values to put into the script?
	 In your Cronus software you have a tool called Device Monitor
	 With that tool you can read all values that your controller is sending to your Cronus Device
	 
	 For example, if you pull your right stick all the way to the right you see a value +96
	 And if you pull your right stick all the way up you see a value -98
	 Now we know the value of RX_Plus that is 96
	 You need to fill in the list like this 
	 int RX_dk_max=  96;
	 int RX_dk_min= -98;
	 
	 If the controller value is +100 or -100 just fill in 100 to cancel any correction */
/////////////////////////////////////////////////////////////////////////////////////////////////	 

	
  do { o[i] = get_val(9 + i);
  } while (i = (i + 1) % 4);
  
  do {
    ValInY[i] = get_oval(STICK_Y[i]);
    ValInX[i] = get_oval(STICK_X[i]); 
    if (isqrt(pow(get_val(STICK_X[i]), 2) + pow(get_val(STICK_Y[i]), 2)) <  StickDZ[i]) {
      if (ValInY[i] != ValPrevY[i] || ValInX[i] != ValPrevX[i]) {
        ValPrevX[i] = ValInX[i];
        ValPrevY[i] = ValInY[i];
        XY[i]  = 100;
      }
      if (XY[i]) {
        XY[i] -= get_rtime();
        if (XY[i] <= 0) {
          OffsetX[i] = inv(ValInX[i]);
          OffsetY[i] = inv(ValInY[i]);
          offset(STICK_X[i], OffsetX[i]);
          offset(STICK_Y[i], OffsetY[i]);
          ValOutX[i] = inv(get_val(STICK_X[i]));
          ValOutY[i] = inv(get_val(STICK_Y[i]));
        }
      }
    }
    offset(STICK_X[i], OffsetX[i] + ValOutX[i]);
    offset(STICK_Y[i], OffsetY[i] + ValOutY[i]);
  } while(i = (i + 1) % 2);
  
  do {
    temp = (i / 2) + PS4_RX;
    i_val = get_val(temp);
    
     if(i_val >= RX_dk_max[i]) set_val(temp, 100);
     if(i_val <= RX_dk_max[i + 1]) set_val(temp, -100);
  
  }while((i + 2) % 8 == i );
}
int StickDZ[2],
	STICK_X[2],
	STICK_Y[2],
	OffsetX[2],
	OffsetY[2],
	ValOutX[2], 
	ValOutY[2],
	ValPrevX[2],
	ValPrevY[2],
	XY[2],
	ValInY[2],
	ValInX[2],
	o[4],
	i;

init {
  STICK_X = 9;  STICK_X[1] = 11; 
  STICK_Y = 10; STICK_Y[1] = 12; 
  StickDZ = dk_max(abs(get_val(9)), abs(get_val(10))) + 5;
  StickDZ[1]  = dk_max(abs(get_val(11)), abs(get_val(12))) + 5;
}
// Joystick outer edge adjustment
int RX_dk_max=  100;
int RX_dk_min= -100;
int RY_dk_max=  100;
int RY_dk_min= -100;
int LX_dk_max=  100;
int LX_dk_min= -100;
int LY_dk_max=  100;
int LY_dk_min= -100;

int temp, i_val;

function dk_min(a, b) { if(a<=b) return a; return b; }
function dk_max(a, b) { if(a>=b) return a; return b; }
function dk_clamp(v, lo, hi) { return dk_min(hi, dk_max(v, lo)); }
function get_oval(io) { return o[io- 9]; }
function offset(axis, offset_val) { 
  set_val(axis, dk_clamp(offset_val * (100 - abs(get_oval(axis))) / 100 + get_oval(axis), -100, 100));
  if(abs(get_val(axis)) < _Rv ) set_val(axis, 0); 
  return;
}
const int8 ExploitPolar[]= {
    100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,
    71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,
    -8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,
    -65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,
    -97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,
    -94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,
    -56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,
    11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,
    81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100
};
const char Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; ú¹ˆ¾†·ƒ´‚´†¿‰½‹³