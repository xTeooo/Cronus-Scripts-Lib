// GPC Online Library
// cronus_zen_controller_test_gpc_32bit_v100__1.gpc

 /*
											 
											_________                                          _____________________ _______    
											\_   ___ \ _______   ____    ____   __ __   ______ \____    /\_   _____/ \      \   
											/    \  \/ \_  __ \ /  _ \  /    \ |  |  \ /  ___/   /     /  |    __)_  /   |   \  
											\     \____ |  | \/(  <_> )|   |  \|  |  / \___ \   /     /_  |        \/    |    \ 
											 \______  / |__|    \____/ |___|  /|____/ /____  > /_______ \/_______  /\____|__  / 
													\/                      \/             \/          \/        \/         \/  

							_________                    __                   .__   .__                    ___________                  __    
							\_   ___ \   ____    ____  _/  |_ _______   ____  |  |  |  |    ____  _______  \__    ___/  ____    _______/  |_  
							/    \  \/  /  _ \  /    \ \   __\\_  __ \ /  _ \ |  |  |  |  _/ __ \ \_  __ \   |    |   _/ __ \  /  ___/\   __\ 
							\     \____(  <_> )|   |  \ |  |   |  | \/(  <_> )|  |__|  |__\  ___/  |  | \/   |    |   \  ___/  \___ \  |  |   
							 \______  / \____/ |___|  / |__|   |__|    \____/ |____/|____/ \___  > |__|      |____|    \___  >/____  > |__|   
							        \/              \/                                         \/                          \/      \/         
									
	        									  ________ __________ _________                 ________      _______   
												 /  _____/ \______   \\_   ___ \         ___  __\_____  \     \   _  \  
												/   \  ___  |     ___//    \  \/         \  \/ /  _(__  <     /  /_\  \ 
												\    \_\  \ |    |    \     \____         \   /  /       \    \  \_/   \  v1.00 
												 \______  / |____|     \______  /          \_/  /______  / /\  \_____  /
												        \/                    \/                       \/  \/        \/ 

CREDITS...
=============================================================================================================================================================
|  TAYLORDRIFT21 - SWIZZY - BATTS - DOGZTHEFIGHTER - DONOTATME - MAJESTIC MOOSE - CRONUS COMMUNITY TEAM                                                     |
=============================================================================================================================================================
=============================================================================================================================================================
|  CONTROLLER TEST SCRIPT FEATURES                                                                                                                          |
=============================================================================================================================================================

*  CONTROLLER TEST OPTIONS  ( CONTROLLER BUTTON TEST - ANALOGUE STICKS TEST - TRIGGER TEST - TOUCHPAD TEST - GYRO/ACC TEST - RUMBLE TEST - BATTERY VIEWER ) 

*  OLED SCREEN TEST OPTIONS ( RECTANGLE SCREEN TEST - DONOTAT ME DIAL - CRONUS ZEN SCREEN SAVER - SNOW EFFECT SCREEN SAVER - ASCII VIEWER )

*  LED TEST OPTIONS ( BATTS OLED/LED RACE - DONOTATME RAINBOW FLOW LEDS - MANUALLY CHANGE LED (RED - GREEN - BLUE ) 

*  ZEN CALCULATOR ( ALL NEW RE-WRITTEN CALCULATOR - CHANGE THE AMOUNT OF VALUES AND HOW YOU WANT TO CALCULATE A SUM VIA OLED SCREEN )  

*  ZEN GAMES ( SNAKE - PING PONG )  ( ZEN SNAKE IS PLAYABLE VIA OLED SCREEN - ZEN PING PONG IS PLAYABLE VIA OLED SCREEN ) 

*  32 BIT GET_POLAR () FUNCTION OLED VIEWER ( YOU CAN VIEW THE ANGLE AND RADIUS OF YOUR RIGHT STICK WHEN USING THE BRAND NEW GET_POLAR() FUNCTION 32 BIT ONLY) 

=============================================================================================================================================================
INSTRUCTIONS... PLEASE READ THE INSTRUCTIONS - THIS WILL HELP YOU BE ABLE TO GET YOUR WAY AROUND THE OLED MENU 
=============================================================================================================================================================
Instructions Index -

	* Menu Navigation       Line 62 
	* Main Menu Navigation  Line 70
	* Test Menu Navigation  Line 80
	* Controller Tests      Line 90
	* Oled Tests            Line 106
	* Led Tests             Line 120
	* Zen Calculator        Line 130
	* Zen Games (Snake)     Line 142
	* Zen Games (Ping Pong) Line 166 
	* 32 Bit get_polar()    Line 176
	* End Of Instructions   Line 187
	
=================================================================
| MENU NAVIGATION                                               |
=================================================================
-----------------------------------------------------------------
	* ENTER MENU - PRESS L2/LT AND OPTIONS 
-----------------------------------------------------------------
	* EXIT MENU  - PRESS CIRCLE/B 
-----------------------------------------------------------------
=================================================================
| MAIN MENU NAVIGATION                                          |
=================================================================
-----------------------------------------------------------------
	* PRESS UP/DOWN TO SCROLL THROUGH OPTIONS
-----------------------------------------------------------------
	* PRESS CIRCLE TO EXIT THE MENU 
-----------------------------------------------------------------
	* PRESS CROSS/A TO ENTER ANY OF THE TEST OPTIONS
-----------------------------------------------------------------
=================================================================
| ANY OF THE TEST OPTIONS YOU ENTER                             |
=================================================================
-----------------------------------------------------------------
	* PRESS LEFT/RIGHT TO SCROLL THROUGH OPTIONS
-----------------------------------------------------------------
	* PRESS CIRCLE/B TO EXIT TO THE MAIN MENU 
-----------------------------------------------------------------
	* PRESS CROSS/A TO ACTIVATE ANY TEST OPTIONS IF APPLICABLE
-----------------------------------------------------------------
==================================================================================
| CONTROLLER TESTS                                                               |
==================================================================================
----------------------------------------------------------------------------------
BUTTON TEST   = PRESS ANY BUTTON TO DISPLAY THE BUTTON YOU HAVE PRESSED 
----------------------------------------------------------------------------------
ANALOGUE TEST = MOVE EITHER YOUR LEFT/RIGHT STICK TO SHOW THE VALUE OF THE INPUT 
----------------------------------------------------------------------------------
TRIGGER TEST  = PRESS ANY OF YOUR TRIGGERS TO SHOW THE VALUE OF THE INPUT
----------------------------------------------------------------------------------
TOUCHPAD TEST = PRESS THE TOUCHPAD TO DISLAY THE VALUE 
----------------------------------------------------------------------------------
GYRO/ACC TEST = TILT THE PLAYSTATION CONTROLLER TO VEIW ON DISPLAY THE VALUE 
----------------------------------------------------------------------------------
RUMBLE TEST   = PRESS UP/DOWN TO CHANGE THE RUMBLE OPTIONS 
----------------------------------------------------------------------------------
==================================================================================
| OLED SCREEN TESTS                                                              |
==================================================================================
----------------------------------------------------------------------------------
TEST SCREEN 1 = PRESS CROSS/A TO ACTIVATE - PRESS CIRCLE/B TO EXIT 
----------------------------------------------------------------------------------
TEST SCREEN 2 = PRESS CROSS/A TO ACTIVATE - PRESS CIRCLE/B TO EXIT
----------------------------------------------------------------------------------
SCREENSAVER 1 = PRESS CROSS/A TO ACTIVATE - PRESS CIRCLE/B TO EXIT
----------------------------------------------------------------------------------
SCREENSAVER 2 = PRESS CROSS/A TO ACTIVATE - PRESS CIRCLE/B TO EXIT
----------------------------------------------------------------------------------
ASCII VIEWER  = PRESS UP/DOWN TO SCROLL THE OPTIONS - PRESS CIRCLE/B TO EXIT
----------------------------------------------------------------------------------
==================================================================================
| LED TESTS                                                                      |
==================================================================================
----------------------------------------------------------------------------------
BATTS OLED/LED RACE = PRESS CROSS/A TO ACTIVATE - PRESS CIRCLE/B TO EXIT 
----------------------------------------------------------------------------------
@ME RAINBOW LED     = NOTHING IS REQUIRED JUST WATCH - IT WILL START AUTOMATICALLY 
----------------------------------------------------------------------------------
MANAUL LED ADJUST   = PRESS UP/DOWN TO SELECT LED - PRESS CIRCLE/B TO EXIT 
----------------------------------------------------------------------------------
==================================================================================
| ZEN CALCULATOR                                                                 |
==================================================================================
----------------------------------------------------------------------------------
PRESS LEFT/RIGHT TO CHANGE WHICH OPTION YOU HIGHLIGHT 
----------------------------------------------------------------------------------
PRESS UP/DOWN TO CHANGE VALUES / SUM 
----------------------------------------------------------------------------------
PRESS CROSS/A TO GET THE FINAL SUM/CALCULATION 
----------------------------------------------------------------------------------
PRESS SQUARE TO RESET THE TOTAL SUM 
----------------------------------------------------------------------------------
==================================================================================
| ZEN GAMES - ZEN SNAKE  HOW TO PLAY                                             |
==================================================================================
----------------------------------------------------------------------------------
NOTE... Known issues with the snake game...
Sometimes it will stop displaying the food intermittedly , Press Triangle to place 
more food :) 
----------------------------------------------------------------------------------
PRESS SQUARE/X TO PLAY THE GAME OF SNAKE / ACCESS ANY OF THE OPTIONS IN GAME MENU
----------------------------------------------------------------------------------
PRESS TRIANGLE/Y TO EXIT THE GAME TO GAME MENU 
----------------------------------------------------------------------------------
USE THE DPAD ON YOUR CONTROLLER TO MOVE THE SNAKE TO GET THE FOOD 
----------------------------------------------------------------------------------
PRESS SHARE/MENU TO RESET THE SNAKE GAME (YOU CAN DO THIS WHILE PLAYING) 
----------------------------------------------------------------------------------
PRESS OPTIONS TO PAUSE THE SNAKE GAME 
----------------------------------------------------------------------------------
TO CHANGE THE NAME OF THE HIGH SCORE - PRESS UP/DOWN (MAX 3 CHARACTERS) 
----------------------------------------------------------------------------------
INSTRUCTIONS VIA OLED - PRESS LEFT/RIGHT TO SCROLL THROUGH INSTRUCTIONS ON SCREEN
----------------------------------------------------------------------------------
PRESS CIRCLE TO COMPLETELY EXIT GAME TO ZEN GAMES MENU 
----------------------------------------------------------------------------------
==================================================================================
| PING PONG GAME                                                                 |
==================================================================================
NOTE * Known Issues with Ping Pong , the ball may get stuck , which loses you a 
point on the scoreboard...
----------------------------------------------------------------------------------
MOVE THE BARS AT BOTH SIDES OF THE SCREEN - MOVE YOUR LEFT AND RIGHT STICK 
----------------------------------------------------------------------------------
PRESS CIRCLE/B TO EXIT THE GAME 
----------------------------------------------------------------------------------
==================================================================================
| 32 BIT GPC GET_POLAR()                                                         |
==================================================================================
----------------------------------------------------------------------------------
GET_POLAR IS A NEW BUILT IN FUNCTION IN THE 32 BIT GPC - 
WHAT GET POLAR DOES IS RETRIEVE THE ANGLE AND RADIUS OF YOUR RIGHT STICK - 
IT CAN ALSO BE APPLIED VIA LEFT STICK TOO , NOT IN THIS SCRIPT! 
----------------------------------------------------------------------------------
MOVE YOUR RIGHT STICK AROUND - THE OLED SCREEN WILL DISPLAY THE ANGLE AND RADIUS
VIA OLED.
----------------------------------------------------------------------------------
==================================================================================
| END OF INSTRUCTIONS - THANKS FOR READING - I HOPE YOU ENJOY EXPERIMENTING      |
==================================================================================
*/
init { 
	RunIntro = TRUE;
	colors = 255;
	Ascii = 33;
	xspeed = 2;
	yspeed = 2;
	xdirection = 3;
	ydirection = random(1, 5);
	p1_score = p2_score = 48;
	xpos = 64;
	ypos = 32;
	cls_oled(0);
} 
/*
============================================================================================================================================
  Main Section - Start Of Menu                                                                                                              
============================================================================================================================================
*/
main { 
	if(RunIntro){ 
		combo_run(Message);
	}
	if(Initialise){
		combo_run(GetInfo);
	} 
	if(get_ival(PS4_L2)){ 
		if(event_press(PS4_OPTIONS)){ 
		    MenuStatus(1,1,0,0,0,0);
		    ModORVal[0]  = 0; 
		    combo_run(RumbleOn);
		    
		    if(!ModOrEditMenu[0]){ 
		    	MenuStatus(0,0,0,0,0,1);
		    }    
	    }
	    set_val(PS4_OPTIONS,0);   
    }
    if(!DisplayTitle){ 
    	if(ModOrEditMenu[0]){
        	ModORVal[0]  = MenuNavigation(ModORVal[0],0,5);
			if(event_press(PS4_CIRCLE)){
				MenuStatus(0,0,0,0,0,1);
				cls_oled(0);
			}	 
        } 
   		if(ModOrEditMenu[1]){ 
        	ModORVal[1]   = MenuNavigation(ModORVal[1],ModRange[ModORVal[0]][0],ModRange[ModORVal[0]][1]); 
    
		   	if(ModORVal[1] == 0){ 
		    	ControllerTest();
		    } 
		    if(ModORVal[1] == 1){ 
		    	LY = get_val(PS4_LY);
		    	LX = get_val(PS4_LX);
		    	RY = get_val(PS4_RY);
		    	RX = get_val(PS4_RX);
		    	DisplayMenu = TRUE; 	 
		    } 
		    if(ModORVal[1] == 2){ 
		    	R2 = get_val(PS4_R2);
		    	L2 = get_val(PS4_L2);
		    	DisplayMenu = TRUE;	
		    } 	
		    if(ModORVal[1] == 5){ 
		    	if(!get_ival(PS4_L2)){
			    	if(event_press(PS4_UP)){ 
			    		RumbleType = Refresh(RumbleType + 1,0,3);
			    		DisplayMenu = TRUE;
			    		reset_rumble();
			    	} 
			    	if(event_press(PS4_DOWN)){ 
			    		RumbleType = Refresh(RumbleType - 1,0,3);
			    		DisplayMenu = TRUE;
			    		reset_rumble();
			    	} 
			    } 
			    RumbleStrength++;
			    DisplayMenu = TRUE;
			    
			    if(RumbleStrength > 255){ 
			    	RumbleStrength = 0;
			    } 
			    if(RumbleType == 0){ 
			    	set_rumble(RUMBLE_A,RumbleStrength);	
			    } 
			    if(RumbleType == 1){ 
			    	set_rumble(RUMBLE_B,RumbleStrength);	
			    }
			    if(RumbleType == 2){ 
			    	set_rumble(RUMBLE_LT,RumbleStrength);   
			    } 
			    if(RumbleType == 3){ 
			    	set_rumble(RUMBLE_RT,RumbleStrength);  
			    } 
		    } 
		    if(ModORVal[1] == 6){ 
		    	if(get_battery() > 10){
					if(batteryChargingCounter == 10){
						batteryLevel++;
						batteryChargingCounter = 0;
					}
					else 
						batteryChargingCounter++;
						
					if(batteryLevel > 10)
						batteryLevel = 0
				}
				else 

				batteryLevel = get_battery();
					
			    if(get_battery() <= 1){
			    	count_battery += get_rtime();
			    	if(count_battery == 10000){	
			        	count_battery = 0;
			        }
			    }
			}
			if(ModORVal[1] == 11){ 
				if(event_press(PS4_UP) || get_val(PS4_UP) && get_ptime(PS4_UP) > 300){ 
		    		Ascii = Refresh(Ascii + 1,33,122);
		    		DisplayMenu = TRUE;
			    } 
			    if(event_press(PS4_DOWN) || get_val(PS4_DOWN) && get_ptime(PS4_DOWN) > 300){ 
			    	Ascii = Refresh(Ascii - 1,33,122);	
			    	DisplayMenu = TRUE;
			    } 
			}
			if(ModORVal[1] == 13){ 
				if(event_press(PS4_UP)){ 
					RgbSelector = Refresh(RgbSelector + 1,0,2);
					DisplayMenu = TRUE;
				} 
				if(event_press(PS4_DOWN)){ 
					RgbSelector = Refresh(RgbSelector - 1,0,2);
					DisplayMenu = TRUE;
				}
				if(RgbSelector == 0){ 
					set_rgb(255,0,0);
				}
				if(RgbSelector == 1){ 
					set_rgb(0,255,0);
				}
				if(RgbSelector == 2){ 
					set_rgb(0,0,255);
				} 
			}
			if(ModORVal[1] == 14){ 
				combo_run(rgb);
			} 
			if(ModORVal[1] == 18){ 
				Radius = get_polar(POLAR_RS,POLAR_RADIUS);
				Angle  = get_polar(POLAR_RS,POLAR_ANGLE); 
				DisplayMenu = TRUE;
			}
    	} 
    	if(ModOrEditMenu[2]){ 
    		ModORVal[2]   = MenuNavigation(ModORVal[2],ModsNToggles[ModORVal[1]][1],ModsNToggles[ModORVal[1]][2]);
    		
    		if(ModORVal[2] == 0){ 
    			TOUCHPAD();
    			if(event_press(PS4_SQUARE)) {
					FINGER1T = !FINGER1T;
					FINGER2T = !FINGER2T;
				}
			}
			if(ModORVal[2] == 1){ 
				GYRO();
				if(event_press(PS4_SQUARE)) {
					GYRO = !GYRO;
					ACC  = !ACC;
				}	
			} 
    		
    		if(ModORVal[2] == 2){ 
				set_rect = TRUE;	
			}
			
			if(ModORVal[2] != 2 && combo_running(SPREAD) && combo_running(SPREAD1)){ 
				combo_stop(SPREAD);
				combo_stop(SPREAD1);
			} 
			
			if(ModORVal[2] == 3){ 
				DoNotAtMeDial();
			}
			
			if(ModORVal[2] == 4){ 
				pixel_oled(X_POS1,Y_POS1,COLOUR)   
      			pixel_oled(X_POS2,Y_POS2,COLOUR)  
				combo_run(RACE_1);
      		} 
      		
      		if(ModORVal[2] == 5){ 
      			DGT += get_rtime();
				if(DGT >= 100) 
				{
					SD1 += 2;	TP1 += 1;	TP2 -= 1;	DGT  = 0;
				}
				DGR += get_rtime();
				
				if(DGR >= 30) 
				{
					Y_1 += 1;	Y_2 += 2;	Y_3 += 3;	Y_4 += 4;
					Y_5 += 5;	Y_6 += 6;	Y_7 += 7;	Y_8 += 8;
					DGR  = 0;
				}
				
				name();
				MSC += get_rtime();
				
				if(MSC >= 1000) 
				{
					MSC = 0;	
					RT += 1;
				}
			}
			if(ModORVal[2] == 6){ 
				DisplayMenu = TRUE;
			}
			if(ModORVal[2] == 7){ 
				Calculator();
			}
			if(ModORVal[2] == 8){ 
				if(snakeState == TITLE) {
					if(menuNav(PS4_UP, PS4_DOWN,PS4_SQUARE)) {
						// Play
						if (menuNav == 0) {
							snakeState = GAME_START;
							DisplayMenu = 1;
							
						// Highscores
						} else if (menuNav == 1) {
							snakeState = HIGHSCORES;
							DisplayMenu = 1;
							
						// Credits
						} else if (menuNav == 2) {
							snakeState = CREDITS;
							DisplayMenu = 1;
						}
						else if (menuNav == 3) {
							snakeState = INSTRUCTIONS;
							DisplayMenu = 1;
						}
					}
				}
				// Display Highscores
				else if (snakeState == HIGHSCORES) {
					// Return
					if (event_press(PS4_SQUARE) || event_press(PS4_TRIANGLE)) {
						snakeState = TITLE;
						menuOptions = 4;
						DisplayMenu = 1;
						
					// Display Highscores
					} 
				} 	
				// Display Credits
				else if (snakeState == CREDITS) {
					// Return
					if (event_press(PS4_SQUARE) || event_press(PS4_TRIANGLE)) {
						snakeState = TITLE;
						menuOptions = 4;
						DisplayMenu = 1;
						
					// Display Credits
					} 
				}
				else if (snakeState == INSTRUCTIONS) {
					if(event_press(PS4_RIGHT)){ 
						NextPage = clamp(NextPage + 1,0,4);
						DisplayMenu = TRUE;
					}
					if(event_press(PS4_LEFT)){ 
						NextPage = clamp(NextPage - 1,0,4);
						DisplayMenu = TRUE;
					}
					if (event_press(PS4_SQUARE) || event_press(PS4_TRIANGLE)) {
						snakeState = TITLE;
						menuOptions = 4;
						DisplayMenu = 1;
					}
				}
				// Loop Gameplay
				else if (snakeState == GAMEPLAY) {
					// Pause Game
					if (event_press(PS4_OPTIONS)) {
						menuNav = 0;
						menuOptions = 2;
						snakeState = PAUSE;
						DisplayMenu = 1;
						
					// Reset Game
					} else if (event_press(PS4_SHARE)) {
						snakeState = GAME_START;
						DisplayMenu = 1;
						
					// Play Game
					}
					else if(event_press(PS4_TRIANGLE)){ 
						EatFood();
					}
					else {
						// DisplayMenu Player Movement
						DisplayMenuMovement();
						
						// DisplayMenu Snake 
						if (snakeTimer > STEP_TIME) {
							// Reset Timer
							snakeTimer = 0;
							
							// Move Player, check if Valid Move
							if (MoveSnake()) {
								// Eat Food
								if (curX == goalX && curY == goalY) {
									// Move Food
									EatFood();
									
									// Move Snake
									DisplayMenuSnake(1);
									
								// Regular Movement
								} else {
									DisplayMenuSnake(0);
								}
								
							// Bad Move, gameover
							} else {
								// Highscore
								if (snakeLength > GetMinHighscore()) {
									snakeState = ENTER_HS;
									
									// Prep Highscore name
									name[0] = 0;
									name[1] = 0;
									name[2] = 0;
									nameI = 0;
									
									DisplayMenu = 1;
									
								// Gameover
								} else {
									snakeState = GAMEOVER;
									DisplayMenu = 1;
								}
							}
							
						// Increment game loop timer
						} else {
							snakeTimer += get_rtime();
						}
					}   
			    // Game Paused
				} else if (snakeState == PAUSE) {
					// Back to Game
					if (event_press(PS4_TRIANGLE) || event_press(PS4_OPTIONS)) {
						// Clear Display
						ResetScreen();
						
						// Reset Game Timer
						snakeTimer = 0;
						snakeState = GAMEPLAY;
						DisplayMenu = 1;
						
					// Check for menu Navigation
					} else if (menuNav(PS4_UP, PS4_DOWN, PS4_SQUARE)) {
						// Resume Game
						if (menuNav == 0) {
							// Clear Display
							ResetScreen();
							
							// Reset Game Timer
							snakeTimer = 0;
							snakeState = GAMEPLAY;
							DisplayMenu = 1;
							
							
						// Quit Game
						} else {
							menuNav = 0;
							menuOptions = 3;
							snakeState = TITLE;
							DisplayMenu = 1;
						}
						
					// Draw Pause Overlay
					}
				}	
				// Gameover
				else if (snakeState == GAMEOVER) {
					// Quit Game
					if (event_press(PS4_SQUARE)) {
						menuNav = 0;
						menuOptions = 3;
						snakeState = TITLE;
						DisplayMenu = 1;
						
					} 
				}
					
				// Enter Highscore
				else if (snakeState == ENTER_HS) {
					// Confirm & Quit
					if (event_press(PS4_SQUARE)) {
						// Confirm
						AddHighscore();
						
						// Quit
						menuNav = 0;
						menuOptions = 3;
						snakeState = TITLE;
						DisplayMenu = 1;
						
					// Edit Name
					} else {
						// Cycle Character - Up
						if (CheckMovement(PS4_UP)) {
							name[nameI] = name[nameI] + 1;
							if (name[nameI] >= LETTER_COUNT)
								name[nameI] = 0;
							
							DisplayMenu = 1;
						
						// Cycle Character - Down
						} else if (CheckMovement(PS4_DOWN)) {
							name[nameI] = name[nameI] - 1;
							if (name[nameI] < 0)
								name[nameI] = LETTER_COUNT - 1;
							
							DisplayMenu = 1;
							
						// Navigate Character - Left
						} else if (event_press(PS4_LEFT) && nameI > 0) {
							nameI--;
							DisplayMenu = 1;
							
						// Navigate Character - Right
						} else if (event_press(PS4_RIGHT) && nameI < NAME_CHARS - 1) {
							nameI++;
							DisplayMenu = 1;
						}
					}
				}		
		    }
		    if(ModORVal[2] == 9){ 
		    	Pong();
		    } 
    	}
    }
    if(DisplayMenu){ 
        if(ModOrEditMenu[1] && !ModOrEditMenu[2]) {
        	rect_oled(2,1,127,52,1,0); 
        }	
		if(ModOrEditMenu[1]) { 
			rect_oled(0, 0, OLED_WIDTH, OLED_HEIGHT, OLED_BLACK, OLED_WHITE);
			line_oled(0, 50,127 , 50, 1, 1); 
			line_oled(0, 20,127 , 20, 1, 1);
		}
		if(ModOrEditMenu[2]){ 	
	    	if(ModORVal[2] == 2){ 
		    	if(set_rect){ 
		    		RectScreenTest();
		    	}else{
		    		set_rect = FALSE;
		    	} 
		    } 
		    if(ModORVal[2] == 3){
		    	cls_oled(0);
		    	circle_oled(32, 32, 29, 0, 1);	
		    } 
		  
		    if(ModORVal[2] == 4){ 
		    	cls_oled(0);                        
      		}
      		
      		if(ModORVal[2] == 5){ 
      			if(RT == 30) 
				{
					RT = 0;
					cls_oled(0);
				}
			}
			if(ModORVal[2] == 6){	
				BattsOledRace();	
			} 
			if(ModORVal[2] == 7){ 
			
				cls_oled(OLED_BLACK);
				rect_oled(1,0,127,20,0,1); // Top Rect 
				rect_oled(0, 0, OLED_WIDTH, OLED_HEIGHT, OLED_BLACK, OLED_WHITE); 
				line_oled(0, 50,127 , 50, 1, 1); 
				print(2,53,0,1,EDIT[0]);
				
				if(!Equals){ 
					NumberToString(Equals,FindDigits(Equals),115,6,OLED_FONT_SMALL);
				}
				if(Equals){ 
					if(Equals >= 0 && Equals <= 9){ 
						NumberToString(Equals,FindDigits(Equals),115,6,OLED_FONT_SMALL);
					}
					else if(Equals >= 0 && Equals <= 99){ 
						NumberToString(Equals,FindDigits(Equals),110,6,OLED_FONT_SMALL);
					} 
					else if(Equals >= 99 && Equals <= 999){ 
						NumberToString(Equals,FindDigits(Equals),100,6,OLED_FONT_SMALL);
					}
					else if(Equals >= 999 && Equals <= 9999){ 
						NumberToString(Equals,FindDigits(Equals),90,6,OLED_FONT_SMALL);
					}
					else if(Equals >= 9999){ 
						NumberToString(Equals,FindDigits(Equals),80,6,OLED_FONT_SMALL);
					}	
				} 
				if(HighLight == 0){ 
					rect_oled(12,42,35,3,1,1);
				}
				if(HighLight == 1){ 
					rect_oled(50,42,20,3,1,1);
				} 
				if(HighLight == 2){ 
					rect_oled(78,42,35,3,1,1);
				}
				if(!ConditionOne || ConditionOne > 0  && ConditionOne <= 99){ 
					NumberToString(ConditionOne,FindDigits(ConditionOne),18,23,OLED_FONT_MEDIUM);
				}
				else if(ConditionOne <= 0){
					NumberToString(ConditionOne,FindDigits(ConditionOne),7,23,OLED_FONT_MEDIUM);
				} 
				else if(ConditionOne >= 99){ 
					NumberToString(ConditionOne,FindDigits(ConditionOne),12,23,OLED_FONT_MEDIUM);
				} 
				if(!ConditionTwo || ConditionTwo > 0  && ConditionTwo <= 99){ 
					NumberToString(ConditionTwo,FindDigits(ConditionTwo),87,23,OLED_FONT_MEDIUM);
				}
				else if(ConditionTwo < 0){ 
					NumberToString(ConditionTwo,FindDigits(ConditionTwo),72,23,OLED_FONT_MEDIUM);
				}
				else if(ConditionTwo >= 99){
					NumberToString(ConditionTwo,FindDigits(ConditionTwo),77,23,OLED_FONT_MEDIUM);
				} 
				if(TotalSum == 0){ 
					putc_oled(1,ASCII_PLUS);
					puts_oled(55,23,1,1,1);
				} 
				if(TotalSum == 1){ 
					putc_oled(1,ASCII_MINUS);
					puts_oled(55,23,1,1,1);
				} 
				if(TotalSum == 2){ 
					putc_oled(1,ASCII_LOWER_X);
					puts_oled(55,22,1,1,1);
				}
				if(TotalSum == 3){ 
					putc_oled(1,ASCII_SLASH);
					puts_oled(55,23,1,1,1);
				} 
			}
			if(ModORVal[2] == 8){ 
				if(snakeState == TITLE) {
					cls_oled(BLACK);
					
				    /// Draw Menu
			    	DrawMenu(0,15,128,49, BLACK);
			 		PrintString(0, 3, 128, SMALL, WHITE, s_SNAKE[0], sizeof(s_SNAKE));
				    // Play
				    PrintString(31, 18 ,64, SMALL, menuNav != 0, s_Play[0], sizeof(s_Play));
				    
				    // HighScore
				    PrintString(31, 29, 64, SMALL, menuNav != 1, s_Highscore[0], sizeof(s_Highscore));
				    
				    // Credits
				    PrintString(31, 41, 64, SMALL, menuNav != 2, s_Credits[0], sizeof(s_Credits));
				    
				    // Instructions
				    PrintString(20, 51, 64, SMALL, menuNav != 3, s_Instruction[0], sizeof(s_Instruction));
				} 
				if(snakeState == HIGHSCORES){
				    // Get Current Highscores
					DisplayMenuHighscores();
					
					// Clear Screen
					cls_oled(BLACK);
					
					// Draw Menu
					DrawMenu(23, 3, 80, 60, BLACK);
					
					//Highscores
					PrintString(0, 5, 128, SMALL, WHITE, s_Highscores[0], sizeof(s_Highscores));
					
					// Print Highscores
					for (nameI = 0; nameI < TOP_PLACES; nameI++) {
						// Place
						PrintChar(25, 19 + nameI * 10, SMALL, WHITE, AC_0 + nameI + 1);
						// Colon
						PrintChar(32, 19 + nameI * 10, SMALL, WHITE, AC_colon);
						// Name
						PrintChar(39, 19 + nameI * 10, SMALL, WHITE, names[nameI * 3]);
						PrintChar(46, 19 + nameI * 10, SMALL, WHITE, names[nameI * 3 + 1]);
						PrintChar(53, 19 + nameI * 10, SMALL, WHITE, names[nameI * 3 + 2]);
						// - 
						PrintChar(67, 19 + nameI * 10, SMALL, WHITE, AC_minus);
						// Score
						PrintNumber(81, 19 + nameI * 10, 21, SMALL, WHITE, highscores[nameI]);
					}
					
					// Back
					PrintString(31, 51, 64, SMALL, BLACK, s_Back[0], sizeof(s_Back));
				} 
				if (snakeState == CREDITS) {
					cls_oled(BLACK);
					
					// Draw Menu
					DrawMenu(30, 5, 66, 59, BLACK);
					
					// Made By:
					PrintString(31, 10, 64, SMALL, WHITE, s_Made_By[0], sizeof(s_Made_By));
					
					// Majestik
					PrintString(31, 24, 64, SMALL, WHITE, s_Majestik[0], sizeof(s_Majestik));
					
				    // Moose
					PrintString(31, 34, 64, SMALL, WHITE, s_Moose[0], sizeof(s_Moose));
				    
					// Back
					PrintString(31, 49, 64, SMALL, BLACK, s_Back[0], sizeof(s_Back));
				} 
				if (snakeState == INSTRUCTIONS) {
					cls_oled(BLACK);
					if(NextPage == 0){ 
				
					//line_oled(0, 50,127 , 50, 1, 1); 
					line_oled(0, 16,127 , 16, 1, 1);
					rect_oled(0, 0, 128, 62, OLED_BLACK, OLED_WHITE); 
					print(26,4,0,1,HowToPlay[0]);
					print(15,22,0,1,PressSquare[0]);
					print(3,35,0,1,Start[0]);
					print(3,50,0,1,NxtPage[0]);
					} 
					if(NextPage == 1){ 
						rect_oled(2,1,127,52,1,0); 
						//line_oled(0, 50,127 , 50, 1, 1); 
						line_oled(0, 16,127 , 16, 1, 1);
						rect_oled(0, 0, 128, 62, OLED_BLACK, OLED_WHITE); 
						print(26,4,0,1,HowToPlay[0]);
						print(8,22,0,1,GameInfo[0]);
						print(7,35,0,1,GameInfo[1]);
						print(3,50,0,1,NxtPage[0]);
					} 
					if(NextPage == 2){ 
						rect_oled(2,1,127,52,1,0); 
						//line_oled(0, 50,127 , 50, 1, 1); 
						line_oled(0, 16,127 , 16, 1, 1);
						rect_oled(0, 0, 128, 62, OLED_BLACK, OLED_WHITE); 
						print(26,4,0,1,HowToPlay[0]);
						print(6,22,0,1,GameInfo[2]);
						print(6,35,0,1,GameInfo[3]);
						print(3,50,0,1,NxtPage[0]);
					} 
					if(NextPage == 3){ 
						rect_oled(2,1,127,52,1,0); 
						//line_oled(0, 50,127 , 50, 1, 1); 
						line_oled(0, 16,127 , 16, 1, 1);
						rect_oled(0, 0, 128, 62, OLED_BLACK, OLED_WHITE); 
						print(26,4,0,1,HowToPlay[0]);
						print(6,22,0,1,GameInfo[4]);
						print(6,35,0,1,GameInfo[5]);
						print(3,50,0,1,NxtPage[0]);
					} 
					if(NextPage == 4){ 
						rect_oled(2,1,127,52,1,0); 
						//line_oled(0, 50,127 , 50, 1, 1); 
						line_oled(0, 16,127 , 16, 1, 1);
						rect_oled(0, 0, 128, 62, OLED_BLACK, OLED_WHITE); 
						print(26,4,0,1,HowToPlay[0]);
						print(2,22,0,1,GameInfo[6]);
						print(8,35,0,1,GameInfo[7]);
						print(3,50,0,1,NxtPage[0]);
					} 
				}
				if (snakeState == GAME_START) {
					// Clear Screen
					cls_oled(BLACK);
					
					// Fill in Gaps that are not movable
					line_oled(0, 0, 0, 63, 1, 1);
					line_oled(1, 0, 1, 63, 1, 1);
					line_oled(127, 0, 127, 63, 1, 1);
					
					line_oled(0, 0, 127, 0, 1, 1);
					line_oled(0, 1, 127, 1, 1, 1);
					line_oled(0, 62, 127, 62, 1, 1);
					line_oled(0, 63, 127, 63, 1, 1);
					
					// Initialize objects
					InitSnake();
					SetGoal(20, 10);
					
					snakeState = GAMEPLAY;
				}
				if (snakeState == PAUSE) {
				// Draw Menu
				    DrawMenu(30, 20, 66, 28, BLACK);
					    
					// Continue
					PrintString(31, 23, 64, SMALL, menuNav != 0, s_Continue[0], sizeof(s_Continue));
					    
					// Quit
					PrintString(31, 35, 64, SMALL, menuNav != 1, s_Quit[0], sizeof(s_Continue));
				}
				if (snakeState == GAMEOVER) {
					// Draw Menu
					DrawMenu(26, 10, 74, 42, BLACK);
				    // Gameover
				    PrintString(26, 13, 74, SMALL, WHITE, s_Gameover[0], sizeof(s_Gameover));
				    // Score
				    PrintString(31, 25, 0,  SMALL, WHITE, s_Score[0], 0);
				    PrintNumber(68, 25, 32, SMALL, WHITE, snakeLength);
				    // Quit
				    PrintString(26, 37, 74, SMALL, BLACK, s_Quit[0], sizeof(s_Quit));
				}
				if (snakeState == ENTER_HS) {
					// Draw Menu
					DrawMenu(26, 5, 74, 52, BLACK);
				    
				    // Highscore
				    PrintString(26, 8, 74, SMALL, WHITE, s_Highscore[0], sizeof(s_Highscore));
				    
				    // Score
				    PrintString(31, 20, 0,  SMALL, WHITE, s_Score[0], 0);
				    PrintNumber(68, 20, 32, SMALL, WHITE, snakeLength);
				    
				    // Name
					for (i = 0; i < NAME_CHARS; i++) {
						PrintKeyWheel(48 + 10 * i, 37, SMALL, WHITE, LETTERS[name[i]], i == nameI);
					}
				} 
			}
			if(ModORVal[2] == 9){ 
				cls_oled(0);
			} 
		}
		else if(ModOrEditMenu[1]){
		    String(ModNames[ModORVal[1]],Small,-20,0);
		   
		    if(ModORVal[1] == 1){ 
		    	if(abs(get_val(PS4_LX)) && abs(get_val(PS4_LY))){ 
		    		print(75,30,0,1,ControllerBtns[0]);
		    		NumberToString(LX,FindDigits(LX),95,30,OLED_FONT_SMALL);
		    		print(10,30,0,1,ControllerBtns[1]);
		    		NumberToString(LY,FindDigits(LY),35,30,OLED_FONT_SMALL);  
		    	} 
		    	else if(abs(get_val(PS4_RX)) && abs(get_val(PS4_RY))){ 
		    		print(75,30,0,1,ControllerBtns[2]);
		    		NumberToString(RX,FindDigits(RX),95,30,OLED_FONT_SMALL);
		    		print(10,30,0,1,ControllerBtns[3]);
		    		NumberToString(RY,FindDigits(RY),35,30,OLED_FONT_SMALL);  
		    	} 
		    } 
		    if(ModORVal[1] == 2){ 
		    	if(get_console() == PIO_PS4) {
		    		print(65,30,0,1,ControllerBtns[5]);
		    		NumberToString(R2,FindDigits(R2),95,30,OLED_FONT_SMALL);
		    	    print(10,30,0,1,ControllerBtns[4]);
		    	    NumberToString(L2,FindDigits(L2),35,30,OLED_FONT_SMALL);  
		    	}
		    	else if(get_console() == PIO_XB1){ 
		    		print(65,30,0,1,ControllerBtns[7]);
		    		NumberToString(R2,FindDigits(R2),90,30,OLED_FONT_SMALL);
		    	    print(10,30,0,1,ControllerBtns[6]);
		    	    NumberToString(L2,FindDigits(L2),35,30,OLED_FONT_SMALL);  
		        } 
		    }
		    if(ModORVal[1] == 5){ 
		    	print(5,30,0,1,RumbleNotifier[RumbleType]);
		    	NumberToString(RumbleStrength,FindDigits(RumbleStrength),85,30,OLED_FONT_SMALL);
		    	putc_oled(1,ASCII_PERCENT);
		    	puts_oled(110,30,0,1,1);
		    } 
		    if(ModORVal[1] == 6){ 
		    	drawBattery(batteryLevel); 
		    }
		    if(ModsNToggles[ModORVal[1]][3] != 0){ 
		    	String(Misc[1],Small,-2,0);
		        String(Misc[2],Small,10,0);
		    } 
		    if(ModORVal[1] == 11){	
		    	putc_oled(1,Ascii)
				puts_oled(55,28,1,1,1);
			}
			if(ModORVal[1] == 13){ 
				String(Rgb[RgbSelector],Small,4,0);
			} 
			if(ModORVal[1] == 14){ 
				String(Misc[4],Small,4,0);
			}
			if(ModORVal[1] == 18){ 
				NumberToString(Radius,FindDigits(Radius),70,38,OLED_FONT_SMALL);
				NumberToString(Angle,FindDigits(Angle),22,38,OLED_FONT_SMALL); 
				print(15,24,0,1,GetPolar[0]);
				print(68,24,0,1,GetPolar[1]);
				
			} 
		}
		else if(ModOrEditMenu[0])
		{ 
			rect_oled(13, 1, 102,47, OLED_WHITE, OLED_BLACK); 
			rect_oled(0, 0, 128, 49, OLED_BLACK, OLED_WHITE); // white contour
			rect_oled(1, 1, 126, 47, OLED_WHITE, OLED_BLACK); // Filled rectangle white (emplacement for lines 1, 2, 3)
			
			DisplayMenu(0,5,1);
			DisplayMenu(1,0,2);
			DisplayMenu(2,1,3);
			DisplayMenu(3,2,4);
			DisplayMenu(4,3,5);
			DisplayMenu(5,4,0);
	    }	 
		DisplayMenu = FALSE;
	} 
	if(ModOrEditMenu[0] || ModOrEditMenu[1]){
		MenuScroll();
	}
    if(!ModOrEditMenu[0] && !ModOrEditMenu[1] && !ModOrEditMenu[2] && !ModOrEditMenu[3]){
		if(DisplayTitle){ 	
	   		rect_oled(2,1,127,52,1,0); 
	   		line_oled(0, 50,127 , 50, 1, 1); 
			line_oled(0, 16,127 , 16, 1, 1);
	    	DisplayController();
	    	DisplayTitle = FALSE;
	        ScreenSaver  = TRUE; 
	        RunIntro = FALSE;
		}
		if(!RunIntro && !Initialise){ 
			IntroScroll();
		} 
		if(ScreenSaver){
	    	BlankScreen += get_rtime();
			if(BlankScreen >= 10000){
				cls_oled(OLED_BLACK);
				BlankScreen = 0;
				ScreenSaver = FALSE;
	    	} 
	    }	
	}
 }
 function DisplayMenu(activeString,previousString,nextString){

	if(ModORVal[0] == activeString){ 
		String(MainMenuId[activeString]  ,Medium,-8,0);
		String(MainMenuId[previousString],Small,-23,0);
		String(MainMenuId[nextString]    ,Small,8,0);
	}
} 

/*
============================================================================================================================================
 Main Menu                                                                                                                      
============================================================================================================================================
*/
int ModORVal[3],ModOrEditMenu[4],DisplayMenu;
// This is the main menu, 
const string MainMenuId[] = {
"GamepadTest",
"Oled Test",
"Led Test",
"Calculator",// 4
"Zen Games",// 5
"32 Bit GPC", // 6   
""};
const uint8  ModRange   [][]   = { 
{   0 ,  6 , 1}, // Main  0 \\//                       
{   7 , 11 , 1}, // Main  1 \\//                                  
{  12 , 14 , 1}, // Main  2 \\// 
{  15 , 15 , 1}, // Main  3 \\//
{  16 , 17 , 1}, // Main  4 \\//
{  18 , 18 , 1}  // Main  5 \\//
};
const string ModNames[] = {
	"Button Test","Anologue Test","Trigger Test","TouchPad Test","Gyro/Acc Test","Rumble Test","Battery Status", 
//        0             1                2              3               4               5              6      \\
	"Screen Test 1","Screen Test 2","ScreenSaver 1","ScreenSaver 2","ASCII Viewer",
//        7                8               9               10            11                                           
	"Batts LED Race","Manual LED Adjust","@ME RGB LEDs",
//        12                13                 14             
	"ZEN Calculator", 
//        15           
	"ZEN Snake","Ping Pong",
//      16           17                                          	
    "32 bit GetPolar()",
//      18
""}
/*
============================================================================================================================================
 Mod Menu                                                                                                                      
============================================================================================================================================
*/
// All Variables for Toggles/Mods For Mod Menu \\
const uint8 ModsNToggles[][] = {
// ModIdx - ValRangeMin - ValRangeMax - Editable - 
//    0         1              2            3                   
{     0   ,     0       ,      0      ,     0    },
{     1   ,     0       ,      0      ,     0    },
{     2   ,     0       ,      0      ,     0    },
{     3   ,     0       ,      0      ,     1    },
{     4   ,     1       ,      1      ,     1    },
{     5   ,     0       ,      0      ,     0    },
{     6   ,     0       ,      0      ,     0    },
{     7   ,     2       ,      2      ,     1    },
{     8   ,     3       ,      3      ,     1    },
{     9   ,     4       ,      4      ,     1    },
{    10   ,     5       ,      5      ,     1    },
{    11   ,     0       ,      0      ,     0    },
{    12   ,     6       ,      6      ,     1    },
{    13   ,     0       ,      0      ,     0    },
{    14   ,     0       ,      0      ,     0    },
{    15   ,     7       ,      7      ,     1    },
{    16   ,     8       ,      8      ,     1    },
{    17   ,     9       ,      9      ,     1    },
{    18   ,     0       ,      0      ,     0    } 
}
/*                                                                                        
============================================================================================================================================
  Display Menu & Strings                                                                                                                           
============================================================================================================================================
*/                                                                                                
const string Misc[] = {"Test Options","Press Cross/A","To Activate","Press Up/Down","Rainbow Flow LEDs","Press Any Button",""};
 //                          0               1              2              3                   

/*                                                                                                
============================================================================================================================================
  Display Title                                                                                                                           
============================================================================================================================================
*/                                                                                                
int DisplayTitle;                                                                          
int ScreenSaver,BlankScreen                                                                       
/*
============================================================================================================================================
  Menu Naviation ()                                                                                                                      
============================================================================================================================================
*/
function MenuNavigation(f_index,f_min,f_max) {
	if(!get_val(PS4_L2))
	{
		if(ModOrEditMenu[0]) 
	    {
	    	f_index = MultiFunction(PS4_DOWN,PS4_UP,f_index,1,f_min,f_max); 
		}
		
		if(!ModOrEditMenu[0])
		{
			f_index = MultiFunction(PS4_RIGHT,PS4_LEFT,f_index,1,f_min,f_max); 
	    }
	}
	 
    if(event_release(PS4_CROSS))
	{
		if(ModOrEditMenu[0]) 
		{
    		if(ModRange[ModORVal[0]][2] != 0)  
			{
				MenuStatus(1,0,1,0,0,0);
				ModORVal[1] = ModRange[ ModORVal[0] ][ 0 ]; 
			} 
	    }
	}
	
	if(event_press(PS4_CROSS))
	{
		if(ModOrEditMenu[1]) 
		{
			if(ModsNToggles[ModORVal[1]][3] != 0) 
			{
				MenuStatus(1,0,0,1,0,0);
				ModORVal[2] = ModsNToggles[ ModORVal[1] ][ 1 ];
				menuOptions = 3;
				snakeState = TITLE;
			}
		}
    }
    if(event_release(PS4_CIRCLE) && !ModOrEditMenu[0])
    {
    	if(ModOrEditMenu[1]) 
    	{
    		MenuStatus(1,1,0,0,0,0);
    		
		}
		else if(ModOrEditMenu[2]) 
		{
			MenuStatus(1,0,1,0,0,0);
		}
	}
	return f_index; 
}
int incs = 1, dec, colors[3];
const string Rgb[] = {"Red LED","Green LED","Blue LED",""}; 
const string GetPolar[] = {"Angle","Radius",""}; 
int RgbSelector;
int Ascii;
int Radius,Angle;
int X_POS1;
int Y_POS1;
int X_POS2;
int Y_POS2;
int COLOUR = 1;
combo RACE_1 {
  X_POS1 = random(1,128); 
  Y_POS1 = random(1,64);
  X_POS2 = random(1,128);
  Y_POS2 = random(1,64);
}
const string DETAILS = "Specification"; 
const string CONSOLE = "Console:";
const string CONTROLLER = "Controller:";
const string PS4 ="PS4";
const string XB1 = "XB1";
 function DisplayController() {
	rect_oled(0, 0, OLED_WIDTH, OLED_HEIGHT, OLED_BLACK, OLED_WHITE);//rect_oled(2,1,127,52,1,0); 
	print(20,4,0,1,DETAILS[0]);
	print(5,20,0,1,CONSOLE[0]);
	print(5,35,0,1,CONTROLLER[0]);
	if(get_console() == PIO_PS4) {
	    print(sizeof(CONSOLE) * 7 + 1,20,0,1,PS4[0]);
	}else if(get_console() == PIO_XB1) {
		print(sizeof(CONSOLE) * 7 + 1,20,0,1,XB1[0]); 
	}
	if(get_controller() == PIO_PS4) {
		print(sizeof(CONTROLLER) * 7 + 1,35,0,1,PS4[0]); 
	}else if(get_controller() == PIO_XB1) {
		print(sizeof(CONTROLLER) * 7 + 1,35,0,1,XB1[0]); 
	}
} 
int button_id[4];
int button_idx,buffer_idx,idx_count;
int j;
function ControllerTest(){ 
	
	 	button_idx = get_button();
        if(button_idx) {
            rect_oled(5,26,117,20,TRUE,0);
            idx_count = button_idx;
            buffer_idx = 1;
            for(j = 0; j <  button_idx; j++) {
        		for(i = 1; i <= BUTTON[button_id[j]][0]; i++) {
        	    	putc_oled(buffer_idx,BUTTON[button_id[j]][i]);
        	    	buffer_idx++;
        		}
        		idx_count--;
        		if(idx_count) {
        		    putc_oled(buffer_idx,32);
        			buffer_idx++;
        		}
        	}
        	puts_oled((OLED_WIDTH / 2) - (buffer_idx * 11 / 2),27,1,buffer_idx - 1,1);
        }
        else{
           	rect_oled(5,26,117,20,TRUE,0);
        } 
        if(!button_idx){ 
        	print(9,32,0,1,Misc[5]);
        }
    }
int btn_idx;
function get_button() {
    btn_idx = 0;
	for(i = 0; i <= 20; i++) {
	    if(abs(get_val(i)) > 10) {
	        set_val(i,0);
	    	button_id[btn_idx] = i;    
            btn_idx++;
            if(btn_idx > 4) {
                break;
            }
        }
    }
    return btn_idx;
}



const uint8 BUTTON[][] = {
	{4, _X, _B, _O, _X,  0},
	{4, _V, _I, _E, _W,  0},
	{4, _M, _E, _N, _U,  0},
	{2, _R, _B,  0,  0,  0},
	{2, _R, _T,  0,  0,  0},
	{2, _R, _S,  0,  0,  0},
	{2, _L, _B,  0,  0,  0},
	{2, _L, _T,  0,  0,  0},
	{2, _L, _S,  0,  0,  0},
	{2, _R, _X,  0,  0,  0},
	{2, _R, _Y,  0,  0,  0},
	{2, _L, _X,  0,  0,  0},
	{2, _L, _Y,  0,  0,  0},
	{2, _U, _P,  0,  0,  0},
	{4, _D, _O, _W, _N,  0},
	{4, _L, _E, _F, _T,  0},
	{5, _R, _I, _G, _H, _T},
	{1, _Y,  0,  0,  0,  0},
	{1, _B,  0,  0,  0,  0},
	{1, _A,  0,  0,  0,  0},
	{1, _X,  0,  0,  0,  0} 
};
int X[8], Y[8];
int x1[4], y1[4];
int tick;
int i, n;
function DoNotAtMeDial(){
tick = (tick + 1) % 360; 
do {
    i = (i + 1) % 360;
    set_polar(2, (i + (45 * n)) % 360, 30);
    X[n] = get_val(POLAR_RX) + 32;
    Y[n] = get_val(POLAR_RY) + 32;
    pixel_oled(X[n], Y[n], 1);
    pixel_oled(Y[n], X[n], 1);
} while(n = (n + 1) % 8);
  line_oled(5, 32, 60, 32, 1, 1)
  line_oled(32, 5, 32, 60, 1, 1)
  set_polar(2, tick, 30);
  x1 = get_val(POLAR_RX) + 32;
  y1 = get_val(POLAR_RY) + 32;
  line_oled(x1 + 1, y1, x1[3] + 1, 31, 3, 0);
  line_oled(x1 + 2, y1, x1[3] + 2, 31, 2, 1);
  line_oled(x1 + 3, y1, x1[3] + 3, 31, 1, 0);
  line_oled(x1 [1], y1[1], 30, 30, 3, 0);
  x1[1] = x1- 1;
  y1[1] = y1- 1;
  line_oled(x1, y1,  31, 31, 2, 1);
  line_oled(x1 + 1, y1 + 1,  32, 32, 1, 0);
  rect_oled(x1[2], y1[2], 6, 6, 1, 0);
  x1[2] = x1;
  y1[2] = y1;
  rect_oled(x1, y1, 5, 5, 0, 1);
  rect_oled(30, y1[3], 6, 6, 1, 0);
  y1[3] = y1;
  rect_oled(30, y1, 5, 5, 0, 1);
  rect_oled(x1[3], 31, 6, 6, 1, 0);
  x1[3] = x1;
  rect_oled(x1, 31, 5, 5, 0, 1);
  line_oled(x1, y1 + 1,32, y1[3] + 1, 3, 0);
  line_oled(x1, y1 + 2,32, y1[3] + 2, 2, 1);
  line_oled(x1, y1 + 3,32, y1[3] + 3, 1, 0);
} 
int XDOT, YDOT, XDOTA,YDOTA,set_rect;
function RectScreenTest(){  
cls_oled(0);
if (XDOT < 1) XDOT = 127;          
if (YDOT < 1) YDOT = 63;   
if (XDOTA < 1) XDOTA = 127;   
if (YDOTA < 1) YDOTA = 63; 
	combo_run (SPREAD);     
    combo_run(SPREAD1); 
}
combo SPREAD {
  XDOT = random(1,128); 
  YDOT = random(1,64);
  wait (1500 );
  cls_oled(0);
}
combo SPREAD1 {
  rect_oled(YDOT,XDOT,YDOTA,XDOTA,0,WHITE);   
  wait (1500);
  rect_oled(XDOTA,YDOT,XDOTA,YDOT,0,WHITE - 1);
  wait (1500);         
  cls_oled(0);
  DisplayMenu = TRUE;
}
//int set_screen;
const string RED = "Red";
const string GREEN = "Green";
const string BLUE = "Blue";
int colorCycleRed;
int colorCycleGreen = 255;
int colorCycleBlue;
int colorCycleTime;
int colorCycleCycle = 1;
int colorCycleDelay = 10;
int colorCycleColorRate = 1;
int colorCycleTimeRate = 60;
function led_color_cycle() {
    colorCycleTime += get_rtime();
    if(colorCycleTime >= colorCycleDelay) {
        ClearRect();
        colorCycleTime = 0;
  if(colorCycleCycle == 1) {
      if(colorCycleRed < 255) {
          colorCycleRed += colorCycleColorRate;            //--red cycles up to max (red & green max)
         }else if(colorCycleGreen > 0) {
             colorCycleGreen -= colorCycleColorRate;       //--green cycles down
         }else if(colorCycleBlue < 255) {
             colorCycleBlue += colorCycleColorRate;       //--blue cycles up
         }else{
             colorCycleCycle = 2;                 //--blue & red @ max
         }
  }
     if(colorCycleCycle == 2) {
         if(colorCycleRed > 0) {
             colorCycleRed -= colorCycleColorRate;             //--red cycles down
         }else if(colorCycleGreen < 255) {
             colorCycleGreen += colorCycleColorRate;    //--green cycles up (blue & green @ max)
         }else if(colorCycleBlue > 0) {
             colorCycleBlue -= colorCycleColorRate;        //--blue cycles down
         }else{ 
             colorCycleCycle = 3;
         }
     }
     if(colorCycleCycle == 3) {
      if(colorCycleRed < 255 && colorCycleGreen == 255) {     //--red & blue cycle up 
          colorCycleRed += colorCycleColorRate;               //--red/green/blue @ max      
             colorCycleBlue += colorCycleColorRate;
         }else if(colorCycleBlue > 0) {
          colorCycleBlue -= colorCycleColorRate;    
          colorCycleGreen -= colorCycleColorRate;
          colorCycleRed -= colorCycleColorRate;
         }else if(colorCycleGreen < 255) {
             colorCycleGreen += colorCycleColorRate;
             if(colorCycleGreen == 1) {
                 colorCycleDelay += colorCycleTimeRate;
                 if(colorCycleDelay  <  0) { 
                     colorCycleDelay = 20;
                     colorCycleTimeRate = inv(colorCycleTimeRate);
                 }   
                 if(colorCycleDelay  > 60) {     
                  colorCycleDelay = 40;   
                  colorCycleTimeRate = inv(colorCycleTimeRate);
                 }
             }
             if(colorCycleGreen == 255) {
              colorCycleCycle = 1; 
             }
   } 
     }
     set_rgb(colorCycleRed,colorCycleGreen,colorCycleBlue); 
 
 }
} 
///////////////////
function ClearRect() {
 rect_oled(11,(63 - (colorCycleRed / 5)) - 12,21,10,TRUE,0);
 rect_oled(46,(63 - (colorCycleGreen / 5)) - 12,35,10,TRUE,0);
 rect_oled(91,(63 - (colorCycleBlue / 5)) - 12,28,10,TRUE,0);
 rect_oled(11,63 - (colorCycleRed / 5),21,colorCycleRed / 5,TRUE,0); //--red
 rect_oled(53,63 - (colorCycleGreen / 5),21,colorCycleGreen / 5,TRUE,0); //--green
 rect_oled(95,63 - (colorCycleBlue / 5),21,colorCycleBlue / 5,TRUE,0); //--blue   
// set_screen = TRUE;
}
function BattsOledRace(){ 
cls_oled(0);
led_color_cycle();
vm_tctrl ( colorCycleCycle / 10 );
print(11,(63 - (colorCycleRed / 5)) - 12,0,1,RED[0]);
print(46,(63 - (colorCycleGreen / 5)) - 12,0,1,GREEN[0]);
print(91,(63 - (colorCycleBlue / 5)) - 12,0,1,BLUE[0]);
rect_oled(11,63 - (colorCycleRed / 5),21,colorCycleRed  / 5,TRUE,1);  //--red
rect_oled(53,63 - (colorCycleGreen / 5),21,colorCycleGreen / 5,TRUE,1); //--green
rect_oled(95,63 - (colorCycleBlue / 5),21,colorCycleBlue / 5,TRUE,1); //--green//--blue
//set_screen = FALSE;
} 
int batteryLevel;
int batteryChargingCounter = 0;
int batteryLevelBarOffset;
int batteryLevelIndex;
int count_battery // for battery warning
function drawBattery(f_level) {
	rect_oled(1, 25, 120, 3, 0, 1);  // Top rect_oled(1, 39, 120, 3, 0, 1);  // Top
	rect_oled(1, 45, 120, 3, 0, 1);  // Bottom
	rect_oled(1, 28, 3, 18, 0, 1);   // Left side
	rect_oled(118, 28, 3, 18, 0, 1); // Right side	
	rect_oled(121, 30, 5, 11, 0, 1); // Right side extension
	rect_oled(6, 42, 110, 19, 0, 0); // Clear center
	batteryLevelBarOffset = 8;
	for(batteryLevelIndex = 0; batteryLevelIndex < f_level; batteryLevelIndex++)
	{
		rect_oled(batteryLevelBarOffset, 30, 7, 13, 1, 1); // Fill center with battery level
		batteryLevelBarOffset += 11; // Move offset for the next bar by width of current + 4 pixels
	}
}
int RT,MSC,SD1,DGT,DGR,TP1,TP2;
int X_1,Y_1,X_2,Y_2,X_3,Y_3, X_4,Y_4,X_5,Y_5,X_6,Y_6,X_7,Y_7,X_8,Y_8,RN1,RN2,RN3,RN4,RN5,RN6,RN7,RN8;
define SSA1 = 67,SSA2 = 82,SSA3 = 79 ,SSA4 = 78 ,SSA5 = 85,SSA6 = 83,SSA7 = 32, SSA8 = 90,SSA9 = 69,SSA10 = 78,SSA11 = 70,SSA12 = 82,SSA13 = 50,SSA14 = 49,SAVER = 5000,SAVER1 = 10;
int SSMU1 = 1;int SSMU2 = 8;int SSMU3 = 15;int SSMU4 = 22;int SSMU5 = 29;int SSMU6 = 36;
int SSMU7 = 43;int SSMU8 = 50;int SSMU9 = 57;int SSMU10 = 64;
combo RACE {
	X_1 = random(0,127);
	wait(SAVER1);
	X_2 = random(0,127);
	wait(SAVER1);
	X_3 = random(0,127);
	wait(SAVER1);
	X_4 = random(0,127);
	wait(SAVER1); 
	X_5 = random(0,127);
	wait(SAVER1);
	X_6 = random(0,127);
	wait(SAVER1); 
	X_7 = random(0,127);
	wait(SAVER1); 
	X_8 = random(0,127);
	wait(SAVER1);
}
combo RN {
	RN1 = random(65,90);
	RN2 = random(60,90);
	RN3 = random(65,90);
	RN4 = random(65,90); 
	RN5 = random(65,90);
	RN6 = random(65,90);
	RN7 = random(65,90);
	RN8 = random(65,90);
	wait(SAVER);
}
function name(){
	cls_oled(0);
	combo_run(RACE);
	combo_run(RN);
if (Y_1 > 64)  Y_1 =   0;
if (Y_2 > 64)  Y_2 =   0;
if (Y_3 > 64)  Y_3 =   0;
if (Y_4 > 64)  Y_4 =   0;
if (Y_5 > 64)  Y_5 =   0;
if (Y_6 > 64)  Y_6 =   0;
if (Y_7 > 64)  Y_7 =   0;
if (Y_8 > 64)  Y_8 =   0;
if (SD1 > 105) SD1 = -50;
if (TP1 > 45)  TP1 =   0;
if (TP2 < 0)   TP2 =  55;
	putc_oled(1,RN1);
	puts_oled(X_1,Y_1,0,1,1);
	putc_oled(1,RN2);
	puts_oled(X_2,Y_2,0,1,1);
	putc_oled(1,RN3);
	puts_oled(X_3,Y_3,0,1,1);
	putc_oled(1,RN4);
	puts_oled(X_4,Y_4,0,1,1);
	putc_oled(1,RN5);
	puts_oled(X_5,Y_5,0,1,1);
	putc_oled(1,RN6);
	puts_oled(X_6,Y_6,0,1,1);
	putc_oled(1,RN7);
	puts_oled(X_7,Y_7,0,1,1);
	putc_oled(1,RN8);
	puts_oled(X_8,Y_8,0,1,1);
	
	putc_oled(1,SSA1);
	puts_oled(SSMU1 + SD1,TP1 + 2,0,1,1);
	
	putc_oled(1,SSA2);
	puts_oled(SSMU2 + SD1,TP2 + 4,0,1,1);
	
	putc_oled(1,SSA3);
	puts_oled(SSMU3 + SD1,TP1 + 6,0,1,1);
	
	putc_oled(1,SSA4);
	puts_oled(SSMU4 + SD1,TP2 + 8,0,1,1);
	
	putc_oled(1,SSA5);
	puts_oled(SSMU5 + SD1,TP1 + 10,0,1,1);
	
	putc_oled(1,SSA6);
	puts_oled(SSMU6 + SD1,TP2 + 12,0,1,1);
	
	putc_oled(1,SSA7);
	puts_oled(SSMU7 + SD1,TP1 + 14,0,1,1);
	
	putc_oled(1,SSA8);
	puts_oled(SSMU8 + SD1,TP2 + 16,0,1,1);
	
	putc_oled(1,SSA9);
	puts_oled(SSMU9 + SD1,TP1 + 18,0,1,1);
	
	putc_oled(1,SSA10);
	puts_oled(SSMU10 + SD1,TP2 + 20,0,1,1);
		 
}
const string ControllerBtns[] ={"LX","LY","RX","RY","L2","R2","LT","RT",""};
const string RumbleNotifier[] ={"Rumble A","Rumble B","Rumble LT","Rumble RT",""}; 
int LX,LY,RY,RX; 
int R2,L2;
int RumbleType,RumbleStrength; 
int ConditionOne,ConditionTwo,Equals; 
int HighLight,TotalSum;
const string EDIT = "Press A for result";
 function Calculator(){
	if(event_press(PS4_RIGHT)){ 
		HighLight = clamp(HighLight + 1,0,2);
		DisplayMenu = TRUE;
	} 
	if(event_press(PS4_LEFT)){ 
		HighLight = clamp(HighLight - 1,0,2);
		DisplayMenu = TRUE;
	} 
	if(HighLight == 0){ 
		if(event_press(PS4_UP) || get_val(PS4_UP) && get_ptime(PS4_UP) > 300){ 
			ConditionOne = clamp(ConditionOne + 1,-100,100);
			DisplayMenu = TRUE;
		}
		if(event_press(PS4_DOWN) || get_val(PS4_DOWN) && get_ptime(PS4_DOWN) > 300){  
			ConditionOne = clamp(ConditionOne - 1,-100,100);
			DisplayMenu = TRUE;
		}
	}
	if(HighLight == 1){ 
		if(event_press(PS4_UP) || get_val(PS4_UP) && get_ptime(PS4_UP) > 300){ 
			TotalSum = clamp(TotalSum + 1,0,3);
			DisplayMenu = TRUE;
		}
		if(event_press(PS4_DOWN) || get_val(PS4_DOWN) && get_ptime(PS4_DOWN) > 300){  
			TotalSum = clamp(TotalSum - 1,0,3);
			DisplayMenu = TRUE;
		}
	} 
	if(HighLight == 2){ 
		if(event_press(PS4_UP) || get_val(PS4_UP) && get_ptime(PS4_UP) > 300){ 
			ConditionTwo = clamp(ConditionTwo + 1,-100,100);
			DisplayMenu = TRUE;
		}
		if(event_press(PS4_DOWN) || get_val(PS4_DOWN) && get_ptime(PS4_DOWN) > 300){  
			ConditionTwo = clamp(ConditionTwo - 1,-100,100);
			DisplayMenu = TRUE;
		}
	}	
	if(event_press(PS4_CROSS)){ 
		if(TotalSum == 0) Equals = ConditionOne + ConditionTwo;
		if(TotalSum == 1) Equals = ConditionOne - ConditionTwo;
		if(TotalSum == 2) Equals = ConditionOne * ConditionTwo;
		if(TotalSum == 3) Equals = ConditionOne / ConditionTwo;
		DisplayMenu = TRUE;
	} 
	if(event_press(PS4_SQUARE)){ 
		Equals = 0;
		DisplayMenu = TRUE;
	} 	
	set_val(TRACE_1,Equals);
} 
/*
============================================================================================================================================
  One Function For All Menu Button Navigation (Including Toggles/Edit Vals)  ()                                                                                                                      
============================================================================================================================================
*/
function MultiFunction(Inc,Dec,Value,Adjust,Min,Max){  
    
    if(event_press(Inc) || get_ival(Inc) && get_ptime(Inc) > 250){
    	Value += Adjust
    	DisplayMenu = TRUE;
    	if(Value > Max) 
    		return Min;
  
    	if(!Value)
	        combo_run(RumbleOff);
	    else
	        combo_run(RumbleOn);  
    }
    if(event_press(Dec) || get_ival(Dec) && get_ptime(Dec) > 250){
    	Value -= Adjust
    	DisplayMenu = TRUE;
    
    	if(Value < Min)
    		return Max;
    		
    	if(!Value)
	        combo_run(RumbleOff);
	    else
	        combo_run(RumbleOn);  
    }
    set_val(Inc,0); set_val(Dec,0);
    return Value; 
}
function MenuStatus(f_display,f_mainmenu,f_modmenu,f_editmenu,f_adjustables,f_displaytitle) { 

    DisplayMenu      = f_display;
	ModOrEditMenu[0] = f_mainmenu;
	ModOrEditMenu[1] = f_modmenu;
	ModOrEditMenu[2] = f_editmenu;
	ModOrEditMenu[3] = f_adjustables;
	DisplayTitle     = f_displaytitle;
	
} 
function Refresh(Value,Min,Max){  
 	
    if(Value > Max) return Min;
    if(Value < Min) return Max;  
   		   
    return Value; 
}


 /*
============================================================================================================================================
  Combo Section ()                                                                                                                      
============================================================================================================================================
*/
combo rgb {
  wait(1);
  set_rgb(colors, colors[1], colors[2]);
  colors[dec] --; colors[incs] ++;
  if(!colors[dec]) { incs = (incs + 1) % 3; dec = (dec + 1) % 3; }
}
combo RumbleOn {
set_ledx(2, 2);
set_rumble(RUMBLE_B, 50);
wait(150);
reset_rumble();
wait(100);
set_rumble(RUMBLE_B, 50);
wait(150);
reset_rumble();
reset_leds();
}
combo RumbleOff {						
set_ledx(3,1);
set_rumble(RUMBLE_A, 50);
wait(300);
reset_rumble();
wait(400);
reset_leds();
}
/*
============================================================================================================================================
  Print String Functions ()                                                                                                                      
============================================================================================================================================
*/ 
define Small  = 0;
define Medium = 1;
define Large  = 2;
int stringPosition,stringHeight; 
int stringLength;
function String (stringLabel,fontSize,offsetY,offsetX) {
    
    if (fontSize == Small) {
        stringPosition = (127 - get_string_length(stringLabel) * 7) / 2;
        stringHeight = (64 - 10) / 2;
    } 
    
    else if (fontSize == Medium) {
        stringPosition = (127 - get_string_length(stringLabel) * 10) / 2;
        stringHeight = (64 - 16) / 2;
    }
    
    else if (fontSize == Large) {
        stringPosition = (127 - get_string_length(stringLabel) * 15) / 2;
        stringHeight = (64 - 21) / 2;
    }
    Print(stringPosition,stringHeight,stringLabel,fontSize,offsetY,offsetX);
}
function get_string_length(offset) { 
    stringLength = 0;
    do { 
        offset++;
        stringLength++;
    } while (duint8(offset));
    return stringLength;
}
function Print (positionString,heightString,captionString,sizeFont,offSetY,offSetX) {
    
        print(positionString + offSetX,heightString + offSetY,sizeFont,1,captionString);
}
/*
============================================================================================================================================
  NumberToString ()                                                                                                                      
============================================================================================================================================
*/   
int bufferIndex;
int charIndex,digitIndex;
function NumberToString(f_val,f_digits,f_centerx,f_centery,f_font) {
    bufferIndex = 1;  
    digitIndex = 10000;
    if(f_val < 0) {                    //--neg numbers
         putc_oled(bufferIndex,45);    //--add leading "-"
         bufferIndex += 1;
         f_val = abs(f_val);
    } 
    for(charIndex = 5; charIndex >= 1; charIndex--) {
        if(f_digits >= charIndex) {
            putc_oled(bufferIndex,(f_val / digitIndex) + 48);
            f_val %= digitIndex;
            bufferIndex ++; 
            if(charIndex == 4) {
                putc_oled(bufferIndex,44);//--add ","
                bufferIndex ++;
            }
        }
        digitIndex /= 10;
    } 
     puts_oled(f_centerx,f_centery,f_font,bufferIndex - 1,OLED_WHITE); // adjustable value centered in X
   
} 
int logVal;
function FindDigits(num) {
   logVal = 0;
   do {
      num /= 10;
      logVal++;
   } while (num);
   return logVal;
}
/*
============================================================================================================================================
  LED Lights ()                                                                                                                      
============================================================================================================================================
*/ 
// Led's For Zen Eyes \\
data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );	

 /*
============================================================================================================================================
  Menu Scroll ()                                                                                                                      
============================================================================================================================================
*/
int introScrollTimer, introScrollPauseTime;
int introScrollTextOffset;
int introScrollTextIndex;
int introScrollCharIndex = 1;

function MenuScroll() {
    introScrollTimer += get_rtime();
    if(introScrollTimer >= introScrollPauseTime) {
        introScrollPauseTime = 30;
        for (introScrollTextIndex = 1; introScrollTextIndex <= 18; introScrollTextIndex++) {
            if (introScrollTextIndex + introScrollTextOffset >= sizeof(MENU_SCROLL_TEXT)) {
                putc_oled(introScrollTextIndex, MENU_SCROLL_TEXT[introScrollTextIndex + (introScrollTextOffset - sizeof(MENU_SCROLL_TEXT))]);
            }
            else {
                putc_oled(introScrollTextIndex, MENU_SCROLL_TEXT[introScrollTextIndex + introScrollTextOffset]);
            }
        }
        puts_oled(1, 53,OLED_FONT_SMALL, introScrollTextIndex, OLED_WHITE);
        introScrollTextOffset++;
        if (introScrollTextOffset >= sizeof(MENU_SCROLL_TEXT)) {
            introScrollTextOffset = 0;
        }
        introScrollCharIndex--;
        if (introScrollCharIndex < 1) {
            introScrollCharIndex = 18;
            introScrollPauseTime = 2000;

        }
        introScrollTimer = 0;
    }
}
function IntroScroll() {
    introScrollTimer += get_rtime();
    if(introScrollTimer >= introScrollPauseTime) {
        introScrollPauseTime = 30;
        for (introScrollTextIndex = 1; introScrollTextIndex <= 18; introScrollTextIndex++) {
            if (introScrollTextIndex + introScrollTextOffset >= sizeof(INTRO_SCROLL_TEXT)) {
                putc_oled(introScrollTextIndex, INTRO_SCROLL_TEXT[introScrollTextIndex + (introScrollTextOffset - sizeof(INTRO_SCROLL_TEXT))]);
            }
            else {
                putc_oled(introScrollTextIndex, INTRO_SCROLL_TEXT[introScrollTextIndex + introScrollTextOffset]);
            }
        }
        puts_oled(1, 53,OLED_FONT_SMALL, introScrollTextIndex, OLED_WHITE);
        introScrollTextOffset++;
        if (introScrollTextOffset >= sizeof(INTRO_SCROLL_TEXT)) {
            introScrollTextOffset = 0;
        }
        introScrollCharIndex--;
        if (introScrollCharIndex < 1) {
            introScrollCharIndex = 18;
            introScrollPauseTime = 2000;

        }
        introScrollTimer = 0;
    }
}
const uint8 MENU_SCROLL_TEXT[] = {
//    1			2		   3	4	     5		    6		 7		  8		    9      10	     11	     12		  13	   14		 15		  16		17        18
     _space, _left,	   _space,  _o,       _r,   _space, _right,  _space,      _t,	    _o,      _space,    _c,    _h,       _a,      _n,      _g,    _e,      _space,          
      
     _space,   _up,    _space,  _o,	      _r,   _space, _down,	 _space,	  _t,       _o,    	 _space,    _c,    _h,       _a,      _n,      _g,    _e,      _space,
     
     _space,   _P,    _r,  _e,   _s,      _s,   _space,	 _A,   _slash,	      _X,       _space,	    _t,      _o,    _space,	 _M,	  _e,		_n,      _u,
     
     _space, _space,  _O,        _slash,   _B, _space,     _T,       _o,       _space,       _E,    _x,      _i,      _t,    _space,    _M,     _e,        _n,     _u,
        
     _space,   _up,    _space,  _o,	      _r,   _space, _down,	 _space,	  _t,       _o,    	 _space,    _c,    _h,       _a,      _n,      _g,    _e,      _space,
     
     _space,   _T,	   _o,    _space,   _A,	    _d, _j,	      _u,	 _s,	_t,     _space,		   _R,	  _u,		 _m, 	     _b,	  _l,		_e,	     _space
     
};    
const uint8 INTRO_SCROLL_TEXT[] = {
//    1			2		3		4	   5		 6		 7		   8		  9		      10	     11		    12		  13		 14		     15		  16		17        18
     _space, _space,   _space, _H,	  _o,	    _l,		_d,	      _space,	 _L,	    _T, 	    _space,    _plus,	  _space,    _M,		 _E,      _N,	    _U,	     _space,
     _space, _space,   _o,	   _r,    _space,   _L,	    _2,	      _space,	 _plus,	    _space,     _O,		   _P,	      _T,		 _I, 	     _O,	  _N,		_S,	     _space,
     _space, _space,   _f,	   _o,     _r,    _space,     _G , _a, _m, _e,_p,_a,_d, _space,	 _M,	  _e,		_n,      _u 
};     

define  _0 = 48,   _A = 65,   _K = 75,   _U =  85,   _e = 101,   _o = 111,   _y       = 121,    _plus      = 43, _slash     = 47 , _dot     =  46;
define  _1 = 49,   _B = 66,   _L = 76,   _V =  86,   _f = 102,   _p = 112,   _z       = 122;
define  _2 = 50,   _C = 67,   _M = 77,   _W =  87,   _g = 103,   _q = 113,   _space   =  32;
define  _3 = 51,   _D = 68,   _N = 78,   _X =  88,   _h = 104,   _r = 114,   _bang    =  33;
define  _4 = 52,   _E = 69,   _O = 79,   _Y =  89,   _i = 105,   _s = 115,   _quote   =  34;
define  _5 = 53,   _F = 70,   _P = 80,   _Z =  90,   _j = 106,   _t = 116,   _hash    =  35;
define  _6 = 54,   _G = 71,   _Q = 81,   _a =  97,   _k = 107,   _u = 117,   _dollar  =  36;
define  _7 = 55,   _H = 72,   _R = 82,   _b =  98,   _l = 108,   _v = 118,   _percent =  37;
define  _8 = 56,   _I = 73,   _S = 83,   _c =  99,   _m = 109,   _w = 119,   _and     =  38;
define  _9 = 57,   _J = 74,   _T = 84,   _d = 100,   _n = 110,   _x = 120,   _tick    =  39;

define _left     = 133,   _right = 134,_up       = 131,_down     = 132,_cross    = 127, _circle   = 128, _triangle = 130;

const uint8  REFERENCE[] = {48,49,50,51,52,53,54,55,56,57};
const string TOUCH_THE_PAD   = "TOUCH THE PAD";
const string TILT_THE_PAD    = "TILT THE PAD";
const string FINGER1X_ ="X";
const string FINGER1Y_ ="Y";
const string FINGER1_  ="FINGER1";
const string FINGER2X_ ="X";
const string FINGER2Y_ ="Y";
const string FINGER2_  ="FINGER2";
const string GYROX_ ="GYROX";
const string GYROY_ ="GYROY";
const string GYROZ_ ="GYROZ";
const string ACCX_ ="ACCX";
const string ACCY_ ="ACCY";
const string ACCZ_ ="ACCZ";

define FINGER1X = PS4_FINGER1X, FINGER1Y = PS4_FINGER1Y, FINGER1 = PS4_FINGER1;
define FINGER2X = PS4_FINGER2X, FINGER2Y = PS4_FINGER2Y, FINGER2 = PS4_FINGER2;
define GYROX = PS4_GYROX, GYROY = PS4_GYROY, GYROZ = PS4_GYROZ;
define ACCX  =  PS4_ACCX,  ACCY =  PS4_ACCY,  ACCZ = PS4_ACCZ;

int ACTUALTL, ACTUALTR, ACTUALTRR;
int DIGITX1 = 18,DIGITX = 18,DIGITY1 = 22, DIGITY = 22, DIGITX2 = 18,DIGITY2 = 22,DIGITSIZE = 1; 
int DIGITSIZE1 = 1, DIGITSIZE2 = 1;
int FINGER1T = 1, FINGER2T = 0, ACC = 1,GYRO;
int COUNT = 1;
define NEG = 45;  
int NO = 1;
function TOUCHPAD ()  {
	cls_oled(0);
	rect_oled(1,1,127,63,0,1);
	rect_oled(4,3,121,59,0,1);
	line_oled(124,22,4,22,1,1);
	line_oled(124,44,4,44,1,1);
	print(16,10,0,1,TOUCH_THE_PAD[0]);	
	
	if (FINGER1T == TRUE) {
		print(25,49,0,1,FINGER1X_[0]);
		print(96,49,0,1,FINGER1Y_[0]);
		print(42,49,0,1,FINGER1_[0]);
	if (get_ival(FINGER1X)) {
		ACTUALTL = (get_val(FINGER1X));
		DIGITX = 15;
		DIGITY = 30;
		DIGITSIZE = 0;
		EDITNUMBER(ACTUALTL,find_digits(ACTUALTL));
	}
	if (get_ival(FINGER1Y)) {
		ACTUALTR = (get_val(FINGER1Y));
		DIGITX1 = 90;
		DIGITY1 = 30;
		DIGITSIZE1 = 0;
		EDITNUMBER1(ACTUALTR,NUMBER(ACTUALTR));
	}
	if (get_ival(FINGER1)) {
		ACTUALTRR = (get_val(FINGER1));
		DIGITX2 = 55;
		DIGITY2 = 30;
		DIGITSIZE2 = 0;
		EDITNUMBER2(ACTUALTRR,NUMBER2(ACTUALTRR));
		}
	}
	if (FINGER2T == TRUE) {
		print(25,49,0,1,FINGER2X_[0]);
		print(96,49,0,1,FINGER2Y_[0]);
		print(42,49,0,1,FINGER2_[0]);
	if (get_ival(FINGER2X)) {
		ACTUALTL = (get_val(FINGER2X));
		DIGITX = 15;
		DIGITY = 30;
		DIGITSIZE = 0;
		EDITNUMBER(ACTUALTL,find_digits(ACTUALTL));
	}
	if (get_ival(FINGER2Y)) {
		ACTUALTR = (get_val(FINGER2Y));
		DIGITX1 = 90;
		DIGITY1 = 30;
		DIGITSIZE1 = 0;
		EDITNUMBER1(ACTUALTR,NUMBER(ACTUALTR));
	}
	if (get_ival(FINGER2)) {
		ACTUALTRR = (get_val(FINGER2));
		DIGITX2 = 55;
		DIGITY2 = 30;
		DIGITSIZE2 = 0;
		EDITNUMBER2(ACTUALTRR,NUMBER2(ACTUALTRR));
		}
	}
}
function GYRO ()  {
	cls_oled(0);
	rect_oled(1,1,127,63,0,1);
	rect_oled(4,3,121,59,0,1);
	line_oled(124,22,4,22,1,1);
	line_oled(124,44,4,44,1,1);
	print(21,10,0,1,TILT_THE_PAD[0]);	
	if (GYRO == TRUE) {
		print(08,49,0,1,GYROX_[0]);
		print(87,49,0,1,GYROY_[0]);
		print(48,49,0,1,GYROZ_[0]);
	if (get_ival(GYROX)) {
		ACTUALTL = (get_val(GYROX));
		DIGITX = 20;
		DIGITY = 30;
		DIGITSIZE = 0;
		EDITNUMBER(ACTUALTL,find_digits(ACTUALTL));
	}
	if (get_ival(GYROY)) {
		ACTUALTR = (get_val(GYROY));
		DIGITX1 = 94;
		DIGITY1 = 30;
		DIGITSIZE1 = 0;
		EDITNUMBER1(ACTUALTR,NUMBER(ACTUALTR));
	}
	if (get_ival(GYROZ)) {
		ACTUALTRR = (get_val(GYROZ));
		DIGITX2 = 58;
		DIGITY2 = 30;
		DIGITSIZE2 = 0;
		EDITNUMBER2(ACTUALTRR,NUMBER2(ACTUALTRR));
		}
	}
	if (ACC == TRUE) {
		print(10,49,0,1,ACCX_[0]);
		print(90,49,0,1,ACCY_[0]);
		print(50,49,0,1,ACCZ_[0]);
	if (get_ival(ACCX)) {
		ACTUALTL = (get_val(ACCX));
		DIGITX = 20;
		DIGITY = 30;
		DIGITSIZE = 0;
		EDITNUMBER(ACTUALTL,find_digits(ACTUALTL));
	}
	if (get_ival(ACCY)) {
		ACTUALTR = (get_val(ACCY));
		DIGITX1 = 94;
		DIGITY1 = 30;
		DIGITSIZE1 = 0;
		EDITNUMBER1(ACTUALTR,NUMBER(ACTUALTR));
	}
	if (get_ival(ACCZ)) {
		ACTUALTRR = (get_val(ACCZ));
		DIGITX2 = 55;
		DIGITY2 = 30;
		DIGITSIZE2 = 0;
		EDITNUMBER2(ACTUALTRR,NUMBER2(ACTUALTRR));
		}
	}
}
function EDITNUMBER(DIGIT,FDIGIT) {
	if(DIGIT < 0) {
		putc_oled(NO,NEG);
		NO += 1;
		DIGIT = abs(DIGIT);
		COUNT = 1;
	}
	else COUNT = 0;
	if(FDIGIT == 4) {
		putc_oled(NO,REFERENCE[DIGIT / 1000]);
		DIGIT = DIGIT % 1000;
		NO +=  1;
	}
	if(FDIGIT >= 3) {
		putc_oled(NO,REFERENCE[DIGIT / 100]);
		DIGIT = DIGIT % 100;
		NO +=  1;
	}
	if(FDIGIT >= 2) {
		putc_oled(NO,REFERENCE[DIGIT / 10]);
		DIGIT = DIGIT % 10;
		NO += 1;
	}
		putc_oled(NO,REFERENCE[DIGIT]);
		puts_oled(DIGITX,DIGITY,DIGITSIZE,NO,1);    
		NO = 1;
	
		putc_oled(NO,REFERENCE[DIGIT]);
} 
function find_digits(f_num) {
    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
} 
function EDITNUMBER1(DIGIT,FDIGIT) {
	if(DIGIT < 0) {
			putc_oled(NO,NEG);
			NO += 1;
			DIGIT = abs(DIGIT);
			COUNT = 1;
		}
	else COUNT = 0;
	if(FDIGIT == 4) {
			putc_oled(NO,REFERENCE[DIGIT / 1000]);
			DIGIT = DIGIT % 1000;
			NO +=  1;
		}
	if(FDIGIT >= 3) {
			putc_oled(NO,REFERENCE[DIGIT / 100]);
			DIGIT = DIGIT % 100;
			NO +=  1;
		}
	if(FDIGIT >= 2) {
			putc_oled(NO,REFERENCE[DIGIT / 10]);
			DIGIT = DIGIT % 10;
			NO += 1;
		}
			putc_oled(NO,REFERENCE[DIGIT]);
			puts_oled(DIGITX1,DIGITY1,DIGITSIZE1,NO,1);    
			NO = 1;
} 
	function NUMBER(NUM) {
    		NUM = abs(NUM);
    if(NUM / 1000 > 0) return 4;
    if(NUM /  100 > 0) return 3;
    if(NUM /   10 > 0) return 2;
    return 1;
}    
function EDITNUMBER2(DIGIT,FDIGIT) {
	if(DIGIT < 0) {
			putc_oled(NO,NEG);
			NO += 1;
			DIGIT = abs(DIGIT);
			COUNT = 1;
		}
	else COUNT = 0;
	if(FDIGIT == 4) {
			putc_oled(NO,REFERENCE[DIGIT / 1000]);
			DIGIT = DIGIT % 1000;
			NO +=  1;
		}
	if(FDIGIT >= 3) {
			putc_oled(NO,REFERENCE[DIGIT / 100]);
			DIGIT = DIGIT % 100;
			NO +=  1;
		}
	if(FDIGIT >= 2) {
			putc_oled(NO,REFERENCE[DIGIT / 10]);
			DIGIT = DIGIT % 10;
			NO += 1;
		}
			putc_oled(NO,REFERENCE[DIGIT]);
			puts_oled(DIGITX2,DIGITY2,DIGITSIZE2,NO,1);    
			NO = 1;
} 
	function NUMBER2(NUM) {
    		NUM = abs(NUM);
    if(NUM / 1000 > 0) return 4;
    if(NUM /  100 > 0) return 3;
    if(NUM /   10 > 0) return 2;
    return 1;
} 
 // --- ASCII Definitions ---
define  AC_space = 32, AC_bang = 33, AC_quote = 34, AC_hash = 35, AC_dollar = 36, AC_percent = 37, AC_and = 38, AC_tick = 39, AC_open = 40, AC_close = 41, AC_star = 42, AC_plus = 43, AC_comma = 44,
AC_minus = 45, AC_stop = 46, AC_slash = 47, AC_0 = 48, AC_1 = 49, AC_2 = 50, AC_3 = 51, AC_4 = 52, AC_5 = 53, AC_6 = 54, AC_7 = 55, AC_8 = 56, AC_9 = 57, AC_colon = 58, AC_semicolon = 59, AC_lt = 60, 
AC_equals = 61, AC_gt = 62, AC_question = 63, AC_at = 64, AC_A = 65, AC_B = 66, AC_C = 67, AC_D = 68, AC_E = 69, AC_F = 70, AC_G = 71, AC_H = 72, AC_I = 73, AC_J = 74, AC_K = 75, AC_L = 76, AC_M = 77, 
AC_N = 78, AC_O = 79, AC_P = 80, AC_Q = 81, AC_R = 82, AC_S = 83, AC_T = 84, AC_U = 85, AC_V = 86, AC_W = 87, AC_X = 88, AC_Y = 89, AC_Z = 90, AC_opensquare = 91, AC_backslash = 92, AC_closesquare = 93, 
AC_hat = 94, AC_underscore = 95, AC_tick1 = 96, AC_a = 97, AC_b = 98, AC_c = 99, AC_d = 100, AC_e = 101, AC_f = 102, AC_g = 103, AC_h = 104, AC_i = 105, AC_j = 106, AC_k = 107, AC_l = 108, AC_m = 109, 
AC_n = 110, AC_o = 111, AC_p = 112, AC_q = 113, AC_r = 114, AC_s = 115, AC_t = 116, AC_u = 117, AC_v = 118, AC_w = 119, AC_x = 120, AC_y = 121, AC_z = 122, AC_opencurly = 123, AC_pipe = 124, 
AC_closecurly = 125, AC_tilda = 126;

// Font Stats
define F_WIDTH  = 0;
define F_HEIGHT = 1;
const uint8 FONT_STATS[][] = {
//   WIDTH  HEIGHT
	{7,     10 }, // Small
	{11,    18 }, // Medium
	{16,    26 }   // Large
};
// Colour
define BLACK = 0;
define WHITE = 1;
const string s_SNAKE      = "GAME MENU";
const string s_Play       = "Play";
const string s_Highscores = "Highscores";
const string s_Credits    = "Credits";
const string s_Instruction= "Instructions";
const string s_Made_By    = "Made By:";
const string s_Majestik   = "Majestik";
const string s_Moose      = "Moose";
const string s_Back       = "Back";
const string s_Continue   = "Continue";
const string s_Quit       = "Quit";
const string s_Gameover   = "Gameover";
const string s_Score      = "Score:";
const string s_Highscore  = "Highscore";
// Number Printing
define MAX_DIGITS = 5;
int numI;
// Game State Machine
int snakeState;
define TITLE      = 1;
define CREDITS    = 2;
define HIGHSCORES = 3;
define INSTRUCTIONS = 4;
define GAME_START = 5;
define GAMEPLAY   = 6;
define PAUSE      = 7;
define GAMEOVER   = 8;
define ENTER_HS   = 9;
// Font Sizes
define SMALL  = 0;
define MEDIUM = 1;
define LARGE  = 2;
// Gameboard Definitions
define SCALE = 5;
define WIDTH = 25;  // 125px
define HEIGHT = 12; // 60px (Fill top 2 & bottom 2 pixels)
define OFFSET_X = 2;
define OFFSET_Y = 2;
define MAX_SNAKE = 300;
// Snake Variables
int snake[MAX_SNAKE];
int snakeI;
int snakeLength;
define DEF_LENGTH = 3;
int curX, curY;
int tmpX, tmpY;
// Snake Movement
int prevMove;
int snakeMove;
define DEF_MOVE = 1;
define MOVE_COUNT = 4;
const int16 MOVEMENT[][] = {
//    X   Y   BUTTON
    { 0,  -1, PS4_UP },
    { 1,  0,  PS4_RIGHT },
    { 0,  1,  PS4_DOWN },
    { -1, 0,  PS4_LEFT }
};
// Goal
int goalX, goalY;
// Gameplay Variables
int snakeTimer;
define STEP_TIME = 100;
define PAUSE_TIME = 200;
// Menu Navigation
int menuNav;
int menuOptions;
// Highscore
define TOP_PLACES = 3;
define NAME_CHARS = 3;
int names[TOP_PLACES * NAME_CHARS];
int highscores[TOP_PLACES];
// Key selector
int name[NAME_CHARS];
int nameI;
define LETTER_COUNT = 52;
const uint8 LETTERS[] = {
	AC_A, AC_B, AC_C, AC_D, AC_E, AC_F, AC_G, AC_H, AC_I, AC_J, AC_K, AC_L, AC_M, AC_N, AC_O, AC_P, AC_Q, AC_R, AC_S, AC_T, AC_U, AC_V, AC_W, AC_X, AC_Y, AC_Z,
	AC_a, AC_b, AC_c, AC_d, AC_e, AC_f, AC_g, AC_h, AC_i, AC_j, AC_k, AC_l, AC_m, AC_n, AC_o, AC_p, AC_q, AC_r, AC_s, AC_t, AC_u, AC_v, AC_w, AC_x, AC_y, AC_z
}
const int16 NAME_SPVARS[][] = {
//    CHAR1    CHAR2     CHAR3     SCORE
	{ SPVAR_1, SPVAR_2,  SPVAR_3,  SPVAR_4 },
	{ SPVAR_5, SPVAR_6,  SPVAR_7,  SPVAR_8 },
	{ SPVAR_9, SPVAR_10, SPVAR_11, SPVAR_12 }
}
const string HowToPlay = "How To Play";
const string PressSquare = "Press Square/X";
const string Start = "To Start The Game";
const string NxtPage = "< Nxt/Prev Page >";

const string GameInfo[] = {"Press Triangle/Y","To Exit The Game","Press Share/Menu Btn","To Reset The Game","Press Options Btn","To Pause The Game","If Game Menu Press","Circle/B To Exit",""}; 
int NextPage;

/**
 * Reset Screen
 * Clear screen to setup gameplay.
 */
function ResetScreen() {
	cls_oled(BLACK);
	
	// Fill in Gaps that are not movable
	line_oled(0, 0, 0, 63, 1, 1);
	line_oled(1, 0, 1, 63, 1, 1);
	line_oled(127, 0, 127, 63, 1, 1);
	
	line_oled(0, 0, 127, 0, 1, 1);
	line_oled(0, 1, 127, 1, 1, 1);
	line_oled(0, 62, 127, 62, 1, 1);
	line_oled(0, 63, 127, 63, 1, 1);
	
	// Draw Snake
	for (i = 0; i < snakeLength; i++) {
		// Get Value
		tmpX = GetSnake(snakeI - i - 1);
		
		// Decompress Value
		tmpY = tmpX / 32;
		tmpX = get_bits(tmpX, 0, 31);
		
		DrawBox(tmpX, tmpY, WHITE);
	}
	
	// Draw Goal
	DrawBox(goalX, goalY, WHITE);
}

/**
 * Menu Navigation
 * Navigate a menu within its bounds (menuOptions)
 * 
 * @param up Navigation button to go up in the list.
 * @param down Navigation button to go down in the list.
 * @param confirm Selected the item in the menu.
 * @returns If the player has selected one of the menu options.
 */
function menuNav(up, down, confirm) {
	// Move Up
	if (event_press(up)){ //&& menuNav > 0) {
		menuNav--;
		DisplayMenu = TRUE;
		return 0;
		
	// Move Down
	} else if (event_press(down)){ // && menuNav < menuOptions - 1) {
		menuNav++;
		DisplayMenu = TRUE;
		return 0;
	}
	
	// Confirm
	return event_press(confirm);
}

/**
 * Check Movement
 * Check for movement from a button.  Triggers on press and while holding for a while.
 * 
 * @param button 
 * @returns Button has been pressed, or is held.
 */
function CheckMovement(button) {
	return event_press(button) || get_val(button) && get_ptime(button) > 250 && get_ptime(button) % (get_rtime() * 8) == 0;
}

/**
 * Init Players
 * Initialize starting locations for players 1 & 2.
 */
function InitSnake() {
	// Clear Snake
	for (i = 0; i < MAX_SNAKE; i++) {
		snake[i] = 0;
	}
	
	// Set Initial Values
	snakeI = 0;
	snakeLength = DEF_LENGTH;
	snakeMove   = DEF_MOVE;
	prevMove    = DEF_MOVE;
	curX = 7;
	curY = 5;
	
	// Set Initial Snake Locations
	for (i = 0; i < DEF_LENGTH; i++) {
		// Set Coordinates
		DisplayMenuSnake(1);
		
		// Move Snake
		if (i != DEF_LENGTH - 1)
			curX++;
	}
}

/**
 * DisplayMenu Movement
 * DisplayMenu direction the snake is going.
 */
function DisplayMenuMovement() {
	// Check all movement Directions
	for (i = 0; i < MOVE_COUNT; i++) {
		// Movement pressed
		if (get_val(MOVEMENT[i][2]) && i % 2 != prevMove % 2) {
			snakeMove = i;
			break;
		}
	}
}

/**
 * Move Snake
 * Move the snake, check if colliding with anything
 * 
 * @returns If the snake successfully moved to the next position. 0 = fail, 1 = succeess.
 */
function MoveSnake() {
	// Move Snake
	curX += MOVEMENT[snakeMove][0];
	curY += MOVEMENT[snakeMove][1];
	prevMove = snakeMove;
	
	// Wall collision
	if (curX < 0 || curX >= WIDTH || curY < 0 || curY >= HEIGHT) {
		return 0;
		
	// Snake Collision
	} else if (CheckSnakeCollision(curX, curY)) {
		return 0;
	}
	
	// No collision, valid movement
	return 1;
}

/**
 * Get Snake
 * Get the position of the snake.  X is first 5 bits, Y is next 5 bits.
 * 
 * @param index Index of the snake array to retreive.  Cycles array if negative number is passed in.
 * @returns Location of the snake at the given index.
 */
function GetSnake(index) {
	if (index < 0)
		return snake[MAX_SNAKE + index];
	return snake[index];
}

/**
 * DisplayMenu Snake
 * DisplayMenu the snake array and draw the head and erase the tail.
 * 
 * @param new If this is a new piece of the snake (initialization or eating).
 */
function DisplayMenuSnake(new) {
	// Add current location
	snake[snakeI] = curX + curY * 32;
	snakeI++;
	if (snakeI >= MAX_SNAKE)
		snakeI = 0;
	
	// Erase Tail
	if (!new) {
		// Get Value
		tmpX = GetSnake(snakeI - snakeLength - 1);
		
		// Decompress Value
		tmpY = tmpX / 32;
		tmpX = get_bits(tmpX, 0, 31);
		
		DrawBox(tmpX, tmpY, BLACK);
	}
	
	// Draw Head
	DrawBox(curX, curY, WHITE);
	
}

/**
 * Draw Box
 * Draw a box in releation to the scale of the gameboard.
 * 
 * @param x X coordinate on the board to draw.
 * @param y Y coordinate on the board to draw.
 * @param colour Colour to fill in the box.
 */
function DrawBox(x, y, colour) {
	rect_oled(OFFSET_X + x * SCALE, OFFSET_Y + y * SCALE, SCALE, SCALE, 1, colour);
}

/**
 * Check Snake Collision
 * Check if the location passed in collides with the snake.
 * 
 * @param x X position to check.
 * @param y Y position to check.
 * @returns If the location has collided with the snake. (Tail Excluded)
 */
function CheckSnakeCollision(x, y) {
	// Check snake lenth for collisions
	for (i = 1; i < snakeLength; i++) {
		// Check for matching coordinates
		if (GetSnake(snakeI - i) == x + y * 32)
			return 1;
	}
	
	return 0;
}

/**
 * Set Goal
 * Set the location of the next goal for the snake.
 * 
 * @param x X position to set the next goal to.
 * @param y Y position to set the next goal to.
 */
function SetGoal(x, y) {
	// Set New Goal location
	goalX = x;
	goalY = y;
	
	// Draw Goal
	DrawBox(x, y, WHITE);
}

/**
 * Eat Food
 * Increase snake length and set new goal.
 */
function EatFood() {
	// Increase snake length
	snakeLength++;
	
	//setup random goal location
	tmpX = random(5, 30) - 5;
	tmpY = random(5, 17) - 5;
	
	// Move until not in an occupied space (also make sure not drawing to tail)
	while (CheckSnakeCollision(tmpX, tmpY) || (tmpX == curX && tmpY == curY)) {
		// Move Goal
		tmpY++;
		
		// Check out of bounds
		if (tmpY >= HEIGHT) {
			tmpY = 0;
			tmpX++;
		}
		
		// Check out of bounds
		if (tmpX >= WIDTH)
			tmpX = 0;
	}
	
	// Set the goal location
	SetGoal(tmpX, tmpY);
}

/**
 * Add Highscore
 * Add the current name[] and snakeLength to the highscores saved to the EEPROM.  Sort current scores accordingly.
 */
function AddHighscore() {
    // Sort new highscore into list
    for (i = 0; i < TOP_PLACES; i++) {
        // Spot Found
        if (snakeLength > get_pvar(NAME_SPVARS[i][3], 3, MAX_SNAKE, 3)) {
            // Shuffle saved highscores
            for (j = TOP_PLACES - 1; j > i; j--) {
                // Save Name
                set_pvar(NAME_SPVARS[j][0], get_pvar(NAME_SPVARS[j - 1][0], 32, 126, AC_N));
                set_pvar(NAME_SPVARS[j][1], get_pvar(NAME_SPVARS[j - 1][1], 32, 126, AC_slash));
                set_pvar(NAME_SPVARS[j][2], get_pvar(NAME_SPVARS[j - 1][2], 32, 126, AC_N));
                
                // Save HighScore
                set_pvar(NAME_SPVARS[j][3], get_pvar(NAME_SPVARS[j - 1][3], 3, MAX_SNAKE, 3));
            }
            
            // Save Name
            set_pvar(NAME_SPVARS[i][0], LETTERS[name[0]]);
            set_pvar(NAME_SPVARS[i][1], LETTERS[name[1]]);
            set_pvar(NAME_SPVARS[i][2], LETTERS[name[2]]);
            
            // Save HighScore
            set_pvar(NAME_SPVARS[i][3], snakeLength);
            break;
        }
    }
}

/**
 * DisplayMenu Highscores
 * Setup the names[] and highscores[] with the current scores saved to the EEPROM.
 */
function DisplayMenuHighscores() {
    for (i = 0; i < TOP_PLACES; i++) {
        // Get Name Characters
        names[i * 3]     = get_pvar(NAME_SPVARS[i][0], 32, 126, AC_N);
        names[i * 3 + 1] = get_pvar(NAME_SPVARS[i][1], 32, 126, AC_slash);
        names[i * 3 + 2] = get_pvar(NAME_SPVARS[i][2], 32, 126, AC_A);
        
        // Get HighScore
        highscores[i] = get_pvar(NAME_SPVARS[i][3], 3, MAX_SNAKE, 3);
    }
}

/**
 * Get Min Highscore
 * Get the lowest highscore. 
 * 
 * @returns The lowest highscore saved.
 */
function GetMinHighscore() {
    return get_pvar(NAME_SPVARS[TOP_PLACES - 1][3], 3, MAX_SNAKE, 3);
}

// ---- Print Functions ----
/**
 * Draw Menu
 * Draw a menu with a 1 pixel frame of the opposing colour.
 * 
 * @param x X coordinate to start the frame at.
 * @param y Y coordinate to start the frame at.
 * @param width Width of the menu in pixels.
 * @param height Height of the menu in pixels.
 * @param colour Colour of the center of the menu (frame will be coloured opposite).
 */
function DrawMenu(x, y, width, height, colour) {
	// Draw Menu Frame
    rect_oled(x, y, width, height, 0, !colour);
    
    // Draw Menu Base
    rect_oled(x + 1, y + 1, width - 2, height - 2, 1, colour);
}

/**
 * Draw Arrow
 * Draw an arrow pointing up/down.
 * 
 * @param x X position of the head of the arrow.
 * @param y Y position of the head of the arrow.
 * @param dir Direction of the arrow: 1 = Pointing Up | -1 = Pointing Down.
 * @param rows Amount of rows to do down.
 * @param colour Colour of the arrow.
 */
function DrawArrow(x, y, dir, rows, colour) {
	// Make sure 1 or -1
	if (dir < 0)
		dir = -1;
	else
		dir = 1;
	
	// Draw Rows for arrow
	for (j = 0; j < rows; j++) {
		pixel_oled(x + j, y + (j * dir), colour);
		pixel_oled(x - j, y + (j * dir), colour);
	}
}

/**
 * Print Key Wheel
 * Draw a character, if it is being used draw a box around it with arrows above and below.
 * 
 * @param x Top left X coordinate of the character (must have 1 pixels left and Font Width + 2 right to work).
 * @param y Top left Y coordinate of the character (must have 7 pixels above and Font height + 6 below to work).
 * @param font Size of the Character.
 * @param colour Colour of the character.
 * @param c Current character.
 * @param isActive If this KeyWheel is currently being used.
 */
function PrintKeyWheel(x, y, font, colour, c, isActive) {
	// Draw Char
	PrintChar(x, y, font, colour, c);
	
	if (isActive) {
		// Outline character
		rect_oled(x - 1, y - 2, FONT_STATS[font][F_WIDTH] + 2, FONT_STATS[font][F_HEIGHT] + 3, 0, 1);
		
		// Up/Down Arrows
		DrawArrow(x + 3, y - 7, 1, 3, 1);
		DrawArrow(x + 3, y + FONT_STATS[font][F_HEIGHT] + 6, -1, 3, 1);
	}
}

/**
 * Print Char
 * Prints a single character to the OLED screen.
 * 
 * @param x Top left X coordinate of the character.
 * @param y Top left Y coordinate of the character.
 * @param font Size of the Character.
 * @param colour Colour of the character.
 * @param c Character to print.
 */
function PrintChar(x, y, font, colour, c) {
	putc_oled(1, c);
	puts_oled(x, y, font, 1, colour);
}

 /**
 * Print String
 * Print a string centered within a determined width. 
 * 
 * @param x Left X coordinate to start drawing string
 * @param y Left Y coordinate to draw string on.
 * @param width Width of the box to center the string within, in px.  If 0, string will print at (x, y).
 * @param font Font size to print
 * @param colour Colour of the text (0 = Black on White, 1 = White on Black)
 * @param str String to print.
 * @param strSize The sizeof(str) of the string you want to print (1 higher than actual string length).  Ignored if 0.
 */
function PrintString(x, y, width, font, colour, str, strSize) {
    // Center string to width
    if (width > 0 && strSize > 0) {
        width = (width - (strSize - 1) * FONT_STATS[font][F_WIDTH]) / 2;
        
        // Apply centering if valid
        if (width > 0)
            x += width;
    }
    
    // Print string
    print(x, y, font, colour, str);
}

 /**
 * Print Number
 * Print a number centered within a determined width 
 * 
 * @param x Left X coordinate to start drawing number
 * @param y Left Y coordinate to draw number on.
 * @param width Width of the box to center the number within, in px.  If 0, number will print at (x, y).
 * @param font Font size to print.
 * @param colour Colour of the text (0 = Black on White, 1 = White on Black)
 * @param num Value to be outputted to the OLED.
 */
function PrintNumber(x, y, width, font, colour, num) {
    if (num == 0) {
		putc_oled(1, AC_0);
		puts_oled(x, y, font, 1, colour);
		return;
	}
	
	numI = 1;
	
	// Negative number
	if (num < 0) {
		num = abs(num);
		putc_oled(numI, AC_minus);
		numI++;
	}
	
	for (i = 4; i >= 0; i--) {
		if (num >= pow(10, i)) {
			if (i == 4)
				putc_oled(numI, AC_0 + num / 10000);
			else
				putc_oled(numI, AC_0 + (num % pow(10, i + 1)) / pow(10, i));
			numI++;
		}
	}
    
    // Center number to width
    if (width > 0) {
        width = (width - (numI - 1) * FONT_STATS[font][F_WIDTH]) / 2;
        
        // Apply centering if valid
        if (width > 0)
            x += width;
    }
    
    // Print Number
	puts_oled(x, y, font, numI - 1, colour);
}

define donotatmewidth = 128;
define donotatmeheight = 64;
int xpos, ypos;
int time;
int rumble;
int xspeed, yspeed;
int xdirection, ydirection;
int restart;
int PLY2, PLY1;
int p1_score, p2_score;

function Pong (){ 
	if (restart) {
    xspeed = 2;
    yspeed = 1;
    restart = 0;
  }
  
  //----  
  if ((xpos <= -4 || xpos >= 132) || (ypos <= -4 || ypos >= 68)) {
    if (xpos < 64) {
      xdirection = -3;
      p2_score++;
      rumble = 0;
    } else if (xpos > 64) {
      xdirection = 3;
      p1_score++;
      rumble = 1;
    }
    xpos = 64;
    combo_run(score);
  }
  //----
  
  //----
  set_val(9, 0);
  set_val(11, 0);
  sensitivity(12, 0, 32);
  sensitivity(10, 0, 32);
  stickize(10, 12, 48);
  PLY1 = clamp(get_val(12), -22, 32) + 22;
  PLY2 = clamp(get_val(10), -22, 32) + 22;
  line_oled(0, 63, 0, 0, 3, 0);
  line_oled(0, 0, 0, PLY1 + 10, 3, 1);
  line_oled(0, 0, 0, PLY1 + 0, 3, 0);
  line_oled(125, 1, 125, 63, 3, 0);
  line_oled(125, 1, 125, PLY2 + 10, 3, 1);
  line_oled(125, 1, 125, PLY2 + 0, 3, 0);
  //----  
  //----
  time++;
  
  if (!(time % 5)) {
    line_oled(xpos - 2, ypos + 2, xpos - 2, ypos - 2, 5, 0);
    if (!combo_running(score)) {
      xpos = xpos + (xspeed * xdirection);
      ypos = ypos + (yspeed * ydirection);
      line_oled(xpos - 1, ypos + 1, xpos - 1, ypos - 2, 4, 1);
    }
  }
  if (xpos > donotatmewidth - 5 || xpos < 5) {
    if (((xpos < 50) && (PLY1 < ypos) && (PLY1 + 15 >= ypos)) || ((xpos > 50) && (PLY2 < ypos) && (PLY2 + 15 >= ypos))) {
      xdirection *= -1;
    }
  }
  if (ypos > donotatmeheight || ypos < 0) {
    ydirection *= -1;
  }
  //----  
  line_oled(64, 1, 64, 63, 1, 1);
  p2_score = max(48, p2_score % 58);
  p1_score = max(48, p1_score % 58);
  putc_oled(1, p1_score);
  puts_oled(45, 5, 1, 1, 1);
  putc_oled(1, p2_score);
  puts_oled(75, 5, 1, 3, 1);
}
combo score {
  set_rumble(!rumble, 100);
  wait(500);
  reset_rumble();
  wait(2000);
  ydirection = random(1, 5);
  ypos = random(10, 54);
  if (ypos > 32) ydirection *= -1;
  restart++;
}
const string INITIALISE = "Initialising";
const string CRONUS = "Cronus";
const string ZEN = "ZEN";
const string CONTROLLERTEST = "Controller Test";
int RunIntro;
int Initialise;
combo Message{ 
cls_oled(0);
print(17,3,2,1,CRONUS[0]);
print(42,25,2,1,ZEN[0]);
print(15,52,0,1,CONTROLLERTEST[0]);
wait(2000);
cls_oled(0);
RunIntro = FALSE;
Initialise = TRUE;
} 
combo GetInfo { 
print(10,30,0,1,INITIALISE[0]);
putc_oled(1,ASCII_PERIOD);
puts_oled(94,23,1,1,1);
wait(500);
putc_oled(1,ASCII_PERIOD);
puts_oled(105,23,1,1,1);
wait(500);
putc_oled(1,ASCII_PERIOD);
puts_oled(118,23,1,1,1);
wait(500);
DisplayTitle = TRUE;
Initialise = FALSE;
}
 
 
 
 

 
 
 
 
  