/*
VVVVVVVV           VVVVVVVV                                     iiii          tttt                                            
V::::::V           V::::::V                                    i::::i      ttt:::t                                            
V::::::V           V::::::V                                     iiii       t:::::t                                            
V::::::V           V::::::V                                                t:::::t                                            
 V:::::V           V:::::V eeeeeeeeeeee    rrrrr   rrrrrrrrr  iiiiiiittttttt:::::ttttttt      aaaaaaaaaaaaa      ssssssssss   
  V:::::V         V:::::Vee::::::::::::ee  r::::rrr:::::::::r i:::::it:::::::::::::::::t      a::::::::::::a   ss::::::::::s  
   V:::::V       V:::::Ve::::::eeeee:::::eer:::::::::::::::::r i::::it:::::::::::::::::t      aaaaaaaaa:::::ass:::::::::::::s 
    V:::::V     V:::::Ve::::::e     e:::::err::::::rrrrr::::::ri::::itttttt:::::::tttttt               a::::as::::::ssss:::::s
     V:::::V   V:::::V e:::::::eeeee::::::e r:::::r     r:::::ri::::i      t:::::t              aaaaaaa:::::a s:::::s  ssssss 
      V:::::V V:::::V  e:::::::::::::::::e  r:::::r     rrrrrrri::::i      t:::::t            aa::::::::::::a   s::::::s      
       V:::::V:::::V   e::::::eeeeeeeeeee   r:::::r            i::::i      t:::::t           a::::aaaa::::::a      s::::::s   
        V:::::::::V    e:::::::e            r:::::r            i::::i      t:::::t    tttttta::::a    a:::::assssss   s:::::s 
         V:::::::V     e::::::::e           r:::::r           i::::::i     t::::::tttt:::::ta::::a    a:::::as:::::ssss::::::s
          V:::::V       e::::::::eeeeeeee   r:::::r           i::::::i     tt::::::::::::::ta:::::aaaa::::::as::::::::::::::s 
           V:::V         ee:::::::::::::e   r:::::r           i::::::i       tt:::::::::::tt a::::::::::aa:::as:::::::::::ss  
            VVV            eeeeeeeeeeeeee   rrrrrrr           iiiiiiii         ttttttttttt    aaaaaaaaaa  aaaa sssssssssss  
            
		╔═══════Rainbow Six Siege═══════════════════════════════════════════════════════════════════════════════╗
		║	Version: 	Veritas AR 7.2.0		 																║
		║	Cronus: 	32bit Zen only																			║
		║	Platform: 	Multi																					║
		║	Controller: Multi																					║
		║	Game: 		Rainbow Six Siege																		║
		║	Author: 	Veritas																					║
		║	Join our discord to get early access:	https://discord.gg/tkGPX8HaNs								║
		║																										║
		║																										║		
		║   All Scripts Are Free. If you paid for a script, file a chargeback because you have been scammed,	║
		║	but if you appriciate the works you can donate here: 												║
		║	https://www.paypal.com/donate?hosted_button_id=AUCJD5BDGTDPY										║		
		╚═══════════════════════════════════════════════════════════════════════════════════════════════════════╝
*/
const string 	OperatorName[] 		= {
	//	0			1			2			3			4			5			6			7			8			9
	"SMOKE",	"MUTE",			"CASTLE",	"PULSE",	"DOC",		"ROOK", 	"KAPKAN",	"TACHANKA",	"JAGER",	"BANDIT",
	"FROST",	"VALKYRIE",		"CAVEIRA",	"ECHO",		"MIRA",		"LESION",	"ELA",		"VIGIL",	"MAESTRO",	"ALIBI",
	"CLASH",	"KAID",			"MOZZIE",	"WARDEN",	"GOYO",		"WAMAI",	"ORYX",		"MELUSI",	"ARUNI", 	"THUNDERBIRD", 	
	"THORN",	"AZAMI", /*32 Defenders*/ ""};
const string 	GunName[]			= {
//	0				1				2				3				4				5				6				7				8			9
"L85A2",		"M590A1",		"P226 MK 25",	"SMG-11",		"USP40",		"ARX200",		"G36C",			"MK1 9MM",		"AUG A2",	"P12",			
//	10				11				12				13				14				15				16				17				18			19
"CSRX 300",		"C75 Auto",		"G8A1",			"SUPERNOVA",	"P229",			"FMG-9",		"SIX12 SD",		"5.7 USG",		"D-50",		"SMG-12",	
//	20				21				22				23				24				25				26				27				28			29
"SUPER SHO..",	"R4-C",			"M45 MEUSOC",	"M1014",		"P9",			"LFP586",		"MP7",			"PMM",			"GSH-18",	"556XI",
//	30				31				32				33				34				35				36				37				38			39
"AR33",			"F2",			"417",			"SG-CQB",		"CAMRS",		"C8-SFW",		"M249",			"PARA-308",		"PRB92",	"552COMMANDO",
//	40				41				42				43				44				45				46				47				48			49	
"OTS-03",		"AK-12",		"6P41",			"SR-25",		"MK17 CQB",		"TYPE-89",		"C7E",			"ITA12S",		"ITA12L",	"PDW9",
//	50				51				52				53				54				55				56				57				58			29
".44MAG SEMI",	"Q-929",		"T-95 LSW",		"BEARING 9",	"SIX12 SD",		"RG15",			"BOSG.12.2",	"SPSMG9",		"LMG-E",	"M762",
//	60				61				62				63				64				65				66				67				68			69		
"Mk 14 EBR",	"V308",			"SPEAR .308",	"AR-15.50",		"M4 GS",		"1911 TACOPS",	"AK-74M",		"F90",			"SC3000K",	"Shield",
//	70				71				72				73				74				75				76				77				78			79
"Gonne-6",		"SASG-12",		"SPAS-12",		"MP5",			"Bailiff 410",	"MP5K",			"VECTOR .45",	"TCSG12",		"MPX",		"P10-C",		
//	80				81				82				83				84				85				86				87				88			89
"COMMANDO 9",	"P10 RONI",		"SDP 9mm",		"UMP45",		"P90",			"M870",			"416CCARBINE",	"9X19VSN",		"9MM C1",	"SUPER90",
//	90				91				92				93				94				95				96				97				98			99
"AUG A3",		"T-5 SMG",		"M12",			"SPAS-15",		"LUISON",		"MP5SD",		"SCORPION",		"FO-12",		"K1A",		"ALDA 5.56",	
//	100				101				102				103				104				105
"ACS12",		"KERATOS.357",	"Mx4 Storm",	"DP27",			"UZK50GI",		"POF-9",			""};
const string  	GunTypeName[] 		= {
//	0,  			1,  		2,  		3,  			4,  			5,  			6,  				7,  		8
"ASSAULTRIFLE", "SHOTGUN", "HANDGUN", "SUBMACHINEGUN", "MACHINEPISTOL", "MARKSMANRIFLE", "LIGHTMACHINEGUN", "HANDGONNE", "HANDGUN", ""};
const int8		GunNameIndex[] 		= {
15,	1, 	-1,	3, 	2,  -1, /* SMOKE */		75,	1, 	-1, 3, 	2, -1, /* MUTE */ 			83, 23, -1, 20, 17, -1, /* CASTLE */	83, 23, -1, 17, 22, -1, /* PULSE */
73, 33, 84, 24, 25, -1, /* DOC */		73, 33, 84, 24, 25, -1, /* ROOK */ 			87, 71, -1, 27, 28, -1, /* KAPKAN */	87, 103, -1, 27, 28, 53, /* TACHANKA */
86, 85, -1, 9,  -1, -1, /* JAGER */		26, 85, -1, 9,  -1, -1, /* BANDIT */		88, 89, -1, 7, 	47, -1, /* FROST */		78, 72,	-1, 18, -1, -1, /* VALKYRIE */	
92, 93, -1, 94, -1, -1, /* CAVEIRA */	95, 13, -1, 53, 14, -1, /* ECHO */			76, 48, -1, 47, 4, -1, /* MIRA */		91, 54, -1, 51, -1, -1, /* LESION */	
96,	97, -1, 55, -1, -1, /* ELA */ 		98, 56, -1, 11, 19, -1, /* VIGIL */			99, 100,-1,74, 101, -1, /* MAESTRO */	102, 100, -1, 101, 74, -1, /* ALIBI */		
57, 20,	-1, -1, -1, 79, /* CLASH */ 	90, 77, -1, 25, 50, -1, /* KAID */			80, 81, -1, 82, -1, -1, /* MOZZIE */	78, 1, 	-1, 19, 79, -1, /* WARDEN */	
76, 77, -1, 14, -1, -1, /* GOYO */		8, 	75,	-1, 101, 9, -1, /* WAMAI */			91, 72,	-1, 74,  4, -1, /* ORYX */		73, 89, -1, 55, -1, -1, /* Melusi */	
81, 60, -1, 38, -1, -1, /* ARUNI */		62, 93, -1, 53, 51, -1, /* THUNDERBIRD */	104, 85,-1, 11, 65, -1, /* THORN */		87, 100, -1, 18, -1, -1 /* AZAMI */
};
const int8   	GunTypeIndex[] 		= {
0, 1, 0, 3, 2, 0, /* SMOKE */	0, 1, 0, 3, 2, 0, /* MUTE */		0, 1, 0, 1, 2, 0, /* CASTLE */		0, 1, 0, 2, 2, 0, /* PULSE */		3, 3, 1, 2, 2, 0, /* DOC */	
3, 3, 1, 2, 2, 0, /* ROOK */	3, 1, 0, 2, 2, 0, /* KAPKAN */		3, 6, 0, 2, 2, 0, /* TACHANKA */ 	0, 1, 0, 2, 2, 0, /* JAGER	*/		0, 1, 0, 2, 2, 0, /* BANDIT */			
0, 2, 0, 2, 1, 0, /* FROST */	0, 1, 0, 2, 2, 0, /* VALKYRIE */	3, 1, 0, 2, 2, 0, /* CAVEIRA */		3, 1, 0, 4, 2, 0, /* ECHO */		3, 1, 0, 1, 2, 0, /* MIRA */		
0, 1, 0, 2, 2, 0, /* LESION */	0, 1, 0, 2, 2, 0, /* Ela */			0, 1, 0, 4, 4, 0, /* VIGIL */		3, 1, 0, 2, 2, 0, /* MAESTRO */		3, 1, 0, 2, 2, 0, /* ALIBI */		
2, 0, 0, 4, 0, 2, /* CLASH */	3, 1, 0, 2, 2, 0, /* KAID */		0, 0, 0, 2, 2, 0, /* MOZZIE */		3, 1, 0, 3, 2, 0, /* WARDEN */		3, 1, 0, 2, 2, 0, /* GOYO */		
0, 4, 0, 2, 2, 0, /* WAMAI */	0, 1, 0, 2, 2, 0, /* ORYX */		0, 1, 0, 2, 2, 0, /* Melusi */		0, 5, 0, 2, 2, 0, /* ARUNI */		0, 1, 0, 4, 2, 0, /* THUNDERBIRD */ 	
0, 1, 0, 4, 2, 0, /* THORN */	3, 1, 0, 2, 0, 0 /* AZAMI */
};
const int8	 	GunRFIndex[] 		= {
0, 1, 0, 0, 1, 0, /* SMOKE */	0, 1, 0, 0, 1, 0, /* MUTE */		0, 1, 0, 1, 1, 0, /* CASTLE */	0, 1, 0, 1, 1, 0, /* PULSE */	0, 0, 1, 1, 1, 0, /* DOC */			
0, 0, 1, 1, 1, 0, /* ROOK */	0, 1, 0, 1, 1, 0, /* KAPKAN */		0, 0, 0, 1, 1, 0, /* TACHAN */	0, 1, 0, 1, 1, 0, /* JAGER */	0, 1, 0, 1, 1, 0, /* BANDIT */	
0, 1, 0, 1, 1, 0, /* FROST */	0, 1, 0, 1, 1, 0, /* VALKYRIE */	0, 1, 0, 1, 1, 0, /* CAVEIRA */	0, 1, 0, 0, 1, 0, /* ECHO */	0, 1, 0, 1, 1, 0, /* MIRA */			
0, 1, 0, 1, 1, 0, /* LESION */	0, 1, 0, 1, 1, 0, /* Ela */			0, 1, 0, 0, 0, 0, /* VIGIL */	0, 1, 0, 1, 1, 0, /* MAESTRO */	0, 1, 0, 1, 1, 0, /* ALIBI */			
0, 0, 0, 0, 0, 1, /* CLASH */	0, 1, 0, 1, 1, 0, /* KAID */		0, 0, 0, 1, 1, 0, /* MOZZIE */	0, 1, 0, 0, 1, 0, /* WARDEN */ 	0, 1, 0, 1, 1, 0, /* GOYO */			
0, 0, 0, 1, 1, 0, /* WAMAI */	0, 1, 0, 1, 1, 0, /* ORYX */		0, 1, 0, 1, 1, 0, /* Melusi */ 	0, 1, 0, 1, 1, 0, /* ARUNI */	0, 1, 0, 0, 1, 0, /* THUNDERBIRD */	
0, 1, 0, 0, 1, 0, /* THORN */   0, 1, 0, 1, 0, 0  /* AZAMI */
};
const int8	 	GunARIndex[]		= {
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* SMOKE */		15,0,0,		0,0,0,		0,0,0,		15,4,0,	0,0,0,	0,0,0, /* MUTE */
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* CASTLE */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* PULSE */		
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* DOC */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* ROOK */		
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* KAPKAN */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* TACHANKA */	
12,-1,0,	0,0,0,		0,0,0,		9,0,0,		0,0,0,	0,0,0, /* JAGER */		13,1,0,		0,0,0,		0,0,0,		9,0,0,	0,0,0,	0,0,0, /* BANDIT */	
11,1,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* FROST */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* VALKYRIE */
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* CAVEIRA */	0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* ECHO */		
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* MIRA */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* LESION */	
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* Ela */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* VIGIL */
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* MAESTRO */	0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* ALIBI */		
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* CLASH */		13,1,0,		0,0,0,		0,0,0,		17,0,0,	0,0,0,	0,0,0, /* KAID */		
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* MOZZIE */		15,0,0,		0,0,0,		0,0,0,		0,0,0,	14,1,0, 0,0,0, /* WARDEN */	
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* GOYO */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* WAMAI */		
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* ORYX */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* Melusi */	
0,0,0,		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0, /* ARUNI */		0,0,0,		0,0,0,		0,0,0,		0,0,0,	0,0,0,	0,0,0, /* THUNDERBIRD */
12,0,0,		0,0,0,		0,0,0,		15,1,0,		0,0,0,	0,0,0, /* THORN */		11,1,0,		0,0,0,		0,0,0,		14,0,0,	0,0,0,	0,0,0  /* AZUMI */
}; 
const int8  	operatorsByYear[] 	= {0, 10, 14, 18, 22, 26, 29};
const int16 	operatorSelMsg[] 	= {80,114,101,115,115,32,65,47,127,32,116,111,32,115,101,108,101,99,116,46,
									32,72,111,108,100,32,76,84,47,76,50,32,43,32,133,32,134,32,84,111,32,
									110,97,118,105,103,97,116,101,32,116,104,114,111,117,103,104,32,115,101,97,115,111,110,115,46,32};	
const string 	avilityName[] 		= {
//DOC			  CAVEIRA		  	ECHO			MAESTRO		    CLASH				 
"STIM", "PISTOL", "SILENT", "STEP", "---", "YOKAI", "EVIL", "EYE", "CCE", "SHIELD", 	""
};
const string 	operatorType[]		= {"Defenders", ""};
const string 	operationYear[] 	= {"",		  	"Year 1",	"Year 2", 	"Year 3",	"Year 4",	"Year 5",	"Year 6",	"Year 7", ""};
const string 	operationName[] 	= {"Original",	"Black",	"Velvet", 	"Chimera",	"Burnt", 	"Void", 	"Crimson",	"Demon", ""};
const string 	operationName2[] 	= {"Operators",	"Ice",		"Shell",	"",			"Horizon",	"Edge", 	"Heist",	"Veil", ""};
const string 	gunIndexMsg[]		= {"Primary", "Secondary", ""};
const string 	configuration[]		= {"Anti-recoil", "Guns", "Mods Values", "Reset", "QT On/Off", "AR Type", ""};
const string 	enterSlotMsg[]		= {"Enter slot number", "for the", "Attackers script", ""};	
const string 	veritasARVersion[]	= {"Version 1", "Version 2", "Version 3", ""};
const string 	quickToggleNames[]	= {"Crouch Spam", "Strafe", "Shaiko Lean", "Lean Spam", "Prone Shot", "tBag LOL", 
										"R-Fire 4All", "Rapid Fire", "Dead Zone", "V. Sens", "H. Sens", "Move-Adj", "VeritasAR",
										"Auto Lean", "Pin On Shot", "Auto Scan", "Inverted", "Bumper Swap", "C. P. Delay", 
										""};
const string 	toggleStatus[]		= {"OFF", "ON", ""};
const string 	saveMessage			= "SAVED";
const string	resetMessage		= "Reset";
const string 	configurationText	= "Configure";
const string 	VersionInfo			= "Veritas AR v7.2.0";
const int16 quickToggleMinMaxDef[][] ={
	//Min	Max		Def
	{30,  	200, 	60}, 	//QT_CROUCH_SPAM
	{100,	200, 	200},	//QT_STRAFE
	{100,	200, 	120},	//QT_SHAIKO_LEAN
	{30,	200, 	95}, 	//QT_LEAN_SPAM
	{100,  	400, 	250}, 	//QT_PRONE_SHOT	
	{10,	100,	30},	//QT_TEA_BAG_LOL
	{0,		1,	 	0},		//SPACE FILLER- donot removed
	{10,	100,	20}, 	//QT_RAPID_FIRE
	{1,		30,		12},	//QT_RS_DEAD_ZONE
	{1,		100,	60},	//QT_VERTICAL_SENSITIVITY
	{1,		100,	60},	//QT_HORIZONTAL_SENSITIVITY
	{1,		10,	 	3},		//QT_RS_MOVEMENT_ADSJ
	{0,		2,	 	2}		//QT_VERITAS_AR
};
enum{
	QT_CROUCH_SPAM,
	QT_STRAFE,
	QT_SHAIKO_LEAN,
	QT_LEAN_SPAM,
	QT_PRONE_SHOT,
	QT_TEA_BAG_LOL,
	QT_RAPID_FIRE_FOR_ALL,
	QT_RAPID_FIRE,
	QT_RS_DEAD_ZONE,
	QT_VERTICAL_SENSITIVITY,
	QT_HORIZONTAL_SENSITIVITY,
	QT_RS_MOVEMENT_ADSJ,
	QT_VERITAS_AR,
	QT_AUTO_LEAN,	
	QT_PIN_ON_SHOT,
	QT_AUTO_SCAN,
	QT_INVERTED,
	QT_BUMPER_SWAP,
	QT_CROUCH_SPAM_DELAY
}
enum{
	MOD_DEFAULT,
	MOD_OPERATOR_SELECTION,
	MOD_OPERATOR_BY_YEAR,
	MOD_GAME,
	MOD_ANTIRECOIL,
	MOD_GUN_SELECTION,
	MOD_RESET,
	MOD_CONFIG,
	MOD_QUICK_TOGGLE,
	MOD_QUICK_TOGGLE_EDIT,
	MOD_CHANGE_SLOT,
	MOD_GUN_MOV_ADJ
}
enum{
	GUN_PRIMARY,
	GUN_SECONDARY
}
enum{
	VERITAS_AR_V1,
	VERITAS_AR_V2,
	VERITAS_AR_V3	
}
define MAX_QT_COUNT					= 18;
define OPERATORS_COUNT 				= 32;

int	quickToggleValue[MAX_QT_COUNT + 1];
int	quickToggleState[MAX_QT_COUNT + 1];
int	autoScanActive 					= FALSE;
int stopScroll		  				= FALSE;
int currentMod						= MOD_DEFAULT;
int toggleIndex						= 0;
int forIndex 						= 1;	
int activeGun						= 0;
int operatorsByYearIndex			= 0;	
int currentConfigModIndex			= 0;
int activeOperator					= 0;
int LINE_TOP						= 7;
int LINE_CENTER						= 25;
int LINE_BOTTOM						= 45;
int messageColumCount 				= 127;
int messageArrayLine				= 0;
int messageSize;
	//Game buttons
int FireButton					= XB1_RT;
int AdsButton   				= XB1_LT;
int AbilityButton  				= XB1_RB;
int TacticalButton				= XB1_LB;
int SelectButton    			= XB1_A;
int CrouchButton    			= XB1_B;
int MeleeButton     			= XB1_RS;
int SprintButton    			= XB1_LS;
int ReloadButton  				= XB1_X;
int SwapButton      			= XB1_Y;
int ForceSwapButton 			= XB1_A;
int UpButton					= XB1_UP;
int RightButton					= XB1_RIGHT;
int DownButton					= XB1_DOWN;
int LeftButton					= XB1_LEFT;
int MenuButton					= XB1_MENU;
int ModsButton					= XB1_VIEW;
int LxButton					= XB1_LX;
int LyButton					= XB1_LY;
int abilityCams					= FALSE;
int abilityDeploying			= FALSE;
int abilityCoolDown				= FALSE;
int abilityTimeCheck			= FALSE;
int abilityReleasing			= FALSE;
int abilityActive				= FALSE;
int abilityFocus				= FALSE;
int abilityDeployCount			= 0;
int abilityReleasingTime 		= 0;
int abilityCountDown			= 0;

int autoLeanDelay				= FALSE;
int autoLeanKnifeDelay			= FALSE;
int autoLeanDelayCountDown 		= 0;
int gunRapidFire;

//AR Vars 
int gunARInfo[6], gunIndex[2];
int verticalAR, horizontalAR, moveAdj;
int i, arVal, c_val, chr_val;
int saveVar = -32768;
int GunARAdjustment[OPERATORS_COUNT * 2];

int vertY,horiX,useX,useY,dzX,dzY,snsX,snsY,sysHor,sysVer;	
int Strafe, InvertedAR;
//Misc vars
int inInfoView;	
int changeOperators	= FALSE;
int gameResume = 0;
int slotNumber = 0;
int crouchSpamDelay;
int serverLogo = 0;
int timer = 0;
int ProneOk = TRUE;
int tempGunIndex = 0;
/*
╔═══════Rainbow Six Siege═══════════╗
║		Main block					║
╚═══════════════════════════════════╝
*/	
init{		
	Load();
	LoadGunARAdjustment();
	quickToggleState[QT_CROUCH_SPAM] = 0; //This should be off by defaul and uset the QuickToggle to turn it ON
	InvertedAR = 1;
   	if(quickToggleState[QT_INVERTED] == 1) InvertedAR = -1;
   	crouchSpamDelay = 200 *  quickToggleState[QT_CROUCH_SPAM_DELAY];
	Strafe = (quickToggleValue[QT_STRAFE] * 32767) / 100;	
	//Flipped Bumbers/Triggers
    if(quickToggleState[QT_BUMPER_SWAP]) {
    	FireButton		= XB1_RB;
		AdsButton   	= XB1_LB;
		AbilityButton  	= XB1_RT;
		TacticalButton	= XB1_LT;
    } 
	changeOperators = TRUE;
    DrawLogo();
    print(CenterText(operatorType[1] - operatorType[0] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_BOTTOM - 5, OLED_FONT_MEDIUM, OLED_WHITE, operatorType[0]);
}
main {	   	
	if(serverLogo == 1 && timer > 330000){
		cls_oled(0);
		serverLogo = 0;
		timer = 0 ;
	}
	if(serverLogo < 2) {
    	timer += get_rtime(); 
    	if(ButtonPress(SelectButton) || ButtonPress(CrouchButton) ||
    		ButtonPress(SwapButton) || ButtonPress(ReloadButton)){
    		serverLogo = 0;
			timer = 0 ;
    	}
    }
	if(serverLogo == 0 && timer > 300000){
		DrawLogo();
		cls_oled(0);
		serverLogo = 1
    	DrawLogo();
    	print(CenterText(operatorType[1] - operatorType[0] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_BOTTOM - 5, OLED_FONT_MEDIUM, OLED_WHITE, operatorType[0]);
    }   
	if(autoLeanDelay){                            
        autoLeanDelayCountDown += get_rtime();
        if(autoLeanDelayCountDown >= 3000){
        	autoLeanDelay	= FALSE;
        }
	}	
	if(autoLeanKnifeDelay){                            
        autoLeanDelayCountDown += get_rtime();
        if(autoLeanDelayCountDown >= 200){
        	autoLeanKnifeDelay	= FALSE;
        }
	}
	if(changeOperators){
		gameResume += get_rtime();
        if(gameResume >= 500){
        	changeOperators	= FALSE;
        	DisplayOperatorSelection();
			DisplayMod(MOD_OPERATOR_SELECTION);
			stopScroll = FALSE;
			operatorsByYearIndex = 0;
        }
	}
	if(ButtonHold(AdsButton) && ButtonPress(MenuButton)){
		currentMod = MOD_OPERATOR_SELECTION;
		DisplayOperatorSelection();
		block_all_inputs();
	}
	//This will turn Heir Trigger on
	deadzone(AdsButton, FireButton, 100, 100);
	if(inInfoView){
		if(ButtonPress(CrouchButton) || ButtonPress(SelectButton)){
			inInfoView = FALSE;	
			DisplayMod(currentMod);
			block_all_inputs();
		}
	}else{
		switch(currentMod){
			case MOD_GAME:{
				if(ButtonHold(AdsButton) && ButtonPress(ModsButton)) DisplayMod(MOD_CONFIG);
				if(ButtonHold(AdsButton) && DoubleTab(ReloadButton)) DisplayScriptInfo();
				if(abilityFocus || !abilityActive){
					if(get_ival(AdsButton) && get_ival(FireButton)){
						if(isqrt(pow(abs(get_ival(XB1_LX)),2) + pow(abs(get_ival(XB1_LY)),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
							set_val(XB1_LX,0);
							set_val(XB1_LY,0);
						}
						if(isqrt(pow(abs(get_ival(XB1_RX)),2) + pow(abs(get_ival(XB1_RY)),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
							set_val(XB1_RX,0);
							set_val(XB1_RY,0);
						}	
						if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V1){
							VeritasAR();
							SetVeritasAR(XB1_RX, sysHor);
							SetVeritasAR(XB1_RY, sysVer);						
						}else if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V2) VeritasARv2();
						else VeritasARv3();
					}
					//Drop a yellow pin on firts shot
					if(ButtonPress(FireButton) 	&& quickToggleState[QT_PIN_ON_SHOT]) 	Set(UpButton);
					//if(ButtonHold(FireButton) 	&& quickToggleState[QT_AUTO_ADS]) 		Set(AdsButton);
					if((quickToggleState[QT_RAPID_FIRE] && gunRapidFire) || quickToggleState[QT_RAPID_FIRE_FOR_ALL] ){
						if(ButtonHold(FireButton))	combo_run(RapidFire);
						else						combo_stop(RapidFire);    	
					}
				}
				if(!abilityActive){			
					//Gun switch 	
					if(ButtonRelease(SwapButton) && get_ptime(SwapButton) < 500){
						if(!ButtonHold(TacticalButton) && !ButtonHold(AbilityButton) && !ButtonHold(LeftButton) && !ButtonHold(RightButton)){
							activeGun = !activeGun;
						}
						DisplaySwitchGun();	
					}
					//Force Gun switch    	
					if(ButtonHold(AdsButton) && DoubleTab(ForceSwapButton)){ 
						activeGun 	= !activeGun;
						DisplaySwitchGun();
					}			
					//Prone Shot
					if(quickToggleState[QT_PRONE_SHOT]){
						if(ButtonHold(FireButton) && get_ptime(FireButton) > quickToggleValue[QT_PRONE_SHOT] && ProneOk){
							set_val(CrouchButton,100);
							ProneOk = FALSE;
						}
						if(ButtonRelease(FireButton)) ProneOk = TRUE;
					}
					//Auto Scan
					if(quickToggleState[QT_AUTO_SCAN] && ButtonHold(SwapButton) && get_ptime(SwapButton) >= 1280) autoScanActive = TRUE;
					if(autoScanActive) combo_run(AutoScan);
					if(ButtonPress(DownButton) || ButtonPress(CrouchButton)	&& combo_running(AutoScan)){autoScanActive = FALSE; combo_stop(AutoScan);}
					//Crouch Spam
					if(quickToggleState[QT_CROUCH_SPAM]){
						if(ButtonHold(FireButton) 	&& get_ptime(FireButton) > crouchSpamDelay) combo_run(CrouchSpam);
						if(!ButtonHold(FireButton) 	&& combo_running(CrouchSpam)) 				combo_stop(CrouchSpam);
					}
					if(quickToggleState[QT_LEAN_SPAM]){
						if(ButtonHold(AdsButton) 	&& ButtonHold(FireButton)) 		combo_run(LeanSpam);
						if(!ButtonHold(FireButton)	&& combo_running(LeanSpam)) 	combo_stop(LeanSpam);
					}
					//Teabugging LOL
					if(quickToggleState[QT_TEA_BAG_LOL] && ButtonHold(DownButton) && get_ptime(DownButton) >= 250) 		combo_run(TeaBag);	
					// Run AutoLean
					if(quickToggleState[QT_AUTO_LEAN]){
						if(ButtonPress(ReloadButton)){
							autoLeanDelayCountDown = 0;
							autoLeanDelay = TRUE;
						}
						if(ButtonPress(AdsButton)){
							autoLeanDelayCountDown = 0;
							autoLeanKnifeDelay = TRUE;
						}
						if(!ButtonHold(FireButton)){
							if(ButtonHold(AdsButton) && abs(get_val(LxButton)) > quickToggleValue[QT_AUTO_LEAN]){
								if(get_val(LxButton) < 0) Set(SprintButton);
								else if(!autoLeanDelay && !autoLeanKnifeDelay) Set(MeleeButton);
							}
						}										
					}
					//Strafe
					if(quickToggleState[QT_STRAFE]){
						if(ButtonHold(FireButton)) combo_run(Strafe);
						if(!ButtonHold(FireButton) && combo_running(Strafe)) combo_stop(Strafe);
						if(((get_val(LyButton) <= -70) || (get_val(LyButton) >= 70) || 
							(get_val(LxButton) <= -70) || (get_val(LxButton) >= 70))) combo_stop(Strafe);
					}
					//Shaiko Lean			
					if(quickToggleState[QT_SHAIKO_LEAN] && ButtonHold(AdsButton)){
						if(ButtonHold(RightButton))	combo_run(ShaikoLeanRight);
						if(ButtonHold(LeftButton)) 	combo_run(ShaikoLeanLeft);					
						Unset(RightButton);
					}											
				}
				//Quick Toggle					
				if(ButtonHold(AdsButton) && DoubleTab(UpButton))	EditQuickToggle(QT_CROUCH_SPAM);
				if(ButtonHold(AdsButton) && DoubleTab(DownButton))	EditQuickToggle(QT_AUTO_LEAN);
				
				//Enter/Exit the operator avility
				if(abilityActive) CheckAbilityOff();
				else DisplayAbility();
				break;
			}
			case MOD_ANTIRECOIL:{
				if(get_ival(AdsButton) && get_ival(FireButton)){
					if(isqrt(pow(abs(get_ival(XB1_LX)),2) + pow(abs(get_ival(XB1_LY)),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
				    	set_val(XB1_LX,0);
				    	set_val(XB1_LY,0);
				  	}
					if(isqrt(pow(abs(get_ival(XB1_RX)),2) + pow(abs(get_ival(XB1_RY)),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
				    	set_val(XB1_RX,0);
				    	set_val(XB1_RY,0);
				  	}	
					if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V1){
						VeritasAR();
						SetVeritasAR(XB1_RX, sysHor);
						SetVeritasAR(XB1_RY, sysVer);						
					}else if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V2) VeritasARv2();
					else VeritasARv3();
				}
				if((quickToggleState[QT_RAPID_FIRE] && gunRapidFire) || quickToggleState[QT_RAPID_FIRE_FOR_ALL] ){
					if(ButtonHold(FireButton))	combo_run(RapidFire);
					else						combo_stop(RapidFire);    	
				}
				if(	ButtonRelease(LeftButton) || ButtonRelease(RightButton) ||
					ButtonRelease(DownButton) || ButtonRelease(UpButton)){
					DisplayAntiRecoilMenu(0);
				}
				AdjustRecoilValue();
				if(ButtonRelease(SelectButton)){
					SaveARInfo();
					DisplayMod(MOD_GAME);
				}
				if(ButtonRelease(CrouchButton)){
					DisplayMod(MOD_GAME);
				}
				if(ButtonRelease(SwapButton)){
					DisplayMod(MOD_GUN_MOV_ADJ);
				}
				Unset(UpButton);
				Unset(DownButton);
				Unset(LeftButton);
				Unset(RightButton);
				Unset(SelectButton);
				Unset(CrouchButton);
				Unset(SwapButton);
				break;
			}
			case MOD_CONFIG:{
				currentConfigModIndex = EditValues(currentConfigModIndex, 0, 3, TRUE);
				if(ButtonPress(LeftButton) || ButtonPress(RightButton)){
					DisplayConfiguration();				
				}
				if(ButtonRelease(SelectButton)){ 			
					if(currentConfigModIndex == 0) DisplayMod(MOD_ANTIRECOIL);
					if(currentConfigModIndex == 1) DisplayMod(MOD_GUN_SELECTION);
					if(currentConfigModIndex == 2) DisplayMod(MOD_QUICK_TOGGLE);	
					if(currentConfigModIndex == 3) DisplayMod(MOD_RESET);
					
				}
				if(ButtonPress(CrouchButton)){
					DisplayMod(MOD_GAME);
				}
				block_all_inputs();
				break;
			}
			case MOD_OPERATOR_SELECTION:{
				if(ButtonHold(AdsButton)){
					operatorsByYearIndex = EditValues(operatorsByYearIndex, 0, 6, TRUE);
					if(ButtonPress(RightButton) || ButtonPress(LeftButton)) DisplayOperatorByYear();
				}else{
					DisplayOperatorSelectionScroll();
					activeOperator = EditValues(activeOperator, 0 , OPERATORS_COUNT - 1, TRUE);
					if(ButtonPress(RightButton) || ButtonPress(LeftButton)) DisplayOperatorSelection();
				}
				if(ButtonRelease(AdsButton)) DisplayOperatorSelection();
				if(ButtonPress(SelectButton)){				
					Unset(SelectButton);
					activeGun = GUN_PRIMARY;
					gunIndex[GUN_PRIMARY] = 0;
					gunIndex[GUN_SECONDARY] = 0;
					LoadARInfo();
					ActivateOperator();
					Unset(SelectButton);
				}
				if(ButtonPress(CrouchButton)) currentMod = MOD_CHANGE_SLOT;
				block_all_inputs();
				break;
			}
			case MOD_GUN_MOV_ADJ:{
				moveAdj = EditValues(moveAdj, quickToggleMinMaxDef[QT_RS_MOVEMENT_ADSJ][0], 
											  quickToggleMinMaxDef[QT_RS_MOVEMENT_ADSJ][1], FALSE);				
				DisplayGunMovAdj();
				if(ButtonRelease(SelectButton)){
					GunARAdjustment[(activeOperator * 2) + activeGun] = moveAdj;
					gunARInfo[2 + (activeGun * 3)] = moveAdj;
					SaveGunARAdjustment();
					DisplayMod(MOD_GAME);
				}
				if(ButtonPress(CrouchButton))	DisplayMod(MOD_ANTIRECOIL);					
				block_all_inputs();
				break;
			}
			case MOD_GUN_SELECTION:{	
				tempGunIndex = gunIndex[activeGun];				
				gunIndex[activeGun] = EditValues(gunIndex[activeGun], 0, 2, TRUE);
				if(GunNameIndex[GetGunNameIndex()] == -1) gunIndex[activeGun] = tempGunIndex;
				if(ButtonPress(LeftButton) || ButtonPress(RightButton)) DisplayGunSelection();
				if(ButtonRelease(SelectButton)){
					if(activeGun == GUN_PRIMARY){
						//Primary Gun
						gunARInfo[0] = GunARIndex[GetGunARIndex()];
						gunARInfo[1] = GunARIndex[GetGunARIndex() + 1];
						gunARInfo[2] = GunARIndex[GetGunARIndex() + 2];
						verticalAR	 = gunARInfo[0];
						horizontalAR = gunARInfo[1];
						moveAdj		 = gunARInfo[2];
						if(moveAdj == 0) moveAdj = quickToggleValue[QT_RS_MOVEMENT_ADSJ];
					}else{
						//Seconday Gun
						gunARInfo[3] = GunARIndex[GetGunARIndex() + 9];
						gunARInfo[4] = GunARIndex[GetGunARIndex() + 10];
						gunARInfo[5] = GunARIndex[GetGunARIndex() + 11];
						verticalAR	 = gunARInfo[3];
						horizontalAR = gunARInfo[4];
						moveAdj		 = gunARInfo[5];
						if(moveAdj == 0) moveAdj = quickToggleValue[QT_RS_MOVEMENT_ADSJ];
					}
					SaveARInfo();
					DisplayMod(MOD_GAME);
				}
				if(ButtonPress(CrouchButton)) DisplayMod(MOD_CONFIG);	
				block_all_inputs();
				break;
			}	
			case MOD_QUICK_TOGGLE:{			
				if(ButtonPress(LeftButton) || ButtonPress(RightButton)){
					toggleIndex = EditValues(toggleIndex, 0, MAX_QT_COUNT, TRUE);
					DisplayQuickToggles(toggleIndex);
				}
				if(ButtonPress(UpButton) || ButtonPress(DownButton)){
					
					quickToggleState[toggleIndex] = !quickToggleState[toggleIndex];
				   	if(toggleIndex == QT_INVERTED){
				   		InvertedAR = 1;
				   		if(quickToggleState[QT_INVERTED] == 1) InvertedAR = -1;   		
				   	}
				   	//Flipped Bumbers/Triggers
				   	if(toggleIndex == QT_BUMPER_SWAP){
					    if(quickToggleState[QT_BUMPER_SWAP]) {
					    	FireButton		= XB1_RB;
							AdsButton   	= XB1_LB;
							AbilityButton  	= XB1_RT;
							TacticalButton	= XB1_LT;
					    }else{
					    	FireButton		= XB1_RT;
							AdsButton   	= XB1_LT;
							AbilityButton  	= XB1_RB;
							TacticalButton	= XB1_LB;
						}
					}
	   				Save();
					DisplayQuickToggles(toggleIndex);
				}
				if(ButtonRelease(SelectButton) && (toggleIndex < QT_AUTO_LEAN && toggleIndex != QT_RAPID_FIRE_FOR_ALL)) DisplayMod(MOD_QUICK_TOGGLE_EDIT);
				if(ButtonPress(CrouchButton)) DisplayMod(MOD_CONFIG);
				block_all_inputs();
				break;
			}
			case MOD_QUICK_TOGGLE_EDIT:{
				if(ButtonPress(LeftButton) || ButtonPress(RightButton)){
					quickToggleValue[toggleIndex] = EditValues(quickToggleValue[toggleIndex], 	
														quickToggleMinMaxDef[toggleIndex][0], 
														quickToggleMinMaxDef[toggleIndex][1], FALSE);				
					DisplayQuickTogglesEdit(toggleIndex);
				}
				if(ButtonRelease(SelectButton)){
					Save();
					DisplayMod(MOD_GAME);
				}
				if(ButtonPress(CrouchButton))	DisplayMod(MOD_QUICK_TOGGLE);
				block_all_inputs();
				break;
			}
			case MOD_CHANGE_SLOT:{
				if(slotNumber == 0 || slotNumber == 9){
					if(get_slot() == arVal) arVal++;
					arVal = EditValues(arVal, 1, 8, TRUE);
					DisplayEnterSlotNumber();
					if(ButtonPress(SelectButton)){
						slotNumber = arVal;
						Save();
					}
				}else ChangeOperatorType(); 
				break;
			}
		}
	}	
	set_val(TRACE_1, verticalAR);
	set_val(TRACE_2, horizontalAR);
	set_val(TRACE_3, GetGunARIndex());
	set_val(TRACE_4, activeGun);
	set_val(TRACE_5, activeOperator);
	set_val(TRACE_6, quickToggleValue[QT_VERITAS_AR]);
}

/*
╔═══════Rainbow Six Siege═══════════╗
║			Combos					║
╚═══════════════════════════════════╝
*/
combo AutoScan{
	Set(SwapButton);
	wait(1280);
	Unset(SwapButton);
	wait(100);
}
combo DoNoficationDelay{
	wait(1000);
	//set_pvar(SPVAR_63, ModsMask);
   	
   	DisplaySwitchGun();
	if(activeGun == GUN_PRIMARY){
		LED(GREEN);
	}else{
		LED(BLUE);
	}
	block_all_inputs();
}
combo SaveNofication{
	cls_oled(0);						
	print(CenterText(sizeof(saveMessage) - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER , OLED_FONT_MEDIUM, OLED_WHITE, saveMessage[0]);
	wait(500);   	
   	DisplaySwitchGun();
	if(activeGun == GUN_PRIMARY){
		LED(GREEN);
	}else{
		LED(BLUE);
	}
	block_all_inputs();
}
combo RapidFire {
    wait(quickToggleValue[QT_RAPID_FIRE]);  // 20ms
    set_val(FireButton, 0);
    wait(quickToggleValue[QT_RAPID_FIRE] - get_rtime());  // 20-10 = 10ms
	set_val(FireButton, 0);  // 10ms
}
combo ResetNotify{
	cls_oled(0);	
   	DisplayFrame();	
	PrintOperatorName(LINE_TOP);
   	print(CenterText(sizeof(resetMessage) - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER , OLED_FONT_MEDIUM, OLED_WHITE, resetMessage[0]);
	wait(450);
	DisplaySwitchGun();
	if(activeGun == GUN_PRIMARY){
		LED(GREEN);
	}else{
		LED(BLUE);
	}
	block_all_inputs();
}
combo TeaBag(){ 
    Set(CrouchButton);
	wait(40);
	Unset(CrouchButton);
	wait(quickToggleValue[QT_TEA_BAG_LOL]);
	Set(CrouchButton);
	wait(40);
	Unset(CrouchButton);
}
combo CrouchSpam{
    Set(CrouchButton);
	wait(40);
	Unset(CrouchButton);
	wait(quickToggleValue[QT_CROUCH_SPAM]);
	Set(CrouchButton);
	wait(40);
	Unset(CrouchButton);
}
combo LeanSpam{
	Set(MeleeButton);
	wait(100);
	Unset(MeleeButton);
	wait(quickToggleValue[QT_LEAN_SPAM]);
	Set(SprintButton);
	wait(100);
	Unset(SprintButton);
}
combo Strafe{
	set_val(POLAR_LX,get_ival(POLAR_LX) + Strafe);
	wait(quickToggleValue[QT_STRAFE]);
	set_val(POLAR_LX,get_ival(POLAR_LX) + inv(Strafe));
	wait(quickToggleValue[QT_STRAFE])
}
combo ShaikoLeanLeft{
	Set(SprintButton);
	wait(300);	
	Set(MeleeButton);
	wait(90);
	Unset(MeleeButton);
	wait(90);
	Set(MeleeButton);
	wait(90);
}
combo ShaikoLeanRight{
	Set(MeleeButton);
	wait(300);	
	Set(SprintButton);
	wait(90);
	Unset(SprintButton);
	wait(90);
	Set(SprintButton);
	wait(90);
}
/*
╔═══════Rainbow Six Siege═══════════╗
║		VeritasAR Functions			║
╚═══════════════════════════════════╝
*/
int CurrentX, CurrentY, MinARecoilFactor, MinARecoilToApply, MovementARecoilToApply;
function SetVeritasAR(AxisToApply,ARecoilToApply) {	
    CurrentY = get_val(XB1_RY);
    CurrentX = get_val(XB1_RX);
    MinARecoilFactor = 20 / 100;
    MinARecoilToApply = MinARecoilFactor * ARecoilToApply;
    MovementARecoilToApply = (1 - MinARecoilFactor) * ((ARecoilToApply * (100 - isqrt(CurrentX*CurrentX + CurrentY*CurrentY))) / (100 + abs(CurrentX) + (CurrentY*CurrentY/2)));

    set_val(AxisToApply,clamp(MinARecoilToApply + MovementARecoilToApply + get_val(AxisToApply),-100,100 - MinARecoilToApply));
}
function VeritasAR(){		
    if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
        useX = horiX;
        useY = vertY;
    }
    if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) > quickToggleValue[QT_RS_DEAD_ZONE]) {
        useX = horiX - (100 / (isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2))));
        useY = vertY - (100 / (isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2))));
        useY = useY  + (useY / moveAdj);
    }
    sysVer = useY * InvertedAR;
    sysHor = useX;
}
function GunConfigAR(){
	dzX 	= ((((horizontalAR 	* 4)/5) 	* (-50 + (quickToggleValue[QT_RS_DEAD_ZONE] * 10))) / 1000);
    dzY 	= ((((verticalAR 	* 4)/5) 	* (-50 + (quickToggleValue[QT_RS_DEAD_ZONE] * 10))) / 1000);
    snsX 	= ((((horizontalAR 	* 5 )/2) 	* (200 )) / 1000);
    snsY 	= ((((verticalAR 	* 5 )/2) 	* (200 )) / 1000);
    vertY 	= ((((verticalAR 	+ (snsY + dzY)) * 327) / 327));
    horiX 	= ((((horizontalAR 	+ (snsX + dzX)) * 327) / 327));
    
    snsX 	= ((((horizontalAR 	* 5 )/2) 	* (200)) / 1000);
    snsY 	= ((((verticalAR 	* 5 )/2) 	* (200)) / 1000);
    vertY 	= ((((verticalAR 	+ (snsY + dzY)) * 327) / 327));
    horiX 	= ((((horizontalAR 	+ (snsX + dzX)) * 327) / 327));
}
//Veritas AR v2
function VeritasARv2(){		
    if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
        useX = horiX;
        useY = vertY;
    }
    if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) > quickToggleValue[QT_RS_DEAD_ZONE]) {
        useX = horiX - (100 / (isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2))));
        useY = vertY - (100 / (isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2))));
        useY = useY  + (useY / moveAdj);
    }
    sysVer = useY * InvertedAR;
    sysHor = useX;
    set_val(XB1_RX,clamp(sysHor * (100 - abs(get_val(XB1_RX))) / 100 + get_val(XB1_RX), -100, 100));
	set_val(XB1_RY,clamp(sysVer * (100 - abs(get_val(XB1_RY))) / 100 + get_val(XB1_RY), -100, 100));    
}
function GunConfigARv2(){
	dzX 	= ((((horizontalAR 	* 4)/5) 	* (-50 + (quickToggleValue[QT_RS_DEAD_ZONE] * 10))) / 1000);
    dzY 	= ((((verticalAR 	* 4)/5) 	* (-50 + (quickToggleValue[QT_RS_DEAD_ZONE] * 10))) / 1000);
    snsX 	= ((((horizontalAR 	* 5 )/2) 	* (200)) / 1000);
    snsY 	= ((((verticalAR 	* 5 )/2) 	* (200)) / 1000);
    vertY 	= ((((verticalAR 	+ (snsY + dzY)) * 327) / 327));
    horiX 	= ((((horizontalAR 	+ (snsX + dzX)) * 327) / 327));
}
//Veritas AR v3
function VeritasARv3(){
   if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) <= quickToggleValue[QT_RS_DEAD_ZONE]) {
        useX = horiX;
        useY = vertY;
    }
    if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) > quickToggleValue[QT_RS_DEAD_ZONE]) {
        useX = horiX - (100 / (isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2))));
        useY = vertY - (100 / (isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2))));
        useY = useY  + (useY / moveAdj);
    }
    sysVer = (useY / 100)* InvertedAR;
    sysHor = (useX / 100);
	set_val(XB1_RX,clamp(sysHor * (100 - abs(get_val(XB1_RX))) / 100 + get_val(XB1_RX), -100, 100));
	set_val(XB1_RY,clamp(sysVer * (100 - abs(get_val(XB1_RY))) / 100 + get_val(XB1_RY), -100, 100));
}
function GunConfigARv3(){
    dzX 	= ((((horizontalAR 	* 327) * 25) * (quickToggleValue[QT_RS_DEAD_ZONE] - 5)) / 1000);
    dzY 	= ((((verticalAR 	* 327) * 25) * (quickToggleValue[QT_RS_DEAD_ZONE] - 5)) / 1000);
    snsX 	= ((((horizontalAR 	* 327) * (25)) * (20 - quickToggleValue[QT_HORIZONTAL_SENSITIVITY])) / 1000);
    snsY 	= ((((verticalAR 	* 327) * (25)) * (20 - quickToggleValue[QT_VERTICAL_SENSITIVITY])) / 1000);
    vertY 	= (((((verticalAR 	* 327) + (snsY + dzY)) * 327) / 327));
    horiX 	= (((((horizontalAR * 327) + (snsX + dzX)) * 327) / 327));
}
/*
╔═══════Rainbow Six Siege═══════════╗
║		Main Functions				║
╚═══════════════════════════════════╝
*/
function ActivateOperator(){
	DisplaySwitchGun();
	DisplayMod(MOD_GAME);
	abilityDeployCount = 0;
	abilityActive = FALSE;
	block_all_inputs();
	serverLogo = 0;
	timer = 0 ;
}
function AdjustRecoilValue(){
	arVal = 0;
	if(ButtonPress(LeftButton))		arVal = 1;
	if(ButtonPress(RightButton))	arVal = 2;
	if(ButtonPress(UpButton))		arVal = 3;
	if(ButtonPress(DownButton))		arVal = 4;
	if(arVal == 0) return;
	if(activeGun == GUN_PRIMARY){
		if(arVal > 2) gunARInfo[0] = EditARValues(gunARInfo[0],   0, 99);
		if(arVal < 3) gunARInfo[1] = EditARValues(gunARInfo[1], -20, 20);
		verticalAR	 = gunARInfo[0];
		horizontalAR = gunARInfo[1];
	}else{
		if(arVal > 2) gunARInfo[3] = EditARValues(gunARInfo[3],	  0, 99);
		if(arVal < 3) gunARInfo[4] = EditARValues(gunARInfo[4], -20, 20);
		verticalAR 	 = gunARInfo[3];
		horizontalAR = gunARInfo[4];
	}
	if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V1)		GunConfigAR();
	else if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V2) 	GunConfigARv2();
	else 														GunConfigARv3();
	DisplayAntiRecoilMenu(arVal);
}
function CloseAvility(){
	abilityReleasingTime 	= 0;
	abilityCountDown		= 0;
	abilityTimeCheck		= FALSE;
	abilityActive			= FALSE;
	DisplaySwitchGun();	
}
function CheckAbilityOff(){	
	if(abilityTimeCheck){				
		abilityCountDown += get_rtime();
		if(abilityCountDown >= abilityReleasingTime) {
			CloseAvility();
			return;
		}
	}
	if(activeOperator == 4)/*DOC */{ 
		if(ButtonRelease(SwapButton)){
			abilityReleasing = TRUE;
			CloseAvility();
		}
	}
	else if(activeOperator == 12)/*CAVEIRA */{ 	
		if(ButtonRelease(TacticalButton)) 	CloseAvility();
		if(ButtonRelease(DownButton)) 		CloseAvility();
		if(ButtonRelease(SwapButton)){
			activeGun = !activeGun;
			CloseAvility();
		}
		if(ButtonRelease(AbilityButton)){
			abilityReleasing = TRUE;
			CloseAvility();
		}
	}
	else if(activeOperator == 13)/*ECHO */{ 
		if(abilityDeployCount > 0 && ButtonPress(DownButton)){
			CloseAvility();
			return;
		}
		if(ButtonPress(DownButton) || ButtonPress(CrouchButton)){
			if(abilityCams){
				abilityCams = FALSE;
			}else{
				CloseAvility();
				return;
			}
		}
	}
	else if(activeOperator == 18)/*MAESTRO*/{
		if(ButtonHold(AdsButton) && DoubleTab(CrouchButton)){
			CloseAvility();
			abilityCams = FALSE;
			abilityDeploying = FALSE;
			return;
		}
		if(ButtonPress(DownButton) 		&& abilityCams){
			abilityCams = FALSE;
			return;
		}
		if(ButtonPress(DownButton) 		&& !abilityDeploying){
			CloseAvility();
			return;
		}
		if(ButtonPress(CrouchButton) 	&& !abilityDeploying){
			CloseAvility();
			abilityCams = FALSE;
			abilityDeploying = FALSE;
		}
		if(ButtonPress(SwapButton)		&& abilityDeployCount == 0){
			activeGun	= !activeGun;
			CloseAvility()
		}
		if(ButtonHold(ReloadButton) 	&& get_ptime(ReloadButton) > 1700){
			if(abilityDeployCount == 2) abilityDeployCount = 0;
			if(abilityDeployCount < 2){
				abilityDeployCount ++;
				abilityDeploying = FALSE;
				CloseAvility();
			}
		}
		if(ButtonPress(AbilityButton) 	&& abilityDeployCount < 2 && !abilityCams){
			abilityReleasing = TRUE;
			abilityDeploying = FALSE;
			CloseAvility();
		}
	} 
	else if(activeOperator == 20)/*CLASS*/{
		if(ButtonRelease(TacticalButton) 	|| 
			ButtonPress(DownButton)){  
			abilityReleasing = TRUE;
			CloseAvility();
		}
		if(ButtonRelease(AbilityButton)){ 
			abilityReleasing = TRUE;
			CloseAvility();
		}
		if(ButtonRelease(SwapButton)){ 			
			CloseAvility();
		}
		
	}
}
function ChangeOperatorType(){	
	block_all_inputs();
	load_slot(slotNumber);
}
function DisplayAntiRecoilDirectionMenu(charIndex){
	if(charIndex != 1){
		putc_oled(1, 133);
		puts_oled(50, 35, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH,1);
	}
	if(charIndex != 2){
		putc_oled(1, 134);
		puts_oled(70, 35, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH,1);
	}
	if(charIndex != 3){
		putc_oled(1, 131);
		puts_oled(60, 25, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH,1);
	}
	if(charIndex != 4){
		putc_oled(1, 132);
		puts_oled(60, 45, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH,1);
	}
}
function DisplayAntiRecoilMenu(charIndex){
	ClearScroll(LINE_TOP);
	DisplayFrame();
	putc_oled(1, 86);
	puts_oled(20, LINE_BOTTOM, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH, 1);
	DisplayAntiRecoilDirectionMenu(charIndex);

	putc_oled(1, 72);
	puts_oled(100, LINE_BOTTOM, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH, 1);
	
	print(CenterText(configuration[1] - configuration[0] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, configuration[0]);
	NumberToString(horizontalAR, FindDigits(horizontalAR), 90, LINE_CENTER);
	NumberToString(verticalAR, FindDigits(verticalAR), 15, LINE_CENTER);
}	
function DisplayAbility(){
	if(abilityReleasing){
		abilityReleasing = FALSE;
		return;
	}
	if(abilityCoolDown){
		abilityCountDown += get_rtime();
		if(abilityCountDown < abilityReleasingTime)return;
		abilityCoolDown = FALSE
	}
	if(activeOperator == 4)/*DOC	*/{ 
		if(ButtonRelease(AbilityButton)){
			PrintAvilityName(0);
			abilityActive = TRUE;
		}
	}
	else if(activeOperator == 12)/*CAVEIRA */{ 	
		if(ButtonRelease(AbilityButton) || ButtonRelease(DownButton)){
			if(activeGun != GUN_SECONDARY){
				 activeGun	= !activeGun;
				 DisplaySwitchGun();
			}
			PrintAvilityName(2);
			abilityActive 			= TRUE;
			abilityReleasingTime 	= 12500;
			abilityCountDown		= 0;
			abilityTimeCheck		= TRUE;
			abilityFocus			= TRUE;
			
		}
	}
	else if(activeOperator == 13)/*ECHO */{ 
		if(ButtonPress(AbilityButton) && !abilityCams){
			if(abilityDeployCount < 2){
				abilityDeployCount ++:
			}else{
				PrintAvilityName(4);
				abilityActive = TRUE;
			}
		}
		if(abilityDeployCount > 0 && ButtonPress(DownButton)){
			PrintAvilityName(4);
			abilityActive = TRUE;
		}
		if(abilityDeployCount > 0 && ButtonPress(AbilityButton)){
			PrintAvilityName(4);
			abilityActive = TRUE;
		}
		if(abilityDeployCount == 0 && ButtonPress(DownButton)){
			abilityCams = TRUE;
		}
	}
	else if(activeOperator == 18)/*MAESTRO*/{ 
		if(ButtonPress(AbilityButton)){
			PrintAvilityName(6);
			abilityActive = TRUE;
			if(abilityDeployCount < 2) abilityDeploying = TRUE;
		}
		if(abilityDeployCount > 0 && ButtonPress(DownButton)){
			PrintAvilityName(6);
			abilityActive = TRUE;
		}
		if(abilityDeployCount == 0 && ButtonPress(DownButton)){
			abilityCams = TRUE;
		}
	}
	else if(activeOperator == 20)/*CLASH -*/{
		if(ButtonRelease(AbilityButton)){
			PrintAvilityName(8);
			abilityActive 	= TRUE;		
		}
		if(ButtonRelease(SwapButton)){
			PrintAvilityName(8);
			abilityActive 	= TRUE;	
		}
	}
}
function DisplayEnterSlotNumber(){
	DisplayFrame();
	
	print(CenterText(enterSlotMsg[0 + 1] - enterSlotMsg[0] - 1, OLED_FONT_SMALL_WIDTH), LINE_TOP, 		OLED_FONT_SMALL, OLED_WHITE, enterSlotMsg[0]);
	print(CenterText(enterSlotMsg[1 + 1] - enterSlotMsg[1] - 1, OLED_FONT_SMALL_WIDTH), LINE_TOP + 10, OLED_FONT_SMALL, OLED_WHITE, enterSlotMsg[1]);
	print(CenterText(enterSlotMsg[2 + 1] - enterSlotMsg[2] - 1, OLED_FONT_SMALL_WIDTH), LINE_TOP + 20, OLED_FONT_SMALL, OLED_WHITE, enterSlotMsg[2]);
	NumberToString(arVal, FindDigits(arVal), CenterText(FindDigits(arVal), OLED_FONT_MEDIUM_WIDTH), LINE_BOTTOM);	
}
function DisplayConfiguration(){
	DisplayFrame();	
	if(currentConfigModIndex == 4){
		print(CenterText(configuration[currentConfigModIndex + 1] - configuration[currentConfigModIndex] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, configuration[currentConfigModIndex]);
		print(CenterText(toggleStatus[quickToggleState[currentConfigModIndex]+ 1] - toggleStatus[quickToggleState[currentConfigModIndex]] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 5, OLED_FONT_MEDIUM, OLED_WHITE, toggleStatus[quickToggleState[currentConfigModIndex]]);
	}else{
		print(CenterText(sizeof(configurationText) - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, configurationText[0]);
		print(CenterText(configuration[currentConfigModIndex + 1] - configuration[currentConfigModIndex] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER , OLED_FONT_MEDIUM, OLED_WHITE, configuration[currentConfigModIndex]);
	}
	
	DisplayLeftRight();		    	
	LED(RED);
}
function DisplayGunName(){
	print(CenterText(GunName[GunNameIndex[GetGunNameIndex()] + 1] - GunName[GunNameIndex[GetGunNameIndex()]] - 1 , OLED_FONT_MEDIUM_WIDTH), LINE_CENTER, OLED_FONT_MEDIUM, OLED_WHITE, GunName[GunNameIndex[GetGunNameIndex()]]);	
}
function DisplayGunMovAdj(){
	DisplayFrame();
	
	print(CenterText(quickToggleNames[QT_RS_MOVEMENT_ADSJ + 1] - quickToggleNames[QT_RS_MOVEMENT_ADSJ] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER - 10, OLED_FONT_MEDIUM, OLED_WHITE, quickToggleNames[QT_RS_MOVEMENT_ADSJ]);
	NumberToString(moveAdj, FindDigits(moveAdj), CenterText(FindDigits(moveAdj), OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 10);

	LED(RED);
}
function DisplayGunSelection(){	
	DisplayFrame();
	DisplayGunIndex();
	DisplayLeftRight();
	DisplayGunName();
}
function DisplayGunType(){
	print(CenterText(GunTypeName[GetGunTypeIdex() + 1] - GunTypeName[GetGunTypeIdex()] - 1 , OLED_FONT_SMALL_WIDTH), LINE_BOTTOM, OLED_FONT_SMALL, OLED_WHITE, GunTypeName[GetGunTypeIdex()]);
	print(CenterText(GunTypeName[GetGunTypeIdex() + 1] - GunTypeName[GetGunTypeIdex()] - 1 , OLED_FONT_SMALL_WIDTH), LINE_BOTTOM, OLED_FONT_SMALL, OLED_WHITE, GunTypeName[GetGunTypeIdex()]);	
	gunRapidFire = GetGunRFIndex();
}
function DisplayGunIndex(){
	ClearScroll(LINE_TOP);
	if(activeGun == GUN_PRIMARY){
		print(CenterText(gunIndexMsg[0 + 1] - gunIndexMsg[0] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, gunIndexMsg[0]);
	}else{
		print(CenterText(gunIndexMsg[1 + 1] - gunIndexMsg[1] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, gunIndexMsg[1]);
	}
}
function DisplayMod(modIndex){	
   	currentMod 	 =  modIndex;
	block_all_inputs();
   	if(modIndex == MOD_ANTIRECOIL)   		DisplayAntiRecoilMenu(0);
   	if(modIndex == MOD_GUN_SELECTION)		DisplayGunSelection();
   	if(modIndex == MOD_CONFIG)				DisplayConfiguration();
   	if(modIndex == MOD_RESET)				ResetOperator(); 	
   	if(modIndex == MOD_GAME)				DisplaySwitchGun(); 
   	if(modIndex == MOD_QUICK_TOGGLE_EDIT)	DisplayQuickTogglesEdit(toggleIndex);    	
    if(modIndex == MOD_QUICK_TOGGLE)    	DisplayQuickToggles(toggleIndex);
    if(modIndex == MOD_GUN_MOV_ADJ)			DisplayGunMovAdj();
}
function DisplayOperatorSelection(){
	DisplayFrame();	
	DisplayLeftRight();
	PrintOperatorName(LINE_CENTER);
	ClearScroll(LINE_TOP);
}
function DisplayOperatorByYear(){
	DisplayFrame();
	activeOperator= operatorsByYear[operatorsByYearIndex];
	
	print(CenterText(operationName[operatorsByYearIndex + 1] - operationName[operatorsByYearIndex] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, operationName[operatorsByYearIndex]);
	print(CenterText(operationName2[operatorsByYearIndex + 1] - operationName2[operatorsByYearIndex] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER, OLED_FONT_MEDIUM, OLED_WHITE, operationName2[operatorsByYearIndex]);
	print(CenterText(operationYear[operatorsByYearIndex + 1] - operationYear[operatorsByYearIndex] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_BOTTOM, OLED_FONT_MEDIUM, OLED_WHITE, operationYear[operatorsByYearIndex]);	
}
function DisplaySwitchGun(){
	DisplayFrame();	
	if(activeGun == GUN_SECONDARY && GunNameIndex[GetGunNameIndex()] == -1){
		activeGun = GUN_PRIMARY;
	}
	print(CenterText(OperatorName[activeOperator + 1] - OperatorName[activeOperator] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_TOP, OLED_FONT_MEDIUM, OLED_WHITE, OperatorName[activeOperator]);		
	DisplayGunName();
	DisplayGunType();
	if(activeGun == GUN_PRIMARY){
		LED(GREEN);
		verticalAR 	  =	gunARInfo[0];
		horizontalAR  = gunARInfo[1];
		moveAdj		  = gunARInfo[2];
		if(moveAdj == 0) moveAdj = quickToggleValue[QT_RS_MOVEMENT_ADSJ];
	}else{
		LED(BLUE);
		verticalAR 	  =	gunARInfo[3];
		horizontalAR  = gunARInfo[4];
		moveAdj		  = gunARInfo[5];
		if(moveAdj == 0) moveAdj = quickToggleValue[QT_RS_MOVEMENT_ADSJ];
	}
	if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V1)		GunConfigAR();
	else if(quickToggleValue[QT_VERITAS_AR] == VERITAS_AR_V2) 	GunConfigARv2();
	else 														GunConfigARv3();
}
function DisplayScriptInfo(){
	cls_oled(0);
	inInfoView = TRUE;	
	DrawLogo();
	print(CenterText(sizeof(VersionInfo) - 1 , OLED_FONT_SMALL_WIDTH), LINE_CENTER + 30, OLED_FONT_SMALL, OLED_WHITE, VersionInfo[0]);	
}
function DisplayOperatorSelectionScroll(){
	if(stopScroll) return;
	messageColumCount --;
	messageSize = sizeof(operatorSelMsg)/sizeof(operatorSelMsg[0]);
	for (messageArrayLine = 0; messageArrayLine < messageSize; messageArrayLine++){
		if(messageColumCount + (10 * messageArrayLine ) > 0 && messageColumCount + (10 * messageArrayLine ) < 127){
			putc_oled(1, operatorSelMsg[messageArrayLine]);
			puts_oled(messageColumCount + (10 * messageArrayLine ), LINE_TOP - 5, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH, 1);
		}
	}

	if(messageColumCount + (10 * messageArrayLine ) < 0 ){
		messageColumCount = 127;
	}
	line_oled(1, 1 , 1 , 22 , 1 , 1 );	
}
function DisplayQuickToggles(qtID){
	DisplayFrame();
	print(CenterText(quickToggleNames[qtID + 1] - quickToggleNames[qtID] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER - 15, OLED_FONT_MEDIUM, OLED_WHITE, quickToggleNames[qtID]);
	if(	qtID == QT_RS_DEAD_ZONE ||
		qtID == QT_RS_MOVEMENT_ADSJ ||
		qtID == QT_VERTICAL_SENSITIVITY ||
		qtID == QT_HORIZONTAL_SENSITIVITY ){
		NumberToString(quickToggleValue[qtID], 	FindDigits(quickToggleValue[qtID]), 	CenterText(FindDigits(quickToggleValue[qtID]), OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 5 );
	}else if(qtID == QT_VERITAS_AR){
		print(CenterText(veritasARVersion[quickToggleValue[QT_VERITAS_AR] + 1] - veritasARVersion[quickToggleValue[QT_VERITAS_AR]] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 5, OLED_FONT_MEDIUM, OLED_WHITE, veritasARVersion[quickToggleValue[QT_VERITAS_AR]]);
	}else{
		print(CenterText(toggleStatus[quickToggleState[qtID] + 1] - toggleStatus[quickToggleState[qtID]] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 5, OLED_FONT_MEDIUM, OLED_WHITE, toggleStatus[quickToggleState[qtID]]);
	}
	DisplayLeftRight();		    	
	LED(RED);
}
function DisplayQuickTogglesEdit(qtID){
	DisplayFrame();
	print(CenterText(quickToggleNames[qtID + 1] - quickToggleNames[qtID] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER - 10, OLED_FONT_MEDIUM, OLED_WHITE, quickToggleNames[qtID]);
	if(qtID == QT_VERITAS_AR){
		print(CenterText(veritasARVersion[quickToggleValue[QT_VERITAS_AR] + 1] - veritasARVersion[quickToggleValue[QT_VERITAS_AR]] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 10, OLED_FONT_MEDIUM, OLED_WHITE, veritasARVersion[quickToggleValue[QT_VERITAS_AR]]);
	}else{
		NumberToString(quickToggleValue[qtID], 	FindDigits(quickToggleValue[qtID]), 	CenterText(FindDigits(quickToggleValue[qtID]), OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 10);
	}
	LED(RED);
}
function DisplayLeftRight(){
	ClearScroll(LINE_BOTTOM);
	putc_oled(1, 133);
	puts_oled(10, LINE_BOTTOM, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH,1);
	putc_oled(1, 134);
	puts_oled(111,LINE_BOTTOM, OLED_FONT_MEDIUM, OLED_FONT_MEDIUM_WIDTH,1);
	line_oled(1, 1 , 1 , LINE_BOTTOM + 10 , 1 , 1 );
}
function DisplayFrame(){
	cls_oled(OLED_BLACK); 
	rect_oled(0, 0, OLED_WIDTH, OLED_HEIGHT, OLED_BLACK, OLED_WHITE);
}
function EditQuickToggle(qtID){
	cls_oled(0);	
   	quickToggleState[qtID] = !quickToggleState[qtID];
   	print(CenterText(quickToggleNames[qtID + 1] - quickToggleNames[qtID] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER - 10, OLED_FONT_MEDIUM, OLED_WHITE, quickToggleNames[qtID]);
   	print(CenterText(toggleStatus[quickToggleState[qtID] + 1] - toggleStatus[quickToggleState[qtID]] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 10, OLED_FONT_MEDIUM, OLED_WHITE, toggleStatus[quickToggleState[qtID]]);
   	if(qtID == QT_INVERTED){
   		InvertedAR = 1;
   		if(quickToggleState[QT_INVERTED] == 1) InvertedAR = -1;   		
   	}
   	Save();
   	combo_run(DoNoficationDelay);
   	block_all_inputs();   	
   	Unset(UpButton);
   	Unset(DownButton);
   
}
function LoadARInfo(){	
	spvar_current_slot = (32768 - activeOperator) * -1;
	spvar_current_bit = 0;
	spvar_current_value = 0;
		
	gunARInfo[0] = GunARIndex[GetGunARIndex()];
	gunARInfo[1] = GunARIndex[GetGunARIndex() + 1];
	gunARInfo[2] = GunARIndex[GetGunARIndex() + 2];
	gunARInfo[3] = GunARIndex[GetGunARIndex() + 9];
	gunARInfo[4] = GunARIndex[GetGunARIndex() + 10];
	gunARInfo[5] = GunARIndex[GetGunARIndex() + 11];	
	
	if(GunARAdjustment[(activeOperator * 2)] != 0){
		gunARInfo[2] = GunARAdjustment[(activeOperator * 2)];
	}
	if(GunARAdjustment[(activeOperator * 2) + 1] != 0){
		gunARInfo[5] = GunARAdjustment[(activeOperator * 2) + 1];
	}

	gunIndex[0]		= read_spvar(0,		2,	0);
	gunIndex[1]		= read_spvar(0,		1,	0);
	gunARInfo[0]	= read_spvar(0,		99,	GunARIndex[GetGunARIndex()]);
	if(gunARInfo[0]	== 0){
		gunARInfo[0]	= GunARIndex[GetGunARIndex()];
		return;
	}
	gunARInfo[1]	= read_spvar(-20,	20,	GunARIndex[GetGunARIndex() + 1]);
	gunARInfo[3]	= read_spvar(0,		99,	GunARIndex[GetGunARIndex() + 6]);
	gunARInfo[4]	= read_spvar(-20,	20,	GunARIndex[GetGunARIndex() + 7]);
	
}
function LoadGunARAdjustment(){
	spvar_current_slot = SPVAR_40;
	spvar_current_bit = 0;
	spvar_current_value = 0;	
	for(i = 0; i <= OPERATORS_COUNT * 2 ; i++){
		GunARAdjustment[i] = read_spvar(1, 10, 0);		
	}
}
function SaveGunARAdjustment(){
	spvar_current_slot = SPVAR_40;
	spvar_current_bit = 0;
	spvar_current_value = 0;	
	for(i = 0; i < OPERATORS_COUNT * 2; i++){				
		save_spvar(GunARAdjustment[i], 0, 10, FALSE);		
	}
	save_spvar(GunARAdjustment[i + 1], 	0, 10,	TRUE);
}
function SaveARInfo(){
		
	spvar_current_slot = (32768 - activeOperator) * -1;
	spvar_current_bit = 0;
	spvar_current_value = 0;
		
	save_spvar(gunIndex[0],	 0,		2,	FALSE);
	save_spvar(gunIndex[1],	 0,		1,	FALSE);
	save_spvar(gunARInfo[0], 0,		99,	FALSE);
	save_spvar(gunARInfo[1], -20,	20,	FALSE);
	save_spvar(gunARInfo[3], 0,		99,	FALSE);
	save_spvar(gunARInfo[4], -20,	20,	TRUE);
		
	combo_run(SaveNofication);
}
function PrintAvilityName(position){
	DisplayFrame();
	print(CenterText(avilityName[position + 1] - avilityName[position] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER - 10, OLED_FONT_MEDIUM, OLED_WHITE, avilityName[position]);
	print(CenterText(avilityName[position + 2] - avilityName[position + 1] - 1, OLED_FONT_MEDIUM_WIDTH), LINE_CENTER + 10, OLED_FONT_MEDIUM, OLED_WHITE, avilityName[position + 1]);
}
function PrintOperatorName(line){
	print(CenterText(OperatorName[activeOperator + 1] - OperatorName[activeOperator] - 1, OLED_FONT_MEDIUM_WIDTH), line, OLED_FONT_MEDIUM, OLED_WHITE, OperatorName[activeOperator]);
}
function ResetOperator(){
	saveVar = (32768 - activeOperator) * -1;
	set_pvar(saveVar, 0);
	LoadARInfo();	
	combo_run(ResetNotify);
	ActivateOperator();
}
function EditValues(value, min, max, loop){
	if(event_press(UpButton) || event_press(RightButton)){
		if(get_ival(AdsButton) && currentMod != MOD_OPERATOR_SELECTION) value += 10;
		else value ++; 

		if(loop && value > max) return min;
	}
	if(event_press(DownButton) || event_press(LeftButton)){
		if(get_ival(AdsButton) && currentMod != MOD_OPERATOR_SELECTION) value -= 10;
		else value --; 
		if(loop && value < min) return max;
	}

	return value = clamp(value, min, max);
}
	//Information functions	
function ClearScroll(scrollLine){
	for (forIndex = 0; forIndex < 127; forIndex++) {		 
		PrintCharacter(32, forIndex, scrollLine);
	}
}	
function GetGunNameIndex() 	{ return (6 * activeOperator) + (activeGun * 3) + gunIndex[activeGun]}
function GetGunTypeIdex() 	{ return GunTypeIndex[GetGunNameIndex()]}
function GetGunRFIndex()   	{ return GunRFIndex[GetGunNameIndex()]}
function GetGunARIndex()	{ return (18 * activeOperator) + (gunIndex[activeGun] * 3)}
function EditARValues(value, min, max){
	if(event_press(UpButton) || event_press(LeftButton)){
		if(get_ival(AdsButton)) value -= 10;
		else value --;                           
	}
	if(event_press(DownButton) || event_press(RightButton)){
		if(get_ival(AdsButton)) value += 10;
		else value ++;
	}

	return value = clamp(value, min, max);
}
	//Buttons funntions
function ButtonPress(button){
	return event_press(button);
} 
function ButtonRelease(button){return event_release(button);}
function ButtonHold(button){
	return get_val(button);
} 	
function DoubleTab(button) { 
	if(event_press(button) && get_brtime(button) < 300) return TRUE;                                     
	return 0;                                        
}  
function Set(button){set_val(button, 100);} 
function Unset(button){set_val(button, 0);}
/*
============================================================================================================================================
  Bit Packing SPVARs ()                                                                                                                      
============================================================================================================================================
*/
// Use these for 32-bit SPVARs
define FULL_BITMASK = -1;
define MAX_BITS = 32;
define MAX_FW_BITS = 32;
function reset_spvar() {
	spvar_current_slot = SPVAR_60; // Change this to say where it's safe to start storing data
	spvar_current_bit = 0;
	spvar_current_value = 0;
}
function get_bit_count(val) {
/*	if (val == (1 << (MAX_FW_BITS - 1))) {
		return MAX_FW_BITS;
	}*/
	if (val < 0) {
		return get_bit_count(abs(val + 1));
	}
	spvar_tmp = 0;
	do {
		spvar_tmp++;
		val = val >> 1; // Shift the value down 1 bit
	} while (val);
	return spvar_tmp;
}
function get_bit_count2(min, max) {	
	spvar_tmp = max(get_bit_count(min), get_bit_count(max));
	if (is_signed2(min, max)) {
		spvar_tmp++;
	}
	return spvar_tmp;
}
function is_signed2(min, max) { return min < 0 || max < 0; }
function make_full_mask(bits) {	
	if (bits == MAX_FW_BITS) {
		return FULL_BITMASK;
	}
	return (FULL_BITMASK & (~(1 << (MAX_FW_BITS - 1)))) >> (MAX_FW_BITS - bits - 1);
}
function make_sign(bits) { return 1 << clamp(bits - 1, 0, MAX_FW_BITS - 1); }
function make_sign_mask(bits) { return ~make_sign(bits); }
function pack_u(val, bits) { return val & make_full_mask(bits); }
function pack_i(val, bits) {
	if (val < 0) {
		return (abs(val) & make_sign_mask(bits)) | make_sign(bits);	
	}
	return val & make_sign_mask(bits);
}
function unpack_i(val, bits) {
	if (val & make_sign(bits)) {
		return 0 - (val & make_sign_mask(bits));
	}
	return val & make_sign_mask(bits);
}

int spvar_current_bit;
int spvar_current_slot;
int spvar_current_value;
int spvar_tmp;
int spvar_bits;

function read_spvar_slot(slot) { return get_pvar(slot, 0-(FULL_BITMASK & (1 << (MAX_BITS - 1))), 0-((0-(FULL_BITMASK & (1 << (MAX_BITS - 1)))) + 1), 0); }
function save_spvar(val, min, max, save) {
	spvar_bits = get_bit_count2(min, max); // Set min to be the bits we're going to need to store this value	
	
	if (is_signed2(min, max)) {
		val = pack_i(val, spvar_bits); // Pack as signed value	
	}
	val = pack_u(val, spvar_bits); // Pack as unsigned value - because this is more inclusive than signed, we don't need an else here - just always do it (micro optimization)
	
	if (spvar_bits > MAX_BITS - spvar_current_bit) { // If we cannot fit the value here, we need to store what we can and move to the next slot
		spvar_current_value = spvar_current_value | (val << spvar_current_bit); // Add what we can to the current value
		set_pvar(spvar_current_slot, spvar_current_value); // Force save, we're moving to the next value		
		spvar_current_slot++; // Move to the next slot
		spvar_bits -= (MAX_BITS - spvar_current_bit); // Update the required bits according to our needs for the next slot
		val = val >> (MAX_BITS - spvar_current_bit); // Move the remaining bits to their new location
		spvar_current_bit = 0; // We've hit the end, so we start over
		spvar_current_value = 0; // Reset our value so we start clean
	}
	
	spvar_current_value = spvar_current_value | (val << spvar_current_bit); // Add the value to the current position
	spvar_current_bit += spvar_bits; // Increment the bit position
	if (spvar_current_bit >= MAX_BITS) {
		spvar_current_bit -= MAX_BITS; // We went beyond the end here, this is too big apparently
		set_pvar(spvar_current_slot, spvar_current_value);
		spvar_current_slot++; // move to the next slot
		if (!spvar_current_bit) {
			spvar_current_value = 0; // Reset our value so we start clean
		}
	}
	if (save) {
		set_pvar(spvar_current_slot, spvar_current_value);
	}	
}
function read_spvar(min, max, _default) {
    spvar_current_value = read_spvar_slot(spvar_current_slot); // Load the value so we always have it where we need it to be
    spvar_bits = get_bit_count2(min, max); // Set min to be the bits we're going to need to store this value
    spvar_current_value = pack_u(spvar_current_value >> spvar_current_bit, spvar_bits); // Shift our bits into position
    
    if (spvar_bits > MAX_BITS - spvar_current_bit) { // if the value doesn't fit in this variable, we need to fetch the next value aswell and merge them accordingly
        spvar_current_slot++; // Move to the next slot
        spvar_tmp = read_spvar_slot(spvar_current_slot); // load the new slot into a temporary variable
        spvar_tmp = pack_u(spvar_tmp, spvar_bits - (MAX_BITS - spvar_current_bit)); // Get the bits we need
        spvar_tmp = spvar_tmp << (MAX_BITS - spvar_current_bit); // Shift the bits into their correct position
        spvar_current_value = pack_u(spvar_current_value, MAX_BITS - spvar_current_bit);
        spvar_current_value = spvar_current_value | spvar_tmp; // put all bits together again
        spvar_current_bit = spvar_current_bit - MAX_BITS; // Reset the bit position so we get the correct position next
    }    
    spvar_current_bit += spvar_bits; // move to the next variable position
    if (spvar_current_bit >= MAX_BITS) {
        spvar_current_bit -= MAX_BITS; // We went beyond the end here, this is too big apparently
        spvar_current_slot++;
    }    
    spvar_current_value = pack_u(spvar_current_value, spvar_bits); // Extract all bits included for this value
    if (is_signed2(min, max)) { // Check if we have a sign bit
        spvar_current_value = unpack_i(spvar_current_value, spvar_bits); // Restore signed value
    }
    if (spvar_current_value < min || spvar_current_value > max) { // Check if the value is below our specified min or above our specified max, if so - return the default value instead
        return _default;
    }
    return spvar_current_value;
}
function Save(){
	reset_spvar();
	
	save_spvar(quickToggleState[QT_CROUCH_SPAM]	+ 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_STRAFE] 		+ 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_SHAIKO_LEAN] + 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_AUTO_LEAN]	+ 1 		, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_PRONE_SHOT] 	+ 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_LEAN_SPAM] 	+ 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_TEA_BAG_LOL] + 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_RAPID_FIRE_FOR_ALL] 	+ 1	, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_RAPID_FIRE] + 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_PIN_ON_SHOT] + 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_AUTO_SCAN] 	+ 1			, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_INVERTED]	+ 1 		, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_BUMPER_SWAP]	+ 1 		, 1, 2, 	FALSE);
	save_spvar(quickToggleState[QT_CROUCH_SPAM_DELAY] + 1 	, 1, 2, 	FALSE);
	
	save_spvar(quickToggleValue[QT_CROUCH_SPAM],			quickToggleMinMaxDef[0][0],  quickToggleMinMaxDef[0][1], FALSE);
	save_spvar(quickToggleValue[QT_STRAFE], 				quickToggleMinMaxDef[1][0],  quickToggleMinMaxDef[1][1], FALSE);
	save_spvar(quickToggleValue[QT_SHAIKO_LEAN],  			quickToggleMinMaxDef[2][0],  quickToggleMinMaxDef[2][1], FALSE);		
	save_spvar(quickToggleValue[QT_PRONE_SHOT],				quickToggleMinMaxDef[3][0],  quickToggleMinMaxDef[3][1], FALSE);
	save_spvar(quickToggleValue[QT_LEAN_SPAM],				quickToggleMinMaxDef[4][0],  quickToggleMinMaxDef[4][1], FALSE);
	save_spvar(quickToggleValue[QT_TEA_BAG_LOL],			quickToggleMinMaxDef[5][0],  quickToggleMinMaxDef[5][1], FALSE);
	save_spvar(quickToggleValue[QT_RAPID_FIRE],				quickToggleMinMaxDef[7][0],  quickToggleMinMaxDef[7][1], FALSE);
	save_spvar(quickToggleValue[QT_RS_DEAD_ZONE],			quickToggleMinMaxDef[8][0],  quickToggleMinMaxDef[8][1], FALSE);
	save_spvar(quickToggleValue[QT_VERTICAL_SENSITIVITY],	quickToggleMinMaxDef[9][0],  quickToggleMinMaxDef[9][1], FALSE);
	save_spvar(quickToggleValue[QT_HORIZONTAL_SENSITIVITY],	quickToggleMinMaxDef[10][0],  quickToggleMinMaxDef[10][1], FALSE);
	save_spvar(quickToggleValue[QT_RS_MOVEMENT_ADSJ], 		quickToggleMinMaxDef[11][0], quickToggleMinMaxDef[11][1], FALSE);
	save_spvar(quickToggleValue[QT_VERITAS_AR], 			quickToggleMinMaxDef[12][0], quickToggleMinMaxDef[12][1], FALSE);
	save_spvar(slotNumber							,		1 , 9, TRUE);		
}
function Load(){
	reset_spvar();	
	
	quickToggleState[QT_CROUCH_SPAM] 			= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_STRAFE] 				= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_SHAIKO_LEAN] 			= read_spvar(  1,  2, 2) - 1;
	quickToggleState[QT_AUTO_LEAN]	 			= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_PRONE_SHOT] 			= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_LEAN_SPAM] 				= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_TEA_BAG_LOL] 			= read_spvar(  1,  2, 2) - 1;
	quickToggleState[QT_RAPID_FIRE_FOR_ALL] 	= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_RAPID_FIRE] 			= read_spvar(  1,  2, 2) - 1;
	quickToggleState[QT_PIN_ON_SHOT] 			= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_AUTO_SCAN] 				= read_spvar(  1,  2, 2) - 1;	
	quickToggleState[QT_INVERTED] 				= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_BUMPER_SWAP] 			= read_spvar(  1,  2, 1) - 1;
	quickToggleState[QT_CROUCH_SPAM_DELAY]		= read_spvar(  1,  2, 2) - 1;
	
	quickToggleValue[QT_CROUCH_SPAM] 			= read_spvar(quickToggleMinMaxDef[0][0],  quickToggleMinMaxDef[0][1], 	quickToggleMinMaxDef[0][2]);
	quickToggleValue[QT_STRAFE] 				= read_spvar(quickToggleMinMaxDef[1][0],  quickToggleMinMaxDef[1][1], 	quickToggleMinMaxDef[1][2]);
	quickToggleValue[QT_SHAIKO_LEAN] 			= read_spvar(quickToggleMinMaxDef[2][0],  quickToggleMinMaxDef[2][1], 	quickToggleMinMaxDef[2][2]);		
	quickToggleValue[QT_LEAN_SPAM] 				= read_spvar(quickToggleMinMaxDef[3][0],  quickToggleMinMaxDef[3][1], 	quickToggleMinMaxDef[3][2]);
	quickToggleValue[QT_PRONE_SHOT] 			= read_spvar(quickToggleMinMaxDef[4][0],  quickToggleMinMaxDef[4][1], 	quickToggleMinMaxDef[4][2]);	
	quickToggleValue[QT_TEA_BAG_LOL] 			= read_spvar(quickToggleMinMaxDef[5][0],  quickToggleMinMaxDef[5][1], 	quickToggleMinMaxDef[5][2]);
	quickToggleValue[QT_RAPID_FIRE] 			= read_spvar(quickToggleMinMaxDef[7][0],  quickToggleMinMaxDef[7][1], 	quickToggleMinMaxDef[7][2]);
	quickToggleValue[QT_RS_DEAD_ZONE] 			= read_spvar(quickToggleMinMaxDef[8][0],  quickToggleMinMaxDef[8][1], 	quickToggleMinMaxDef[8][2]);
	quickToggleValue[QT_VERTICAL_SENSITIVITY] 	= read_spvar(quickToggleMinMaxDef[9][0],  quickToggleMinMaxDef[9][1], 	quickToggleMinMaxDef[9][2]);
	quickToggleValue[QT_HORIZONTAL_SENSITIVITY] = read_spvar(quickToggleMinMaxDef[10][0], quickToggleMinMaxDef[10][1], 	quickToggleMinMaxDef[10][2]);
	quickToggleValue[QT_RS_MOVEMENT_ADSJ] 		= read_spvar(quickToggleMinMaxDef[11][0], quickToggleMinMaxDef[11][1], 	quickToggleMinMaxDef[11][2]);
	quickToggleValue[QT_VERITAS_AR]				= read_spvar(quickToggleMinMaxDef[12][0], quickToggleMinMaxDef[12][1], 	quickToggleMinMaxDef[12][2]);
	slotNumber							 		= read_spvar(1,  9, 9);		
}
	//Utilities functions
//--LED
define BLUE      = 1;
define RED       = 2;
define GREEN     = 3;
define PINK      = 4;
define SKYBLUE	 = 5;
define YELLOW    = 6;
define WHITE     = 7;
	 
data(
	0,0,0,0, //0. Off
	2,0,0,0, //1. Blue
  	0,2,0,0, //2. Red
  	0,0,2,0, //3. Lime/Green
  	0,0,0,2, //4. Fuchsia/Pink
  	2,0,2,0, //5. SkyBlue
  	0,2,2,0, //6. Yellow
  	2,2,2,2  //7. White
);	
function CenterText(f_chars,f_font) {                                                         
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2); 
}   
function NumberToString(f_val,f_dgts, x_val,y_val) {
 
	i = 1;  chr_val = 10000;
    
	if(f_val < 0){          
         putc_oled(i,45);    
         i += 1;
         f_val = abs(f_val);
	} 
	for(c_val = 5; c_val >= 1; c_val--){
	    if(f_dgts >= c_val) {
            putc_oled(i, (f_val / chr_val) + 48);
            f_val = f_val % chr_val;
            i +=  1; 
            if(c_val == 4){
                putc_oled(i,44);   
                i += 1;
            }
        }
        chr_val /= 10;
    }  

    puts_oled(x_val, y_val, 1,i - 1, 1);    
} 
function PrintCharacter(character, column, scrollLine){
	if(column > 0 && column < 127){
		putc_oled(1,character);
		puts_oled(column, scrollLine, 0, 1, 1);
	}
}	
function FindDigits(digits) {                         
	//  FindDigits(value)                                
	//        return Number of Digits in Value Passed     		                                                      
    digits = abs(digits);                               
    if(digits / 10000 > 0) return 5;                   
    if(digits /  1000 > 0) return 4;                   
    if(digits /   100 > 0) return 3;                   
    if(digits /    10 > 0) return 2;                   
                          return 1;                  
}
function LED(Colour) {
    set_led(LED_1,duint8(Colour*4));
    set_led(LED_2,duint8((Colour*4) + 1));
    set_led(LED_3,duint8((Colour*4) + 2));
    set_led(LED_4,duint8((Colour*4) + 3));
}
int pictureOffset, pictureBit,pictureY,pictureX,pictureData,pictureX2,pictureY2;
function DrawLogo() {
	
	pictureOffset = 2; // Reset the starting point
	pictureBit = 16; // Reset bit flag

	for (pictureY = 0; pictureY < logo[1]; pictureY++) { // Loop the Y axis
		for (pictureX = 0; pictureX < logo[0]; pictureX++) { // Loop the X axis
			pictureData = logo[pictureOffset]
			pictureX2 = pictureX;
			pictureY2 = pictureY;
			if (pictureX2 < 0 || pictureX2 >= 128) {
				pictureX2 -= 128;
			}
			if (pictureY2 < 0 || pictureY2 >= 64) {
				pictureY2 -= 64;
			}
			if (test_bit(pictureData, pictureBit - 1)) {
				pixel_oled(pictureX2, pictureY2, 1);
			}
			else {
				pixel_oled(pictureX2, pictureY2, 0);
			}
			pictureBit--; // Decrement the bit flag, we're moving to the next bit
			if (!pictureBit) { // Check if we've just handled the last bit
				pictureBit = 16; // Reset the bit flag
				pictureOffset++; // Move to the next value
			}
		}
	}
}
const int16  logo[] = {125, 31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1F00, 0x6000, 0x61FF, 0xFC3F, 
0xFF01, 0x87FF, 0xF804, 0x0007, 0xFE03, 0x0007, 0x0FFF, 0xE1FF, 0xFC0C, 0x3FFF, 0xC070, 0x007C, 0xF81C, 0x0030, 0x6000, 0x0C00, 0x7060, 0x0300, 
0x0380, 0x0300, 0xE060, 0x0383, 0x0000, 0x6001, 0x8300, 0x1800, 0x1E00, 0x3807, 0x0300, 0x1C18, 0x0003, 0x000C, 0x1800, 0xC001, 0xF001, 0x8018, 
0x1C00, 0xC0C0, 0x0018, 0x0060, 0xC006, 0x000D, 0x800C, 0x0000, 0x600E, 0x0600, 0x00C0, 0x0706, 0x0030, 0x0066, 0x0070, 0x0003, 0x8070, 0x3FF8, 
0x07FF, 0xF030, 0x0180, 0x0630, 0x0380, 0x001C, 0x0301, 0xFFC0, 0x3FFF, 0x0180, 0x0C00, 0x31C0, 0x0F00, 0x0060, 0x3800, 0x0000, 0x0000, 0x0C00, 
0x6003, 0x8600, 0x3F00, 0x0381, 0x8000, 0x0000, 0x0000, 0x6003, 0x0018, 0x3000, 0x7F00, 0x0C0C, 0x0000, 0x0000, 0x0003, 0x0018, 0x00FF, 0xC000, 
0x7E00, 0x60E0, 0x0000, 0x0000, 0x0018, 0x00C0, 0x0FFE, 0x0000, 0x7803, 0x8600, 0x0000, 0x0000, 0x00C0, 0x0600, 0x0000, 0x0000, 0xE00C, 0x7000, 
0x0000, 0x0000, 0x0600, 0x3000, 0x0000, 0x0003, 0x8063, 0x803F, 0xF807, 0xFFC0, 0x3001, 0x8000, 0x0000, 0x001C, 0x0398, 0x01FF, 0xC03F, 0xFF01, 
0x800C, 0x0000, 0x0000, 0x0060, 0x0DC0, 0x0C00, 0x0180, 0x180C, 0x0060, 0x0000, 0x0300, 0x0300, 0x7E00, 0x6000, 0x0C00, 0xE060, 0x0300, 0x7FFE, 
0x1800, 0x1803, 0xE003, 0x0000, 0x6003, 0x0300, 0x180F, 0xFFF8, 0xE000, 0xC00F, 0x0018, 0x0003, 0x001C, 0x1800, 0xC07F, 0xFFC3, 0x800E, 0x0070, 
0x00C0, 0x0018, 0x0060, 0xC006, 0x0300, 0x071E, 0x00E0, 0x0180, 0x07FF, 0xF0C0, 0x0386, 0x0030, 0x3000, 0x187C, 0x3E00, 0x0C00, 0x3FFF, 0x8600, 
0x0C30, 0x0181, 0x8000, 0xC0FF, 0xE000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x01FC, 0x0000}; ���������������� 