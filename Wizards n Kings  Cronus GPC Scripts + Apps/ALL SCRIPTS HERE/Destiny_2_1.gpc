/*
 _______   _______     _______.___________. __  .__   __. ____    ____     __   __  
|       \ |   ____|   /       |           ||  | |  \ |  | \   \  /   /    |  | |  | 
|  .--.  ||  |__     |   (----`---|  |----`|  | |   \|  |  \   \/   /     |  | |  | 
|  |  |  ||   __|     \   \       |  |     |  | |  . `  |   \_    _/      |  | |  | 
|  '--'  ||  |____.----)   |      |  |     |  | |  |\   |     |  |        |  | |  | 
|_______/ |_______|_______/       |__|     |__| |__| \__|     |__|        |__| |__| 
                                                                                    
Game: Destiny 2
Version 5.7
Device: CronusZEN ONLY
Controller tested: DS4 - Elite 2 - Elite 1
Console tested: XB1 - PS4 - Windows 10
Author: noozbar 
Special thanks to all community moderators and community!
-------------------------------------------------
Logo/Display - ASC - Random - OBS -    		    |
Dropshot - SlideShot - DoubleJump - quickswap   |
- Massive 92 Weapon Table by: XBL Jedi 			|
-------------------------------------------------								© 2020 CronusMax & CronusZen. All rights reserved.
____________________________________________________________________________________________________________________________________________________

◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸

											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES
											FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES  -  FEATURES

NOTE IF YOU GOING TO USE THIS READ INSTRUCTIONS!
FAILURE TO READ WILL CAUSE IT NOT TO WORK FOR YOU!

V5.7 fixed swap to work with aim assist and recoil.	

Features which can be activated (ON or OFF) independently on each of the three profiles (for example; AntiRecoil is ON on profile 1, OFF on profile 2 and ON on profile 3)

	####--- 3 Profiles (weapon) with:
			Antirecoil - with editable values and toggle for each of the profiles (save all)
					Antirecoil Start
					Antirecoil End
					Antirecoil Time
					Antirecoil Horizontal
					
	####---	RapidFire - with editable values and toggle for each of the profile
				- while fireing with R2
	  	OR			(can't be enable at the same time)
	####---	BurstFire - with editable values and toggle for each of the profile 
				- while fireing with R2
			
	####---	AIM Assist - with editable values and toggle for each of the profile
				-Hold L2 ONLY
			
	####---	Strafe Shot - with editable values and toggle for of the each profile
				- while fireing with R2

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
	General features which can be activated or deactivated on all profiles at the same time (three bars displayed on the OLED screen)
			
			####-- DynaSens - with editable values and toggle 
				- while aiming with L2/LT 
			
			####-- Reload - with editable value and toggle 
				- double tap reload to start reload, cut reload and switch weapon
			
			####-- AutoRun - with toggle
				- push forward Left stick
					- Elite controller: hold PR1 (Paddle Right 1) to temporarily stop running.
			
			####-- Swap Trigger/bumper - with toggle
				- swap L1 with L2 and R1 with R2
			
			####-- Inverted Y for vertical antirecoil - with toggle.
				- Invert Y axis.  (and Hair Trigger but always ON).
			
			####-- Random Dropshot - with toggle---(If ON then it will activate when Aiming an Firing.)
						
			####-- SlideShot - with toggle---(If ON then when you Press LS/L3 forward RS/R3 it will sprint slide shoot melee.)
			
			####-- DoubleJump - with toggle---(Press A/CROSS to DoubleJump when toggled ON.)
			
			####-- One Button Super - with toggle---(aka OBS, when ON press Dpad DOWN to activate.)
			
			####-- JumpShot - with toggle---(While Aiming an Firing it will activate.)
			
			####-- Legit Assist - with toggle. (Legits Aim Assist.)
			
			####-- Quickswap - with toggle. (If tap Y/Triangle it quickswaps.)
			
◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺		
____________________________________________________________________________________________________________________________________________________

◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸

											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											

	Enter and Exit ModMenu
		- Hold L2/LT and tap OPTIONS/MENU 
		
		Navigate between every mods and toogles
			- Tap LEFT or RIGHT on the D-PAD
			
		Enable or disable the displayed mod
			- Tap UP to turn ON
			- Tap DOWN to turn OFF
			
		Switch (weapon) Profile 1, 2 or 3 (in ModMenu) 
			- Tap TRIANGLE/Y
			
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
	OLED screen indications in ModMenu: 
		- First line: 
			Mod Name
						
		- Second line: 
			Bars that indicate on which profile/weapon we are acting:
				bar to the left 		= profile/weapon 1, blue
				bar to the middle 		= profile/weapon 2, pink
				bar to the  right 		= profile/weapon 3, skyblue
				3 bars at the same time = every profiles/weapons, any
				
		- Third line
			ON or OFF status
						
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
	Enter ModEdit (only available for some mods and only if you are in ModMenu)
		While in ModMenu,
			- Tap CROSS/A to enter ModEdit on the current/displayed mod (if the mod have editable values)
			- Tap CIRCLE/B to exit ModEdit
			
		Navigate between every values available for this mod (if there is more than one value for this mod)
			- Tap LEFT or RIGHT 
			
		Edit values
			- Hold SQUARE/X   + RIGHT for +1 (or +10 depending value type)
				              + LEFT for -1 (or -10 depending value type)
				              + UP for +10 (or +100 depending value type)
				              + DOWN for -10 (or -100 depending value type)

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
				           
	Save every values (only available if you are in ModMenu or ModEdit)		
		- Tap PS/XBOX to save EVERY values and toggles and independently for EVERY profiles 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
	Speed toggles (outside Mod Menu/Edit)
		- Hold L2/LT and hold 300ms UP, DOWN, RIGHT or LEFT
			- UP for	RapidFire
			- DOWN for	BurstFire
			- RIGHT for	AIM Assist
			- LEFT for	Strafe Shot

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	
	Switch profiles
		- In Game:
			- Tap TRIANGLE/Y to switch profile 1 and 2 (primary and secondary)
			- Hold TRIANGLE so switch to special weapon (every "assist" disabled)
		- In modMenu
			- Tap TRIANGLE/Y to loop profile 1, 2, 3, 1, 2, 3 ...

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜		
		
	Kill Switch (enable/disable everything) delete part if you don't want every ways to kill swutch (see us line 638)
		- Hold L2/LT and tap OPTIONS/MENU - or
		- Tap PS/XBOX 
	
____________________________________________________________________________________________________________________________________________________
		
		
How to set up my profiles/weapons:

	Open ModMenu and press TRIANGLE/Y to change profile/weapon, Zen's eyes will change color
		If you see a bar on the left,   ZEN eyes are blue,    you are on the primary weapon
		If you see a bar in the middle, ZEN eyes are pink,    you are on the secondary weapon
		If you see a bar on the right,  ZEN eyes are skyblue, you are on the HEAVY

		If there are all three bars, the mod you set from OFF to ON will be activated for all profiles/weapons (like AutoRun for example)

	If the mod name has a star like that:  * 
		like AntiRecoil* and RapidFire*, this means that each profile/weapon has its own values

	If the mod name has something like this:  ' 
		like BurstFire' (and other mods), this means that the values you set for BurstFire will be the same on all profiles/weapons where you have enabled BurstFire
		
	If the mod name has nothing, 
		like AutoRun (and other mods), this means that there is no editable value, it's just a mod with a toggle only
		
		
											THANK YOU FOR READING
											THANK YOU FOR READING
											THANK YOU FOR READING
											
											
◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺	
____________________________________________________________________________________________________________________________________________________



 	Text info:
			Almost every text are displayed in MEDIUM size because I'm far from my Zen and I can't read small texts
			"SAVED" is displayed in LARGE, you can replace SAVED text by something with 7 chars max
			"Profile x" is displayed in SMALL, ..... 18 chars max
			For the others text, they are displayed in MEDIUM, can be replaced by 11 chars max
*/
const int16 picture[] = {77, 33, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0070, 0x0070, 0x0000, 0x0000, 0x0000, 0x0FE0, 0x0FE0, 0x0000, 0x0000, 0x0000, 0xFF9C, 0xFF80, 0x0000, 0x0000, 0x0007, 0xFDF7, 0xFC00, 0x0000, 0x0000, 0x003F, 0xEFBF, 0xE000, 0x0000, 0x0000, 0x01FF, 0x7DFF, 0x0000, 0x0000, 0x0000, 0x07FB, 0xEFF0, 0x0000, 0x0000, 0x0000, 0x1FDF, 0x7F00, 0x0000, 0x0000, 0x0000, 0x7EFB, 0xF000, 0x0000, 0x0000, 0x0001, 0xF7DF, 0x0000, 0x0000, 0x0000, 0x0007, 0x9CF0, 0x0000, 0x0000, 0x0000, 0x001E, 0x4F00, 0x0000, 0x0000, 0x0000, 0x0078, 0xF000, 0x0000, 0x0000, 0x0000, 0x03FF, 0x8000, 0x0000, 0x0000, 0x0000, 0x1FFC, 0x0000, 0x0000, 0x0000, 0x0000, 0x7FC0, 0x0000, 0x0000, 0x0000, 0x0003, 0xFE00, 0x0000, 0x0000, 0x0000, 0x000F, 0xE000, 0x0000, 0x0000, 0x0000, 0x007F, 0x0000, 0x0000, 0x0000, 0x0000, 0x03F8, 0x0000, 0x0000, 0x0000, 0x0000, 0x1FC0, 0x0000, 0x0000, 0x0000, 0x0000, 0x7C00, 0x0000, 0x0000, 0x0000, 0x0001, 0xC000};

// Text to screen
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE= "SAVED";
	const string PROFILE_1 = "Primary":   // or primary weapon
	const string PROFILE_2 = "Secondary": // or secondary weapon
	
	const string SPECIAL = "Heavy weapon": // or special weapon
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mod Name
	const string ANTIRECOIL = "AntiRecoil*";   // modName_idx =  0
	const string RAPIDFIRE = "RapidFire*";     // modName_idx =  1
	const string BURSTFIRE = "BurstFire'";     // modName_idx =  2
	const string AIMASSIST = "AIM Assist'";    // modName_idx =  3 		
	const string STRAFE_SHOT = "StrafeShot'";  // modName_idx =  4
	const string DYNASENS = "DynaSens'";	   // modName_idx =  5
	const string RELOAD = "Reload'";           // modName_idx =  6	
	const string AUTORUN = "AutoRun";	       // modName_idx =  7	    
	const string SWAP = "Swap Tr/Bu";          // modName_idx =  8
	const string INVERTED = "Inverted Y";      // modName_idx =  9
	const string DROPSHOT = "DropShot";		   // modName_idx = 10
	const string SLIDESHOT = "SlideShot";	   // modName_idx = 11
	const string DJUMP = "DoubleJump";		   // modName_idx = 12
	const string OBS = "OBS";				   // modName_idx = 13
	const string JUMP = "Jumpshot";			   // modName_idx = 14
	const string KILLSWITCH = "KillSwitch";	   // modName_idx = 15
	const string LEGITASSIST = "LegitAssist";  // modName_idx = 16
	const string QUICKSWAP = "QuickSwap";	   // modName_idx = 17

// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;

// modName_idx # of the last Mod Name string - Used for cycle modName_idx
	define LAST_MODNAME_STRING = 17;
	
// # of the last modName_idx that has a value that can be edited
	define LAST_EDITABLE_STRING = 6;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	// modName_idx = 0 = ANTIRECOIL string
	const string ANTIRECOIL_START = "AR Start"; 	    // valName_idx = 0  
	const string ANTIRECOIL_END = "AR End";				// valName_idx = 1
	const string ANTIRECOIL_TIME = "AR Time";			// valName_idx = 2
	const string ANTIRECOIL_HORIZONTAL = "AR Horiz";	// valName_idx = 3
	// modName_idx = 1
	const string RATE_OF_FIRE = "Rounds/sec";			// valName_idx = 4
	// modName_idx = 2
	const string BURSTFIRE_HOLD = "BF Hold";			// valName_idx = 5
	const string BURSTFIRE_RELEASE = "BF Release";		// valName_idx = 6
	// modName_idx = 3 = AIMASSIST string
	const string AIMASSIST_SIZE = "AA Size";			// valName_idx = 7
	const string AIMASSIST_TIME = "AA Time";			// valName_idx = 8
	// modName_idx = 4
	const string STRAFESHOT_TIME = "S.Shot Time";		// valName_idx = 9 
	// modName_idx = 5 = DYNASENS string
	const string DYNASENS_INITIAL_SENS = "DS Ini Sens"; // valName_idx = 10  
	const string DYNASENS_LIMIT = "DS Limit";			// valName_idx = 11
	const string DYNASENS_RESTART = "DS Restart";		// valName_idx = 12
	const string DYNASENS_MAX_SENS = "DS Max Sens";		// valName_idx = 13
	const string DYNASENS_INCREASE_RATE = "DS Inc Rate";// valName_idx = 14
	// modName_idx = 6 = RELOAD string
	const string RELOAD_TIME = "Reload Time"; 		    // valName_idx = 15  
	
// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;

	define AMOUNT_OF_VALNAME_IDX = 15;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// /!\ DO NOT CHANGE RATE OF FIRE VALUE IN THE ARRAY
// Constant bytes - VALUES array (mods with value and toggle) - VALUES[line][column]
	const uint8 VALUES[][] = { 		
			/* PRIMARY 1 */	{    45,              20,                5,                   0,                  1       },		// profile_idx = 0 
			/* SECOND 2 */	{     0,              10,               15,                   0,                  1       }, 		// profile_idx = 1 
			/* HEAVY 3   */ {    12,              32,               10,                   0,                  1       }};		// profile_idx = 2 
/*		     	   	antirecoil_start[]  antirecoil_end[]  antirecoil_time[]  antirecoil_horizontal[]  rate_of_fire[]           
          	   		    AntiRecoil          AntiRecoil       AntiRecoil            AntiRecoil          RapidFire  
val_col_idx  	    	       = 0               = 1               = 2                  = 3                 = 4       */
/*◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿
--- 92 Weapon Recoil Table ---◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹
-- ROSE/THORN ---------------- = 55			     = 50			   = 500				= 0			 	    = 9
-- DRANG --------------------- = 55				 = 45			   = 1500				= 0					= 9
-- BASTION ------------------- =
-- HOOSEGOW XE5837 ----------- =
-- BELOVED ------------------- =
-- SPARE RATIONS ------------- =
-- NOT FORGOTTEN ------------- =
-- ASTRAL HORIZON ------------ =
-- SUMMONER ------------------ =
-- REVOKER ------------------- = 
-- RECLUSE ------------------- =
-- DIRE PROMISE -------------- =
-- MIND BENDERS AMBITION ----- =
-- SUROS REGIME -------------- =
-- ACE OF SPADES ------------- =
-- KINDLED ORCHID ------------ =
-- MIDA MULTI TOOL ----------- =
-- TIGERSPITE ---------------- =
-- NO TURNING BACK ----------- =
-- GARDEN PROGENY 1 ---------- =
-- BRAYTECH WEREWOLF --------- =
-- ARBALEST ------------------ =
-- VIGILANCE WING ------------ =
-- D.F.A. -------------------- =
-- GRAVITON LANCE ------------ =
-- EVERY WAKING MOMENT ------- =
-- TROPHY HUNTER ------------- =
-- RISKRUNNER ---------------- =
-- DEVIL'S RUIN -------------- =
-- TOMMY'S MATCHBOOK --------- =
-- TELESTO ------------------- =
-- RIGHT SIDE OF WRONG ------- =
-- HAMMERHEAD ---------------- =
-- WHISPER OF THE WORM ------- =
-- TRACTOR CANNON ------------ =
-- CLASSICAL-42 -------------- =
-- THE WARDCLIFF COIL -------- =
-- DEATHBRINGER -------------- =
-- BLACK TALON --------------- =
-- THE QUEENBREAKER ---------- =
-- HAWTHORNE'S FIELD-FORGED -- =
-- TRANQUILITY --------------- =
-- BUZZARD ------------------- =
-- GO FIGURE ----------------- =
-- LOUD LULLABY -------------- =
-- STEELFEATHER REPEATER ----- =
-- BYGONES ------------------- =
-- TRACKLESS WASTE ----------- =
-- DUKE MK 44 ---------------- =
-- TOIL AND TROUBLE ---------- =
-- NIFLHEIM FROST ------------ =
-- THE FRIGID JACKAL --------- =
-- BRAYTECH WINTER WOLF ------ =
-- IMPERATIVE ---------------- =
-- SMUGGLER'S WORD ----------- =
-- STURM --------------------- =
-- ETHER DOCTOR -------------- =
-- PRIBINA-D ----------------- = 
-- TEN PACES ----------------- =
-- SCATHELOCKE --------------- =
-- URIEL'S GIFT -------------- =
-- SYMMETRY ------------------ =
-- MAIN INGREDIENT ----------- =
-- LAST HOPE ----------------- =
-- BADLANDER ----------------- =
-- ARC LOGIC ----------------- = 
-- GALLANT CHARGE ------------ =
-- THE CUT AND RUN ----------- =
-- THE FIGHTING LION --------- = 
-- DEATH BY SCORN ------------ =
-- JACK QUEEN KING 3 --------- =
-- MISFIT -------------------- =
-- LAST HOPE ----------------- =
-- MARTYR'S RETRIBUTION ------ =
-- PROMETHEUS LENS ----------- =
-- OPTATIVE ------------------ =
-- MERCILESS ----------------- =
-- ELEGY-49 ------------------ =
-- IKELOS_SMG_V1.0.1 --------- =
-- ARSENIC BITE-4B ----------- =
-- BAD REPUTATION ------------ =
-- VACUNA SR2 ---------------- =
-- ERIANA'S VOW -------------- =
-- BRAYTECH RWP MK. II ------- =
-- POLARIS LANCE ------------- =
-- IKELOS_HC_V1.0.1 ---------- =
-- THE COLONY ---------------- =
-- TERRAN WIND --------------- =
-- CROOKED FANG-4FR ---------- =
-- THROUGH FIRE & FLOOD ------ =
-- EDGE TRANSIT -------------- =
-- ZENOBIA-D ----------------- = 
-- OUTRAGEOUS FORTUNE -------- =
◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿
  ◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿
◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿◸◹◺◿

// VALUES array column number - Buffer to add or substract edited value to corresponding value in VALUES array */
	int antirecoil_start[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
	int antirecoil_end[3];
	int antirecoil_time[3];
	int antirecoil_horizontal[3];
	int rate_of_fire[3];

/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
	int profile_idx; 
	
// Index to find VALUES array column - Follow valName_idx to edit the right value (that is in VALUES array or not like Strafe_t value)
	int val_col_idx;

// # of the last column - used in display_edit() function 
	define LAST_EDITABLE_COLUMN = 4;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Multi toggles
	int toggle_antirecoil[3];  // for 3 Profiles: profile_idx = 0, 1 and 2
	int toggle_rapidfire[3];  
	int toggle_burstfire[3];
	int toggle_aimassist[3];
	int toggle_strafeShot[3]; 
	
// Amount of profiles - Used for switch profiles cycle
	define AMOUNT_OF_PROFILES = 3;  
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 5;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mods (toggles and values) that activates for all profiles at the same time (if toggled ON)
// BurstFire
	int burstfire_hold; // BurstFire have toggle for each profiles BUT the same values for each
	int burstfire_release;
// Aim Assist
	int aimassist_size; // AIM Assist have toggle for each profiles BUT the same values for each
	int aimassist_time;
// Legit Assist
	int angle;
	int SPEED = 10;
	int radius = 13;
// Strafe Shot
	int strafeShot_time; // StrafeShot have toggle for each profiles BUT the same value for each
// DynaSens
	int dynasens_initial_sens;    // initial RX/RY sentitivity
	int dynasens_limit;           // stick input point where RX/RY sens increases
	int dynasens_restart;         // stick input point where RX/RY sens will reset back to initial value dynasens_initial_sens
	int dynasens_max_sens;        // maximum sensitivity value 
	int dynasens_increase_rate;   // rate sensitivity increased (8 = 80ms delay between increase)
// Reload Switch 
	int reload_time;              // amount of time before you cut reload animation and switch weapon
	
// Toggles
	int dynasens_on;
	int reload_on;
	int autorun_on;
	int swap_on;
	int inverted_on;
	int dropshot_on;
	int slideshot_on;
	int djump_on;
	int obs_on;
	int jumpshot_on;
	int killswitch_on;
	int legitassist_on;
	int quickswap_on;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};

// Buffer to display converted values 
	//int display_val;  
	
// Variables for function number_to_string() 
	int i;
	int c,c_val;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_black;
    
// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil                                                 
	int i_val;                                                        
	int i_pnt;                                                        
	int i_num;                                                        
	int i_cnt;                                                        
	int v,ar_y;
	int ar_x;
	int x_ref;
	int invert; // -1 for inverted, 1 for standard
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter
	int count_black;  // for screen saver
	//int count_battery // for battery warning
	
// Double Tap
	int double_tap;
	
// Profiles
	int profile_1or2;   // Profile 1 and 2
	int profile_3;      // Profile 3
	int special_weapon; // Special weapon
 	
// DynaSens
	int sens_x;
	int sens_y;
	int sens_xcnt,sens_ycnt;
	
/*// Battery Display
	int batteryLevel;
	int batteryChargingCounter = 0;
	int batteryLevelBarOffset;
	int batteryLevelIndex;	*/

//Misc
	
	int map_btn;
	int map;
	int currentSlot;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
init{
// Profile 1
	// Toggles                                                  // Values
	toggle_antirecoil[0] = get_pvar(SPVAR_1, 0, 1, 0 );         antirecoil_start[0]      = get_pvar(SPVAR_6, -99, 99, 0);         
	toggle_rapidfire[0]  = get_pvar(SPVAR_2, 0, 1, 0 );         antirecoil_end[0]        = get_pvar(SPVAR_7, -99, 99, 0);         
	toggle_burstfire[0]  = get_pvar(SPVAR_3, 0, 1, 0 );         antirecoil_time[0]       = get_pvar(SPVAR_8, -99, 99, 0);      
	toggle_aimassist[0]  = get_pvar(SPVAR_4, 0, 1, 0 );         antirecoil_horizontal[0] = get_pvar(SPVAR_9, -99, 99, 0);
	toggle_strafeShot[0] = get_pvar(SPVAR_5, 0, 1, 0 );         rate_of_fire[0]          = get_pvar(SPVAR_10,  0, 25, 0);
// Profile 2
	// Toggles                                                  // Values
	toggle_antirecoil[1] = get_pvar(SPVAR_11, 0, 1, 0 );        antirecoil_start[1]      = get_pvar(SPVAR_16, -99, 99, 0);         
	toggle_rapidfire[1]  = get_pvar(SPVAR_12, 0, 1, 0 );        antirecoil_end[1]        = get_pvar(SPVAR_17, -99, 99, 0);         
	toggle_burstfire[1]  = get_pvar(SPVAR_13, 0, 1, 0 );        antirecoil_time[1]       = get_pvar(SPVAR_18, -99, 99, 0);        
	toggle_aimassist[1]  = get_pvar(SPVAR_14, 0, 1, 0 );        antirecoil_horizontal[1] = get_pvar(SPVAR_19, -99, 99, 0);
	toggle_strafeShot[1] = get_pvar(SPVAR_15, 0, 1, 0 );	    rate_of_fire[1]          = get_pvar(SPVAR_20,   0, 25, 0);
// Profile 3
	// Toggles                                                  // Values
	toggle_antirecoil[2] = get_pvar(SPVAR_21, 0, 1, 0 );        antirecoil_start[2]      = get_pvar(SPVAR_26, -99, 99, 0);         
	toggle_rapidfire[2]  = get_pvar(SPVAR_22, 0, 1, 0 );        antirecoil_end[2]        = get_pvar(SPVAR_27, -99, 99, 0);         
	toggle_burstfire[2]  = get_pvar(SPVAR_23, 0, 1, 0 );        antirecoil_time[2]       = get_pvar(SPVAR_28, -99, 99, 0);         
	toggle_aimassist[2]  = get_pvar(SPVAR_24, 0, 1, 0 );        antirecoil_horizontal[2] = get_pvar(SPVAR_29, -99, 99, 0);
	toggle_strafeShot[2] = get_pvar(SPVAR_25, 0, 1, 0 );	    rate_of_fire[2]          = get_pvar(SPVAR_30,   0, 25, 0);
	
// Misc values
	burstfire_hold       = get_pvar(SPVAR_31, 1, 999, 120);		dynasens_initial_sens    = get_pvar(SPVAR_36, 1, 327, 60 );     reload_time = get_pvar(SPVAR_41, 1, 9999, 800);
	burstfire_release    = get_pvar(SPVAR_32, 1, 999, 120);		dynasens_limit           = get_pvar(SPVAR_37, 1, 100, 60 );
	aimassist_size       = get_pvar(SPVAR_33, 1, 50 , 20 );		dynasens_restart         = get_pvar(SPVAR_38, 1, 100, 40 );
	aimassist_time       = get_pvar(SPVAR_34, 1, 999, 40 );		dynasens_max_sens        = get_pvar(SPVAR_39, 1, 327, 100);
	strafeShot_time      = get_pvar(SPVAR_35, 1, 999, 500);		dynasens_increase_rate   = get_pvar(SPVAR_40, 1, 50 , 1  );
	
// Misc toggles 
	dynasens_on   = get_pvar(SPVAR_42, 0, 1, 0 );    		    
	reload_on     = get_pvar(SPVAR_43, 0, 1, 0 );    		    
	autorun_on    = get_pvar(SPVAR_44, 0, 1, 0 );    		
	swap_on       = get_pvar(SPVAR_45, 0, 1, 0 );    
	inverted_on   = get_pvar(SPVAR_46, 0, 1, 0 );    
	dropshot_on   = get_pvar(SPVAR_47, 0, 1, 0 );
	djump_on 	  = get_pvar(SPVAR_48, 0, 1, 0 );
	slideshot_on  = get_pvar(SPVAR_49, 0, 1, 0 );
	obs_on		  = get_pvar(SPVAR_50, 0, 1, 0 );
	jumpshot_on   = get_pvar(SPVAR_51, 0, 1, 0 );
	killswitch_on = get_pvar(SPVAR_52, 0, 1, 0 );
	legitassist_on = get_pvar(SPVAR_53, 0, 1, 0 );
	quickswap_on = get_pvar(SPVAR_54, 0, 1, 0 );

	currentSlot = get_slot();
}

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                                     MAIN SECTION                                                      |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
main {
// Debug - Device Monitor

	//set_val(TRACE_1, count_black);
	//set_val(TRACE_2, map);
	//set_val(TRACE_3, KillSwitch);
/*
	set_val(TRACE_1, modName_idx); 
	set_val(TRACE_2, valName_idx); 
	set_val(TRACE_3, profile_idx);
	set_val(TRACE_4, ModMenu); 
	set_val(TRACE_5, ModEdit);
	
	// Antirecoil values	
	set_val(TRACE_3, VALUES[profile_idx][0] + antirecoil_start[profile_idx]); // ar start for the active profile
	set_val(TRACE_4, VALUES[profile_idx][1] + antirecoil_end[profile_idx]); // ar end
	set_val(TRACE_5, VALUES[profile_idx][2] + antirecoil_time[profile_idx]); // ar time
	set_val(TRACE_6, VALUES[profile_idx][3] + antirecoil_horizontal[profile_idx]); // ar horizontal
	
	// RapidFire + BurstFire values
	set_val(TRACE_4, VALUES[profile_idx][4] + rate_of_fire[profile_idx]);  // rof value
	set_val(TRACE_5, VALUES[profile_idx][5] + burstfire_hold[profile_idx]); // ar time
	set_val(TRACE_6, VALUES[profile_idx][6] + burstfire_release[profile_idx]); // ar horizontal
	
	// RapidFire toggle values
	set_val(TRACE_1, toggle_rapidfire[0]); // RapidFire toggle Profile 1
	set_val(TRACE_2, toggle_rapidfire[1]); // RapidFire toggle Profile 2
	set_val(TRACE_3, toggle_rapidfire[2]); // RapidFire toggle Profile 3
	
	// BurstFire toggle values
	set_val(TRACE_4, toggle_burstfire[0]); // BurstFire toggle Profile 1
	set_val(TRACE_5, toggle_burstfire[1]); // BurstFire toggle Profile 2
	set_val(TRACE_6, toggle_burstfire[2]); // BurstFire toggle Profile 3
*/

// Crossover - PS4/XBOX controllers
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
    	// On PS4 console:
        if(get_console() == PIO_PS4)
        { 
        	if(get_ival(PS4_SHARE))
        	{
        		if(get_ival(PS4_R3)) // RS + View =  ScreenShot on PS4
        		{
					set_val(PS4_SHARE,100);
                	set_val(PS4_TOUCH,0);
                	set_val(PS4_R3,0);
        			map_btn = PS4_TOUCH;
        		}
        		else // View only = PS4_TOUCH = display the map
        		{
        			set_val(PS4_TOUCH, 100);
        			set_val(PS4_SHARE, 0);
        			map_btn = PS4_SHARE;
        		}
        	}
        }
        else // If XBOX console
            map_btn = PS4_SHARE;
	}
    else // If PS4 controller
        map_btn = PS4_TOUCH;

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     DISPLAY TITLE                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

// Display Script Title    
    if(display_title)
    {
    	cls_oled(0);	// clear OLED screen
    	count_black = 0;// reset screen saver timer
    	
    	if(KillSwitch)
    	{
    	//Display OFF 
    		//printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,WHITE,OFF[0]);	// centered in X Y
    		printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),8,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);	// display OFF centered in X 
    		
    	/*// Display Battery
			drawBattery(batteryLevel);	*/
    	}
    	else
    	{
    	// Display logo
    		draw_picture(0, 0, 0);
    		//printf(center_x(sizeof(TITLE) - 1, OLED_FONT_MEDIUM_WIDTH),13,OLED_FONT_MEDIUM,OLED_WHITE,TITLE[0]);	// display TITLE centered in X 
    		
    	// Display # ZEN slot
    		display_edit(NOT_USE, NOT_USE, NOT_USE, NOT_USE);
    	
    	// Display profile name
    		if(special_weapon)
    			printf(center_x(sizeof(SPECIAL) - 1, OLED_FONT_SMALL_WIDTH),45,OLED_FONT_SMALL,OLED_WHITE,SPECIAL[0]);
    		else 
    		{
    		if(profile_idx == 0)
    			printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),45,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); 
    		if(profile_idx == 1)
    			printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),45,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]);
    		
    		}
    	
    		display_black = TRUE;	// screen saver
    		display_title = FALSE;
    	}
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
    	count_black += get_rtime();
    	if(count_black >= 5000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    	}
    }

/*// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Battery 
	if(get_battery() > 10) 
	{
		if(batteryChargingCounter == 10)
		{
			batteryLevel++;
			batteryChargingCounter = 0;
		}
		else 
			batteryChargingCounter++;
			
		if(batteryLevel > 10)
			batteryLevel = 0
	}
	else 
		batteryLevel = get_battery();
		
// Battery warning
/*
    if(get_battery() <= 1) 
	{
       	count_battery += get_rtime();
 
           	if(count_battery == 10000)
           	{	
               	combo_run(BATTERY);
               	count_battery = 0;
           	}
    }
*/
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                      KILL SWITCH                                                      |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

// Kill Switch
if(killswitch_on)
{
	if(!ModMenu && !ModEdit)
	{
		if( // Multi KillSwitch method
		
		   (!get_val(PS4_L2) && event_press(PS4_OPTIONS)) 	//  Tap OPTIONS/MENU - if you decide to delete this way, delete also the "or" just below
		   || 												//  or
	   	   event_press(PS4_PS)                           	//  Tap PS/XBOX button - if you decide to delete this way, delete also the "or" just below
	   	   )
		{			
			KillSwitch = !KillSwitch;
			
			if(KillSwitch) 
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				
			else
			{
				combo_run(RUMBLE_ON);	// rumble and LED blink
				map = FALSE;
			}
		
			display_title = TRUE;
		}
		
		if(event_release(map_btn) && KillSwitch)
			map = TRUE;
	
		if(map)
		{
			if(event_press(PS4_CIRCLE) || event_press(map_btn) || (get_val(PS4_SQUARE) && get_ptime(PS4_SQUARE) > 1000)) 
			{
				map = FALSE;
				KillSwitch = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE;
			}
		}
	}}
	
	if(get_lval(PS4_L3))
		set_val(PS4_R3, 0);

	if(KillSwitch && get_val(PS4_CIRCLE) && get_ptime(PS4_CIRCLE) > 600)
	{	
		KillSwitch = FALSE;
		combo_run(RUMBLE_ON);
		display_title = TRUE;
	}
	
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       MOD MENU                                                        |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
  
	if(get_val(PS4_L2))
	{
	// toggle ModMenu ON/OFF
		if(event_release(PS4_OPTIONS) && !KillSwitch && !special_weapon)
		{
			ModMenu = !ModMenu;
			
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				//save ();				// save function
				//combo_run(EXIT_SAVE);	// rumble, blink and display SAVED then display TITLE
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
		
		set_val(PS4_SHARE, 0);		    // block
		set_val(PS4_OPTIONS, 0);		// block
	}} // L2 end

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

if(!KillSwitch)
{

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
// ModMenu
	if(ModMenu)
	{
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            MOD EDIT                                               |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

	// toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
		if(modName_idx <= LAST_EDITABLE_STRING)	// if ANTIRECOIL (so modName_idx = 0) or AIMASSIST or RAPIDFIRE or BURSTFIRE or StrafeShot or Dynasens or Reload is diplayed 
		{
			if(event_press(PS4_CROSS) && !ModEdit) // Turn ModEdit ON
			{
				valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
				ModEdit = TRUE;
				combo_run(RUMBLE_ON);
				display_new = TRUE;
			}
			
			if(event_press(PS4_CIRCLE) && ModEdit) // Turn ModEdit OFF
			{
				ModEdit = FALSE;
				combo_run(RUMBLE_OFF);
				display_new = TRUE;
			}
		}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                          EDIT VALUES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
            
	// ModEdit ON
		if(ModEdit)
		{
			if(get_val(PS4_SQUARE)) // Edit value: hold SQUARE/X + UP (+1 or +10) or DOWN (-1 or -10) or RIGHT (+10 or +100) or LEFT (-10 or -100)
			{
			// Mods that can have different values depending the active Profile
			
    		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], range min , range max, increase/decrease by X, increase/decrease by X); 	
				antirecoil_start[profile_idx]      = edit_val( 0 , antirecoil_start[profile_idx]     , 0 , 99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
				antirecoil_end[profile_idx]        = edit_val( 1 , antirecoil_end[profile_idx]       , 0 , 99 , 1 , 10   ); // the 2 last numbers are range min and range max
				antirecoil_time[profile_idx]       = edit_val( 2 , antirecoil_time[profile_idx]      , 0 , 99 , 1 , 10   ); // only antirecoil_time display value x100 (real time in ms) - so 99 display 9,900 so 9.9 seconds 
				antirecoil_horizontal[profile_idx] = edit_val( 3 , antirecoil_horizontal[profile_idx], 99, 99 , 1 , 10   );
				rate_of_fire[profile_idx]          = edit_val( 4 , rate_of_fire[profile_idx]         , 0 , 25 , 1 , 10   ); // 25 rounds/s max
				
			// Mods that have same value on every Profiles
			
			  //val_I_want_to_edit = edit_val( corresponding valName_idx , val_I_want_to_edit, range min , range max, increase/decrease by X, increase/decrease by X);
				burstfire_hold         = edit_val( 5 , burstfire_hold         , 0 , 990  , 10 , 100 );
				burstfire_release      = edit_val( 6 , burstfire_release      , 0 , 990  , 10 , 100 );
				aimassist_size         = edit_val( 7 , aimassist_size         , 0 , 50   , 1  , 10  );
				aimassist_time         = edit_val( 8 , aimassist_time         , 0 , 990  , 1  , 10  ); 
				strafeShot_time        = edit_val( 9 , strafeShot_time        , 0 , 9990 , 10 , 100 );
				dynasens_initial_sens  = edit_val( 10, dynasens_initial_sens  , 0 , 327  , 1  , 10  );
				dynasens_limit         = edit_val( 11, dynasens_limit         , 0 , 100  , 1  , 10  );
				dynasens_restart       = edit_val( 12, dynasens_restart       , 0 , 100  , 1  , 10  );
				dynasens_max_sens      = edit_val( 13, dynasens_max_sens      , 0 , 327  , 1  , 10  );
				dynasens_increase_rate = edit_val( 14, dynasens_increase_rate , 1 , 50   , 1  , 10  );
				reload_time            = edit_val( 15, reload_time            , 0 , 9990 , 10 , 100 );
			}  

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        VALUES AVAILABLE                                           |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

			else // NOT SQUARE/X (if not editing value)
			{
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
					display_new = TRUE; // Display value name and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
					display_new = TRUE;
				}
				
			// Adjustable values available for each of the mods (exemple: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
			 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
				if(modName_idx == 0) vals_available( 0 , 3  );// Anti-Recoil		
				if(modName_idx == 1) vals_available( 4 , 4  );// RapidFire            				
				if(modName_idx == 2) vals_available( 5 , 6  );// If BurstFire was displayed before I enter ModEdit, I can only edit all BurstFire values			
				if(modName_idx == 3) vals_available( 7 , 8  );// AIM Assist				
				if(modName_idx == 4) vals_available( 9 , 9  );// StrafeShot				
				if(modName_idx == 5) vals_available( 10, 14 );// DynaSens				
				if(modName_idx == 6) vals_available( 15, 15 );// Reload Switch	
			} // NOT SQUARE/X (if not editing value) end
		} // ModEdit end

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            TOGGLES                                                |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

		else // if NOT ModEdit BUT if ModMenu
		{
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx += 1;
				display_new = TRUE;
			}
			if(event_press(PS4_LEFT))
			{
				modName_idx -= 1;
				display_new = TRUE;
			}
			
		// Cycle mods name
			if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
				modName_idx = 0;
			if(modName_idx < 0)
				modName_idx = LAST_MODNAME_STRING;
				
		// Switch profiles	
			if(event_press(PS4_TRIANGLE))
			{
				profile_idx += 1;
				display_new = TRUE;
			}
		// Cycle profiles	
			if(profile_idx > (AMOUNT_OF_PROFILES - 1))
				profile_idx = 0;
			
		// Toggles (UP to turn ON, DOWN to turn OFF)
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			toggle_antirecoil[profile_idx] = toggle( 0, toggle_antirecoil[profile_idx]);
			toggle_rapidfire[profile_idx]  = toggle( 1, toggle_rapidfire[profile_idx] );
			toggle_burstfire[profile_idx]  = toggle( 2, toggle_burstfire[profile_idx] );
			toggle_aimassist[profile_idx]  = toggle( 3, toggle_aimassist[profile_idx] );
			toggle_strafeShot[profile_idx] = toggle( 4, toggle_strafeShot[profile_idx]);
		
			// Mods that have same ON/OFF status on every Profiles
    		
		  //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
			dynasens_on = toggle( 5 , dynasens_on );
			reload_on   = toggle( 6 , reload_on   );
			autorun_on  = toggle( 7 , autorun_on  );			
			swap_on     = toggle( 8 , swap_on     );
			inverted_on = toggle( 9 , inverted_on );
			dropshot_on = toggle( 10 , dropshot_on );
			slideshot_on = toggle( 11 , slideshot_on );
			djump_on 	= toggle( 12 , djump_on );
			obs_on	    = toggle( 13 , obs_on   );
			jumpshot_on = toggle( 14 , jumpshot_on);
			killswitch_on = toggle( 15 , killswitch_on);
			legitassist_on = toggle( 16 , legitassist_on);
			quickswap_on = toggle( 17 , quickswap_on);
			
		} // if NOT ModEdit BUT if ModMenu end
		
	// If ModMenu AND ModEdit
		if(event_press(PS4_PS))
			save ();
			
		//block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
		block_all_inputs();
		
	} // ModMenu ON end


							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                              NOT MOD MENU AND NOT MOD EDIT                                             |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — */	 
	if(!ModMenu)
	{
	
	/* Swap triggers and bumpers */
		if(swap_on) // (8)
		{
			swap(PS4_R1, PS4_R2);
			swap(PS4_L1, PS4_L2);
		}
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        SPEED TOGGLES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	// Speed Toggles
	
	  //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2, hold time, toggle_I_want_to_edit[profile] , corresponding modName_idx );
		toggle_rapidfire[profile_idx]  = speed_toggle( PS4_L2, PS4_UP   , 500 , toggle_rapidfire[profile_idx] , 1 );
		toggle_burstfire[profile_idx]  = speed_toggle( PS4_L2, PS4_DOWN , 500 , toggle_burstfire[profile_idx] , 2 );
		toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT, 500 , toggle_aimassist[profile_idx] , 3 );
		toggle_strafeShot[profile_idx] = speed_toggle( PS4_L2, PS4_LEFT , 500 , toggle_strafeShot[profile_idx], 4 );
		// We can add as many speed toogle as we need		

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 


	/* Special Weapon mode (Anti-Recoil, RapidFire, BurstFire, AIM Assist, Strafe Shot, Reload disable)
    Hold TRIANGLE/Y (Led color turn OLED_WHITE)*/
    if(get_val(PS4_TRIANGLE) && get_ptime(PS4_TRIANGLE) > 500)
    {
        special_weapon = TRUE;
        display_title = TRUE;
    }
    
    if(special_weapon && event_press(PS4_TRIANGLE))
         special_weapon = FALSE;
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	// Double Tap
    /*	if(double_tap) 
        	double_tap -= get_rtime();*/
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜    
	// Hair Trigger
   	 	deadzone(PS4_L2,PS4_R2,99,99);
    	
 	 /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
 	 |                                                      AIM ASSIST (3)                                                      |
 	 ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// If AIM Assist is enable for the curent profile
		if(toggle_aimassist[profile_idx] == 1 && !special_weapon)
		{
			if(get_val(PS4_L2)  && !get_val(PS4_R2)) 
				combo_run(AIM_ASSIST);
			else 
				combo_stop(AIM_ASSIST); 
		}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      STRAFE SHOT (4)                                                  |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
  
	// If Strafe Shot is enable for the curent profile
		if(toggle_strafeShot[profile_idx] == 1 && !special_weapon)
		{
		// Run combo
			if(get_val(PS4_R2))
				combo_run(STRAFESHOT);
			else
				combo_stop(STRAFESHOT);
		}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                       DYNASENS (5)                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
			
    	if(dynasens_on)
    	{	
    		if(get_val(PS4_L2) || get_val(PS4_R1) || get_val(PS4_L1))
    		{
    			if(abs(get_val(PS4_RX)) <= abs(dynasens_limit) && abs(get_val(PS4_RY)) <= abs(dynasens_limit) && !get_val(PS4_R2))
					deadzone(PS4_RX, PS4_RY, 15, 15);
    				
    			set_sens();
    		}
    		else if(!get_val(PS4_DOWN) && get_ival(PS4_LY) > -15)
    		{
    			sensitivity(PS4_RX, 80, 100);
    			sensitivity(PS4_RY, 80, 100);
    		}
    	}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                    RELOAD SWITCH (6)                                                  |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/


    if(reload_on && event_press(PS4_SQUARE) && !special_weapon) 
    {
        if(double_tap) 
        {
            combo_run(RELOAD);
            combo_stop(AUTORUN);
            profile_1or2=!profile_1or2;
        }
            else
                double_tap = 300; 
    }

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      OTHER MODS                                                       |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* AutoRun press sensitive (Work better when in game option "Press to Sprint" is turned OFF)
       Push your stick to more than 60% to run automatically */
		if(autorun_on) // (7)
		{
    		if(get_val(PS4_L2) || get_ival(XB1_PR1) && get_ptime(XB1_PR1) > 200)
    	    	combo_stop(AUTORUN);
    	    	
    	    else if(get_val(PS4_LY) < -60)
    	    	combo_run(AUTORUN);
		}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	/* Inverted Y for antirecoil */
		if(inverted_on) // (9)
			invert = -1;
		else
			invert = 1;
	 // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
     /* Random DropShot */
     if(dropshot_on) //(10)
    {  
    	if(get_val(XB1_RT)){
    	combo_run(RDROPSHOT);
    }}
    
    // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    /* SlideShot */
    if(slideshot_on) //(11)
    {
    	if(event_press(XB1_RS)){
    	combo_run(SLIDESHOT);
    }}
    
    // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    /* DoubleJump */
    if(djump_on) //(12)
    {
    if(get_ival(XB1_A)){
    combo_run(DOUBLEJUMP);
    }}
    
    // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    /* OBS */
    if(obs_on) //(13)
    {
    if(event_press(XB1_DOWN)){
    combo_run(OBS);
    combo_stop(RAPIDFIRE);
    combo_stop(BURSTFIRE);
    }
    set_val(XB1_DOWN,0);
    }
    
     // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
     /* JumpShot */
     if(jumpshot_on) //(14)
    {
    if(get_val(XB1_RT)){
    	combo_run(JUMPSHOT);
    }}
    
    // 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
    /* Legit Assist */
    if(legitassist_on)
    {
    if(get_val(XB1_LT) > 95){
        if(isqrt(abs(get_val(XB1_RX)) * abs(get_val(XB1_RX)) + abs(get_val(XB1_RY)) * abs(get_val(XB1_RY))) <= radius) {
              angle = (angle + SPEED) % 360;
              set_polar(POLAR_RS, angle, radius * random(326,328));
     }}}

	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	/* QuickSwap */
	if(quickswap_on)
	{
	if(event_press(XB1_Y)){
	combo_run(QUICKSWAP);
	set_val(PS4_TRIANGLE,0);
	}}
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                     SWITCH PROFILE                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
  
	// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold R3/RS + tap for sync color

    	if(!get_val(PS4_DOWN) && event_press(PS4_TRIANGLE) || (get_val(PS4_L3) && event_press(PS4_TRIANGLE)))
    	{
    	    profile_1or2=!profile_1or2; 
    	    profile_3 = FALSE;
        
    	    if(double_tap) 
    	    { 
    	     	profile_3 = TRUE ; 
    	    	profile_1or2 = !profile_1or2;
    	    }
			else
            	double_tap = 200;
    
    		if(ModMenu)
				display_new = TRUE;
			else
				display_title = TRUE;
    	}
		if(get_lval(PS4_L3))
			set_val(PS4_TRIANGLE, 0);
		
    // If Profile 3
    	if(profile_3)
    		profile_idx = 2;
    	
    	else
    	{    
    	// If Profile 2
    		if(profile_1or2)
    			profile_idx = 1;
    		
    	// If Profile 1
    		else	
    			profile_idx = 0;
		}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	} // ModMenu OFF end

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                      FEATURES THAT WORK EVERYTIME (MOD MENU/EDIT OR NOT) BUT NOT WITH SPECIAL WEAPON                  |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
	if(!special_weapon)
	{
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    ANTI RECOIL (0)                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// If Anti-Recoil is enable for the active profile
		if(toggle_antirecoil[profile_idx] == 1)
		{
			ar_x = (VALUES[profile_idx][3] + antirecoil_horizontal[profile_idx]);
		
		// Antirecoil vertical by Batts		
    		if((VALUES[profile_idx][0] + antirecoil_start[profile_idx]) < (VALUES[profile_idx][1] + antirecoil_end[profile_idx]))
    	   		i_val = 1; 
    		else
    	    	i_val = -1;
    		i_pnt = ((VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10) / (abs((VALUES[profile_idx][0] + antirecoil_start[profile_idx]) - (VALUES[profile_idx][1] + antirecoil_end[profile_idx]))); 
    	
    		if(!get_val(PS4_R2)) 
    		{
				ar_y = VALUES[profile_idx][0] + antirecoil_start[profile_idx];
    	    	i_cnt = 0;
    	    	i_num = 0;
    		}     
    		
    	// Run antirecoil
    		if(toggle_burstfire[profile_idx] != 1 && get_val(PS4_L2) && get_val(PS4_R2) || toggle_burstfire[profile_idx] == 1 && get_val(PS4_R2) && get_ptime(PS4_R2) <= hold_time)
    		{		
				combo_run(X_VAL);
			
    	    	if(!p_complete())  
					ar_y = p_val();
    	    	else
    	        	ar_y = VALUES[profile_idx][1] + antirecoil_end[profile_idx];
            
				if(y_val() < 100)
           			set_val(PS4_RY,y_val()); 	
    		}
    	
    		if(abs(get_val(PS4_RX)) > abs(ar_x) + 5)
  	  			combo_stop(X_VAL);
		}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    RAPID FIRE (1)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/  
  
	// If RapidFire is enable for the active profile
		if(toggle_rapidfire[profile_idx] == 1)
		{
		// Rate of Fire Calculation
    		hold_time = 500 / (VALUES[profile_idx][4] + rate_of_fire[profile_idx]); 
   			rest_time = hold_time - 20;
    		if(rest_time < 0) rest_time = 0;
    
    	// Run combo
    		if(get_val(PS4_R2))
    			combo_run(RAPIDFIRE);
    		else
    			combo_stop(RAPIDFIRE);
    		
    		led_on = 150;
    		led_off = 300;
    		combo_run(BLINK);
		}
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    BURST FIRE (2)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/ 
      	
// If BurstFire is enable for the active profile
		if(toggle_burstfire[profile_idx] == 1) 
		{
    	// Hold and Release
			hold_time = burstfire_hold;
			rest_time = burstfire_release;
			
    	// Run combo
    		if(get_val(PS4_R2))	
    			combo_run(BURSTFIRE);

    		led_on = 200;
    		led_off = 1000;
    		combo_run(BLINK);
		} 
		if(event_release(PS4_R2))
    		combo_stop(BURSTFIRE);

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	} // MOT Special weapon end	
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    REFRESH DISPLAY                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(display_new) 
	{
	// Clear OLED screen	
		cls_oled(0);
		count_black = 0;
		
		if(ModEdit)
		{
	    // Display Value Name and value
    		// Mods that can have different values depending the active Profile
    		
		  //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
			display_edit( 0 , center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH)      , ANTIRECOIL_START[0]      , antirecoil_start[profile_idx]      );
			display_edit( 1 , center_x(sizeof(ANTIRECOIL_END) - 1, OLED_FONT_MEDIUM_WIDTH)        , ANTIRECOIL_END[0]        , antirecoil_end[profile_idx]        );
			display_edit( 2 , center_x(sizeof(ANTIRECOIL_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)       , ANTIRECOIL_TIME[0]       , antirecoil_time[profile_idx]       );
			display_edit( 3 , center_x(sizeof(ANTIRECOIL_HORIZONTAL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_HORIZONTAL[0] , antirecoil_horizontal[profile_idx] );
			display_edit( 4 , center_x(sizeof(RATE_OF_FIRE) - 1, OLED_FONT_MEDIUM_WIDTH)          , RATE_OF_FIRE[0]          , rate_of_fire[profile_idx]          );
			
			// Mods that have same value on every Profile
			display_edit( 5 , center_x(sizeof(BURSTFIRE_HOLD) - 1, OLED_FONT_MEDIUM_WIDTH)         , BURSTFIRE_HOLD[0]         , burstfire_hold         );
			display_edit( 6 , center_x(sizeof(BURSTFIRE_RELEASE) - 1, OLED_FONT_MEDIUM_WIDTH)      , BURSTFIRE_RELEASE[0]      , burstfire_release      );
			display_edit( 7 , center_x(sizeof(AIMASSIST_SIZE) - 1, OLED_FONT_MEDIUM_WIDTH)         , AIMASSIST_SIZE[0]         , aimassist_size         );
			display_edit( 8 , center_x(sizeof(AIMASSIST_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)         , AIMASSIST_TIME[0]         , aimassist_time         );
			display_edit( 9 , center_x(sizeof(STRAFESHOT_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)        , STRAFESHOT_TIME[0]        , strafeShot_time        );
			display_edit( 10, center_x(sizeof(DYNASENS_INITIAL_SENS) - 1, OLED_FONT_MEDIUM_WIDTH)  , DYNASENS_INITIAL_SENS[0]  , dynasens_initial_sens  );
			display_edit( 11, center_x(sizeof(DYNASENS_LIMIT) - 1, OLED_FONT_MEDIUM_WIDTH)         , DYNASENS_LIMIT[0]         , dynasens_limit         );
			display_edit( 12, center_x(sizeof(DYNASENS_RESTART) - 1, OLED_FONT_MEDIUM_WIDTH)       , DYNASENS_RESTART[0]       , dynasens_restart       );
			display_edit( 13, center_x(sizeof(DYNASENS_MAX_SENS) - 1, OLED_FONT_MEDIUM_WIDTH)      , DYNASENS_MAX_SENS[0]      , dynasens_max_sens      );
			display_edit( 14, center_x(sizeof(DYNASENS_INCREASE_RATE) - 1, OLED_FONT_MEDIUM_WIDTH) , DYNASENS_INCREASE_RATE[0] , dynasens_increase_rate );
			display_edit( 15, center_x(sizeof(RELOAD_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)            , RELOAD_TIME[0]            , reload_time            );
		}
		else
		{
	    // Display Mod Name and ON/OFF
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
			display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH)  , ANTIRECOIL[0]  , toggle_antirecoil[profile_idx]);
			display_mod( 1 ,  center_x(sizeof(RAPIDFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)   , RAPIDFIRE[0]   , toggle_rapidfire[profile_idx] );
			display_mod( 2 ,  center_x(sizeof(BURSTFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)   , BURSTFIRE[0]   , toggle_burstfire[profile_idx] );
			display_mod( 3 ,  center_x(sizeof(AIMASSIST) - 1, OLED_FONT_MEDIUM_WIDTH)   , AIMASSIST[0]   , toggle_aimassist[profile_idx] );
			display_mod( 4 ,  center_x(sizeof(STRAFE_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH) , STRAFE_SHOT[0] , toggle_strafeShot[profile_idx]);
			
			// Mods that have same ON/OFF status on every Profile
			display_mod( 5 ,  center_x(sizeof(DYNASENS) - 1, OLED_FONT_MEDIUM_WIDTH)   , DYNASENS[0]    , dynasens_on);
			display_mod( 6 ,  center_x(sizeof(RELOAD) - 1, OLED_FONT_MEDIUM_WIDTH)     , RELOAD[0]      , reload_on  );
			display_mod( 7 ,  center_x(sizeof(AUTORUN) - 1, OLED_FONT_MEDIUM_WIDTH)    , AUTORUN[0]     , autorun_on );
			display_mod( 8,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)        , SWAP[0]        , swap_on    );
			display_mod( 9,  center_x(sizeof(INVERTED) - 1, OLED_FONT_MEDIUM_WIDTH)    , INVERTED[0]    , inverted_on);
			display_mod( 10,  center_x(sizeof(DROPSHOT) - 1, OLED_FONT_MEDIUM_WIDTH)    , DROPSHOT[0]    , dropshot_on);
			display_mod( 11,  center_x(sizeof(SLIDESHOT) - 1, OLED_FONT_MEDIUM_WIDTH)   , SLIDESHOT[0]   , slideshot_on);
			display_mod( 12,  center_x(sizeof(DJUMP) - 1, OLED_FONT_MEDIUM_WIDTH)       , DJUMP[0]       , djump_on);
			display_mod( 13,  center_x(sizeof(OBS)        - 1, OLED_FONT_MEDIUM_WIDTH)  , OBS[0]         , obs_on);
			display_mod( 14,  center_x(sizeof(JUMP)  - 1, OLED_FONT_MEDIUM_WIDTH)	    , JUMP[0] 	     , jumpshot_on);
			display_mod( 15,  center_x(sizeof(KILLSWITCH) - 1, OLED_FONT_MEDIUM_WIDTH)  , KILLSWITCH[0]  , killswitch_on);
			display_mod( 16,  center_x(sizeof(LEGITASSIST) - 1, OLED_FONT_MEDIUM_WIDTH) , LEGITASSIST[0] , legitassist_on);
			display_mod( 17,  center_x(sizeof(QUICKSWAP) - 1, OLED_FONT_MEDIUM_WIDTH) , QUICKSWAP[0] , quickswap_on);
			
		}
		
	// Display Profile only on mods that may have a different value depending on the Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
		{
			if(profile_idx == 0) // profile_idx = profile_idx = Profile
    			//printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
    			line_oled(0, 26, 39, 26, 5, 1); // print a line to the left to say profile 1
    		else if(profile_idx == 1)
    			//printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
    			line_oled(44, 26, 83, 26, 5, 1); // print a line in the middle to say Profile 2
    		else if(profile_idx == 2)
    			//printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
    			line_oled(88, 26, 127, 26, 5, 1); // print a line to the right to say Profile 3
		}
		else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    	{
    		line_oled(0, 26, 39, 26, 5, 1);
    		line_oled(44, 26, 83, 26, 5, 1);
    		line_oled(88, 26, 127, 26, 5, 1);
    	}
    	
		display_black = TRUE;
        display_new = FALSE;
    } // display_new end
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
} // NOT KillSwitch end

	if(KillSwitch)
		led(7);
	else if(special_weapon)
		led(4);
	else
		led(profile_idx);

 }
// main end
 
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     COMBO SECTION                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo SAVE { 
	cls_oled(0);						// clear OLED screen 
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	wait(10)
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times								
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_new = TRUE;				   // display mods
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
/*
combo BATTERY { 
	cls_oled(0);
	drawBattery(batteryLevel);
	call(RUMBLE_OFF);							
	wait(10);
	call(RUMBLE_OFF);
	wait(10);
	call(RUMBLE_OFF);	
	wait(10);
	cls_oled(0);
}
*/
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
combo X_VAL { // Antirecoil Horizontal
	x_ref = get_val(PS4_RX) + ar_x;
    if(x_ref > 100) x_ref = 100;
    set_val(PS4_RX, x_ref);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
combo JUMPSHOT{
	set_val(19, 100);                          
	wait(50);                                 
	set_val(19, 0);                            
	wait(50);                                 
}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RDROPSHOT {
	set_val(18,100);
	wait(random(30,100));
	wait(random(60,250));
	set_val(18,100);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo SLIDESHOT {                                      
    set_val(XB1_LS,100);
    wait(100);
    set_val(XB1_LY,-100);
    wait(700);
    set_val(XB1_B,100);
    wait(1000);
    set_val(XB1_RT,100);
    wait(100);
    set_val(XB1_RB,100);
    wait(100);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo QUICKSWAP{
	set_val(PS4_TRIANGLE,100);
	set_val(PS4_L3,100);
	set_val(PS4_LY,-100);
	wait(100);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
/*
combo QUICKSWAP{
	set_val(XB1_Y,100);
    wait(200);
	set_val(XB1_LS,100);
    wait(100);
    set_val(XB1_LY,-100);
    wait(700);
    set_val(XB1_LT,100);
}
*/
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo DOUBLEJUMP {
	set_val(XB1_A,100);	
	wait(100);
	set_val(XB1_A,0);
	wait(100);
	set_val(XB1_A,100);
	wait(1000);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo AIM_ASSIST { // AIM Assist
    set_val(PS4_RY,aimassist(PS4_RY, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RX,aimassist(PS4_RX, aimassist_size));
    set_val(PS4_LX,aimassist(PS4_LX, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RY,aimassist(PS4_RY,inv(aimassist_size))); 
    wait(aimassist_time);
    set_val(PS4_RX,aimassist(PS4_RX,inv(aimassist_size)));
    set_val(PS4_LX,aimassist(PS4_LX,inv(aimassist_size)));
    wait(aimassist_time);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo STRAFESHOT { // StrafeShot
    set_val(PS4_LX, 100);
    wait(strafeShot_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafeShot_time);
    wait(50);
}
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RELOAD {
    wait(reload_time); 
    set_val(PS4_TRIANGLE,100);
    wait(random(15,20));
}
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo AUTORUN {
	set_val(PS4_LY, -100);
	set_val(PS4_L3, 100);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
 }
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo OBS {
	set_val(XB1_LB,100);
	set_val(XB1_RB,100);
	wait(random(60,250));
}
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       FUNCTIONS                                                       |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	


// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods
	
	if(valName_idx < f_min)
		valName_idx = f_max;
	if(valName_idx > f_max)
		valName_idx = f_min;
		
// Match the # of value names index with the right column in VALUES array
	val_col_idx = valName_idx;	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
					
	if(valName_idx == f_idx)
	{
    // +1 or -1															 // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2

	// We can also add (f_ref)
	// Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_start[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;	
	}
	// Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
	if(rate_of_fire[profile_idx] < 0)
		rate_of_fire[profile_idx] = 0;

	//return f_ref;

	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function speed_toggle(f_hold, f_press, f_time, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(get_val(f_press) && get_ptime(f_press) == f_time) // Hold second button 300ms or more
		{
			modName_idx = f_string;
			
			if(f_val == 0)
			{
				if(f_string == 1) // If RapidFire is enable, 
					toggle_burstfire[profile_idx] = 0; // disable BurstFire
				else if(f_string == 2) // If BurstFire is enable, 
					toggle_rapidfire[profile_idx] = 0; // disable RapidFire
					
				f_val = 1;
				combo_run(RUMBLE_ON);
			}
			else
			{
				f_val = 0;
				combo_run(RUMBLE_OFF);
			}
			display_new = TRUE;
		} 
	set_val(f_press, 0)
	}
		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == 1) // If RapidFire is enable, 
				toggle_burstfire[profile_idx] = 0; // disable BurstFire
			else if(f_idx == 2) // If BurstFire is enable, 
				toggle_rapidfire[profile_idx] = 0; // disable RapidFire
				
			f_val = 1;
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			f_val = 0;
			combo_run(RUMBLE_OFF);
		}		
		display_new = TRUE;
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);
	
	if(display_title)
		number_to_string(currentSlot, find_digits(currentSlot)); // display current # slot 
	else
	{
    	if(valName_idx == f_idx)
    	{
		// Display value name and value
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    		
    	// Display AntiRecoil Time value x 100 so 1,000 (displayed) = 1 second - script value is 10
    		if(f_idx == 2) 
    			number_to_string((VALUES[profile_idx][val_col_idx] + f_val) * 100, find_digits((VALUES[profile_idx][val_col_idx] + f_val) * 100));
    	
    	// Display all editable values in VALUES array
    		else if(f_idx <= LAST_EDITABLE_COLUMN) 
    			number_to_string(VALUES[profile_idx][val_col_idx] + f_val, find_digits(VALUES[profile_idx][val_col_idx] + f_val));
    	
    	// Display editable values that are not in the array (burstfire_hold for exemple)
    		else 
    			number_to_string(f_val, find_digits(f_val));
    	}
    }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 2, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);
    	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
    // Values that are not in the array (aimassist_time for exemple)
		if(valName_idx > LAST_EDITABLE_COLUMN)
		{
    	// Substract    
        	if(f_val < inv(f_rng_min)) 
        		f_val = inv(f_rng_min); 
   		// Add   
       		if(f_val > f_rng_max) 
        		f_val = f_rng_max;
		}
		
    // Values that are in the array 
		else
		{
    // Substract    
        if((f_val + VALUES[profile_idx][val_col_idx]) < inv(f_rng_min)) 
        	f_val = inv(f_rng_min + VALUES[profile_idx][val_col_idx]); 
    // Add   
        if((f_val + VALUES[profile_idx][val_col_idx]) > f_rng_max) 
        	f_val = f_rng_max - VALUES[profile_idx][val_col_idx]; 
        }
        display_new = TRUE;
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function p_complete() { // Antirecoil

    i_cnt++;
    if(i_cnt > (VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10) 
    {
        i_cnt = (VALUES[profile_idx][2] + antirecoil_time[profile_idx]) * 10;
        return 1;
    }    
    return 0;
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function p_val() { // Antirecoil

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function y_val() { // Antirecoil

    v = get_val(10);
    
    if(abs(v) < 10)
        v = 0;
        
    if(abs(v) > ar_y + 5)
        return v;
        
    return v + (ar_y * invert);           
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function aimassist(f_axis,f_val) { // AIM Assist

    if(abs(get_val(f_axis)) < aimassist_size + 1) // + 1 is release
        return f_val;
        
    return get_val(f_axis); 
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }
    if(display_title)
    	//puts_oled(120, 53, OLED_FONT_SMALL, i - 1, OLED_WHITE); // display current # slot - Small
    	puts_oled(116, 45, OLED_FONT_MEDIUM, i - 1, OLED_WHITE); // display current # slot - Medium
    else
    	puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function find_digits(f_num) {
//  find_digits(value)  
//	    return Number of Digits in Value Passed  

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//	    return X for Centering String Horizontally

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {
//  center_y(font size);  
//	    return Y for Centering String Vertically

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function press_hold(f_btn) { 
//  return TRUE - event_press()   
//			    - every 250ms when button is held

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// DynaSens by Batts
function set_sens () {
    if(abs(get_lval(PS4_RX)) >= dynasens_limit) 
    {
	    sens_xcnt += 1;
	    
		if(sens_xcnt >= dynasens_increase_rate && sens_x < dynasens_max_sens) 
		{ 
		    sens_x += 1; 
		    sens_xcnt = 0; 
		} 
			else if(sens_x >= dynasens_max_sens) 
				sens_xcnt = 0;  
	}
	
    else if(abs(get_val(PS4_RX)) < dynasens_restart) 
    {
	    sens_xcnt = 0; 
	    sens_x = dynasens_initial_sens;    		    
	} 
	
    if(abs(get_val(PS4_RY)) >= dynasens_limit) 
    {
	    sens_ycnt += 1;
		if(sens_ycnt >= dynasens_increase_rate && sens_y < dynasens_max_sens) 
		{ 
		    sens_y += 1; 
		    sens_ycnt = 1; 
		} 
			else if(sens_y >= dynasens_max_sens) 
				sens_ycnt = 0; 
	}
	
    else if(abs(get_val(PS4_RY)) < dynasens_restart) 
    {
	    sens_y = dynasens_initial_sens; 
	    sens_ycnt = 0;
	}
	
	sensitivity(PS4_RX,NOT_USE,sens_x);
    sensitivity(PS4_RY,NOT_USE,sens_y);
}


// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
/*
function drawBattery(f_level) {
	rect_oled(1, 39, 120, 3, 1, 1);  // Top
	rect_oled(1, 61, 120, 3, 1, 1);  // Bottom
	rect_oled(1, 39, 3, 64, 1, 1);   // Left side
	rect_oled(118, 39, 3, 25, 1, 1); // Right side	
	rect_oled(121, 46, 5, 11, 1, 1); // Right side extension
	rect_oled(6, 42, 110, 19, 1, 0); // Clear center
	batteryLevelBarOffset = 8;
	for(batteryLevelIndex = 0; batteryLevelIndex < f_level; batteryLevelIndex++)
	{
		rect_oled(batteryLevelBarOffset, 45, 7, 13, 1, 1); // Fill center with battery level
		batteryLevelBarOffset += 11; // Move offset for the next bar by width of current + 4 pixels
	}
}
*/
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function save () {
	combo_run(SAVE);
	
// Profile 1
	// Toggles                                      // Values
	set_pvar(SPVAR_1,toggle_antirecoil[0]);         set_pvar(SPVAR_6 ,antirecoil_start[0]     );         
	set_pvar(SPVAR_2,toggle_rapidfire[0] );         set_pvar(SPVAR_7 ,antirecoil_end[0]       );        
	set_pvar(SPVAR_3,toggle_burstfire[0] );         set_pvar(SPVAR_8 ,antirecoil_time[0]      );     
	set_pvar(SPVAR_4,toggle_aimassist[0] );         set_pvar(SPVAR_9 ,antirecoil_horizontal[0]);
	set_pvar(SPVAR_5,toggle_strafeShot[0]);         set_pvar(SPVAR_10,rate_of_fire[0]         );
// Profile 2
	// Toggles                                       // Values
	set_pvar(SPVAR_11,toggle_antirecoil[1]);         set_pvar(SPVAR_16,antirecoil_start[1]     );       
	set_pvar(SPVAR_12,toggle_rapidfire[1] );         set_pvar(SPVAR_17,antirecoil_end[1]       );      
	set_pvar(SPVAR_13,toggle_burstfire[1] );         set_pvar(SPVAR_18,antirecoil_time[1]      );     
	set_pvar(SPVAR_14,toggle_aimassist[1] );         set_pvar(SPVAR_19,antirecoil_horizontal[1]);
	set_pvar(SPVAR_15,toggle_strafeShot[1]);	     set_pvar(SPVAR_20,rate_of_fire[1]         );
// Profile 3
	// Toggles                                       // Values
	set_pvar(SPVAR_21,toggle_antirecoil[2]);         set_pvar(SPVAR_26,antirecoil_start[2]     );       
	set_pvar(SPVAR_22,toggle_rapidfire[2] );         set_pvar(SPVAR_27,antirecoil_end[2]       );      
	set_pvar(SPVAR_23,toggle_burstfire[2] );         set_pvar(SPVAR_28,antirecoil_time[2]      );      
	set_pvar(SPVAR_24,toggle_aimassist[2] );         set_pvar(SPVAR_29,antirecoil_horizontal[2]);
	set_pvar(SPVAR_25,toggle_strafeShot[2]);         set_pvar(SPVAR_30,rate_of_fire[2]         );
// Misc values
	set_pvar(SPVAR_31, burstfire_hold   );			 set_pvar(SPVAR_36, dynasens_initial_sens );		set_pvar(SPVAR_41, reload_time);
	set_pvar(SPVAR_32, burstfire_release);			 set_pvar(SPVAR_37, dynasens_limit        );
	set_pvar(SPVAR_33, aimassist_size   );			 set_pvar(SPVAR_38, dynasens_restart      );
	set_pvar(SPVAR_34, aimassist_time   );			 set_pvar(SPVAR_39, dynasens_max_sens     );
	set_pvar(SPVAR_35, strafeShot_time  );			 set_pvar(SPVAR_40, dynasens_increase_rate);
//Misc toggles
	set_pvar(SPVAR_42, dynasens_on);				 
	set_pvar(SPVAR_43, reload_on  );				 
	set_pvar(SPVAR_44, autorun_on );				
	set_pvar(SPVAR_45, swap_on    );
	set_pvar(SPVAR_46, inverted_on);
	set_pvar(SPVAR_47, dropshot_on);
	set_pvar(SPVAR_48, slideshot_on);
	set_pvar(SPVAR_49, djump_on);
	set_pvar(SPVAR_50, obs_on);
	set_pvar(SPVAR_51, jumpshot_on);
	set_pvar(SPVAR_52, killswitch_on);
	set_pvar(SPVAR_53, legitassist_on);
	set_pvar(SPVAR_54, quickswap_on);
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
/*
function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
/*set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);
}  
 */
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int __pictureX, __pictureX2, __pictureY, __pictureY2, __pictureBit, __pictureOffset, __pictureData;
function draw_picture(x, y, invert) {
	__pictureOffset = 2; // Reset the starting point
	__pictureBit = 16; // Reset bit flag
	for (__pictureY = 0; __pictureY < picture[1]; __pictureY++) { // Loop the Y axis
		for (__pictureX = 0; __pictureX < picture[0]; __pictureX++) { // Loop the X axis
			__pictureData = picture[__pictureOffset]
			__pictureX2 = x + __pictureX;
			__pictureY2 = y + __pictureY;
			if (__pictureX2 < 0 || __pictureX2 >= 128) {
				__pictureX2 -= 128;
			}
			if (__pictureY2 < 0 || __pictureY2 >= 64) {
				__pictureY2 -= 64;
			}
			if (test_bit(__pictureData, __pictureBit - 1)) {
				pixel_oled(__pictureX2, __pictureY2, !invert);
			}
			else {
				pixel_oled(__pictureX2, __pictureY2, invert);
			}
			__pictureBit--; // Decrement the bit flag, we're moving to the next bit
			if (!__pictureBit) { // Check if we've just handled the last bit
				__pictureBit = 16; // Reset the bit flag
				__pictureOffset++; // Move to the next value
			}
		}
	}
}
// © 2020 CronusMax & CronusZen. All rights reserved.