
	const string TITLE = "RealmRoyale"; // 11 char max
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE= "SAVED";
	const string PROFILE_1 = "Profile 1": // or primary weapon
	const string PROFILE_2 = "Profile 2": // or secondary weapon
	const string PROFILE_3 = "Profile 3": // or handgun
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mod Name
	const string ANTIRECOIL 		= "AntiRecoil";		 // modName_idx = 0
	const string RAPIDFIRE 			= "RapidFire";       // modName_idx = 1
	const string BURSTFIRE 			= "BurstFire";       // modName_idx = 2
	const string AIMASSIST 			= "AIM Assist"       // modName_idx = 3 		
	const string STRAFE_SHOT 		= "StrafeShot";      // modName_idx = 4
	const string CUSTOM_SENSE		= "CustomSense";	 // modName_idx = 5
	const string JUMP_SHOT			= "JumpShot";		 // modName_idx = 6
	const string CROUCH_SHOT		= "CrouchShot";		 // modName_idx = 7
	const string SWAP_SHOT			= "SwapShot"; 		 // modName_idx = 8
	const string AUTO_RELOAD		= "AutoReload";		 // modName_idx = 9
	const string EASY_PING			= "EasyPing";		 // modName_idx = 10
	const string EASY_SUPPORT		= "EasySupport";	 // modName_idx = 11
	const string EASY_OFFENSE		= "EasyOffense";	 // modName_idx = 12
	const string EASY_POTION		= "EasyPotion";		 // modName_idx = 13
	const string SWAP 				= "Swap Tr/Bu";		 // modName_idx = 14
	const string INVERTED 			= "Inverted Y";   	 // modName_idx = 15

// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;

// modName # of the last Mod Name string - Used for cycle modName_idx
	define LAST_MODNAME_STRING = 15;

// # of the last modName_idx that has a value that can be edited
	define LAST_EDITABLE_STRING = 5;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	// modName_idx = 0 = ANTIRECOIL string
	const string ANTIRECOIL_VERTICAL = "AR Vertical"; 		// valName_idx = 0  
	const string ANTIRECOIL_HORIZONTAL = "AR Horiz";		// valName_idx = 1
	// modName_idx = 1
	const string RATE_OF_FIRE = "Rounds/sec";				// valName_idx = 2
	// modName_idx = 2
	const string BURSTFIRE_HOLD = "BF Hold";				// valName_idx = 3
	const string BURSTFIRE_RELEASE = "BF Release";			// valName_idx = 4
	// modName_idx = 3 = AA string
	const string AIMASSIST_SIZE = "AA Size";				// valName_idx = 5
	const string AIMASSIST_TIME = "AA Time";				// valName_idx = 6
	// modName_idx = 4
	const string STRAFESHOT_TIME = "S.Shot Time";			// valName_idx = 7 
	// modName_idx = 5
	const string CUSTOMSENSE_TIME = "C.SENSE Time";		// valName_idx = 8 
// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
	define AMOUNT_OF_VALNAME_IDX = 8;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// /!\ DO NOT CHANGE RATE OF FIRE VALUE IN THE ARRAY
// Constant bytes - VALUES array (mods with value and toggle) - VALUES[line][column]
	const uint8 VALUES[][] = { 		
/* Profile 1 */	{    10,                    0,                  1       },	// profile_idx = 0 
/* Profile 2 */	{    11,                    0,                  1       }, 	// profile_idx = 1 
/* Profile 3 */ {    12,                    0,                  1       }};	// profile_idx = 2 
/*		   antirecoil_vertical[], antirecoil_horizontal[]  rate_of_fire[]           
                 AntiRecoil             AntiRecoil          RapidFire  
val_col_idx         = 0                   = 1                 = 2                  */

// VALUES array column number - Buffer to add or substract edited value to corresponding value in VALUES array
	int antirecoil_vertical[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the VALUES array to find your final value
	int antirecoil_horizontal[3];
	int rate_of_fire[3];

/* VALUES array line number - index - 
   Used to define Profiles and also define # of profile to find, edit, and display the right index */
	int profile_idx; 
	
// Index to find VALUES array column - Follow valName_idx to edit the right value (that is in VALUES array or not like Strafe_t value)
	int val_col_idx;

// # of the last column - used in display_edit() function 
	define LAST_EDITABLE_COLUMN = 2;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Multi toggles
	int toggle_antirecoil  [3];  // for 3 Profiles: profile_idx = 0, 1 and 2
	int toggle_rapidfire   [3];  
	int toggle_burstfire   [3];
	int toggle_aimassist   [3];
	int toggle_strafeShot  [3];
	int toggle_customSense [3];
	int toggle_jumpShot    [3];
	int toggle_crouchShot  [3];
	int toggle_swapShot    [3];
	int toggle_autoReload  [3];
	int toggle_easyPing    [3];
	int toggle_easySupport [3];
	int toggle_easyOffense [3];
	int toggle_easyPotion  [3];
	
// Amount of profiles - Used for switch profiles cycle
	define AMOUNT_OF_PROFILES = 3;  
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 14;
		
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Mods (with values) that activates for all profiles at the same time (if toggled ON)
// BurstFire
    int burstfire_hold;
    int burstfire_release;
// AIM Assist
    int aimassist_size;
    int aimassist_time;
// Strafe Shot
    int strafeShot_time;
// Custom Sense
	int customSense_time
// Toggles
    int swap_on;
    int inverted_on;
//Screen Saver
    int SCREENSAVER;
    define SSA1 = 80;
    define SSA2 = 65;
    define SSA3 = 82;
    define SSA4 = 65;
    define SSA5 = 70;
    define SSA6 = 76;
    define SSA7 = 65;
    define SSA8 = 88;
    define SAVER = 5000;
    define SAVER1 = 10;
	int SSMU1 = 1;
	int SSMU2 = 8;
	int SSMU3 = 15;
	int SSMU4 = 22;
	int SSMU5 = 29;
	int SSMU6 = 36;
	int SSMU7 = 43;
	int SSMU8 = 50;
	int SSMU9 = 57;
	int SSMU10 = 64;
	int SSMU11 = 71;
	int SSMU12 = 78;
	int SSMU13 = 85;
	int SSMU14 = 92;    

    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for function number_to_string() 
	int i;
	int c,c_val;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//    Blue      Pink    SkyBlue    Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//   Yellow    White      Red       OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_black;
    
// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil values                                                 
	int AntirecoilVertical; 
	int AntirecoilHorizontal;
	int invert; // -1 for inverted, 1 for standard
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter
	int count_black; // for screen saver

	
// Double Tap
	int double_tap;
	
// Profiles
	int profile_1or2; // Profile 1 and 2
	int profile_3;   // Profile 3

// Custom Sense
	int GEN_SENS = 100;
    int ADS_SENS = 100;
    int FIRE_SENS = 100;
    int ADS_FIRE_SENS = 100;
    int USE_SENS;
    int CS = TRUE;
    /*Defualt = 100
    Ranges from 0 to 327*/

//Swap Shot
	define TRIANGLE_PRESS_TIME   = 500;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
init{
// Profile 1
	// Toggles                                                  // Values
	toggle_antirecoil[0] 	= get_pvar(SPVAR_1, 0, 1, 0 );         antirecoil_vertical[0]   = get_pvar(SPVAR_15, -99, 99, 0);         
	toggle_rapidfire[0]  	= get_pvar(SPVAR_2, 0, 1, 0 );         antirecoil_horizontal[0] = get_pvar(SPVAR_16, -99, 99, 0);
	toggle_burstfire[0]  	= get_pvar(SPVAR_3, 0, 1, 0 );         rate_of_fire[0]          = get_pvar(SPVAR_17,  0, 25, 0);
	toggle_aimassist[0]  	= get_pvar(SPVAR_4, 0, 1, 0 );        
	toggle_strafeShot[0] 	= get_pvar(SPVAR_5, 0, 1, 0 );
	toggle_customSense[0] 	= get_pvar(SPVAR_6, 0, 1, 0 );
	toggle_jumpShot[0] 		= get_pvar(SPVAR_7, 0, 1, 0 );
	toggle_crouchShot[0] 	= get_pvar(SPVAR_8, 0, 1, 0 );
	toggle_swapShot[0] 		= get_pvar(SPVAR_9, 0, 1, 0 );
	toggle_autoReload[0] 	= get_pvar(SPVAR_10, 0, 1, 0 );
	toggle_easyPing[0] 		= get_pvar(SPVAR_11, 0, 1, 0 );
	toggle_easySupport[0] 	= get_pvar(SPVAR_12, 0, 1, 0 );
	toggle_easyOffense[0] 	= get_pvar(SPVAR_13, 0, 1, 0 );
	toggle_easyPotion[0] 	= get_pvar(SPVAR_14, 0, 1, 0 );
// Profile 2
	// Toggles                                                  // Values
	toggle_antirecoil[1] 	= get_pvar(SPVAR_18, 0, 1, 0 );        antirecoil_vertical[1]   = get_pvar(SPVAR_32, -99, 99, 0);         
	toggle_rapidfire[1]  	= get_pvar(SPVAR_19, 0, 1, 0 );        antirecoil_horizontal[1] = get_pvar(SPVAR_33, -99, 99, 0);
	toggle_burstfire[1]  	= get_pvar(SPVAR_20, 0, 1, 0 );        rate_of_fire[1]          = get_pvar(SPVAR_34,   0, 25, 0);
	toggle_aimassist[1]  	= get_pvar(SPVAR_21, 0, 1, 0 );        
	toggle_strafeShot[1] 	= get_pvar(SPVAR_22, 0, 1, 0 );
	toggle_customSense[1] 	= get_pvar(SPVAR_23, 0, 1, 0 );
	toggle_jumpShot[1] 		= get_pvar(SPVAR_24, 0, 1, 0 );
	toggle_crouchShot[1] 	= get_pvar(SPVAR_25, 0, 1, 0 );
	toggle_swapShot[1] 		= get_pvar(SPVAR_26, 0, 1, 0 );
	toggle_autoReload[1] 	= get_pvar(SPVAR_27, 0, 1, 0 );
	toggle_easyPing[1] 		= get_pvar(SPVAR_28, 0, 1, 0 );
	toggle_easySupport[1] 	= get_pvar(SPVAR_29, 0, 1, 0 );
	toggle_easyOffense[1] 	= get_pvar(SPVAR_30, 0, 1, 0 );
	toggle_easyPotion[1] 	= get_pvar(SPVAR_31, 0, 1, 0 );
// Profile 3
	// Toggles                                                  // Values
	toggle_antirecoil[2] 	= get_pvar(SPVAR_35, 0, 1, 0 );        antirecoil_vertical[2]   = get_pvar(SPVAR_49, -99, 99, 0);         
	toggle_rapidfire[2]  	= get_pvar(SPVAR_36, 0, 1, 0 );        antirecoil_horizontal[2] = get_pvar(SPVAR_50, -99, 99, 0);
	toggle_burstfire[2]  	= get_pvar(SPVAR_37, 0, 1, 0 );        rate_of_fire[2]          = get_pvar(SPVAR_51,   0, 25, 0);
	toggle_aimassist[2]  	= get_pvar(SPVAR_38, 0, 1, 0 );        
	toggle_strafeShot[2] 	= get_pvar(SPVAR_39, 0, 1, 0 );
	toggle_customSense[2] 	= get_pvar(SPVAR_40, 0, 1, 0 );
	toggle_jumpShot[2] 		= get_pvar(SPVAR_41, 0, 1, 0 );
	toggle_crouchShot[2] 	= get_pvar(SPVAR_42, 0, 1, 0 );
	toggle_swapShot[2] 		= get_pvar(SPVAR_43, 0, 1, 0 );
	toggle_autoReload[2] 	= get_pvar(SPVAR_44, 0, 1, 0 );
	toggle_easyPing[2] 		= get_pvar(SPVAR_45, 0, 1, 0 );
	toggle_easySupport[2] 	= get_pvar(SPVAR_46, 0, 1, 0 );
	toggle_easyOffense[2] 	= get_pvar(SPVAR_47, 0, 1, 0 );
	toggle_easyPotion[2] 	= get_pvar(SPVAR_48, 0, 1, 0 );
	
// Misc	
// Toggles only													// Values
    															burstfire_hold    	= get_pvar(SPVAR_54, 1, 999, 200); 
    swap_on      = get_pvar(SPVAR_52, 0, 1, 0);					burstfire_release 	= get_pvar(SPVAR_55, 1, 999, 300); 
    inverted_on  = get_pvar(SPVAR_53, 0, 1, 0);					aimassist_size    	= get_pvar(SPVAR_56, 1, 50 , 20 ); 
    															aimassist_time    	= get_pvar(SPVAR_57, 1, 999, 40 ); 
    															strafeShot_time   	= get_pvar(SPVAR_58, 1, 999, 500); 
    															customSense_time 	= get_pvar(SPVAR_59, 1,	100, 100);
}

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                                     MAIN SECTION                                                      |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
main {
// Debug - Device Monitor
	set_val(TRACE_1, modName_idx); 
	set_val(TRACE_2, valName_idx); 
	set_val(TRACE_3, profile_idx);
	set_val(TRACE_4, count_black);
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Crossover
    if(get_controller() != PIO_PS4) // If XBOX controller:
    {
        if(get_console() == PIO_PS4) // If PS4 console:
        {
            swap(PS4_SHARE,PS4_TOUCH); // View = TouchPad
        
                if(get_val(PS4_R3) && event_press(PS4_TOUCH)) //  RS + View = ScreenShot
                {
                    set_val(PS4_SHARE,100);
                    set_val(PS4_TOUCH,0);
                    set_val(PS4_R3,0);
                }
        }
	}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     DISPLAY TITLE                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

// Display Script Title    
    if(display_title)
    {
    	cls_oled(0);	// clear OLED screen
    	count_black = 0;// reset screen saver counter
    	
    	if(KillSwitch)
    	{
    		printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),8,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);	// display OFF centered in X 
			
		}
    	else
    	{
    		printf(center_x(sizeof(TITLE) - 1, OLED_FONT_MEDIUM_WIDTH),13,OLED_FONT_MEDIUM,OLED_WHITE,TITLE[0]);	// display TITLE centered in X 
    	
    	// Display profile name
    		if(profile_idx == 0)
    			printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_1[0]); 
    		if(profile_idx == 1)
    			printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_2[0]);
    		if(profile_idx == 2)
    			printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_MEDIUM_WIDTH),45,OLED_FONT_MEDIUM,OLED_WHITE,PROFILE_3[0]);
    	
    		display_black = TRUE;	// screen saver
    		display_title = FALSE;
    		SCREENSAVER = FALSE;
    	}
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
// Screen saver (OLED off)
    if(display_black && !ModMenu && !KillSwitch)
    {
    	count_black += get_rtime();
    	if(count_black >= 5000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    		SCREENSAVER = TRUE;
    	}
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                      KILL SWITCH                                                      |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
  
	if(get_val(PS4_L2))
	{
	// Kill Switch	
		if(event_release(PS4_SHARE))
		{
			KillSwitch = !KillSwitch;
			
			if(KillSwitch)        
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			else
				combo_run(RUMBLE_ON);	// rumble and LED blink
			
    		//display_black = FALSE;
			display_title = TRUE;
		}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       MOD MENU                                                        |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

	// toggle ModMenu ON/OFF
		if(event_release(PS4_OPTIONS) && !KillSwitch)
		{
			ModMenu = !ModMenu;
			
			if(!ModMenu)
			{
				ModEdit = FALSE; 		// close ModEdit too
				//save ();				// save function
				//combo_run(EXIT_SAVE);	// rumble, blink and display SAVED then display TITLE
				combo_run(RUMBLE_OFF);  // rumble and LED blink
				display_title = TRUE;   // display Title
			}
			
			if(ModMenu)
			{
				modName_idx = 0;        // start to the first adjustable value
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_new = TRUE;		// display mod name, profile, ON/OFF and value
			}
		}
		set_val(PS4_SHARE, 0);		    // block
		set_val(PS4_OPTIONS, 0);		// block
	} // L2 end

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
if(!KillSwitch)
{
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
// ModMenu
	if(ModMenu)
	{
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            MOD EDIT                                               |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

	// toggle ModEdit ON/OFF - only for mods who have adjustable value(s)
		if(modName_idx <= LAST_EDITABLE_STRING)	// if ANTIRECOIL (so modName_idx = 0) or AA or RAPIDFIRE or BURSTFIRE or StrafeShot is diplayed 
		{
			if(event_press(PS4_CROSS) && !ModEdit) // Turn ModEdit ON
			{
				valName_idx = AMOUNT_OF_VALNAME_IDX + 1; // always display first val names available when enter in edition mod
				ModEdit = TRUE;
				combo_run(RUMBLE_ON);
				display_new = TRUE;
			}
			
			if(event_press(PS4_CIRCLE) && ModEdit) // Turn ModEdit OFF
			{
				ModEdit = FALSE;
				combo_run(RUMBLE_OFF);
				display_new = TRUE;
			}
		}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                          EDIT VALUES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
            
	// ModEdit ON
		if(ModEdit)
		{
			if(get_val(PS4_L2)) // Edit value: hold L2 + UP (+1) or DOWN (-1) or RIGHT (+10) or LEFT (-10)
			{
			// Mods that can have different values depending the active Profile
			
    		  //val_I_want_to_edit[profile] = edit_val( corresponding valName_idx , val_I_want_to_edit[profile], abs(range min) , range max ); 	
				antirecoil_vertical[profile_idx]   = edit_val( 0 , antirecoil_vertical[profile_idx]  ,  0 , 99 , 1 , 10   ); // the first 0 define valName_idx so in this case, AR Start
				antirecoil_horizontal[profile_idx] = edit_val( 1 , antirecoil_horizontal[profile_idx],  99, 99 , 1 , 10   );
				rate_of_fire[profile_idx]          = edit_val( 2 , rate_of_fire[profile_idx]         ,  0 , 25 , 1 , 10   );  // 25 rounds/s max
				
			// Mods that have same value on every Profiles
			
			  //val_I_want_to_edit = edit_val( corresponding valName_idx , val_I_want_to_edit, range min , range max );
				burstfire_hold    = edit_val( 3 , burstfire_hold    , 0 , 990  , 10 , 100  );
				burstfire_release = edit_val( 4 , burstfire_release , 0 , 990  , 10 , 100  );
				aimassist_size    = edit_val( 5 , aimassist_size    , 0 , 50   , 1  , 10   );
				aimassist_time    = edit_val( 6 , aimassist_time    , 0 , 990  , 1  , 10   ); 
				strafeShot_time   = edit_val( 7 , strafeShot_time   , 0 , 9990 , 10 , 100  );
				customSense_time  = edit_val( 8 , customSense_time  , 0 , 327  , 10 , 100  );
			}

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        VALUES AVAILABLE                                           |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

			else // NOT L2 (if not editing value)
			{
			// Navigate value name
				if(event_press(PS4_R1))
				{
					valName_idx += 1;
					display_new = TRUE; // Display value name and value
				}
				if(event_press(PS4_L1))
				{
					valName_idx -= 1;
					display_new = TRUE;
				}
				
			// Adjustable values available for each of the mods (example: Anti-Recoil have 4 values per profile: 0 = antirecoil_start[<active profile>], 1 = antirecoil_end[], 2 = at_t, 3 = at_h  
			 // if(modName_idx == 0) <so if I display Anti-Recoil>  vals_available( 0 , 3  ); <vals_available are valName_idx 0, 1, 2 or 3>
				if(modName_idx == 0) vals_available( 0 , 1  );// Anti-Recoil		
				if(modName_idx == 1) vals_available( 2 , 2  );// RapidFire            				
				if(modName_idx == 2) vals_available( 3 , 4  );// If BurstFire was displayed before I enter ModEdit, I can only edit all BurstFire values			
				if(modName_idx == 3) vals_available( 5 , 6  );// AIM Assist				
				if(modName_idx == 4) vals_available( 7 , 7  );// StrafeShot
				if(modName_idx == 5) vals_available( 8 , 8  );// Custom Sense
			} // NOT SQUARE (if not editing value) end
		} // ModEdit end

            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                            TOGGLES                                                |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

		else // if NOT ModEdit BUT if ModMenu
		{
		// Navigate mods name
			if(event_press(PS4_R1))
			{
				modName_idx += 1;
				display_new = TRUE;
			}
			if(event_press(PS4_L1))
			{
				modName_idx -= 1;
				display_new = TRUE;
			}
			
		// Cycle mods name
			if(modName_idx > LAST_MODNAME_STRING) // max column for displaying mod name  
				modName_idx = 0;
			if(modName_idx < 0)
				modName_idx = LAST_MODNAME_STRING;
				
		// Switch profiles	
			if(event_press(PS4_TRIANGLE))
			{
				profile_idx += 1;
				display_new = TRUE;
			}
		// Cycle profiles	
			if(profile_idx > (AMOUNT_OF_PROFILES - 1))
				profile_idx = 0;
			
		// Toggles (UP to turn ON, DOWN to turn OFF)
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //toggle_I_want_to_edit[profile]  = toggle( corresponding modName_idx, toggle_I_want_to_edit[profile] );
			toggle_antirecoil[profile_idx] 	= toggle( 0, toggle_antirecoil[profile_idx] );
			toggle_rapidfire[profile_idx]  	= toggle( 1, toggle_rapidfire[profile_idx]  );
			toggle_burstfire[profile_idx]  	= toggle( 2, toggle_burstfire[profile_idx]  );
			toggle_aimassist[profile_idx]  	= toggle( 3, toggle_aimassist[profile_idx]  );
			toggle_strafeShot[profile_idx] 	= toggle( 4, toggle_strafeShot[profile_idx] );
			toggle_customSense[profile_idx] = toggle( 5, toggle_customSense[profile_idx] );
			toggle_jumpShot[profile_idx] 	= toggle( 6, toggle_jumpShot[profile_idx] );
			toggle_crouchShot[profile_idx] 	= toggle( 7, toggle_crouchShot[profile_idx] );
			toggle_swapShot[profile_idx] 	= toggle( 8, toggle_swapShot[profile_idx] );
			toggle_autoReload[profile_idx]  = toggle( 9, toggle_autoReload[profile_idx] );
			toggle_easyPing[profile_idx]  	= toggle( 10, toggle_easyPing[profile_idx] );
			toggle_easySupport[profile_idx] = toggle( 11, toggle_easySupport[profile_idx] );
			toggle_easyOffense[profile_idx] = toggle( 12, toggle_easyOffense[profile_idx] );
			toggle_easyPotion[profile_idx]  = toggle( 13, toggle_easyPotion[profile_idx] );
		
			// Mods that have same ON/OFF status on every Profiles
    		
		  //toggle_I_want_to_edit = toggle( corresponding modName_idx, toggle_I_want_to_edit );
			swap_on     = toggle( 14 , swap_on     );
			inverted_on = toggle( 15 , inverted_on );
		} // if NOT ModEdit BUT if ModMenu end
		
	// If ModMenu AND ModEdit
		if(event_press(PS4_CIRCLE))
			save ();
			
		//block_btn (); // block ALL btn (exept L2_R2_RX_RY_LX_LY to test antirecoil, rapidfire and burstfire against a wall without leaving ModEdit and ModMenu)
		block_all_inputs();
		
	} // ModMenu ON end


							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                              NOT MOD MENU AND NOT MOD EDIT                                             |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — */	 
	if(!ModMenu)
	{
	
		if(swap_on) // (6)
		{
			swap(PS4_R1, PS4_R2);
			swap(PS4_L1, PS4_L2);
		}
            /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
            |                                        SPEED TOGGLES                                              |
            ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	// Speed Toggles
	
	  //toggle_I_want_to_edit[profile]  = speed_toggle( hold BTN1, hold BTN2 300ms   , toggle_I_want_to_edit[profile] , corresponding modName_idx );
		toggle_rapidfire[profile_idx]  	= speed_toggle( PS4_L2, PS4_UP   		, toggle_rapidfire[profile_idx] , 1 );
		toggle_burstfire[profile_idx]  	= speed_toggle( PS4_L2, PS4_RIGHT 		, toggle_burstfire[profile_idx] , 2 );
		toggle_aimassist[profile_idx]  	= speed_toggle( PS4_L2, PS4_LEFT		, toggle_aimassist[profile_idx] , 3 );
		toggle_strafeShot[profile_idx] 	= speed_toggle( PS4_L2, PS4_DOWN 		, toggle_strafeShot[profile_idx], 4 );
		toggle_jumpShot[profile_idx] 	= speed_toggle( PS4_SHARE, PS4_UP 		, toggle_jumpShot[profile_idx], 6 );
		toggle_crouchShot[profile_idx] 	= speed_toggle( PS4_SHARE, PS4_DOWN 	, toggle_crouchShot[profile_idx], 7 );
		toggle_swapShot[profile_idx] 	= speed_toggle( PS4_SHARE, PS4_LEFT 	, toggle_swapShot[profile_idx], 8 );
		toggle_autoReload[profile_idx] 	= speed_toggle( PS4_SHARE, PS4_RIGHT 	, toggle_autoReload[profile_idx], 9 );
		
		// We can add as many speed toogle as we need

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	// Double Tap
    	if(double_tap) 
        	double_tap -= get_rtime();
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	// Hair Trigger
   	 	deadzone(PS4_L2,PS4_R2,99,99);
    	
 	 /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
 	 |                                                      AIM ASSIST (3)                                                      |
 	 /◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// If AIM Assist is enable for the curent profile
		if(toggle_aimassist[profile_idx] == 1)
		{
			if(get_val(PS4_L2)  && !get_val(PS4_R2) || get_val(PS4_R2) || get_val(PS4_LX) || get_val(PS4_LY) || get_val(PS4_L2)) 
				combo_run(AIM_ASSIST);
			else 
				combo_stop(AIM_ASSIST); 
		}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      STRAFE SHOT (4)                                                      |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
  
	// If Strafe Shot is enable for the curent profile
		if(toggle_strafeShot[profile_idx] == 1)
		{
		// Run combo
			if(get_val(PS4_R2))
				combo_run(STRAFESHOT);
			else
				combo_stop(STRAFESHOT);
		}

  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                      OTHER MODS                                                       |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
	//Custom Sense is enable for the curent profile
   		
 	if(toggle_customSense[profile_idx] == 1) {
 		
    if(CS)
    if(!get_val(PS4_L2) && !get_val(PS4_R2))  
    USE_SENS=GEN_SENS;}
    	else if(get_val(PS4_L2) && !get_val(PS4_R2)) { 
   			USE_SENS=ADS_SENS;}    
   		else if(!get_val(PS4_L2) && get_val(PS4_R2)) { 
    		USE_SENS=FIRE_SENS;}
    else if(get_val(PS4_L2) && get_val(PS4_R2)) { 
  			USE_SENS=ADS_FIRE_SENS;}
    			sensitivity(PS4_RY,NOT_USE,USE_SENS);
    			sensitivity(PS4_RX,NOT_USE,USE_SENS);
    		}
			
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜		
	
	//Swap Shot is enable for the curent profile

	if(toggle_swapShot [profile_idx] == 1) {

    if(event_release(PS4_R2)) 
              combo_run(S1);
        }
    }


	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

	//Auto Reload is enabled for the current profile
	
	if(toggle_autoReload [profile_idx] ==1) {
	
	if(event_release(PS4_R2))
		combo_run (AUTORELOAD);
	
	}

	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
	//Easy Ping is enable for the curent profile
 
 {
if(toggle_easyPing[profile_idx] == 1)
        
        
        
    // Run combo
		if(get_val(PS4_R2))
			combo_run(EASYPING);
    	else
			combo_stop(EASYPING);
    
    }
	
	//Crouch Shot is enable for the curent profile
{
	
if(toggle_crouchShot[profile_idx] == 1)
		
	// Run combo
		if(get_val(PS4_R2) || get_val(PS4_L2))
			combo_run(CROUCHSHOT);
    	else
			combo_stop(CROUCHSHOT);
		
	}
	
	//Jump Shot is enable for the curent profile
{
	
if(toggle_jumpShot[profile_idx] == 1)
		
	// Run combo
		if(get_val(PS4_R2))
			combo_run(JUMPSHOT);
    	else
			combo_stop(JUMPSHOT);
		
	}
	
	//Easy Support is enable for the curent profile
{
	
if(toggle_easySupport[profile_idx] == 1)
		
	// Run combo
		if(get_val(PS4_R2))
			combo_run(EASYSUPPORT);
    	else
			combo_stop(EASYSUPPORT);
		
	}
	
	//Easy Offense is enable for the curent profile
	
	{
	
if(toggle_easyOffense[profile_idx] == 1)
		
	// Run combo
		if(get_val(PS4_R2))
			combo_run(EASYOFFENSE);
    	else
			combo_stop(EASYOFFENSE);
	
	}
	
	//Easy Potion is enable for the curent profile
	
	{
	
if(toggle_easyPotion[profile_idx] == 1)
		
	// Run combo
		if(get_val(PS4_UP))
			combo_run(EASYPOTION);
	
	}
	
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
	{
		if(inverted_on) // (7)
			invert = -1;
		else
			invert = 1;}
	
  	/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  	|                                                     SWITCH PROFILE                                                    |
  	◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
  
	// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold R3/RS + tap for sync color

    	if(event_press(PS4_TRIANGLE) || (get_val(PS4_L3) && event_press(PS4_TRIANGLE)))
    	{
    	    profile_1or2=!profile_1or2; 
    	    profile_3 = FALSE;
        
    	    if(double_tap) 
    	    { 
    	     	profile_3 = TRUE ; 
    	    	profile_1or2 = !profile_1or2;
    	    }
			else
            	double_tap = 200;
    
    		if(ModMenu)
				display_new = TRUE;
			else
				display_title = TRUE;
    	}
		if(get_val(PS4_L3))
			set_val(PS4_TRIANGLE, 0);
		{
    // If Profile 3
    	if(profile_3)
    		profile_idx = 2;
    	
    	else
    	
    	{    
    	// If Profile 2
    		if(profile_1or2)
    			profile_idx = 1;
    		
    	// If Profile 1
    		else	
    			profile_idx = 0;
		}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	} // ModMenu OFF end

							/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
							|                                   FEATURES THAT WORK EVERYTIME (MOD MENU/EDIT OR NOT)                                 |
							◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    ANTI RECOIL (0)                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

// If Anti-Recoil is enable for the active profile
		
	if(toggle_antirecoil[profile_idx] == 1)
	{
		if(toggle_burstfire[profile_idx] != 1 && get_val(PS4_L2) && get_val(PS4_R2) || toggle_burstfire[profile_idx] == 1 && get_val(PS4_R2) && get_ptime(PS4_R2) <= hold_time)
			combo_run(ANTIRECOIL);
		else
			combo_stop(ANTIRECOIL);
	}

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    RAPID FIRE (1)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/  
  
// If RapidFire is enable for the active profile
	if(toggle_rapidfire[profile_idx] == 1)
	{
	// Rate of Fire Calculation
    	hold_time = 500 / (VALUES[profile_idx][4] + rate_of_fire[profile_idx]); 
   		rest_time = hold_time - 20;
    	if(rest_time < 0) rest_time = 0;
    
    // Run combo
    	if(get_val(PS4_R2))
    		combo_run(RAPIDFIRE);
    	else
    		combo_stop(RAPIDFIRE);
    		
    	led_on = 150;
    	led_off = 300;
    	combo_run(BLINK);
	}
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    BURST FIRE (2)                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/ 
  
// If BurstFire is enable for the active profile
	if(toggle_burstfire[profile_idx] == 1)
	{
    // Hold and Release
		hold_time = burstfire_hold;
		rest_time = burstfire_release;
			
    // Run combo
    	if(get_val(PS4_R2))	
    		combo_run(BURSTFIRE);
    	else
    		combo_stop(BURSTFIRE);

		led_on = 200;
    	led_off = 1000;
    	combo_run(BLINK);
	}  
		
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                    REFRESH DISPLAY                                                    |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(display_new) 
	{
	// Clear OLED screen	
		cls_oled(0);
    	count_black = 0;// reset screen saver counter
		
		if(ModEdit)
		{
	    // Display Value Name and value
    		// Mods that can have different values depending the active Profile
    		
		  //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[profile] );
			display_edit( 0 , center_x(sizeof(ANTIRECOIL_VERTICAL) - 1, OLED_FONT_MEDIUM_WIDTH)   , ANTIRECOIL_VERTICAL[0]   , antirecoil_vertical[profile_idx]   );
			display_edit( 1 , center_x(sizeof(ANTIRECOIL_HORIZONTAL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL_HORIZONTAL[0] , antirecoil_horizontal[profile_idx] );
			display_edit( 2 , center_x(sizeof(RATE_OF_FIRE) - 1 , OLED_FONT_MEDIUM_WIDTH)         , RATE_OF_FIRE[0]          , rate_of_fire[profile_idx]          );
			
			// Mods that have same value on every Profile
			display_edit( 3 , center_x(sizeof(BURSTFIRE_HOLD) - 1, OLED_FONT_MEDIUM_WIDTH)    , BURSTFIRE_HOLD[0]    , burstfire_hold    );
			display_edit( 4 , center_x(sizeof(BURSTFIRE_RELEASE) - 1, OLED_FONT_MEDIUM_WIDTH) , BURSTFIRE_RELEASE[0] , burstfire_release );
			display_edit( 5 , center_x(sizeof(AIMASSIST_SIZE) - 1, OLED_FONT_MEDIUM_WIDTH)    , AIMASSIST_SIZE[0]    , aimassist_size    );
			display_edit( 6 , center_x(sizeof(AIMASSIST_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)    , AIMASSIST_TIME[0]    , aimassist_time    );
			display_edit( 7 , center_x(sizeof(STRAFESHOT_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)   , STRAFESHOT_TIME[0]   , strafeShot_time   );
			display_edit( 8 , center_x(sizeof(CUSTOMSENSE_TIME) - 1, OLED_FONT_MEDIUM_WIDTH)   , CUSTOMSENSE_TIME[0]   , customSense_time   );
		}
		else
		{
	    // Display Mod Name and ON/OFF
    		// Mods that can have different ON/OFF status depending the active Profile
    		
		  //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
			display_mod( 0 ,  center_x(sizeof(ANTIRECOIL) - 1, OLED_FONT_MEDIUM_WIDTH) , ANTIRECOIL[0] , 	toggle_antirecoil[profile_idx]);
			display_mod( 1 ,  center_x(sizeof(RAPIDFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)  , RAPIDFIRE[0]  , 	toggle_rapidfire[profile_idx]);
			display_mod( 2 ,  center_x(sizeof(BURSTFIRE) - 1, OLED_FONT_MEDIUM_WIDTH)  , BURSTFIRE[0]  , 	toggle_burstfire[profile_idx]);
			display_mod( 3 ,  center_x(sizeof(AIMASSIST) - 1, OLED_FONT_MEDIUM_WIDTH)  , AIMASSIST[0]  , 	toggle_aimassist[profile_idx]);
			display_mod( 4 ,  center_x(sizeof(STRAFE_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH), STRAFE_SHOT[0], 	toggle_strafeShot[profile_idx]);
			display_mod( 5 ,  center_x(sizeof(CUSTOM_SENSE) - 1, OLED_FONT_MEDIUM_WIDTH), CUSTOM_SENSE[0], 	toggle_customSense[profile_idx]);
			display_mod( 6 ,  center_x(sizeof(JUMP_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH), JUMP_SHOT[0], 		toggle_jumpShot[profile_idx]);
			display_mod( 7 ,  center_x(sizeof(CROUCH_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH), CROUCH_SHOT[0], 	toggle_crouchShot[profile_idx]);
			display_mod( 8 ,  center_x(sizeof(SWAP_SHOT) - 1, OLED_FONT_MEDIUM_WIDTH), SWAP_SHOT[0], 		toggle_swapShot[profile_idx]);
			display_mod( 9 ,  center_x(sizeof(AUTO_RELOAD) - 1, OLED_FONT_MEDIUM_WIDTH), AUTO_RELOAD[0], 	toggle_autoReload[profile_idx]);
			display_mod( 10 ,  center_x(sizeof(EASY_PING) - 1, OLED_FONT_MEDIUM_WIDTH), EASY_PING[0], 		toggle_easyPing[profile_idx]);
			display_mod( 11 ,  center_x(sizeof(EASY_SUPPORT) - 1, OLED_FONT_MEDIUM_WIDTH), EASY_SUPPORT[0], toggle_easySupport[profile_idx]);
			display_mod( 12 ,  center_x(sizeof(EASY_OFFENSE) - 1, OLED_FONT_MEDIUM_WIDTH), EASY_OFFENSE[0], toggle_easyOffense[profile_idx]);
			display_mod( 13 ,  center_x(sizeof(EASY_POTION) - 1, OLED_FONT_MEDIUM_WIDTH), EASY_POTION[0], 	toggle_easyPotion[profile_idx]);
			
			// Mods that have same ON/OFF status on every Profile
			display_mod( 14 ,  center_x(sizeof(SWAP) - 1, OLED_FONT_MEDIUM_WIDTH)    , SWAP[0]    , swap_on);
			display_mod( 15 ,  center_x(sizeof(INVERTED) - 1, OLED_FONT_MEDIUM_WIDTH), INVERTED[0], inverted_on);
		}
		
	// Display Profile only on mods that may have a different value depending on the Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE)  // idx from 0 to 4 are mods that can have different values depending the active Profile
		{
			if(profile_idx == 0) // profile_idx = profile_idx = Profile
    			//printf(center_x(sizeof(PROFILE_1) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_1[0]); // print Profile 1
    			line_oled(0, 26, 39, 26, 5, 1); // print a line to the left to say profile 1
    		else if(profile_idx == 1)
    			//printf(center_x(sizeof(PROFILE_2) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_2[0]); // print Profile 2
    			line_oled(44, 26, 83, 26, 5, 1); // print a line in the middle to say Profile 2
    		else if(profile_idx == 2)
    			//printf(center_x(sizeof(PROFILE_3) - 1, OLED_FONT_SMALL_WIDTH),23,OLED_FONT_SMALL,OLED_WHITE,PROFILE_3[0]); // print Profile 3
    			line_oled(88, 26, 127, 26, 5, 1); // print a line to the right to say Profile 3
		}
		else // Mods that work on every profiles print the 3 lines (disable this if you prefer display the text Profile X
    	{
    		line_oled(0, 26, 39, 26, 5, 1);
    		line_oled(44, 26, 83, 26, 5, 1);
    		line_oled(88, 26, 127, 26, 5, 1);
    	}
    	
		display_black = TRUE;
        display_new = FALSE;
        SCREENSAVER = FALSE;
    } // display_new end
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 // NOT KillSwitch end

if(display_black && !ModMenu && !KillSwitch)
    {
    	count_black += get_rtime();
    	if(count_black >= 5000)
    	{
    		cls_oled(0);
    		count_black = 0;
    		display_black = FALSE;
    		SCREENSAVER = TRUE;
    	
    	}
    }
    if (SCREENSAVER) { 
		DGT += get_rtime();
		if (DGT >= 100) {
			SD1 += 2;
			TP1 += 1;
			TP2 -= 1;
			DGT  = 0;
		}
				DGR += get_rtime();
				
				if (DGR >= 30) {
					Y_1 += 1;
					Y_2 += 2;
					Y_3 += 3;
					Y_4 += 4;
					Y_5 += 5;
					Y_6 += 6;
					Y_7 += 7;
					Y_8 += 8;
					DGR  = 0;
				}
						NAME();
						MSC += get_rtime();
						if(MSC >= 1000) {
							MSC = 0;
							RT += 1;
						}
							if(RT == 90) {
								SCREENSAVER = 0;
								RT = 0;
								cls_oled(0);		
							}
						}
	

} // main end
 
  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                     COMBO SECTION                                                     |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

combo RUMBLE_ON {						// 2 high rumbles + green blink 2 times
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						// 1 high rumble + red blink 1 time
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo SAVE { 
	cls_oled(0);						// clear OLED screen 
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	wait(10)
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times								
	wait(150);
	call(RUMBLE_ON);					// 2 high rumbles + green blink 2 times	
	wait(1000);
	display_new = TRUE;				   // display mods
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

//Swap Shot
combo S1 {
    wait(500);
    set_val(PS4_TRIANGLE, 100);
    wait(500);
    set_val(PS4_TRIANGLE, 0);
    wait(500);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
combo ANTIRECOIL {
// Vertical
    AntirecoilVertical = get_val(PS4_RY) + (VALUES[profile_idx][0] + antirecoil_vertical[profile_idx]);  
    if(AntirecoilVertical > 100) AntirecoilVertical = 100;
    if(abs(get_val(PS4_RY)) < abs(VALUES[profile_idx][0] + antirecoil_vertical[profile_idx]) + 5)
    set_val(PS4_RY, (AntirecoilVertical * invert));
// Horizontal
    AntirecoilHorizontal = get_val(PS4_RX) + (VALUES[profile_idx][1] + antirecoil_horizontal[profile_idx]);
    if(AntirecoilHorizontal > 100) AntirecoilHorizontal = 100;
    if(abs(get_val(PS4_RX)) < abs(VALUES[profile_idx][1] + antirecoil_horizontal[profile_idx]) + 5)
    set_val(PS4_RX, AntirecoilHorizontal);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(PS4_R2, 0);
    wait(rest_time);
    }

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo AIM_ASSIST { // AIM Assist
    set_val(PS4_RY,aa(PS4_RY, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RX,aa(PS4_RX, aimassist_size));
    set_val(PS4_LX,aa(PS4_LX, aimassist_size));
    wait(aimassist_time);
    set_val(PS4_RY,aa(PS4_RY,inv(aimassist_size))); 
    wait(aimassist_time);
    set_val(PS4_RX,aa(PS4_RX,inv(aimassist_size)));
    set_val(PS4_LX,aa(PS4_LX,inv(aimassist_size)));
    wait(aimassist_time);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo STRAFESHOT { // StrafeShot
    wait(300);
    set_val(PS4_LX, 100);
    wait(strafeShot_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafeShot_time);
    wait(50);
    }
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	
	//JumpShot
combo JUMPSHOT {
    wait(400);
    set_val(PS4_CROSS,100);
    wait(50);
    set_val(PS4_CROSS,0);
    wait(700);
    }
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
	//CrouchShot
combo CROUCHSHOT {
    wait(400);
    set_val(PS4_L3,100);
    wait(400);
    set_val(PS4_L3,0);
    wait(400);
    }
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
//AutoReload
combo AUTORELOAD {
    wait(200);
    set_val(PS4_SQUARE,100);
    wait(200);
    }
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

//Easy Support
combo EASYSUPPORT {
    wait(400);
    set_val(PS4_L1, 100);
    wait(100);
    set_val(PS4_L1, 0);
    wait(200);
	}
//Easy Offense
 
 combo EASYOFFENSE {
    wait(400);
    set_val(PS4_R1, 100);
    wait(100);
    set_val(PS4_R1, 0);
    wait(200);	
}

//Easy Potion
combo EASYPOTION {
	set_val(PS4_UP, 100);
	wait(2000);
	set_val(PS4_DOWN, 100);
	wait(2000);
	}
	
//Easy Ping
combo EASYPING {
	wait(1500)
	set_val(PS4_LEFT, 100);
	wait(3000);
	set_val(PS4_LEFT, 0);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	
	
combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
    }
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RACE {
	X_1 = random(0,127);
	wait(SAVER1);
	X_2 = random(0,127);
	wait(SAVER1);
	X_3 = random(0,127);
	wait(SAVER1);
	X_4 = random(0,127);
	wait(SAVER1); 
	X_5 = random(0,127);
	wait(SAVER1);
	X_6 = random(0,127);
	wait(SAVER1); 
	X_7 = random(0,127);
	wait(SAVER1); 
	X_8 = random(0,127);
	wait(SAVER1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RN {
	RN1 = random(65,90);
	RN2 = random(60,90);
	RN3 = random(65,90);
	RN4 = random(65,90); 
	RN5 = random(65,90);
	RN6 = random(65,90);
	RN7 = random(65,90);
	RN8 = random(65,90);
	wait(SAVER);
}
    

  /*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
  |                                                       FUNCTIONS                                                       |
  ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

function  NAME(){
		cls_oled(0);
		combo_run(RACE);
		combo_run(RN);
	if (Y_1 > 64)  
		Y_1 =  0;
	if (Y_2 > 64)  
		Y_2 =  0;
	if (Y_3 > 64)  
		Y_3 =  0;
	if (Y_4 > 64)  
		Y_4 =  0;
	if (Y_5 > 64)  
		Y_5 =  0;
	if (Y_6 > 64)  
		Y_6 =  0;
	if (Y_7 > 64)  
		Y_7 =  0;
	if (Y_8 > 64)  
		Y_8 =  0;
	if (SD1 > 105) 
		SD1 = -50;
	if (TP1 > 45)  
		TP1 =  0;
	if (TP2 < 0)   
		TP2 = 55;
		putc_oled(1,RN1);
		puts_oled(X_1,Y_1,0,1,1);
		putc_oled(1,RN2);
		puts_oled(X_2,Y_2,0,1,1);
		putc_oled(1,RN3);
		puts_oled(X_3,Y_3,0,1,1);
		putc_oled(1,RN4);
		puts_oled(X_4,Y_4,0,1,1);
		putc_oled(1,RN5);
		puts_oled(X_5,Y_5,0,1,1);
		putc_oled(1,RN6);
		puts_oled(X_6,Y_6,0,1,1);
		putc_oled(1,RN7);
		puts_oled(X_7,Y_7,0,1,1);
		putc_oled(1,RN8);
		puts_oled(X_8,Y_8,0,1,1);
		putc_oled(1,SSA1);
		puts_oled(SSMU1 + SD1,TP1 + 2,0,1,1);
		putc_oled(1,SSA2);
		puts_oled(SSMU2 + SD1,TP2 + 4,0,1,1);
		putc_oled(1,SSA3);
		puts_oled(SSMU3 + SD1,TP1 + 6,0,1,1);
		putc_oled(1,SSA4);
		puts_oled(SSMU4 + SD1,TP2 + 8,0,1,1);
		putc_oled(1,SSA5);
		puts_oled(SSMU5 + SD1,TP1 + 10,0,1,1);
		putc_oled(1,SSA6);
		puts_oled(SSMU6 + SD1,TP2 + 12,0,1,1);
		putc_oled(1,SSA7);
		puts_oled(SSMU7 + SD1,TP1 + 14,0,1,1);
		putc_oled(1,SSA8);
		puts_oled(SSMU8 + SD1,TP2 + 16,0,1,1);
	}	

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function vals_available(f_min, f_max) { // Define adjustable values available for each of the mods

	if(valName_idx < f_min)
		valName_idx = f_max;
	if(valName_idx > f_max)
		valName_idx = f_min;
		
// Match the # of value names index with the right column in VALUES array
	val_col_idx = valName_idx;	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
int RN1,RN2,RN3,RN4,RN5,RN6,RN7,RN8;
function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  // antirecoil_start[profile_idx] = edit_val( 0 , antirecoil_start[profile_idx], 99  , 99  )
					
	if(valName_idx == f_idx)
	{
    // +1 or -1															 // We can add function variable for increase/decrease to define if we increase/decrease by 1, 10, 100 ...
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); // inv(f_inc1)
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); // f_inc1
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); // inv(f_inc2)
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); // f_inc2

	// We can also add (f_ref)
	// Value for your features  // antirecoil_start_final = VALUES[profile_idx][val_col_idx] +  antirecoil_start[profile_idx] ;
        //f_ref = VALUES[profile_idx][val_col_idx] + f_val ;	
	}
	// Block Rate of Fire to 1 minimum (if 0 combo goes crazy lol)
	if(rate_of_fire[profile_idx] < 0)
		rate_of_fire[profile_idx] = 0;

	//return f_ref;

	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function speed_toggle(f_hold, f_press, f_val, f_string) {  // toggle_aimassist[profile_idx] = speed_toggle(PS4_R3, PS4_UP, toggle_aimassist[profile_idx], #cons_string for this toggle);
	
	if(get_val(f_hold))
	{
		if(get_val(f_press) && get_ptime(f_press) == 300) // Hold second button 300ms or more
		{
			modName_idx = f_string;
			
			if(f_val == 0)
			{
				if(f_string == 1) // If RapidFire is enable, 
					toggle_burstfire[profile_idx] = 0; // disable BurstFire
				else if(f_string == 2) // If BurstFire is enable, 
					toggle_rapidfire[profile_idx] = 0; // disable RapidFire
					
				f_val = 1;
				combo_run(RUMBLE_ON);
			}
			else
			{
				f_val = 0;
				combo_run(RUMBLE_OFF);
			}
			display_new = TRUE;
		} 
	set_val(f_press, 0)
	}
		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { // toggle_antirecoil[profile_idx] = toggle(1, PS4_UP, toggle_antirecoil[profile_idx]);
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == 1) // If RapidFire is enable, 
				toggle_burstfire[profile_idx] = 0; // disable BurstFire
			else if(f_idx == 2) // If BurstFire is enable, 
				toggle_rapidfire[profile_idx] = 0; // disable RapidFire
				
			f_val = 1;
			combo_run(RUMBLE_ON);
		}
		
		display_new = TRUE;
	}
			
	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			f_val = 0;
			combo_run(RUMBLE_OFF);
		}		
		display_new = TRUE;
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit(f_idx, f_string, f_print, f_val) { // display_edit(0, center_x(sizeof(ANTIRECOIL_START) - 1, MEDIUM) , ANTIRECOIL_START[0], antirecoil_start[profile_idx]);

    	if(valName_idx == f_idx)
    	{
		// Display value name and value
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
    	
    	// Display all editable values in VALUES array
    		if(f_idx <= LAST_EDITABLE_COLUMN) 
    			number_to_string(VALUES[profile_idx][val_col_idx] + f_val, find_digits(VALUES[profile_idx][val_col_idx] + f_val));
    	
    	// Display editable values that are not in the array (burstfire_hold for exemple)
    		else 
    			number_to_string(f_val, find_digits(f_val));
    	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
int RT,MSC,SD1,DGT,DGR,TP1,TP2;
function display_mod(f_idx, f_string, f_print, f_toggle) { // display_mod(1, center_x(sizeof(ANTIRECOIL) - 1, MEDIUM) , ANTIRECOIL[0], toggle_antirecoil[profile_idx]);
    	if(modName_idx == f_idx)
    	{
		// Display MOD_NAME
    		printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);
        	
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);
    	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
    // Values that are not in the array (aimassist_time for exemple)
		if(valName_idx > LAST_EDITABLE_COLUMN)
		{
    	// Substract    
        	if(f_val < inv(f_rng_min)) 
        		f_val = inv(f_rng_min); 
   		// Add   
       		if(f_val > f_rng_max) 
        		f_val = f_rng_max;
		}
		
    // Values that are in the array 
		else
		{
    // Substract    
        if((f_val + VALUES[profile_idx][val_col_idx]) < inv(f_rng_min)) 
        	f_val = inv(f_rng_min + VALUES[profile_idx][val_col_idx]); 
    // Add   
        if((f_val + VALUES[profile_idx][val_col_idx]) > f_rng_max) 
        	f_val = f_rng_max - VALUES[profile_idx][val_col_idx]; 
        }
        display_new = TRUE;
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function aa(f_axis,f_val) { // AIM Assist

    if(abs(get_val(f_axis)) < aimassist_size + 1) // + 1 is release
        return f_val;
        
    return get_val(f_axis); 
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function number_to_string(f_val,f_digits) {
/***********************************************************
 *  number_to_string(value to convert, # of digits in value)
 *
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767)
 *   
 *      Convert digits to ASCII
 *      Add ASCII character to print buffer
 *      Print string centered X & Y on OLED
 *  
***********************************************************/
    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }
        }
        c_val /= 10;
    }   
    puts_oled(center_x(i - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,i - 1,OLED_WHITE); // adjustable value centered in X
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function find_digits(f_num) {
//  find_digits(value)  
//	    return Number of Digits in Value Passed  

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {
//  center_x(number of chars,font size);  
//	    return X for Centering String Horizontally

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {
//  center_y(font size);  
//	    return Y for Centering String Vertically

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function press_hold(f_btn) { 
//  return TRUE - event_press()   
//			    - every 250ms when button is held

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {
   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

//Swap Shot Function

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
int X_1,Y_1,X_2,Y_2,X_3,Y_3, X_4,Y_4,X_5,Y_5,X_6,Y_6,X_7,Y_7,X_8,Y_8;
function save () {
	combo_run(SAVE);
	
// Profile 1
	// Toggles                                      // Values
	set_pvar(SPVAR_1,toggle_antirecoil[0]);         set_pvar(SPVAR_32 ,antirecoil_vertical[0]     );         
	set_pvar(SPVAR_2,toggle_rapidfire[0] );         set_pvar(SPVAR_33 ,antirecoil_horizontal[0]);
	set_pvar(SPVAR_3,toggle_burstfire[0] );         set_pvar(SPVAR_34,rate_of_fire[0]         );
	set_pvar(SPVAR_4,toggle_aimassist[0] );         
	set_pvar(SPVAR_5,toggle_strafeShot[0]);
	set_pvar(SPVAR_6,toggle_customSense[0]); 	
	set_pvar(SPVAR_7,toggle_jumpShot[0]);
	set_pvar(SPVAR_8,toggle_crouchShot[0]);
	set_pvar(SPVAR_9,toggle_swapShot[0]);
	set_pvar(SPVAR_10,toggle_autoReload[0]);
	set_pvar(SPVAR_11,toggle_easyPing[0]);
	set_pvar(SPVAR_12,toggle_easySupport[0]);
	set_pvar(SPVAR_13,toggle_easyOffense[0]);
	set_pvar(SPVAR_14,toggle_easyPotion[0]);
// Profile 2
	// Toggles                                       // Values
	set_pvar(SPVAR_18,toggle_antirecoil[1]);         set_pvar(SPVAR_35,antirecoil_vertical[1]     );       
	set_pvar(SPVAR_19,toggle_rapidfire[1] );         set_pvar(SPVAR_36,antirecoil_horizontal[1]);     
	set_pvar(SPVAR_20,toggle_burstfire[1] );         set_pvar(SPVAR_37,rate_of_fire[1]         );     
	set_pvar(SPVAR_21,toggle_aimassist[1] );         
	set_pvar(SPVAR_22,toggle_strafeShot[1]);
	set_pvar(SPVAR_23,toggle_customSense[1]);	
	set_pvar(SPVAR_24,toggle_jumpShot[1]);
	set_pvar(SPVAR_25,toggle_crouchShot[1]);
	set_pvar(SPVAR_26,toggle_swapShot[1]);
	set_pvar(SPVAR_27,toggle_autoReload[1]);
	set_pvar(SPVAR_28,toggle_easyPing[1]);
	set_pvar(SPVAR_29,toggle_easySupport[1]);
	set_pvar(SPVAR_30,toggle_easyOffense[1]);
	set_pvar(SPVAR_31,toggle_easyPotion[1]);
// Profile 3
	// Toggles                                       // Values
	set_pvar(SPVAR_38,toggle_antirecoil[2]);         set_pvar(SPVAR_52,antirecoil_vertical[2]     );       
	set_pvar(SPVAR_39,toggle_rapidfire[2] );         set_pvar(SPVAR_53,antirecoil_horizontal[2]);      
	set_pvar(SPVAR_40,toggle_burstfire[2] );         set_pvar(SPVAR_54,rate_of_fire[2]         );      
	set_pvar(SPVAR_41,toggle_aimassist[2] );         
	set_pvar(SPVAR_42,toggle_strafeShot[2]);
	set_pvar(SPVAR_43,toggle_customSense[2]); 	
	set_pvar(SPVAR_44,toggle_jumpShot[2]);
	set_pvar(SPVAR_45,toggle_crouchShot[2]);
	set_pvar(SPVAR_46,toggle_swapShot[2]);
	set_pvar(SPVAR_47,toggle_autoReload[2]);
	set_pvar(SPVAR_48,toggle_easyPing[2]);
	set_pvar(SPVAR_49,toggle_easySupport[2]);
	set_pvar(SPVAR_50,toggle_easyOffense[2]);
	set_pvar(SPVAR_51,toggle_easyPotion[2]);
// Misc
    // Toggles only									 // Values
    				 								 set_pvar(SPVAR_57, burstfire_hold    );
    set_pvar(SPVAR_55, swap_on     );				 set_pvar(SPVAR_58, burstfire_release );
    set_pvar(SPVAR_56, inverted_on );				 set_pvar(SPVAR_59, aimassist_size    );
    												 set_pvar(SPVAR_60, aimassist_time    );
    												 set_pvar(SPVAR_61, strafeShot_time   );
    												 set_pvar(SPVAR_62, customSense_time  );
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
/*
function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
//set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
//set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);
}   */
