/*———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Game: Every Shooter (FPS / TPS)
Version: 1.2
Device: CronusZEN ONLY
Controller tested: DS4 - Elite 2
Console tested: PS4 (XBOX and PC compatible)
Author: noozbar

———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Ce script possède la plupart des mods qui sont indispensables à la plupart des jeux de tir (FPS ou TPS).

Ce script n'est pas plug and play, l'utilisateur devra activer les mods qui l'intéressent, regler les valeurs et aussi définir quels sont les boutons JUMP et CROUCH dans le menu OLED.


Compatible avec les manettes PS4 et XBOX, ce script remplacera le bouton View de la manette XBOX par le bouton TOUCHPAD lorsque vous jouez sur PlayStation.

Pour capturer (bouton SHARE sur les manettes PS), appuyez sur RS + View.


Ce script est intelligent, il désactivera RapidFire si vous activez BurstFire sur le même profil (ou vice versa),

Il va désactiver Dynamic Sens si vous activez AIM Assist sur l'un des 3 profils ou désactiver AIM Assist sur tous les profils si vous activez Dynamic Sens (parce que ces mods ne sont pas compatibles).

Il affichera les boutons PS dans le menu OLED si votre contrôleur est un contrôleur PS, sinon il affichera les boutons XBOX.

Il vous permettra d'entrer dans Mod Edit seulement si le mod affiché est activé et s'il a une ou plusieurs valeurs ajustables.


La combinaison AntiRecoil + AIM Assist a été retravaillée pour une compatibilité maximale entre ces deux mods.

En bref, beaucoup de travail a été consacré à ce script et je pense avoir réussi à contrer la plupart des erreurs de manipulation possibles... Amusez-vous bien !

———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸	
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸											

Comment utiliser le ModMenu :

	Ouvrir le ModMenu (L2/LT + OPTIONS/MENU pour ouvrir ou fermer)
	
		Choisissez le profil que vous souhaitez modifier (primaire, secondaire ou SideArm). 
			- Appuyez sur TRIANGLE/Y 
			
		Naviguez entre les différents MODS avec GAUCHE ou DROITE (croix directionnel ou "D pad")
			- Tapez HAUT ou BAS pour activer ou désactiver un mod ou choisir de type du mod (exemple antirecoil: vous choisissez entre OFF, Progressive, Standard et On Rumble).
		
		Activez les mods que vous voulez sur chacun des profils...
		
	Si le mod affiché est activé et possède une ou plusieurs valeur(s) modifiable(s) : 
		- Tapez CROIX/A pour fermer le ModMenu et aller à ModEdit.
			
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

Comment utiliser le ModEdit : (lorsque vous êtes dans le ModMenu, tapez CROSS/A pour fermer le ModMenu et aller dans le ModEdit - si le mod affiché est activé et a une ou plusieurs valeurs modifiables)

		Naviguez entre les différents noms de valeurs avec GAUCHE ou DROITE.
		Modifier/éditer la valeur :
			- Maintenez CROIX/A et 
				- appuyez sur HAUT ou DROIT pour augmenter la valeur 
				- appuyez sur BAS ou GAUCHE pour diminuer la valeur
		
		Pour quitter ModEdit et revenir au ModMenu, tapez sur CERCLE/B.
		
		Maintenez la touche L2/LT enfoncée et appuyez sur PS/XBOX pour fermer le menu OLED.
	
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
				           
	Sauvegarder toutes les valeurs et quitter (seulement disponible si vous êtes dans ModMenu ou ModEdit)		
		- Tapez PS/XBOX pour sauvegarder TOUTES les valeurs, et TOUTE votre configuration de mods pour CHAQUE profil. 

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Activation rapide des mods (speed toggle) pour le profil actif 
		- Maintenez le bouton de visée et maintenez 300ms
			- HAUT   pour AntiRecoil 
			- BAS    pour AIM Assist
			- DROITE pour RapidFire
			- GAUCHE pour BurstFire
			
		- Maintenez le bouton de visée et
			- DOUBLE TAPEZ  HAUT   pour passer d'un type d'AntiRecoil à l'autre.
			- DOUBLE TAPEZ  BAS    pour passer d'une forme d'assistance AIM à l'autre.
			- DOUBLE TAPEZ  DROITE pour passer d'un type de tir rapide à l'autre

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	
	Changement de profil
		- Dans le jeu :
			- Tapez TRIANGLE/Y pour changer de profil 1 et 2 (primaire et secondaire).
			- Double tapez pour passer au profil 3 (arme de poing) (tapez à nouveau pour revenir au profil précédent).
		- Dans Mod Menu/Edit/Weapon
			- Tapez TRIANGLE/Y pour faire une boucle avec les profils 
			
	Resynchroniser les profils
		- Maintenez L3/LS et tapez sur TRIANGLE/Y

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Kill Switch (désactive le script)
		- Bascule ON vers OFF ou OFF vers ON
			- Maintenez le bouton de visée et tapez SHARE/VIEW 
			- Tapez PS/XBOX 
			
		- Bascule ON (désactive le script)
			- Tapez OPTIONS/MENU
			
		- Bascule OFF (le script est actif)
			- Double tapez CIRCLE/B
			- Maintenez CIRCLE/B au moins 600ms
		
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

														M O D S   D E S C R I P T I O N
														
AntiRecoil : permet de contrôler le recul d'une arme.

	Il y a 3 types d'AntiRecoil Vertical dans le script:
	- Progressif : le plus précis mais aussi le plus difficile à régler. Il est composé de 3 valeurs réglables :
		- AR Start qui est la valeur qui va vous permettre de contrer le kick de votre arme sur les 5 premières balles, sur la première rafale.
		- AR End qui est la valeur qui vous permet de stabiliser l'arme lorsque vous maintenez le bouton de tir pour vider votre chargeur sur l'ennemi.
		- AR Time qui est une valeur temporelle et qui définit la durée de la progression, le temps que ca va mettre pour augmenter ou diminuer progressivement votre AntiRecoil.

Par exemple, Start = 48, End = 25 et Time = 1000.
Lorsque vous tirez, votre AntiRecoil va compenser votre recul à 48 pour contrer le kick et ensuite il va commencer à descendre progressivement jusqu'à 25 et atteindra 25 en 1 seconde (1000ms)
C'est exactement ce que vous faites avec votre doigt sur le stick lorsque vous n'avez pas ZEN, vous tirez fortement en arrière pour contrer le kick 
et ensuite vous relâchez progressivement (en quelques secondes) la pression sur le stick pour stabiliser l'arme.

	- Standard : moins précis mais plus facile à régler. Il n'a qu'une seule valeur réglable :
		- AR Vertical qui est la valeur qui vous permet de stabiliser l'arme lorsque vous maintenez le bouton de tir pour vider votre chargeur sur l'ennemi.
	
	- On Rumble : assez précis sur certain jeux et très simple à régler, il se base sur les vibrations envoyées à la manette par le jeu. Il n'a qu'une seule valeur réglable :
		- Rumble Power qui est une valeur (coefficient) qui permet d'ajuster finement le recul de l'arme si la valeur par défaut est trop élevée ou trop faible.

Chacun de ces 3 types d'AntiRecoil Vertical possède également un AntiRecoil Horizontal qui est composée d'une seule valeur :
		- AR Horiz qui est une valeur qui vous permet de corriger le recul horizontal de votre arme, si elle va à gauche ou à droite lorsque vous tirez, compensez à l'opposé.


Chaque arme est différente et aura des valeurs d'AntiRecoil différentes.
AntiRecoil On Rumble est celui qui fonctionne le mieux pour la plupart des armes sans que vous ayez à modifier la valeur du mod.

Comment regler?
Vous devez augmenter la valeur si votre arme continue à monter vers le ciel, et diminuer la valeur si vous tirez dans vos pieds, jusqu'a ce que vous trouvier une valeur qui convient bien
Faites des tests sur une vrai cible si possible ou dans un stand de tir plutot que contre un mur

Si vous jouez avec le stick droit inversé, réglez votre AntiRecoil Vertical avec des valeurs négatives.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

RapidFire : transforme une arme coup par coup en arme automatique en spammant la gâchette à votre place lorsque vous la maintenez enfoncée.
	Il y a 3 types de RapidFire
	- Dynamic : aucun réglage à effectuer, plus vous appuyez sur la gâchette, plus ca tir vite
	- Rounds per min : n'a qu'une seule valeur réglable :
		- Rate Of Fire qui définit le nombre de cartouches tirées en une minute (RPM ou BPM de votre arme).
	- Rounds per sec : n'a qu'une seule valeur réglable :
		- Rate Of Fire qui définit le nombre de coups tirés en une seconde (RPS ou BPS de votre arme).

N'utilisez pas RapidFire avec une arme automatique, vous ralentiriez la cadence !

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

BurstFire : transforme une arme automatique en arme rafale en tirant en courtes rafales lorsque vous maintenez la gâchette enfoncée - vous permet d'avoir moins de recul et d'économiser des balles - Il a 2 valeurs ajustables
	- BF Hold qui est la durée pendant laquelle la gâchette est maintenue enfoncée.
	- BF Release qui est la durée pendant laquelle la gâchette est relâchée.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

AIM Assist dessine un petit cercle (ou une autre forme) avec le stick droit pour faciliter le maintien de votre viseur dans la bulle virtuelle autour de votre ennemi.
	Il existe 6 types différents d'AIM Assist
	- Sticky (non polaire)
	- Circular (dessine un cercle)
	- Tall Oval (dessine un Ovale verticale)
	- Wide Oval (dessine un Ovale horizontale)
	- Spiral
	- Helix
	
Ces différents types ont 2 valeurs ajustables :
	- Radius qui définit le rayon ou la taille de la forme dessinée.
	
Plus le rayon est grand, plus vous aurez la sensation d'écran qui tremble, mais plus l'assistance sera forte.
Plus il est petit, plus la sensation de tremblement disparaîtra, mais l'assistance sera moins forte.

	- Steps est la vitesse à laquelle les formes sont dessinées.
	
Avec Sticky, plus la valeur est élevée, plus la vitesse à laquelle se dessine les formes est lente.
Avec les autres formes (shapes), plus la valeur est élevée, plus la vitesse à laquelle se dessine les formes est rapide.
Une vitesse trop rapide peut créer des ralentissements dans les mouvements du personnage.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

AIM Abuse va spammer le bouton de visée pour essayer d'abuser de l'autosnap présent dans le jeu (fonctionne bien avec des jeux comme GTA).
	Nous avons 2 valeurs ajustables :
		- Hold Time qui est le temps pendant lequel le bouton de visée restera enfoncé.
		- Release Time qui est le temps pendant lequel le bouton sera relâché.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Shot Mod :
	Il existe 3 types de Shot Mod :
	- Strafe Shot vous permet de faire des pas de côté (de droite à gauche)
	- Jump Shot vous permet de sauter lorsque vous tirez (vous devez régler le bouton JUMP dans le menu).
	- Crouch Shot vous permet de vous accroupir ou de vous allonger lorsque vous tirez (vous devez définir le bouton CROUCH dans le menu).

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Shot Activator vous permet de définir quand et comment le Shot Mod que vous avez choisi va démarrer.
	Il y a 3 options possibles :
	- ADS + FIRE : le Shot Mod choisi démarrera lorsque vous appuierez sur les deux gâchettes.
	- ADS Only   : le Shot Mod choisi démarrera lorsque vous appuyez sur ADS et s'arrête lorsque vous appuyez sur FIRE.
	- FIRE Only  : le Shot Mod choisi démarrera lorsque vous appuyez sur FIRE et s'arrête lorsque vous appuyez sur ADS.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Sensibilité : permet de modifier la sensibilité de votre stick droit.
	Il y a 2 choix possibles :
	- Custom Sens vous permet de définir votre sensibilité dans 4 situations différentes (donc 4 valeurs ajustables).
		- General modifie votre sensibilité générale, quand vous vous déplacez, sans appuyer sur ADS ou FIRE.
		- ADS modifie votre sensibilité lorsque vous maintenez la touche ADS enfoncée.
		- FIRE modifie votre sensibilité lorsque vous maintenez la touche FIRE enfoncée.
		- ADS + FIRE modifie votre sensibilité lorsque vous maintenez ADS et FIRE en même temps.

	- Dynamic Sens vous permet de créer une courbe de sensibilité comme celles disponibles avec les manettes Elite - ce mod est assez compliqué à régler, voir l'exemple ci-dessous

	DYNASENS_INITIAL_SENS affiché sur l'écran OLED "DS Ini Sens" est votre sensibilité initiale X et Y (plage de valeurs 0 - 100)
		Par exemple, lorsque je vise, je veux que ma sensibilité, qui est fixée à 100% dans mon jeu, soit réduite de moitié tant que la position de mon stick ne dépasse pas la valeur de DYNASENS_LIMIT.
		Donc "DS Ini Sens" = 50 sur l'écran OLED

	DYNASENS_LIMIT affiché sur l'écran OLED "DS Limit" est la valeur limite du stick à partir duquel la sensibilité augmente progressivement(plage de valeurs de 0 à 100).
		Par exemple, lorsque la position du stick dépasse 65 (ma valeur DYNASENS_LIMIT), la sensibilité augmente progressivement et passe de 50 (ma valeur DYNASENS_INITIAL_SENS) à 100 (ma valeur DYNASENS_MAX_SENS).
		Le taux d'augmentation progressive de la sensibilité est défini par DYNASENS_INCREASE_RATE.

	DYNASENS_RESTART affiché sur l'écran OLED "DS Restart" est la valeur limite du stick à laquelle la sensibilité sera réinitialisée à DYNASENS_INITIAL_SENS (plage de valeurs 0 - 100)
		Lorsque la position du stick descend en dessous de 30 (ma valeur DYNASENS_RESTART), la sensibilité du stick revient à 50 (ma valeur DYNASENS_INITIAL_SENS).

	DYNASENS_MAX_SENS affiché sur l'écran OLED "DS Max Sens" est la valeur de sensibilité maximale que vous souhaitez.
		100 signifie que la sensibilité maximale de "DynaSens" sera celle que vous avez définie dans votre jeu.

	DYNASENS_INCREASE_RATE affiché sur l'écran OLED "DS Inc Rate" taux d'augmentation de la sensibilité
		1 = 10ms de délai entre les augmentations

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Hair Trigger vous permet d'augmenter la sensibilité de votre gâchette pour une réactivité inégalée.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- AutoRun vous permet de courir automatiquement lorsque vous poussez le stick vers l'avant (ou sur les côtés).
	Le mod maintient L3 (ou LS sur XBOX) lorsque vous poussez le stick gauche à plus de 90% - si votre jeu à l'option "maintenez pour courir" activez la

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Auto ADS permet d'appuyer sur ADS lorsque vous appuyez sur FIRE.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Auto FIRE permet d'appuyer sur FIRE lorsque vous appuyez sur ADS

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Jump BTN fait correspondre votre bouton pour sauter dans le jeu au bouton JUMP dans le menu OLED pour le mod Jump Shot.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Crouch BTN fait correspondre votre bouton pour s'accroupir dans le jeu au bouton CROUCH dans le menu OLED pour le mod Crouch Shot

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Trigger/Bumper vous permet d'inverser les boutons et les gâchettes
	Si vous jouez avec les gâchettes inversées dans les options du jeu, alors activez ce mod.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Rumble FeedBack permet de bloquer les vibrations de la manette si vous n'aimez pas jouer avec des vibrations.
	Laissez les vibrations activées dans les options du jeu car l'AntiRecoil On Rumble a besoin que les vibrations soient activées dans le jeu.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

															THANK YOU FOR READING
															THANK YOU FOR READING
															THANK YOU FOR READING
											
											
◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺
———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*/

// Text to display 
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE = "SAVED";
	const string ALL = "Every Profiles";
	const string MUTE = "Script OFF";
	const string HOLD = "Dbl-Tap CIRCLE/B";
	const string ACTIVE = "to turn ON"
	const string ANTIRECOIL_VERTICAL = "AR Vertical";
	
	const string PROFILE[] = {
	"Primary", "Secondary", "SideArm" };
	
	const string ANTIRECOIL[] = {
	"OFF", "Progressive", "Standard", "On Rumble" };
	
	const string RAPIDFIRE[] = {
	"OFF", "Dynamic", "Rounds per min", "Rounds per sec" };
	
	const string SHAPES[] = {
	"OFF", "Sticky", "Circular", "Tall Oval", "Wide Oval", "Spiral", "Helix" };
	
	const string SHOT_MOD[] = {
	"OFF", "Strafe Shot", "Jump Shot", "Crouch Shot" };
	
	const string SHOT_ACTIVATOR[] = {
	"ADS + FIRE", "ADS Only", "FIRE Only" };
	
	const string SENSITIVITY[] = {
	"OFF", "Custom Sens", "Dynamic Sens" };
	
	const string SWAP[] = {
	"Standard", "Swapped"};
	
	const string PS_BTN[] = {
	"CROSS", "CIRCLE", "R3", "L1" };
	
	const string XB_BTN[] = {
	"A", "B", "RS", "LB" };
	
	const uint8 BTN[] = {
	PS4_CROSS, PS4_CIRCLE, PS4_R3, PS4_L1 };
	
	const string INFO_MENU_PS[] = {
	"Switch Profile:", "tap TRIANGLE", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", 
	"Edit Menu:", "tap CROSS", "Close ModMenu:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_EDIT_PS[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold CROSS +", "UP DOWN LEFT RIGHT", 
	"Toggle Menu:", "tap CIRCLE", "Close ModMenu:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_MENU_XB[] = {
	"Switch Profile:", "tap Y", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", 
	"Edit Menu:", "tap A", "Close ModMenu:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 
	
	const string INFO_EDIT_XB[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold A +", "UP DOWN LEFT RIGHT", 
	"Toggle Menu:", "tap B", "Close ModMenu:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

//                          M O D S   N A M E   A N D   T O G G L E S

// Mod Name
	const string MODNAME[] = {
			"AntiRecoil"    , "RapidFire"   , "BurstFire"     , "AIM Assist"    , "AIM Abuse" ,  "Shot Mod"  , 
// modName_idx = 0          |      1        |      2          |       3         |      4      |        5
			"Shot Acrivator","Sensitivity"  , "Hair Trigger"  , "AutoRun"       , "Auto ADS"  , "Auto FIRE"  ,  
// modName_idx = 6          |      7        |      8          |       9         |      10     |      11
			 "Jump BTN"     , "Crouch BTN"  , "Trigger/Bumper", "RumbleFeedBack"
// modName_idx = 12         |     13        |       14        |      15         |    
	};

// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;
	
	define 	ANTIRECOIL_M = 0, RAPIDFIRE_M = 1, BURSTFIRE_M = 2, AIMASSIST_M = 3, AIMABUSE_M = 4, SHOTMOD_M = 5, SHOTACTIVATOR_M = 6,
			SENSITIVITY_M = 7, HAIRTRIGGER_M = 8, AUTORUN_M = 9, AUTOADS = 10, AUTOFIRE = 11, 
			JUMPBTN_M = 12, CROUCH_BTN = 13, TRIGGERBUMPER_M = 14, RUMBLEFEEDBACK_M = 15;
			
// Toggles for [3] Profiles: [profile_idx] = 0, 1 and 2
	int toggle_antirecoil[3];  
	int toggle_rapidfire[3];  
	int toggle_burstfire[3];
	int toggle_aimassist[3];
	int toggle_aimabuse[3];
	int toggle_shotMod[3]; 
	int toggle_shotActivator[3];
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 7;

// Toggles
	int sensitivity_on;
	int hairTrigger_on;
	int autorun_on;
	int autoADS_on;
	int autoFIRE_on;
	int jump_btn;
	int crouch_btn;
	int swap_on;
	int rumble_on;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	const string VALNAME [] = {
			"AR Start"   , "AR End"   , "AR Time"   , "AR Horiz"   , "Rumble Power", "Rate of Fire" , 
// valName_idx = 0       |      1     |      2      |       3      |       4       |       5
 			"BF Hold"    ,"BF Release", "Radius"    , "Steps"      ,  "Hold Time"  , "Release Time" , "Strafe Time",
// valName_idx = 6       |      7     |      8      |       9      |       10      |     11         |       12
 			"DS Ini Sens", "DS Limit" , "DS Restart", "DS Max Sens", "DS Inc Rate" , "General"      , "ADS" , "FIRE" , "ADS + FIRE" 
// valName_idx = 13      |     14     |      15     |      16      |      17       |       18       |   19  |   20   |      21      |    
	};

// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
// Adjustable values for [3] profiles: [profile_idx] = 0, 1 and 2 
	int antirecoil_start[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the array to find your final value
	int antirecoil_end[3];
	int antirecoil_time[3];
	int antirecoil_horizontal[3];
	int rate_of_fire[3];
	int rumble_power[3];
	
// Adjustable values
  // BurstFire values
	int burstfire_hold; // BurstFire have toggle for each profiles BUT the same values for each
	int burstfire_release;
  // AIM Assist values
	int aimassist_radius; // AIM Assist have toggle for each profiles BUT the same values for each
	int aimassist_angle;
// AIM Abuse values
	int aimabuse_hold;
	int aimabuse_release;
	// Strafe Shot value
	int strafe_time; // StrafeShot have toggle for each profiles BUT the same value for each
  // Custom Sens values
	int genSens;
	int adsSens;
	int hipSens;
	int adsfireSens;
	int customsens;
  // Dynamic Sens values
	int dynasens_initial_sens;    // initial RX/RY sentitivity
	int dynasens_limit;           // stick input point where RX/RY sens increases
	int dynasens_restart;         // stick input point where RX/RY sens will reset back to initial value dynasens_initial_sens
	int dynasens_max_sens;        // maximum sensitivity value 
	int dynasens_increase_rate;   // rate sensitivity increased (8 = 80ms delay between increase)
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

	const int16 ANTIRECOIL_VAL[][] = { 
//               ar start, ar end, ar time, ar horiz
/* Primary   */ {  50    ,   30  ,   1000  ,    0   }, 
/* Secondary */	{  35    ,   25  ,   1000  ,    0   },
/* SideArm   */	{  40    ,   20  ,   1000  ,    0   }
	};

// Adjustable value + array value = final value
	int final_antirecoil_start;
	int final_antirecoil_end;
	int final_antirecoil_time;
	int final_antirecoil_horizontal;
	int final_rate_of_fire;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for functions 
	int i;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_info;
	int display_black;
	int screensaver;

// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil  
	//int rumble;
	int rumble_recoil;
	int antirecoil_boost;
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter
	int count_black; 
	int info_timer;
	
// Profiles
	int switch_ref;
	int profile_idx; // Used to define Profiles and also define # of profile to find, edit, and display the right index
 	
//Misc
	int ads_btn;
	int fire_btn;
	int currentSlot;
	int current_info;
	int logo_on; // check if logo is displayed or not to refresh display
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

init{
					// Load default/stored values
// Toggles
	pmemValue = get_pvar(SPVAR_1, 1, 32767, 0);
	toggle_burstfire[0]    = get_15var(pmemValue, 0);	toggle_burstfire[1]  = get_15var(pmemValue,  1);	toggle_burstfire[2]  = get_15var(pmemValue,  2);
	hairTrigger_on         = get_15var(pmemValue, 3);	autorun_on           = get_15var(pmemValue,  4);	autoADS_on           = get_15var(pmemValue,  5);
	autoFIRE_on            = get_15var(pmemValue, 6);	swap_on              = get_15var(pmemValue,  7);	rumble_on            = get_15var(pmemValue,  8);	
	toggle_aimabuse[0]     = get_15var(pmemValue, 9);	toggle_aimabuse[1]   = get_15var(pmemValue, 10);	toggle_aimabuse[2]   = get_15var(pmemValue, 11);
	
	
	pmemValue = get_pvar(SPVAR_2, -32768, 32767, 0);
	toggle_antirecoil[0] = get_4var(pmemValue, 3);		toggle_antirecoil[1] = get_4var(pmemValue, 2);		toggle_antirecoil[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_3, -32768, 32767, 0);
	toggle_rapidfire[0] = get_4var(pmemValue, 3);		toggle_rapidfire[1] = get_4var(pmemValue, 2);		toggle_rapidfire[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_4, -32768, 32767, 0);
	toggle_aimassist[0] = get_4var(pmemValue, 3);		toggle_aimassist[1] = get_4var(pmemValue, 2);		toggle_aimassist[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_5, -32768, 32767, 0);
	toggle_shotMod[0] = get_4var(pmemValue, 3);		toggle_shotMod[1] = get_4var(pmemValue, 2);		toggle_shotMod[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_6, -32768, 32767, 0);
	toggle_shotActivator[0] = get_4var(pmemValue, 3);		toggle_shotActivator[1] = get_4var(pmemValue, 2);		toggle_shotActivator[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_7, -32768, 32767, 0);
	sensitivity_on = get_4var(pmemValue, 3);		jump_btn = get_4var(pmemValue, 2);		crouch_btn = get_4var(pmemValue, 1);
	
// Antirecoil vertical values
	pmemValue = get_pvar(SPVAR_8, -32768, 32767, 0);
	antirecoil_start[0] = get_2var(pmemValue, 0);		antirecoil_end[0] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_9, -32768, 32767, 0);
	antirecoil_start[1] = get_2var(pmemValue, 0);		antirecoil_end[1] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_10, -32768, 32767, 0);
	antirecoil_start[2] = get_2var(pmemValue, 0);		antirecoil_end[2] = get_2var(pmemValue, 1);
	
	antirecoil_time[0] = get_pvar(SPVAR_11, -32768, 32767, 0);
	antirecoil_time[1] = get_pvar(SPVAR_12, -32768, 32767, 0);
	antirecoil_time[2] = get_pvar(SPVAR_13, -32768, 32767, 0);
	
// Antirecoil horizontal & rumble recoil values
	pmemValue = get_pvar(SPVAR_14, -32768, 32767, 0);
	antirecoil_horizontal[0] = get_2var(pmemValue, 0);		rumble_power[0] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_15, -32768, 32767, 0);
	antirecoil_horizontal[1] = get_2var(pmemValue, 0);		rumble_power[1] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_16, -32768, 32767, 0);
	antirecoil_horizontal[2] = get_2var(pmemValue, 0);		rumble_power[2] = get_2var(pmemValue, 1);
	
// Rate of fire values
	rate_of_fire[0] = get_pvar(SPVAR_17, -32768, 32767, 0);
	rate_of_fire[1] = get_pvar(SPVAR_18, -32768, 32767, 0);
	rate_of_fire[2] = get_pvar(SPVAR_19, -32768, 32767, 0);
	
// BurstFire values
	burstfire_hold     = get_pvar(SPVAR_20, 1,  1000, 120);
	burstfire_release  = get_pvar(SPVAR_21, 1,  1000, 120);
	
// AIM Assist values
	pmemValue = get_pvar(SPVAR_22, 1, 32767, set_2var(20, 15));
	aimassist_radius = get_2var(pmemValue, 0);		aimassist_angle = get_2var(pmemValue, 1);
	
// StrafeShot value
	strafe_time = get_pvar(SPVAR_23, 1, 10000, 500);
	
// Custom Sens values
	genSens     = get_pvar(SPVAR_24, 1, 327, 100);
	adsSens     = get_pvar(SPVAR_25, 1, 327, 100);
	hipSens     = get_pvar(SPVAR_26, 1, 327, 100);
	adsfireSens = get_pvar(SPVAR_27, 1, 327, 100);
	
// Dynamic Sens values
	dynasens_initial_sens = get_pvar(SPVAR_28, 1, 327, 60 );
	
	pmemValue = get_pvar(SPVAR_29, 1, 32767, set_2var(80, 30));
	dynasens_limit   = get_2var(pmemValue, 0);		dynasens_restart = get_2var(pmemValue, 1);
	
	dynasens_max_sens      = get_pvar(SPVAR_30, 1, 327, 100);
	dynasens_increase_rate = get_pvar(SPVAR_31, 1, 50 , 1  );
	
// AIM Abuse values
	aimabuse_hold     = get_pvar(SPVAR_32, 1, 500, 100);
	aimabuse_release  = get_pvar(SPVAR_33, 1, 500,  50);
	
// Get current slot
	currentSlot = get_slot();
}

main { // main section start
/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                         DEBUG                                                         |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

	set_val(TRACE_1, profile_idx);
	set_val(TRACE_2, modName_idx);
	set_val(TRACE_2, valName_idx);

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                       CROSSOVER                                                       |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
    if(get_controller() != PIO_PS4) // If not PS4 controller:
    {
    	// If PS4 console:
        if(get_console() == PIO_PS4)
        { 
        	if(get_ival(PS4_SHARE))
        	{
        		if(get_ival(PS4_R3)) // RS + View =  ScreenShot
        		{
					set_val(PS4_SHARE,100);
                	set_val(PS4_TOUCH,0);
                	set_val(PS4_R3,0);
        		}
        		else // View only = PS4_TOUCH
        		{
        			set_val(PS4_TOUCH, 100);
        			set_val(PS4_SHARE, 0);
        		}
        	}
        }
	}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                   TOGGLE KILLSWITCH                                                   |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
	if(!ModMenu && !ModEdit)
	{
	// KillSwitch ON or OFF method
		if( (get_ival(PS4_L2) && event_press(PS4_SHARE)) || (!get_ival(PS4_L2) && event_press(PS4_PS)) )
		{			
			KillSwitch = !KillSwitch;
			
			if(KillSwitch) 
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				
			else
			{
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_title = TRUE;	// display Title screen, profile, Weapon Name, active slot and killswitch
			}
		}

	// KillSwitch - activation method (TRUE, script is muted)
		if(!KillSwitch)
		{
			combo_stop(KILLSWITCH);
			
			if(!get_ival(PS4_L2) && event_press(PS4_OPTIONS))
			{
				KillSwitch = TRUE;
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			}
		}
		
	// KillSwitch - exit method (FALSE, script is actived)
		if(KillSwitch) 
		{
    		screensaver= FALSE;
			count_black = 0;
			logo_on = FALSE;
	
			if( (get_ival(PS4_CIRCLE) && get_ptime(PS4_CIRCLE) > 600) || (event_press(PS4_CIRCLE) && get_brtime(PS4_CIRCLE) < 200) ) // Hold CIRCLE/B 600ms or double tap to exit
			{
				KillSwitch = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE; 
			}
			
			combo_run(KILLSWITCH);
		}
	// Block button	
		if(get_ival(PS4_L2))
		{
			if(get_controller() != PIO_PS4) 
				set_val(PS4_TOUCH, 0);
			else
				set_val(PS4_SHARE, 0);
		}
	}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                        IF KILLSWITCH IS OFF (SCRIPT IS ACTIVE)                                        |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(!KillSwitch)
	{
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                     TOGGLE MOD MENU                                   |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(get_ival(PS4_L2))
		{	
			if(event_release(PS4_OPTIONS))
			{
				cls_oled(OLED_BLACK);
    			logo_on = FALSE;
    			
				if(ModEdit)
				{
					ModEdit = FALSE;
					display_title = TRUE;   
				}
				else 
					ModMenu = !ModMenu;
				
				if(!ModMenu)
				{
					combo_run(RUMBLE_OFF); 
					display_title = TRUE;  
				}
				if(ModMenu)
				{
					modName_idx = ANTIRECOIL_M;        
					current_info = 0;		
					combo_run(RUMBLE_ON);	
					draw_base_menu();		
					draw_modMenu();		
					draw_chars_line1();		
					draw_chars_line2(); 
					draw_chars_line3();		
					display_new = TRUE;
					display_info = TRUE;
				}
			}
		// Block button	   
			set_val(PS4_OPTIONS, 0);
		} // L2/LT section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                   MOD MENU IS ACTIVE                                  |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(ModMenu) 
		{
		// Buttons animation
			button_animation(); 
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                           TOGGLE FOR MODS                             |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		// From ModMenu to ModEdit
			if(check_toggle()) 	 
			{
				if(event_release(PS4_CROSS))
				{
					if(toggle_antirecoil[profile_idx] == 3)
						valName_idx = 4; // Display rumble power first
					else
						valName_idx = entry_count(VALNAME_TXT) + 1; // always display first val names available when enter in edition mod
						
					if(modName_idx == RAPIDFIRE_M) // RapidFire defaut values
					{
						if(toggle_rapidfire[profile_idx] == 2 && rate_of_fire[profile_idx] < 60)
							rate_of_fire[profile_idx] = 240;
						if(toggle_rapidfire[profile_idx] == 3 && rate_of_fire[profile_idx] > 25)
							rate_of_fire[profile_idx] = 4;
					}
					
					current_info = 0;		
					ModEdit = TRUE;
					ModMenu = FALSE;
					draw_modEdit();			
					draw_chars_line1();		
					draw_chars_line2();		
					draw_hold_to_edit();
					draw_chars_line3();	
					display_new = TRUE;
					display_info = TRUE;
				}
			}
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                  MOD NAME NAVIGATION                  |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx = cycle(modName_idx + 1, 0, entry_count(MODNAME_TXT)); // create a loop in the values
				display_new = TRUE; 
			}
			
			if(event_press(PS4_LEFT))
			{
				modName_idx = cycle(modName_idx - 1, 0, entry_count(MODNAME_TXT));  // create a loop in the values
				display_new = TRUE; 
			}
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                    TOGGLE FOR MODS                    |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Tap UP or DOWN to turn ON/OFF
	   		// Mods that may have different ON/OFF status depending on the active Profile
			toggle_antirecoil[profile_idx]    = toggle( ANTIRECOIL_M   , toggle_antirecoil[profile_idx]    );
			toggle_rapidfire[profile_idx]     = toggle( RAPIDFIRE_M    , toggle_rapidfire[profile_idx]     );
			toggle_burstfire[profile_idx]     = toggle( BURSTFIRE_M    , toggle_burstfire[profile_idx]     );
			toggle_aimassist[profile_idx]     = toggle( AIMASSIST_M    , toggle_aimassist[profile_idx]     );
			toggle_aimabuse[profile_idx]      = toggle( AIMABUSE_M     , toggle_aimabuse[profile_idx]      );
			toggle_shotMod[profile_idx]       = toggle( SHOTMOD_M      , toggle_shotMod[profile_idx]       );
			toggle_shotActivator[profile_idx] = toggle( SHOTACTIVATOR_M, toggle_shotActivator[profile_idx] );
		
		// Mods that have same ON/OFF status on every Profiles
			sensitivity_on = toggle( SENSITIVITY_M   , sensitivity_on );
			hairTrigger_on = toggle( HAIRTRIGGER_M   , hairTrigger_on );
			autorun_on     = toggle( AUTORUN_M       , autorun_on     );
			autoADS_on     = toggle( AUTOADS         , autoADS_on     );
			autoFIRE_on    = toggle( AUTOFIRE        , autoFIRE_on    );
			jump_btn       = toggle( JUMPBTN_M       , jump_btn       );
			crouch_btn     = toggle( CROUCH_BTN      , crouch_btn     );
			swap_on        = toggle( TRIGGERBUMPER_M , swap_on        );
			rumble_on      = toggle( RUMBLEFEEDBACK_M, rumble_on      );
		} // ModMenu section end
	
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                   MOD EDIT IS ACTIVE                                  |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/	
		if(ModEdit) 
		{
		// Buttons animation
			button_animation(); // define if the rectangle behind the arrow must be clear or fill, and define if the arrow must be black or white
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                EDIT ADJUSTABLE VALUES                 |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Edit value: hold CROSS/A + UP (+1 or +10) or DOWN (-1 or -10) or RIGHT (+10 or +100) or LEFT (-10 or -100)	
			if(get_ival(PS4_CROSS)) 
			{
			// Mods that may have different values depending on the active Profile
				antirecoil_start[profile_idx]      = edit_val( 0 , antirecoil_start[profile_idx]     , -99 ,    99 ,   1 , 10   ); 
				antirecoil_end[profile_idx]        = edit_val( 1 , antirecoil_end[profile_idx]       , -99 ,    99 ,   1 , 10   ); 
				antirecoil_time[profile_idx]       = edit_val( 2 , antirecoil_time[profile_idx]      ,  0  , 10000 , 100 , 1000 );  
				antirecoil_horizontal[profile_idx] = edit_val( 3 , antirecoil_horizontal[profile_idx], -99 ,    99 ,   1 , 10   ); 
				rumble_power[profile_idx]          = edit_val( 4 , rumble_power[profile_idx]         , -60 ,    60 ,   1 , 10   );
				if(toggle_rapidfire[profile_idx] == 2)
					rate_of_fire[profile_idx]      = edit_val( 5 , rate_of_fire[profile_idx]         ,  60 ,   750 ,   1 , 10   );
				else if(toggle_rapidfire[profile_idx] == 3)
					rate_of_fire[profile_idx]      = edit_val( 5 , rate_of_fire[profile_idx]         ,  1  ,    25 ,   1 , 10   );
				
			// Mods that have same value on every Profiles
				burstfire_hold         = edit_val( 6 , burstfire_hold         , 0 ,  1000 , 10 , 100 );
				burstfire_release      = edit_val( 7 , burstfire_release      , 0 ,  1000 , 10 , 100 );
				aimassist_radius       = edit_val( 8 , aimassist_radius       , 0 ,    50 , 1  , 10  );
				aimassist_angle        = edit_val( 9 , aimassist_angle        , 0 ,    50 , 1  , 10  ); 
				aimabuse_hold          = edit_val( 10, aimabuse_hold          , 0 ,   500 , 10 , 100 );
				aimabuse_release       = edit_val( 11, aimabuse_release       , 0 ,   500 , 10 , 100 ); 
				strafe_time            = edit_val( 12, strafe_time            , 0 , 10000 , 10 , 100 );
				dynasens_initial_sens  = edit_val( 13, dynasens_initial_sens  , 0 ,   327 , 1  , 10  );
				dynasens_limit         = edit_val( 14, dynasens_limit         , 0 ,   100 , 1  , 10  );
				dynasens_restart       = edit_val( 15, dynasens_restart       , 0 ,   100 , 1  , 10  );
				dynasens_max_sens      = edit_val( 16, dynasens_max_sens      , 0 ,   327 , 1  , 10  );
				dynasens_increase_rate = edit_val( 17, dynasens_increase_rate , 1 ,    50 , 1  , 10  );
				genSens                = edit_val( 18, genSens                , 1 ,   327 , 1  , 10  );
				adsSens                = edit_val( 19, adsSens                , 1 ,   327 , 1  , 10  );
				hipSens                = edit_val( 20, hipSens                , 1 ,   327 , 1  , 10  );
				adsfireSens            = edit_val( 21, adsfireSens            , 1 ,   327 , 1  , 10  );
			} // CROSS/A section end
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|  FIND AVAILABLE VALUES AND NAVIGATION BETWEEN VALUES  |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
			else // if NOT EDIT_BTN
			{	
			// From ModEdit to ModMenu	
				if(event_press(PS4_CIRCLE))
				{
					current_info = 0;	
					ModMenu = TRUE;
					ModEdit = FALSE;
					draw_modMenu();		
					draw_chars_line1();	
					draw_chars_line2();	
					draw_chars_line3();
					display_new = TRUE;
					display_info = TRUE;
				}
				
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
				// Limits for Standard Anti-Recoil	
					if(modName_idx == ANTIRECOIL_M && toggle_antirecoil[profile_idx] == 2)
					{								
						if(valName_idx == 2)
							valName_idx = 3;
						if(valName_idx > 3)
							valName_idx = 1;
					}
					display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
				// Limits for Standard Anti-Recoil 
					if(modName_idx == ANTIRECOIL_M && toggle_antirecoil[profile_idx] == 2)
					{	
						if(valName_idx == 2)
							valName_idx = 1;
						if(valName_idx < 1)
							valName_idx = 3;
					}
					display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
				}
					
			// Available values for each of the mods 
				if(modName_idx == ANTIRECOIL_M) // AntiRecoil
				{
					if(toggle_antirecoil[profile_idx] == 3)
						valName_idx = cycle(valName_idx, 3, 4 );   // Rumble AR
					else if(toggle_antirecoil[profile_idx] == 2)
						valName_idx = cycle(valName_idx, 1 , 3  ); // AntiRecoil Standard
					else
						valName_idx = cycle(valName_idx, 0 , 3  ); // AntiRecoil Progressive
				}
				
				if(modName_idx == RAPIDFIRE_M) valName_idx = cycle(valName_idx, 5 , 5  );// RapidFire
				if(modName_idx == BURSTFIRE_M) valName_idx = cycle(valName_idx, 6 , 7  );// BurstFire
				if(modName_idx == AIMASSIST_M) valName_idx = cycle(valName_idx, 8 , 9  );// AIM Assist
				if(modName_idx == AIMABUSE_M ) valName_idx = cycle(valName_idx, 10, 11 );// AIM Abuse
				if(modName_idx == SHOTMOD_M  ) valName_idx = cycle(valName_idx, 12, 12 );// StrafeShot
				
				if(modName_idx == SENSITIVITY_M) // Sensitivity
				{
					if(sensitivity_on == 1)
						valName_idx = cycle(valName_idx, 18, 21 );// Custom Sens
					else if(sensitivity_on == 2)
						valName_idx = cycle(valName_idx, 13, 17 );// DynaSens
				}
			} // NOT EDIT_BTN section end
		} // ModEdit section end	

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                             MOD MENU OR MOD EDIT IS ACTIVE                            |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(ModMenu || ModEdit) 
		{
		//Stop screen Saver
    		screensaver = FALSE;
			count_black = 0;
			
		// Timer to display user infos
			info_timer += get_rtime();
	
			if(info_timer > 2000)
			{
				current_info ++;
				display_info = TRUE;
			}
			
		// Save everything and EXIT
			if(!get_ival(PS4_L2) && event_release(PS4_PS))
				save();
				
		// block ALL inputs 
			block_btn(); // user function
			
		// Switch Profiles (not in ModEdit)
			if(event_release(PS4_TRIANGLE) && !ModEdit)
			{	
				profile_idx = cycle(profile_idx + 1, 0, entry_count(PROFILE_TXT));
				display_new = TRUE; 
			}
		}

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                      FIND FINAL ANTIRECOIL AND RAPIDFIRE VALUES                       |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
	
	// Find final values in relation to Weapon Category and Weapon Name arrays		
		final_antirecoil_start       = ANTIRECOIL_VAL[profile_idx][0] + antirecoil_start[profile_idx];
		final_antirecoil_end         = ANTIRECOIL_VAL[profile_idx][1] + antirecoil_end[profile_idx];
		final_antirecoil_time        = ANTIRECOIL_VAL[profile_idx][2] + antirecoil_time[profile_idx];
		final_antirecoil_horizontal  = ANTIRECOIL_VAL[profile_idx][3] + antirecoil_horizontal[profile_idx];
		final_rate_of_fire           = rate_of_fire[profile_idx];
				
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                             FEATURES ACTIVE IN GAME ONLY                              |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(!ModMenu && !ModEdit)
		{
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                               FEATURES                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		// Swap triggers and bumpers 
			if(swap_on) 
			{
				ads_btn = PS4_L1;
				fire_btn = PS4_R1;
			}
			else
			{
				ads_btn = PS4_L2;
				fire_btn = PS4_R2;
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
		
		// Hair Trigger
			if(hairTrigger_on)
	   	 		deadzone(PS4_L2,PS4_R2,99,99);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	
		// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold L3/LS + tap TRIANGLE/Y for sync color
			if( (!get_val(PS4_DOWN) || get_val(PS4_L3)) && event_press(PS4_TRIANGLE) )
			{
				if(get_brtime(PS4_TRIANGLE) < 250) 
					profile_idx = 2;
				else
				{
				    if(switch_ref != 2) 
						switch_ref = !switch_ref;  
				                	
					profile_idx = switch_ref;
				}	
				
				display_title = TRUE;
		   	}
		    	
			if(get_lval(PS4_L3))
				set_val(PS4_TRIANGLE, 0);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Custom Sensitivity
	    	if(sensitivity_on == 1)
	    	{	
	    		if(isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 8)
	    		{
		    		if(!get_val(ads_btn) && !get_val(fire_btn))
						customsens = genSens;
					else if(get_val(ads_btn) && !get_val(fire_btn))
						customsens = adsSens;
					else if(!get_val(ads_btn) && get_val(fire_btn))
						customsens = hipSens;
					if(get_val(ads_btn) && get_val(fire_btn))
						customsens = adsfireSens;
			
					sensitivity(PS4_RY,NOT_USE,customsens);
					sensitivity(PS4_RX,NOT_USE,customsens);
				}
	    	}
	    	
		// Dynamic Sensitivity
	    	else if(sensitivity_on == 2)
	    	{	
	    		if((get_val(ads_btn) || get_val(fire_btn)) && isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 20)
	    			set_sens();
	    	}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		/* AutoRun 
		   push the left stick 90% forward or to the sides to run - hold to sprint must be enable */
			if(autorun_on)
			{
				if((isqrt(pow(abs(get_ival(PS4_LX)),2) + pow(abs(get_ival(PS4_LY)),2)) >= 90) && get_ival(PS4_LY) < 20 && !get_val(ads_btn) && !get_val(fire_btn))
					set_val(PS4_L3, 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

		// In game rumbles block
			if(!rumble_on)
				block_rumble();
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// If Strafe Shot is enable for the curent profile
			if(toggle_shotMod[profile_idx] == 1)
			{
				if(check_activator())
					combo_run(STRAFESHOT);
				else
					combo_stop(STRAFESHOT);
			}
	
		// If Jump Shot is enable for the curent profile
			else if(toggle_shotMod[profile_idx] == 2)
			{
				if(check_activator())
					combo_run(JUMPSHOT);
			}
	
		// If Crouch Shot is enable for the curent profile
			else if(toggle_shotMod[profile_idx] == 3)
			{
				if(check_activator())
					set_val(BTN[crouch_btn], 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Speed Toggles
			toggle_antirecoil[profile_idx] = speed_toggle( ads_btn, PS4_UP   , 500 , toggle_antirecoil[profile_idx], ANTIRECOIL_M );
			toggle_rapidfire[profile_idx]  = speed_toggle( ads_btn, PS4_RIGHT, 500 , toggle_rapidfire[profile_idx] , RAPIDFIRE_M  );
			toggle_burstfire[profile_idx]  = speed_toggle( ads_btn, PS4_LEFT , 500 , toggle_burstfire[profile_idx] , BURSTFIRE_M  );
			toggle_aimassist[profile_idx]  = speed_toggle( ads_btn, PS4_DOWN , 500 , toggle_aimassist[profile_idx] , AIMASSIST_M  );
		
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

	/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
	|                          SCREEN SAVER BY DoGz                         |
	¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		    if(display_black)
		    {
		    	count_black += get_rtime();
		    	if(count_black >= 5000)
		    	{
		    		cls_oled(0);
		    		count_black = 0;
		    		screensaver = TRUE;
		    		logo_on = FALSE;
		    		display_black = FALSE;
		    	}
		    }
		    
		    if(screensaver)
		    {
		    	DGT += get_rtime();
				if(DGT >= 100) 
				{
					SD1 += 2;	TP1 += 1;
					TP2 -= 1;	DGT  = 0;
				}
				DGR += get_rtime();
				
				if(DGR >= 30) 
				{
					Y_1 += 1;	Y_2 += 2;	Y_3 += 3;	Y_4 += 4;
					Y_5 += 5;	Y_6 += 6;	Y_7 += 7;	Y_8 += 8;
					DGR  = 0;
				}
				
				name();
				MSC += get_rtime();
				
				if(MSC >= 1000) 
				{
					MSC = 0;
					RT += 1;
				}
				
				if(RT == 30) 
				{
					screensaver = 0;
					RT = 0;
					cls_oled(0);
				}
		    }
		} // NOT ModMenu and NOT ModEdit section end
		
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                         FEATURES ACTIVE IN GAME AND IN MOD EDIT                       |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(!ModMenu)
		{
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             AIM Abuse                                 |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
			
			
			if(toggle_aimabuse[profile_idx])
			{
				if(get_val(ads_btn))
					combo_run(AIM_ABUSE);
				else
					combo_stop(AIM_ABUSE);
			}
		
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             AIM Assist                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/

			if(toggle_aimassist[profile_idx])
			{
				if(toggle_aimassist[profile_idx] == 1) // Batts Sticky
				{	
					if(get_val(ads_btn) || get_val(fire_btn))
					    combo_run(STICKY);
				}
				else // Polar Shapes
				{
					if(toggle_antirecoil[profile_idx] && get_val(fire_btn))
					{
						RX = SmartSens(final_antirecoil_horizontal, PS4_RX);
						RY = SmartSens(ar_y, PS4_RY);
					}
					else
					{
						RX = get_val(PS4_RX);
						RY = get_val(PS4_RY);
					}
					
					actual_Magnitude = isqrt(pow(RX, 2) + pow(RY, 2));	
					max_Magnitude = (actual_Magnitude < 100);
				
					if(!(time++ % 1))
						angle += aimassist_angle;
						
					angle = angle % 360;
					sin_angle = Polar_Array[angle % 360];
					cos_angle = Polar_Array[(angle + 270) % 360];
					
				  
				  	if(get_val(fire_btn) || get_val(ads_btn))
				  	{
				    	if(actual_Magnitude <= aimassist_radius) 
				    	{
							sin_angle -= RY;
				      		cos_angle -= RX;
				    	}
					    else 
					    {
							sin_angle = (sin_angle * (200 - ((abs(RY) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
							cos_angle = (cos_angle * (200 - ((abs(RX) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
					    }
					    
					    GetShapesV1(aimassist_radius);
					    
					    if((!get_val(fire_btn) && toggle_antirecoil[profile_idx]) || !toggle_antirecoil[profile_idx])
					    {
							set_val(PS4_RX, clamp(get_val(PS4_RX) + cos_angle, -100, 100));
							set_val(PS4_RY, clamp(get_val(PS4_RY) + sin_angle, -100, 100));
				  		}
					}
				}
			}

		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             AntiRecoil                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/

			if(toggle_antirecoil[profile_idx])
			{
				check_trigger();
				
			// Antirecoil Standard final value
				if(toggle_antirecoil[profile_idx] == 2)
					final_antirecoil_start = final_antirecoil_end;
					
			// Progressive AntiRecoil vertical		
	    		if(final_antirecoil_start < final_antirecoil_end)
	    	   		i_val = 1; 
	    		else
	    	    	i_val = -1;
	    		i_pnt = (final_antirecoil_time / 10) / (abs(final_antirecoil_start - final_antirecoil_end)); 
	    		
	    	// Reset
	    		if(!get_val(trigger)) 
	    		{
					ar_y = final_antirecoil_start;
	    	    	i_cnt = 0;
	    	    	i_num = 0;
	    	    	//rumble = 0;
	    	    	rumble_recoil = 0;
	    	    	antirecoil_boost = 0;
	    		}     
	    					
	    		if(get_lval(trigger))
				{
				
				// Rumble AntiRecoil Boost
					antirecoil_boost += random(1, 5);
					if(antirecoil_boost > 10)
						antirecoil_boost = 0;
						
/*				// SmartStop
					if(get_ptime(trigger) < 500 || get_rumble(RUMBLE_A))
						rumble = 1;
					else if(get_rumble(RUMBLE_A) == 0)
						rumble = 0;
*/						
				// Progression Calculation
			        if(!p_complete())  
						ar_y = p_val();
			        else
			            ar_y = final_antirecoil_end;
			 
				// Run Rumble Antirecoil
					if(toggle_antirecoil[profile_idx] == 3) 
					{	
						rumble_recoil = max(get_rumble(RUMBLE_A),get_rumble(RUMBLE_B));
					                 				
						if(rumble_recoil > 10 && rumble_recoil < 90) 
						{
							if(!toggle_aimassist[profile_idx])
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY), -100, 100));
								set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX), -100, 100));
							}
							else if(toggle_aimassist[profile_idx] > 1)
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY) + sin_angle, -100, 100));
								set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX) + cos_angle, -100, 100));
							}
							else if(toggle_aimassist[profile_idx] == 1)
							{
								recoilAssist = rumble_recoil + rumble_power[profile_idx] + antirecoil_boost;
								combo_run(STICKY);
							}
						}
						else if(rumble_recoil < 10)
						{
							ar_y = final_antirecoil_end;
							antirecoil();
						}
					}
				// Run Progressive or Standard AntiRecoil
					else
					{	
				    // If BurstFire
				    	if(toggle_burstfire[profile_idx] == 1 && get_ptime(trigger) <= hold_time)
				    	{
							antirecoil();
				    	}
				    // Full auto and RapidFire with smart stop
				        if(toggle_burstfire[profile_idx] == 0  || toggle_rapidfire[profile_idx] >= 1)
				        {
					        //if(rumble)
					        //{
								antirecoil();
					    	//}
				    	}
				    }
		    	}
			}
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             RapidFire                                 |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		
		// RapidFire
			if(toggle_rapidfire[profile_idx])
			{
				if(toggle_rapidfire[profile_idx] == 1)
				{
				// Rate of Fire Calculation
					hold_time = 50;
					rest_time = 35 * 10 - (get_ival(XB1_RT) * 3);
		    	}
				else if(toggle_rapidfire[profile_idx] == 2)
				{
				// Rate of Fire Calculation
		    		rest_time = 5000 / ((final_rate_of_fire * 10) / 60); 
		   			hold_time = rest_time;
		    		if(rest_time < 0) rest_time = 0;
		    	}
				else if(toggle_rapidfire[profile_idx] == 3)
				{
				// Rate of Fire Calculation
		    		rest_time = 500 / final_rate_of_fire; 
		   			hold_time = rest_time;
		    		if(rest_time < 0) rest_time = 0;
		    	}
	    
	    	// Run combo
	    		if(get_val(fire_btn))
	    			combo_run(RAPIDFIRE);
	    		else
	    			combo_stop(RAPIDFIRE);
	    		
	    		led_on = 150;
	    		led_off = 300;
	    		combo_run(BLINK);
			}
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                              BurstFire                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
	
		//BurstFire
			if(toggle_burstfire[profile_idx] == 1) 
			{
	    	// Hold and Release
				hold_time = burstfire_hold;
				rest_time = burstfire_release;
				
	    	// Run combo
	    		if(get_val(fire_btn))	
	    			combo_run(BURSTFIRE);
	    		
				if(event_release(fire_btn))
	    			combo_stop(BURSTFIRE);
	
	    		led_on = 200;
	    		led_off = 1000;
	    		combo_run(BLINK);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
		}// NOT ModMenu but ModEdit

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|            DISPLAY TEXT AND VALUES IN MOD MENU, MOD EDIT AND MOD WEAPON               |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(display_new) 
		{
			screensaver = FALSE;
			count_black = 0;
			
			if(ModEdit) // Display editable value 
			{
				display_edit_line1();
			// Clears value zone
				rect_oled(38, 18, 51 , OLED_FONT_SMALL_HEIGHT + 3 , OLED_WHITE , OLED_BLACK); // small rectangle left (line 2 value)
				rect_oled(27, 31, 74 , OLED_FONT_SMALL_HEIGHT + 6 , OLED_WHITE , OLED_BLACK); // small rectangle left (line 3 value)
			
			// Display editable value
				display_values();
			}
			else if(ModMenu) // Display Profile, mod name, toggle
			{
				display_edit_line1();
				display_edit_line2();
				display_edit_line3();
			}
			else // Speed Toggle Display
			{
				cls_oled(OLED_BLACK);
			// Display mod name
				printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));
			// Display toggle
				display_edit_line3();
				count_black = 2000;
			}
			
			display_black = TRUE;
	        display_new = FALSE;
	       
	    } // display_new section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|               DISPLAY USER INFOS IN MOD MENU, MOD EDIT AND MOD WEAPON                 |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
	
		if(display_info) // display navigation infos
		{
			info_timer = 0;
			rect_oled(1, 50, 126, 13, OLED_WHITE, OLED_BLACK); // bottom rectangle (clear)
			if(ModMenu)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_MENU_PS_TXT));
				
				if(get_controller() == PIO_PS4)
					printf(center_x(get_string_length(get_string(INFO_MENU_PS_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_MENU_PS_TXT, current_info));
				else
					printf(center_x(get_string_length(get_string(INFO_MENU_XB_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_MENU_XB_TXT, current_info));
			}
			if(ModEdit)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_EDIT_PS_TXT));
				
				if(get_controller() == PIO_PS4)
					printf(center_x(get_string_length(get_string(INFO_EDIT_PS_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_EDIT_PS_TXT, current_info));
				else
					printf(center_x(get_string_length(get_string(INFO_EDIT_XB_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_EDIT_XB_TXT, current_info));
			}
			display_info = FALSE;
		}
	} // !KillSwitch section end

// back to main section

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                           DISPLAY TITLE - KILLSWITCH - PROFILE - WEAPON NAME - # SLOT                                 |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
// Display Script Title    
    if(display_title)
    {
    	screensaver= FALSE;
    	count_black = 0;	
    	
    // Display logo
    	if(!logo_on)
    	{
    		cls_oled(0);
   			draw_logo();
   		}
   		else
   			rect_oled(0, 45, 128, 31, OLED_WHITE, OLED_BLACK); // clear profile and #slot
   			
   	// Display current slot
   		number_to_string(currentSlot, find_digits(currentSlot)); 

   	// Display profile name
		display_profile();
		
		logo_on = TRUE;
   		display_black = TRUE;	
    	display_title = FALSE;
    }

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                      COLOR LED                                                        |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	if(KillSwitch)
		led(7);
	else
		led(profile_idx);
		
} // main section end
/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                  MAIN SECTION END                                                     |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                   COMBO SECTION                                                       |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
combo RACE {
	X_1 = random(0,127);
	wait(SAVER1);
	X_2 = random(0,127);
	wait(SAVER1);
	X_3 = random(0,127);
	wait(SAVER1);
	X_4 = random(0,127);
	wait(SAVER1); 
	X_5 = random(0,127);
	wait(SAVER1);
	X_6 = random(0,127);
	wait(SAVER1); 
	X_7 = random(0,127);
	wait(SAVER1); 
	X_8 = random(0,127);
	wait(SAVER1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_ON {					
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
combo KILLSWITCH {
	cls_oled(OLED_BLACK);
    printf(center_x(sizeof(MUTE) - 1, OLED_FONT_MEDIUM_WIDTH),8,OLED_FONT_MEDIUM,OLED_WHITE,MUTE[0]);    
    wait(get_rtime());
    wait(250);
    printf(center_x(sizeof(HOLD) - 1, OLED_FONT_SMALL_WIDTH),38,OLED_FONT_SMALL,OLED_WHITE,HOLD[0]);     
    printf(center_x(sizeof(ACTIVE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,ACTIVE[0]); 
    wait(get_rtime());
    wait(5000);  
    cls_oled(OLED_BLACK);
    wait(get_rtime());
    wait(5000);  
}
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo SAVE { 
	call(RUMBLE_ON);
	wait(150);
	call(RUMBLE_ON);		
	wait(1000);
	display_title = TRUE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RN {
	RN1 = random(65,90);
	RN2 = random(60,90);
	RN3 = random(65,90);
	RN4 = random(65,90); 
	RN5 = random(65,90);
	RN6 = random(65,90);
	RN7 = random(65,90);
	RN8 = random(65,90);
	wait(SAVER);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(fire_btn, 0);
    wait(rest_time - get_rtime());
    set_val(fire_btn, 0);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo STRAFESHOT { 
    set_val(PS4_LX, 100);
    wait(strafe_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafe_time);
    wait(50);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
 combo JUMPSHOT {
 	set_val(BTN[jump_btn], 100);
 	wait(50);
 	wait(100);
 }
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int recoilAssist;

combo STICKY {
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
	{
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    	set_val(PS4_RY, SmartSens(aimassist_radius + recoilAssist, PS4_RY));
    }
    else 
    	set_val(PS4_RY, SmartSens(aimassist_radius, PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(aimassist_radius, PS4_RX));
    set_val(PS4_LX, SmartSens(aimassist_radius, PS4_LX));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
	{
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius) + recoilAssist, PS4_RY));
    }
    else
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius), PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(inv(aimassist_radius), PS4_RX));
    set_val(PS4_LX, SmartSens(inv(aimassist_radius), PS4_LX));
    wait(aimassist_angle);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo AIM_ABUSE {
    wait(aimabuse_hold);
    set_val(ads_btn, 0);
    wait(aimabuse_release - get_rtime());
    set_val(ads_btn, 0);
}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                 FUNCTION SECTION                                                      |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

function display_edit_line1() {

// Clears text emplacement line 1
	rect_oled(13, 1, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
	
	if(ModMenu)
	{				
	// Display Profile only on mods that may have different ON/OFF status depending on the active Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE) 
			display_profile ();
		else // Mods that have the same toggle on every profiles, display EVERY PROFILE
    		printf(center_x(sizeof(ALL) - 1, OLED_FONT_SMALL_WIDTH),4,OLED_FONT_SMALL,OLED_WHITE,ALL[0]);
	}
	
	if(ModEdit) 
	{
	// Display Value Name
    	if(valName_idx == 1 && toggle_antirecoil[profile_idx] == 2)
    		printf(center_x(sizeof(ANTIRECOIL_VERTICAL) - 1, OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,ANTIRECOIL_VERTICAL[0]);  
    	else
    		printf(center_x(get_string_length(get_string(VALNAME_TXT, valName_idx)), OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(VALNAME_TXT, valName_idx));  
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit_line2() {
	
// Clears text emplacement line 2
	rect_oled(13, 17, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
		
	if(ModMenu)
	{
	// Display Mod Name
		printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));  // small size
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit_line3() {
	
// Clears text emplacement line 3
	rect_oled(13, 33, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);

// Display toggle ON/OFF status
    // Mods that may have different ON/OFF status depending on the active Profile
	display_toggle( ANTIRECOIL_M    , toggle_antirecoil[profile_idx]   ); // display_toggle( corresponding modName_idx , toggle_I_want_to_be_displayed[profile]);
	display_toggle( RAPIDFIRE_M     , toggle_rapidfire[profile_idx]    );
	display_toggle( BURSTFIRE_M     , toggle_burstfire[profile_idx]    );
	display_toggle( AIMASSIST_M     , toggle_aimassist[profile_idx]    );
	display_toggle( AIMABUSE_M      , toggle_aimabuse[profile_idx]     );
	display_toggle( SHOTMOD_M       , toggle_shotMod[profile_idx]      );
	display_toggle( SHOTACTIVATOR_M , toggle_shotActivator[profile_idx]);
	
	// Mods that have same ON/OFF status on every Profile
	display_toggle( SENSITIVITY_M    , sensitivity_on);
	display_toggle( HAIRTRIGGER_M    , hairTrigger_on);
	display_toggle( AUTORUN_M        , autorun_on    );
	display_toggle( AUTOADS          , autoADS_on    );
	display_toggle( AUTOFIRE         , autoFIRE_on   );
	display_toggle( JUMPBTN_M        , jump_btn      );
	display_toggle( CROUCH_BTN       , crouch_btn    );
	display_toggle( TRIGGERBUMPER_M  , swap_on       );
	display_toggle( RUMBLEFEEDBACK_M , rumble_on     );
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_values() {

	// Mods that may have different values depending on the active Profile
	display_edit( 0 , final_antirecoil_start      );// Display_edit( corresponding valName_idx , val_I_want_to_be_displayed[profile] );
	display_edit( 1 , final_antirecoil_end        );
	display_edit( 2 , final_antirecoil_time       );
	display_edit( 3 , final_antirecoil_horizontal );
	display_edit( 4 , rumble_power[profile_idx]   );
	display_edit( 5 , final_rate_of_fire          );
				
	// Mods that have same value on every Profile
	display_edit( 6 , burstfire_hold         );
	display_edit( 7 , burstfire_release      );
	display_edit( 8 , aimassist_radius       );
	display_edit( 9 , aimassist_angle        );
	display_edit( 10, aimabuse_hold          );
	display_edit( 11, aimabuse_release       );
	display_edit( 12, strafe_time            );
	display_edit( 13, dynasens_initial_sens  );
	display_edit( 14, dynasens_limit         );
	display_edit( 15, dynasens_restart       );
	display_edit( 16, dynasens_max_sens      );
	display_edit( 17, dynasens_increase_rate );
	display_edit( 18, genSens                );
	display_edit( 19, adsSens                );
	display_edit( 20, hipSens                );
	display_edit( 21, adsfireSens            );
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int profile_y;

function display_profile() {

	if(display_title)
		profile_y = 50; // Title screen
	else
		profile_y = 4; // Menus
	
    printf(center_x(get_string_length(get_string(PROFILE_TXT, profile_idx)), OLED_FONT_SMALL_WIDTH),profile_y,OLED_FONT_SMALL,OLED_WHITE,get_string(PROFILE_TXT, profile_idx));
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function display_edit(f_idx, f_val) { 
	
    if(valName_idx == f_idx)
    		number_to_string(f_val, find_digits(f_val));
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_toggle(f_idx, f_toggle) { 

    if(modName_idx == f_idx)
   	{
		if(f_idx == ANTIRECOIL_M) // if AntiRecoil MOD
    	// Display OFF or Progressive or Standard or On Rumble
    		printf(center_x(get_string_length(get_string(ANTIRECOIL_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(ANTIRECOIL_TXT, f_toggle));
    		
    	else if(f_idx == RAPIDFIRE_M) // if RapidFire MOD
    	// Display OFF or RPM/BPM or RPS/BPS
    		printf(center_x(get_string_length(get_string(RAPIDFIRE_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(RAPIDFIRE_TXT, f_toggle));
    		
		else if(f_idx == AIMASSIST_M) // if Polar Assist MOD
    	// Display AIM Assist shapes
    		printf(center_x(get_string_length(get_string(SHAPES_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHAPES_TXT, f_toggle));
    		
		else if(f_idx == SHOTMOD_M) // if Shot Mod
    	// Display Shot Mod
    		printf(center_x(get_string_length(get_string(SHOT_MOD_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHOT_MOD_TXT, f_toggle));
    		
		else if(f_idx == SHOTACTIVATOR_M) // if Shot Activator
    	// Display Shot Mod
    		printf(center_x(get_string_length(get_string(SHOT_ACTIVATOR_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHOT_ACTIVATOR_TXT, f_toggle));
    		
		else if(f_idx == SENSITIVITY_M) // if Sensitivity MOD
    	// Display Custom Sens or Dynamic Sens
    		printf(center_x(get_string_length(get_string(SENSITIVITY_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SENSITIVITY_TXT, f_toggle));
    		
    	else if(f_idx == JUMPBTN_M || f_idx == CROUCH_BTN) // if Jump or Crouch btn
    	{	
    		if(get_controller() == PIO_PS4)
    			printf(center_x(get_string_length(get_string(PS_BTN_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(PS_BTN_TXT, f_toggle));
    		else
    			printf(center_x(get_string_length(get_string(XB_BTN_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(XB_BTN_TXT, f_toggle));
    	}
    	
		else if(f_idx == TRIGGERBUMPER_M) // if Trigger/Bumper MOD
    	// Display Standard or Swapped
    		printf(center_x(get_string_length(get_string(SWAP_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SWAP_TXT, f_toggle));
    		
		else
		{
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,OFF[0]);
   		}
   	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define SSA1 = 78,SSA2 = 79,SSA3 = 90,SSA4 = 66,SSA5 = 65,SSA6 = 82,SSA7 = 68,SSA8 = 82,SSA9 = 73,SSA10 = 70,SSA11 = 82,SSA13 = 50,SSA14 = 49,SAVER = 5000,SAVER1 = 10;

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  
	
	if(valName_idx == f_idx)
	{
    // +1 or -1															 
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); 
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); 
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); 
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); 
	}		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
        if(modName_idx == ANTIRECOIL_M) // array value + temp value
        {
	    // Substract    
	        if((f_val + ANTIRECOIL_VAL[profile_idx][valName_idx]) < f_rng_min) 
	        	f_val = f_rng_min - ANTIRECOIL_VAL[profile_idx][valName_idx]; 
	    // Add   
	        if((f_val + ANTIRECOIL_VAL[profile_idx][valName_idx]) > f_rng_max) 
	        	f_val = f_rng_max - ANTIRECOIL_VAL[profile_idx][valName_idx]; 
        }
        
        else
        {
		// Substract    
	    	if(f_val < f_rng_min) 
	    		f_val = f_rng_min; 
		// Add   
	   		if(f_val > f_rng_max) 
	    		f_val = f_rng_max; 
    	}	
        display_new = TRUE; 
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { 
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == ANTIRECOIL_M) // toggle 0 or 1 or 2 or 3 to select antirecoil type
				f_val = cycle(f_val + 1, 0, entry_count(ANTIRECOIL_TXT));
				
			else if(f_idx == RAPIDFIRE_M) // toggle 0 or 1 or 2 to select rapidfire type
			{
				f_val = cycle(f_val + 1, 0, entry_count(RAPIDFIRE_TXT));
				
				if(f_val >= 1) // disable BurstFire if RapidFire is ON
					toggle_burstfire[profile_idx] = 0;
			}
			
			else if(f_idx == BURSTFIRE_M) // toggle 0 or 1 to select BurstFire
			{
				f_val = cycle(f_val + 1, 0, 1);
				
				if(f_val == 1) // disable RapidFire if BurstFire is ON
					toggle_rapidfire[profile_idx] = 0;
			}
				
			else if(f_idx == AIMASSIST_M) // toggle 0 or 1 or 2 ... or 6 to select aim assist shape
			{
				f_val = cycle(f_val + 1, 0, entry_count(SHAPES_TXT));
				
				if(f_val >= 1 && sensitivity_on == 2) // if AIM Assist disable dynasens
					sensitivity_on = 0;
			}
				
			else if(f_idx == SHOTMOD_M) // toggle 0 or 1 or 2 or 3 to select Shot Mod
				f_val = cycle(f_val + 1, 0, entry_count(SHOT_MOD_TXT));
				
			else if(f_idx == SHOTACTIVATOR_M) // toggle 0 or 1 or 2 to select Shot Activator
				f_val = cycle(f_val + 1, 0, entry_count(SHOT_ACTIVATOR_TXT));
				
			else if(f_idx == SENSITIVITY_M) // toggle 0 or 1 or 2 or 3 to select Custom or Dynamic Sens
			{
				f_val = cycle(f_val + 1, 0, entry_count(SENSITIVITY_TXT));
				
				if(f_val == 2) // if dynasens disable AIM Assist
				{
					toggle_aimassist[0] = 0;
					toggle_aimassist[1] = 0;
					toggle_aimassist[2] = 0;
				}
			}
			
			else if(f_idx == JUMPBTN_M || f_idx == CROUCH_BTN) // toggle 0 or 1 or 2 or 3 to select Jump and Crouch btn
				f_val = cycle(f_val + 1, 0, entry_count(PS_BTN_TXT)); // or XB_BTN_TXT 
				
			else
				f_val = cycle(f_val + 1, 0, 1);
		
		// Rumble	
			if(f_val == 0) 
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);
		}
		display_new = TRUE; 
	}

	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == ANTIRECOIL_M) // toggle 0 or 1 or 2 or 3 to select antirecoil type
				f_val = cycle(f_val - 1, 0, entry_count(ANTIRECOIL_TXT));
				
			else if(f_idx == RAPIDFIRE_M) // toggle 0 or 1 or 2 to select rapidfire type
			{
				f_val = cycle(f_val - 1, 0, entry_count(RAPIDFIRE_TXT));
				
				if(f_val >= 1) // disable BurstFire if RapidFire is ON
					toggle_burstfire[profile_idx] = 0;
			}
			
			else if(f_idx == BURSTFIRE_M) // toggle 0 or 1 to select BurstFire
			{
				f_val = cycle(f_val - 1, 0, 1);
				
				if(f_val == 1) // disable RapidFire if BurstFire is ON
					toggle_rapidfire[profile_idx] = 0;
			}
				
			else if(f_idx == AIMASSIST_M) // toggle 0 or 1 or 2 ... or 6 to select aim assist shape
			{
				f_val = cycle(f_val - 1, 0, entry_count(SHAPES_TXT));
				
				if(f_val >= 1 && sensitivity_on == 2) // if AIM Assist disable dynasens
					sensitivity_on = 0;
			}
				
			else if(f_idx == SHOTMOD_M) // toggle 0 or 1 or 2 or 3 to select Shot Mod
				f_val = cycle(f_val - 1, 0, entry_count(SHOT_MOD_TXT));
				
			else if(f_idx == SHOTACTIVATOR_M) // toggle 0 or 1 or 2 to select Shot Activator
				f_val = cycle(f_val - 1, 0, entry_count(SHOT_ACTIVATOR_TXT));
				
			else if(f_idx == SENSITIVITY_M) // toggle 0 or 1 or 2 or 3 to select Custom or Dynamic Sens
			{
				f_val = cycle(f_val - 1, 0, entry_count(SENSITIVITY_TXT));
				
				if(f_val == 2) // if dynasens disable AIM Assist
				{
					toggle_aimassist[0] = 0;
					toggle_aimassist[1] = 0;
					toggle_aimassist[2] = 0;
				}
			}
			
			else if(f_idx == JUMPBTN_M || f_idx == CROUCH_BTN) // toggle 0 or 1 or 2 or 3 to select Jump and Crouch btn
				f_val = cycle(f_val - 1, 0, entry_count(PS_BTN_TXT)); // or XB_BTN_TXT 
				
			else
				f_val = cycle(f_val - 1, 0, 1);
		
		// Rumble	
			if(f_val == 0) 
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);	
		}
		display_new = TRUE; 
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function speed_toggle(f_hold, f_press, f_time, f_val, f_idx) {  
	
	if(get_val(f_hold))
	{
		if(event_press(f_press) && get_brtime(f_press) <= 200) 
		{		
			if(f_idx == ANTIRECOIL_M) // if AntiRecoil
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(ANTIRECOIL_TXT)) ; // Antirecoil type 
			}
			if(f_idx == RAPIDFIRE_M) // if RapidFire
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(RAPIDFIRE_TXT)) ; // RapidFire type 
			}
			if(f_idx == AIMASSIST_M) // if Polar Assist
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(SHAPES_TXT)) ;// switch shapes 
			}
			display_new = TRUE; 
		}
		
		if(get_val(f_press) && get_ptime(f_press) == f_time) // Hold second button 300ms or more
		{
			modName_idx = f_idx;
			f_val = !f_val;	
			
			if(f_idx == AIMASSIST_M) // polar assist
			{
				if(f_val >= 1 && sensitivity_on == 2) // if AIM Assist disable dynasens
					sensitivity_on = 0;
			}
			
			if(f_val == 0)
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);
				
			display_new = TRUE; 
		} 
		
		set_val(f_press, 0)
	}
		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function check_toggle() {
	if(modName_idx == ANTIRECOIL_M  && toggle_antirecoil[profile_idx])      return TRUE;
	if(modName_idx == RAPIDFIRE_M   && toggle_rapidfire[profile_idx] > 1)   return TRUE;
	if(modName_idx == BURSTFIRE_M   && toggle_burstfire[profile_idx])       return TRUE;
	if(modName_idx == AIMASSIST_M   && toggle_aimassist[profile_idx])       return TRUE;
	if(modName_idx == AIMABUSE_M    && toggle_aimabuse[profile_idx])        return TRUE;
	if(modName_idx == SHOTMOD_M     && toggle_shotMod[profile_idx] == 1)    return TRUE;
	if(modName_idx == SENSITIVITY_M && sensitivity_on)                      return TRUE;
	return FALSE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function check_activator() {	
	if(toggle_shotActivator[profile_idx] == 0)
	{
		if(get_val(ads_btn) && get_val(fire_btn))
			return TRUE;
	}
	else if(toggle_shotActivator[profile_idx] == 1)
	{
		if(get_val(ads_btn) && !get_val(fire_btn))
			return TRUE;
	}
	else if(toggle_shotActivator[profile_idx] == 2)
	{
		if(!get_val(ads_btn) && get_val(fire_btn))
			return TRUE;
	}	
	return FALSE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int trigger;

function check_trigger() {		
	if(autoADS_on)
	{
		if(get_val(fire_btn))
		{	
			trigger = fire_btn;
			set_val(ads_btn, 100);
		}
	}
	else if(autoFIRE_on)
	{
		if(get_val(ads_btn))
		{
			trigger = ads_btn;
			set_val(fire_btn, 100);
		}
	}
	if(autoADS_on && autoFIRE_on)
	{
		if(get_val(fire_btn))
		{	
			trigger = fire_btn;
			set_val(ads_btn, 100);
		}
		else if(get_val(ads_btn))
		{
			trigger = ads_btn;
			set_val(fire_btn, 100);
		}
	}	
	else if(!autoADS_on && !autoFIRE_on)
	{
		if(get_val(fire_btn))
			trigger = fire_btn;
	}	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define MODNAME_TXT = 0;
define VALNAME_TXT = 1;
define INFO_MENU_PS_TXT = 2;
define INFO_EDIT_PS_TXT = 3;
define INFO_MENU_XB_TXT = 4;
define INFO_EDIT_XB_TXT = 5;
define SHAPES_TXT = 6;
define ANTIRECOIL_TXT = 7;
define PROFILE_TXT = 8;
define RAPIDFIRE_TXT = 9;
define SENSITIVITY_TXT = 10;
define SHOT_MOD_TXT = 11;
define SHOT_ACTIVATOR_TXT = 12;
define SWAP_TXT = 13;
define PS_BTN_TXT = 14;
define XB_BTN_TXT = 15;

function entry_count(f_array_idx) { // by Swizzy

    i = 0;
    if (f_array_idx == MODNAME_TXT) { while (MODNAME[i] != -1) { i++; } }
    else if (f_array_idx == VALNAME_TXT) { while (VALNAME[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MENU_PS_TXT) { while (INFO_MENU_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_PS_TXT) { while (INFO_EDIT_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MENU_XB_TXT) { while (INFO_MENU_XB[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_XB_TXT) { while (INFO_EDIT_XB[i] != -1) { i++; } }
    else if (f_array_idx == SHAPES_TXT) { while (SHAPES[i] != -1) { i++; } }
    else if (f_array_idx == ANTIRECOIL_TXT) { while (ANTIRECOIL[i] != -1) { i++; } }
    else if (f_array_idx == PROFILE_TXT) { while (PROFILE[i] != -1) { i++; } }
    else if (f_array_idx == RAPIDFIRE_TXT) { while (RAPIDFIRE[i] != -1) { i++; } }
    else if (f_array_idx == SENSITIVITY_TXT) { while (SENSITIVITY[i] != -1) { i++; } }
    else if (f_array_idx == SHOT_MOD_TXT) { while (SHOT_MOD[i] != -1) { i++; } }
    else if (f_array_idx == SHOT_ACTIVATOR_TXT) { while (SHOT_ACTIVATOR[i] != -1) { i++; } }
    else if (f_array_idx == SWAP_TXT) { while (SWAP[i] != -1) { i++; } }
    else if (f_array_idx == PS_BTN_TXT) { while (PS_BTN[i] != -1) { i++; } }
    else if (f_array_idx == XB_BTN_TXT) { while (XB_BTN[i] != -1) { i++; } }
    return i - 1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function get_string(f_array_idx, f_idx) { 

	if(f_array_idx == MODNAME_TXT)
		return MODNAME[f_idx];
		
	if(f_array_idx == VALNAME_TXT)
		return VALNAME[f_idx];
			
	if(f_array_idx == INFO_MENU_PS_TXT)
		return INFO_MENU_PS[f_idx];
		
	if(f_array_idx == INFO_EDIT_PS_TXT)
		return INFO_EDIT_PS[f_idx];
			
	if(f_array_idx == INFO_MENU_XB_TXT)
		return INFO_MENU_XB[f_idx];
		
	if(f_array_idx == INFO_EDIT_XB_TXT)
		return INFO_EDIT_XB[f_idx];
		
	if(f_array_idx == SHAPES_TXT)
		return SHAPES[f_idx];
		
	if(f_array_idx == ANTIRECOIL_TXT)
		return ANTIRECOIL[f_idx];
		
	if(f_array_idx == PROFILE_TXT)
		return PROFILE[f_idx];
		
	if(f_array_idx == RAPIDFIRE_TXT)
		return RAPIDFIRE[f_idx];
		
	if(f_array_idx == SENSITIVITY_TXT)
		return SENSITIVITY[f_idx];
		
	if(f_array_idx == SHOT_MOD_TXT)
		return SHOT_MOD[f_idx];
		
	if(f_array_idx == SHOT_ACTIVATOR_TXT)
		return SHOT_ACTIVATOR[f_idx];
		
	if(f_array_idx == SWAP_TXT)
		return SWAP[f_idx];
		
	if(f_array_idx == PS_BTN_TXT)
		return PS_BTN[f_idx];
		
	if(f_array_idx == XB_BTN_TXT)
		return XB_BTN[f_idx];
		
	return -1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int stringLength;
function get_string_length(offset) { // by Swizzy

    stringLength = 0;
    while (duint8(offset++)) { stringLength++; }
    return stringLength + 1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int sens_x;
int sens_y;
int sens_xcnt,sens_ycnt;

function set_sens () { // Dynamic Sens by Batts

    if(abs(get_lval(PS4_RX)) >= dynasens_limit) 
    {
	    sens_xcnt += 1;
	    
		if(sens_xcnt >= dynasens_increase_rate && sens_x < dynasens_max_sens) 
		{ 
		    sens_x += 1; 
		    sens_xcnt = 0; 
		} 
			else if(sens_x >= dynasens_max_sens) 
				sens_xcnt = 0;  
	}
	
    else if(abs(get_val(PS4_RX)) < dynasens_restart) 
    {
	    sens_xcnt = 0; 
	    sens_x = dynasens_initial_sens;
	} 
	
    if(abs(get_val(PS4_RY)) >= dynasens_limit) 
    {
	    sens_ycnt += 1;
		if(sens_ycnt >= dynasens_increase_rate && sens_y < dynasens_max_sens) 
		{ 
		    sens_y += 1; 
		    sens_ycnt = 1; 
		} 
			else if(sens_y >= dynasens_max_sens) 
				sens_ycnt = 0; 
	}
	
    else if(abs(get_val(PS4_RY)) < dynasens_restart) 
    {
	    sens_y = dynasens_initial_sens; 
	    sens_ycnt = 0;
	}
	
	sensitivity(PS4_RX,NOT_USE,sens_x);
    sensitivity(PS4_RY,NOT_USE,sens_y);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
                                          
int i_cnt;    

function p_complete() { 

    i_cnt++;
    if(i_cnt > final_antirecoil_time / 10) 
    {
        i_cnt = final_antirecoil_time / 10;
        return 1;
    }    
    return 0;
}  

int i_num;
int i_pnt;
int ar_y;	
int i_val;

function p_val() { 

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int SmartSens_side;
int SmartSens;
	
function SmartSens(f_val, f_axis) { 

	if(f_val < 0)
		SmartSens_side = -1; 
	else 
		SmartSens_side = 1; 

	if(SmartSens_side == -1) 
	{
	    if(get_ival(f_axis) > 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 - f_val)) / 100); 
	    
	    else if(get_ival(f_axis) <= 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 + f_val)) / 100);
	}
	
	if(SmartSens_side == 1) 
	{
	    if(get_ival(f_axis) < 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 + f_val)) / 100); 
	    	
	    else if(get_ival(f_axis) >= 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 - f_val)) / 100);
	}
	
	if(SmartSens_side == -1 && get_ival(f_axis) >= f_val + SmartSens || SmartSens_side == 1 && get_ival(f_axis) <= f_val + SmartSens)
	    return clamp(f_val + SmartSens, -100, 100);
	    
	return 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function antirecoil() {

	if(!toggle_aimassist[profile_idx])
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY), -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX), -100, 100));
	}
	else if(toggle_aimassist[profile_idx] > 1)
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY) + sin_angle, -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX) + cos_angle, -100, 100));
	}
	else if(toggle_aimassist[profile_idx] == 1)
	{
		recoilAssist = ar_y;
		combo_run(STICKY);
	}
}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int c,c_val;

function number_to_string(f_val,f_digits) {

    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            /*if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }*/
        }
        c_val /= 10;
    }
    if(display_title)
    	puts_oled(120, 54, OLED_FONT_SMALL, i - 1, OLED_WHITE); // display current # slot
    else
    	puts_oled(center_x(i - 1,OLED_FONT_MEDIUM_WIDTH),28,OLED_FONT_MEDIUM,i - 1,OLED_WHITE); // adjustable value centered in X - medium size
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_base_menu() {
	rect_oled(0, 0, 128, 49, OLED_BLACK, OLED_WHITE); // white contour 
	line_oled(1, 16, 126, 16, 1, OLED_WHITE); // draw line 1
	
// Filled rectangle white (emplacement for the chars line 1)	
	rect_oled(2, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 1)
	rect_oled(115, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 1)
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_modMenu() {
// Clears text emplacement line 2 and 3 (value zone while in ModEdit)
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Separate ex value zone
	line_oled(1, 32, 126, 32, 1, OLED_WHITE); // line 2 
	
// Filled rectangle white (emplacement for the chars line 2, 3)
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_modEdit() {
// Clears line 2 and 3
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Filled rectangle white 
	// Emplacement for the chars line 2, 3)	
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
	// Emplacement for + / -
	rect_oled(14, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE , OLED_WHITE); // rectangle left (line 2 + 3)
	rect_oled(102, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE, OLED_WHITE); // rectangle right (line 2 + 3)

// Display - / +
	line_oled(16, 31, 23, 31, 2, OLED_BLACK); // left -
	putc_oled(1, 43); // +
	puts_oled(103, 24, OLED_FONT_MEDIUM, 1, OLED_BLACK); // right + 	    

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define UP = 131; define DOWN = 132; define LEFT = 133; define RIGHT = 134; define TRIANGLE = 130; define Y = 89; define CROSS = 127; define A = 65;
define LEFT_X = 4; define RIGHT_X = 117;
define LINE_1_Y = 4; define LINE_2_Y = 20;  define LINE_3_Y = 36; define LINE_4_Y = 53;  
int btn_left;
int btn_right;

function draw_chars_line1() {
// Define button
	if(ModMenu)
	{		
		if(get_controller() == PIO_PS4)
		{
			btn_left = TRIANGLE;
			btn_right = TRIANGLE;
		}
		else
		{
			btn_left = Y;
			btn_right = Y;
		}
	}
	if(ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}

// Clears/fill rectangle
	rect_oled(3, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 1)
	rect_oled(116, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 1)
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_right); 

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_chars_line2() {
// Define button
	if (ModMenu || ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}
	if(ModEdit)
	{
	// Clears/fill rectangle
		rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 2)
		rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
	}
	else
	{
	// Clears/fill rectangle
		rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); //  rectangle left (line 2)
		rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
	}
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_right); 
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_chars_line3() { 
// Define button
	if (ModMenu)
	{
		btn_left = DOWN;
		btn_right = UP;
	}
	if(ModEdit)
	{
		btn_left = DOWN;
		btn_right = UP;
		
	// Clears/fill rectangle
		rect_oled(3, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 3)
		rect_oled(116, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); // rectangle right (line 3)	
	}
	else
	{
	// Clears/fill rectangle
		rect_oled(3, 35, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 3)
		rect_oled(116, 35, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 3)
	}
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_left); 
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_right);  
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_hold_to_edit() { 
// Clears/fill the inside of the "hold button" rectangle
	rect_oled(28, 19, OLED_FONT_SMALL_WIDTH + 1 , OLED_FONT_SMALL_HEIGHT , OLED_WHITE , col_rec_left); 
	rect_oled(91, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT  , OLED_WHITE, col_rec_right); 
// Display chars	
	if(get_controller() == PIO_PS4)
	{	
		putc_oled(1, CROSS);
		puts_oled(92, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, CROSS);
		puts_oled(28, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_right);
	}
	else
	{
		putc_oled(1, A);
		puts_oled(92, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, A);
		puts_oled(29, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_right);
	}
// Contour for chars X / A (must be after display chars)
	rect_oled(27, 18, OLED_FONT_SMALL_WIDTH + 3 , OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK , OLED_WHITE); // small rectangle left (line 2)
	rect_oled(90, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK, OLED_WHITE); // small rectangle right (line 2)
}	

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int col_char_left; 
int col_char_right;
int col_rec_left = 1;
int col_rec_right = 1;

function button_animation() {
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_TRIANGLE))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModMenu)
			draw_chars_line1();
	}
	else if(event_release(PS4_TRIANGLE))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModMenu)
			draw_chars_line1();
	}	
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	if(event_press(PS4_LEFT))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
	if(event_release(PS4_LEFT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_RIGHT))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;	
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
	if(event_release(PS4_RIGHT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_UP))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
	if(event_release(PS4_UP))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_DOWN))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
	if(event_release(PS4_DOWN))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_CROSS))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
	if(event_release(PS4_CROSS))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int SSMU1 = 1,SSMU2 = 8,SSMU3 = 15,SSMU4 = 22,SSMU5 = 29,SSMU6 = 36,SSMU7 = 43;

function cycle(f_val, f_lo, f_hi) {
	if(f_val > f_hi) return f_lo;
	if(f_val < f_lo) return f_hi;
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int X_1,Y_1,X_2,Y_2,X_3,Y_3, X_4,Y_4,X_5,Y_5,X_6,Y_6,X_7,Y_7,X_8,Y_8,RN1,RN2,RN3,RN4,RN5,RN6,RN7,RN8;

function find_digits(f_num) {

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int RT,MSC,SD1,DGT,DGR,TP1,TP2;

function press_hold(f_btn) { 

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {

   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function save() {
	ModMenu = FALSE;
	ModEdit = FALSE;
	cls_oled(OLED_BLACK);
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 
	combo_run(SAVE);
	
// Toggles
	pmemValue = set_15var(pmemValue, toggle_burstfire[0] , 0);		pmemValue = set_15var(pmemValue, toggle_burstfire[1] ,  1);		pmemValue = set_15var(pmemValue, toggle_burstfire[2] ,  2);
	pmemValue = set_15var(pmemValue, hairTrigger_on      , 3);	 	pmemValue = set_15var(pmemValue, autorun_on          ,  4);	 	pmemValue = set_15var(pmemValue, autoADS_on          ,  5);
	pmemValue = set_15var(pmemValue, autoFIRE_on         , 6); 		pmemValue = set_15var(pmemValue, swap_on             ,  7);		pmemValue = set_15var(pmemValue, rumble_on           ,  8);
	pmemValue = set_15var(pmemValue, toggle_aimabuse[0]  , 9);		pmemValue = set_15var(pmemValue, toggle_aimabuse[1]  , 10);		pmemValue = set_15var(pmemValue, toggle_aimabuse[2]  , 11);
	set_pvar(SPVAR_1,pmemValue);
	
	pmemValue = set_4var(toggle_antirecoil[0], toggle_antirecoil[1], toggle_antirecoil[2], NOT_USE);
	set_pvar(SPVAR_2,pmemValue);
	
	pmemValue = set_4var(toggle_rapidfire[0], toggle_rapidfire[1], toggle_rapidfire[2], NOT_USE);
	set_pvar(SPVAR_3,pmemValue);
	
	pmemValue = set_4var(toggle_aimassist[0], toggle_aimassist[1], toggle_aimassist[2], NOT_USE);
	set_pvar(SPVAR_4,pmemValue);
	
	pmemValue = set_4var(toggle_shotMod[0], toggle_shotMod[1], toggle_shotMod[2], NOT_USE);
	set_pvar(SPVAR_5,pmemValue);
	
	pmemValue = set_4var(toggle_shotActivator[0], toggle_shotActivator[1], toggle_shotActivator[2], NOT_USE);
	set_pvar(SPVAR_6,pmemValue);
	
	pmemValue = set_4var(sensitivity_on, jump_btn, crouch_btn, NOT_USE);
	set_pvar(SPVAR_7,pmemValue);
	
// Antirecoil vertical values
	pmemValue = set_2var(antirecoil_start[0], antirecoil_end[0]);
	set_pvar(SPVAR_8,pmemValue);
	pmemValue = set_2var(antirecoil_start[1], antirecoil_end[1]);
	set_pvar(SPVAR_9,pmemValue);
	pmemValue = set_2var(antirecoil_start[2], antirecoil_end[2]);
	set_pvar(SPVAR_10,pmemValue);
	set_pvar(SPVAR_11,antirecoil_time[0]);
	set_pvar(SPVAR_12,antirecoil_time[1]);
	set_pvar(SPVAR_13,antirecoil_time[2]);

// Antirecoil horizontal & rumble recoil values
	pmemValue = set_2var(antirecoil_horizontal[0], rumble_power[0]);
	set_pvar(SPVAR_14,pmemValue);
	pmemValue = set_2var(antirecoil_horizontal[1], rumble_power[1]);
	set_pvar(SPVAR_15,pmemValue);
	pmemValue = set_2var(antirecoil_horizontal[2], rumble_power[2]);
	set_pvar(SPVAR_16,pmemValue);
	
// Rate of fire values
	set_pvar(SPVAR_17,rate_of_fire[0]);
	set_pvar(SPVAR_18,rate_of_fire[1]);
	set_pvar(SPVAR_19,rate_of_fire[2]);
	
// BurstFire values
	set_pvar(SPVAR_20, burstfire_hold   );
	set_pvar(SPVAR_21, burstfire_release);

// AIM Assist values
	pmemValue = set_2var(aimassist_radius, aimassist_angle);
	set_pvar(SPVAR_22,pmemValue);
	
// StrafeShot values
	set_pvar(SPVAR_23,strafe_time);

// Custom Sens values
	set_pvar(SPVAR_24,genSens);
	set_pvar(SPVAR_25,adsSens);
	set_pvar(SPVAR_26,hipSens);
	set_pvar(SPVAR_27,adsfireSens);

// Dynamic Sens	values
	set_pvar(SPVAR_28,dynasens_initial_sens);
	pmemValue = set_2var(dynasens_limit, dynasens_restart);
	set_pvar(SPVAR_29,pmemValue);
	set_pvar(SPVAR_30,dynasens_max_sens);
	set_pvar(SPVAR_31,dynasens_increase_rate);
	
// AIM Abuse values
	set_pvar(SPVAR_32,aimabuse_hold);
	set_pvar(SPVAR_33,aimabuse_release);

}

int mask;
int ret;
int pmemValue;

function set_15var(pvar, ret, position) { // values range = 0 ~ 1
	for(i = position; i < (1 + position); i++)
	{
		pvar = pvar & (~(1 << i));
	}
	pvar = pvar | (ret << position);
	
	return pvar;
}
function get_15var(pvar, position){
	mask = 0;
	ret = 0;
	for(i = 0; i < 1 ; i++)
	{
		mask = mask | (1 << i);
	}
	mask = mask << position
	ret = (pvar & mask) >> position
return ret;
}
//----

function set_4var(_1, _2, _3, _4) { // values range = 0 ~ 15
	return 0xff00 & ((0xf0 & (_1 << 4) | _2) << 8) | (0xf0 & (_3 << 4) | _4); 
}
function get_4var(f_PMemory, f_dec_pos) { 
	return  (f_PMemory >> (4 * f_dec_pos)) & 0x0F; 
}
//----

function set_2var(var1, var2) { // values range = -127 ~ 127
	ret = 0;
	
	if(var1 < 0)
   		var1 = abs(var1) | 0x80;

	ret = (abs(var2) << 8)|var1;
	
	if(var2 < 0)
		ret *= -1;
	
	return ret;
}
function get_2var(pvar, var) {
	ret = 0;
	
	if(var == 0)
	{	 
		ret = 0x80 & abs(pvar) ;
		ret = ret >> 7;
		ret = ((-2) * ret) + 1;
		ret = (abs(pvar) & 0x7F) * ret;
	}
	else
	{
		ret = pvar >> 8;

	    if(pvar < 0)
			ret += 1;
	}
	
	return ret;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function name(){
	cls_oled(0);
	combo_run(RACE);
	combo_run(RN);
if (Y_1 > 64)  Y_1 =   0;
if (Y_2 > 64)  Y_2 =   0;
if (Y_3 > 64)  Y_3 =   0;
if (Y_4 > 64)  Y_4 =   0;
if (Y_5 > 64)  Y_5 =   0;
if (Y_6 > 64)  Y_6 =   0;
if (Y_7 > 64)  Y_7 =   0;
if (Y_8 > 64)  Y_8 =   0;
if (SD1 > 105) SD1 = -50;
if (TP1 > 45)  TP1 =   0;
if (TP2 < 0)   TP2 =  55;
	putc_oled(1,RN1);
	puts_oled(X_1,Y_1,0,1,1);
	putc_oled(1,RN2);
	puts_oled(X_2,Y_2,0,1,1);
	putc_oled(1,RN3);
	puts_oled(X_3,Y_3,0,1,1);
	putc_oled(1,RN4);
	puts_oled(X_4,Y_4,0,1,1);
	putc_oled(1,RN5);
	puts_oled(X_5,Y_5,0,1,1);
	putc_oled(1,RN6);
	puts_oled(X_6,Y_6,0,1,1);
	putc_oled(1,RN7);
	puts_oled(X_7,Y_7,0,1,1);
	putc_oled(1,RN8);
	puts_oled(X_8,Y_8,0,1,1);
	putc_oled(1,SSA1);
	puts_oled(SSMU1 + SD1,TP1 + 2,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU2 + SD1,TP2 + 4,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU3 + SD1,TP1 + 6,0,1,1);
	putc_oled(1,SSA3);
	puts_oled(SSMU4 + SD1,TP2 + 8,0,1,1);
	putc_oled(1,SSA4);
	puts_oled(SSMU5 + SD1,TP1 + 10,0,1,1);
	putc_oled(1,SSA5);
	puts_oled(SSMU6 + SD1,TP2 + 12,0,1,1);
	putc_oled(1,SSA6);
	puts_oled(SSMU7 + SD1,TP1 + 14,0,1,1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
/*set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);*/
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

const string TITLE1 = "SHOOTER"
const string TITLE2 = "MASTER"

function draw_logo() {
	printf(center_x(sizeof(TITLE1) - 1,OLED_FONT_LARGE_WIDTH),1,OLED_FONT_LARGE,OLED_WHITE,TITLE1[0]);
	printf(center_x(sizeof(TITLE2) - 1,OLED_FONT_LARGE_WIDTH),22,OLED_FONT_LARGE,OLED_WHITE,TITLE2[0]);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int time;
int RX, RY;
int angle, cos_angle, sin_angle;
int SpiralPosition1,SpiralPosition2,InnerSpiral,OuterSpiral;
int actual_Magnitude, max_Magnitude, Position;

const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,    
80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7, 
6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,  
-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95, 
-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,   
-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61, 
-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,
9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,
82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int timer;

function GetShapesV1(f_var) {     
   
    if(!SpiralPosition1)                                
	{
		InnerSpiral -= 1;
		if(InnerSpiral < 1)
			SpiralPosition1 = TRUE;
	}
	else
	{
	    InnerSpiral += 1;
		if(InnerSpiral > f_var)
			SpiralPosition1 = FALSE;
	}
	if(!SpiralPosition2)
	{
		OuterSpiral -= 1;
		if(OuterSpiral < 1)
			SpiralPosition2 = TRUE;
	}
	else
	{
		OuterSpiral += 1;
		if(OuterSpiral >  f_var)
			SpiralPosition2 = FALSE;
	} 
	if(toggle_aimassist[profile_idx] == 2)                    
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 3)        
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * (f_var / 2)) /100; 
	}
	if(toggle_aimassist[profile_idx] == 4)                     
	{ 
        RY = (sin_angle * (f_var / 2)) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 5)                  
	{
        RY = (sin_angle * InnerSpiral) /100;
        RX = (cos_angle * OuterSpiral) /100;  
	}
    if(toggle_aimassist[profile_idx] == 6)
	{
		RX = (cos_angle * Position) /100;
		RY = (sin_angle * Position) /100;
	
		if(Position == 0)
		    RX = (cos_angle * f_var) /100;
		    
		if(Position == 1)
			RY = (sin_angle * f_var) /100;
			
		if(Position == 2) 
			RX = (cos_angle * f_var) /100 * -1;
			
		if(Position == 3)
			RY = (sin_angle * f_var) /100 * -1;
			
		timer++;
		if(timer >= aimassist_angle)
		{
			Position++;
			timer = 0;
		}
				
		if(Position == 4)
			Position = 0;
    }
    
	cos_angle = RX;
	sin_angle = RY;
}