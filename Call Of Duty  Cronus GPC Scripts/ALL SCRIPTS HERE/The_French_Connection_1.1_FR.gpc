/*
 ___                              _ ,                             
-   ---___- ,,                  ,- -                        ,,            ,- _~.                                ,                         
   (' ||    ||                 _||_                         ||           (' /|                                 ||   '                     
  ((  ||    ||/\\  _-_        ' ||   ,._-_  _-_  \\/\\  _-_ ||/\\       ((  ||    /'\\ \\/\\ \\/\\  _-_   _-_ =||= \\  /'\\ \\/\\         
 ((   ||    || || || \\         ||    ||   || \\ || || ||   || ||       ((  ||   || || || || || || || \\ ||    ||  || || || || ||         
  (( //     || || ||/           |,    ||   ||/   || || ||   || ||        ( / |   || || || || || || ||/   ||    ||  || || || || ||         
    -____-  \\ |/ \\,/        _-/     \\,  \\,/  \\ \\ \\,/ \\ |/         -____- \\,/  \\ \\ \\ \\ \\,/  \\,/  \\, \\ \\,/  \\ \\ 
              _/                                              _/  


version: 1.1
Device: CronusZEN ONLY
Controller tested: DS4 - Elite 2
Console tested: PS4 (XBOX and PC compatible)
Author: noozbar


Thanks to Cronus community and staff                                                             © 2022 CronusMax & CronusZen. All rights reserved.
———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Ce script possède la plupart des mods qui sont essentiels à la plupart des jeux de tir (FPS ou TPS).

Il n'est pas plug and play, l'utilisateur devra activer les mods qui l'intéressent et également définir sa disposition des boutons depuis le menu OLED.

Compatible avec les manettes PS4 et XBOX, ce script remplacera :

	- le bouton VIEW sur la manette XBOX avec le bouton TOUCHPAD lorsque vous jouez sur PlayStation (pour capturer (bouton SHARE sur les manettes PlayStation), appuyez sur RS + VIEW)

	- le bouton TOUCHPAD de la manette PlayStation par le bouton VIEW lorsque vous jouez sur XBOX ou PC.



Ce script est "intelligent", il désactivera RapidFire si vous activez BurstFire sur le même profil (ou vice versa),

Il désactivera Dynamic Sens si vous activez AIM Assist sur l'un des 3 profils ou désactivera AIM Assist sur tous les profils si vous activez Dynamic Sens (car ces mods ne sont pas compatibles).

Il affichera les boutons PlatStation dans le menu si votre contrôleur est un contrôleur PlatStation, sinon il affichera les boutons XBOX.

Il vous permettra d'entrer dans Mod Edit seulement si le mod affiché est activé et s'il a une ou plusieurs valeurs ajustables.

La combinaison AntiRecoil + AIM Assist a été retravaillée pour une compatibilité maximale entre ces deux mods.

En bref, beaucoup de travail a été consacré à ce script et je pense avoir réussi à contrer la plupart des erreurs de manipulation possibles... Amusez-vous bien !

———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
											INSTRUCTIONS - IMPORTANT, LISEZ ATTENTIVEMENT
											INSTRUCTIONS - IMPORTANT, LISEZ ATTENTIVEMENT
											INSTRUCTIONS - IMPORTANT, LISEZ ATTENTIVEMENT
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸	

Comment utiliser le menu Principal :

		Ouvrir le menu Principal 
			- maintenez L2/LT et appuyez sur OPTIONS/MENU pour ouvrir ou fermer le menu
			
		Naviguez entre les différents Menus
			- appuyez sur HAUT ou BAS 
			- appuyez sur CROSS/A pour entrer dans le sous-menu
			
		Maintenez L2/LT et appuyez sur OPTIONS/MENU pour fermer tous les menus
			
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

Comment utiliser le menu Mod :
	
		Choisissez le profil que vous souhaitez modifier (primaire, secondaire ou custom)
			- Appuyez sur TRIANGLE/Y 
			
		Naviguez entre les différents MODS avec GAUCHE ou DROITE (D pad / croix directionnel)
			- Appuyez HAUT ou BAS pour activer / désactiver ou changer le type du mod
		
		Activez les mods que vous voulez sur chaque profil...
		
		Si le mod affiché est actif et possède une ou plusieurs valeur(s) modifiable(s) : 
			- Appuyez sur CROIX/A pour fermer le menu Mod et aller à menu Edit
		
		Pour quitter menu Mod et revenir au menu Principal, tapez sur ROND/B
		
		Maintenez L2/LT et appuyez sur OPTIONS/MENU pour fermer tous les menus
	
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

Comment utiliser le menu Edit : (dans le menu Mod, tapez CROIX/A pour fermer le menu Mod et aller au menu Edit - si le mod affiché est actif et a une ou plusieurs valeurs modifiables)

		Naviguez entre les différents noms de valeurs avec GAUCHE ou DROITE
		Modifier/éditer la valeur :
			- Maintenez CROIX/A et 
				- appuyez sur HAUT ou DROITE pour augmenter la valeur 
				- appuyez sur BAS ou GAUCHE pour diminuer la valeur
		
		Pour quitter menu Edit et revenir au menu Mod, appuyez sur ROND/B
		
		Maintenez L2/LT et appuyez sur OPTIONS/MENU pour fermer tous les menus
	
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

Comment utiliser le menu Controller :
	
		Choisissez le bouton que vous voulez modifier (ADS, Fire, Jump ... ... ...) - ou le mod que vous voulez activer (Hair Trigger ou Block Rumble).
			- Appuyez sur GAUCHE ou DROIT
			
		Assignez le bouton correspondant - ou activez /désactivez Hair Trigger ou Block Rumble
			- appuyez sur HAUT ou BAS 
		
		Pour quitter le menu Controleur et revenir au menu Principal, appuyez sur ROND/B
		
		Maintenez la touche L2/LT enfoncée et appuyez sur OPTIONS/MENU pour fermer tous les menus
			
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

Comment utiliser le menu Profiles :
	
			Naviguez à travers les différentes options du menu Profiles
				- Appuyez sur TRIANGLE/Y
			
			Prim/Sec btn : Changez la façon dont vous passez du profil 1 au profil 2
				- appuyez sur GAUCHE ou DROITE
				
			Custom Profile : Modifier la façon dont vous passez au profil Custom
				- appuyez sur GAUCHE ou DROITE pour sélectionner le bouton que vous devrez maintenir enfoncé
				- tapez sur HAUT ou BAS pour sélectionner le bouton sur lequel vous devrez appuyer
				
			Resync BTN : Définir la manière de resynchroniser les profils
				- tapez sur GAUCHE ou DROITE pour sélectionner le bouton que vous devrez maintenir enfoncé
				- appuyez sur HAUT ou BAS pour sélectionner le bouton sur lequel vous devrez appuyer
			
		Pour quitter le menu Profiles et revenir au menu Principal, appuyez sur ROND/B
		
		Maintenez la touche L2/LT enfoncée et appuyez sur OPTIONS/MENU pour fermer tous les menus
			
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
				           
	Sauvegardez TOUTES les valeurs, bascules ON/OFF, de CHAQUE profil et quittez les menus (seulement disponible si vous êtes dans un menu)		
		- Tapez PS/XBOX  

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Speed Toggle pour le profil actif (en dehors de tout menu) - Désactiver le mod ou revenir au type que vous avez choisi auparavant en un instant in game
		- Maintenez le bouton de visée et maintenez 500ms (une demi seconde)
			- UP pour AntiRecoil 
			- DOWN pour AIM Assist
			- DROITE pour RapidFire
			- GAUCHE pour ShotMod
			
		- Maintenez le bouton de visée et
			- DOUBLE TAPEZ HAUT pour passer d'un type d'antirecul à l'autre
			- DOUBLE TAPEZ BAS pour passer d'une forme d'assistance AIM à l'autre
			- DOUBLE TAPEZ DROITE pour passer d'un type de tir rapide à un autre
			- DOUBLE TAPEZ GAUCHE pour passer d'un type de ShotMod à l'autre

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Kill Switch (désactive le script)
		- Passer de ON à OFF ou de OFF à ON
			- Maintenez le bouton L2/LT enfoncé et appuyez sur SHARE/VIEW 
			ou
			- Tapez PS/XBOX 
			
		- Activer le Kill Switch (désactivez le script)
			- Appuyez sur OPTIONS/MENU
			
		- Désactiver le Kill Switch (activez le script)
			- Tapez deux fois sur ROND/B
		
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

														M O D S   D E S C R I P T I O N
														
AntiRecoil : permet de contrôler le recul d'une arme

	Il y a 3 types d'AntiRecoil Vertical dans le script:
	- Progressif : le plus précis mais aussi le plus difficile à régler. Il est composé de 3 valeurs réglables :
		- AR Start qui est la valeur qui va vous permettre de contrer le kick de votre arme sur les 5 premières balles, sur la première rafale
		- AR End qui est la valeur qui vous permet de stabiliser l'arme lorsque vous maintenez le bouton de tir pour vider votre chargeur sur l'ennemi
		- AR Time qui est une valeur temporelle et qui définit la durée de la progression, le temps que ca va mettre pour augmenter ou diminuer progressivement votre AntiRecoil

Par exemple, Start = 48, End = 25 et Time = 1000.
Lorsque vous tirez, votre AntiRecoil va compenser votre recul à 48 pour contrer le kick et ensuite il va commencer à descendre progressivement jusqu'à 25 et atteindra 25 en 1 seconde (1000ms)
C'est exactement ce que vous faites avec votre doigt sur le stick lorsque vous n'avez pas ZEN, vous tirez fortement en arrière pour contrer le kick 
et ensuite vous relâchez progressivement (en quelques secondes) la pression sur le stick pour stabiliser l'arme

	- Standard : moins précis mais plus facile à régler. Il n'a qu'une seule valeur réglable :
		- AR Vertical qui est la valeur qui vous permet de stabiliser l'arme lorsque vous maintenez le bouton de tir pour vider votre chargeur sur l'ennemi
	
	- On Rumble : assez précis sur certain jeux et très simple à régler, il se base sur les vibrations envoyées à la manette par le jeu. Il n'a qu'une seule valeur réglable :
		- Rumble Power qui est une valeur (coefficient) qui permet d'ajuster finement le recul de l'arme si la valeur par défaut est trop élevée ou trop faible

Chacun de ces 3 types d'AntiRecoil Vertical possède également un AntiRecoil Horizontal qui est composée d'une seule valeur :
		- AR Horiz qui est une valeur qui vous permet de corriger le recul horizontal de votre arme, si elle va à gauche ou à droite lorsque vous tirez, compensez à l'opposé


Chaque arme est différente et aura des valeurs d'AntiRecoil différentes.
AntiRecoil On Rumble est celui qui fonctionne le mieux pour la plupart des armes sans que vous ayez à modifier la valeur du mod

Comment regler?
Vous devez augmenter la valeur si votre arme continue à monter vers le ciel, et diminuer la valeur si vous tirez dans vos pieds, jusqu'a ce que vous trouvier une valeur qui convient bien
Faites des tests sur une vrai cible si possible ou dans un stand de tir plutot que contre un mur

Si vous jouez avec le stick droit inversé, réglez votre AntiRecoil Vertical avec des valeurs négatives

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

RapidFire : transforme une arme coup par coup en arme automatique en spammant la gâchette à votre place lorsque vous la maintenez enfoncée
	Il y a 3 types de RapidFire
	- Dynamic : aucun réglage à effectuer, plus vous appuyez sur la gâchette, plus ca tir vite
	- Rounds per min : n'a qu'une seule valeur réglable :
		- Rate Of Fire qui définit le nombre de cartouches tirées en une minute (RPM ou BPM de votre arme)
	- Rounds per sec : n'a qu'une seule valeur réglable :
		- Rate Of Fire qui définit le nombre de coups tirés en une seconde (RPS ou BPS de votre arme)

N'utilisez pas RapidFire avec une arme automatique, vous ralentiriez la cadence !

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

BurstFire : transforme une arme automatique en arme rafale en tirant en courtes rafales lorsque vous maintenez la gâchette enfoncée - vous permet d'avoir moins de recul et d'économiser des balles - Il a 2 valeurs ajustables
	- BF Hold qui est la durée pendant laquelle la gâchette est maintenue enfoncée
	- BF Release qui est la durée pendant laquelle la gâchette est relâchée

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

AIM Assist dessine un petit cercle (ou une autre forme) avec le stick droit pour faciliter le maintien de votre viseur dans la bulle virtuelle autour de votre ennemi
	Il existe 6 types différents d'AIM Assist
	- Sticky (non polaire)
	- Circular (dessine un cercle)
	- Tall Oval (dessine un Ovale verticale)
	- Wide Oval (dessine un Ovale horizontale)
	- Spiral
	- Helix
	
Ces différents types ont 2 valeurs ajustables :
	- Radius qui définit le rayon ou la taille de la forme dessinée
	
Plus le rayon est grand, plus vous aurez la sensation d'écran qui tremble, mais plus l'assistance sera forte
Plus il est petit, plus la sensation de tremblement disparaîtra, mais l'assistance sera moins forte

	- Steps est la vitesse à laquelle les formes sont dessinées.
	
Avec Sticky, plus la valeur est élevée, plus la vitesse à laquelle se dessine les formes est lente
Avec les autres formes (shapes), plus la valeur est élevée, plus la vitesse à laquelle se dessine les formes est rapide
Une vitesse trop rapide peut créer des ralentissements dans les mouvements du personnage

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

AIM Abuse va spammer le bouton de visée pour essayer d'abuser de l'autosnap présent dans le jeu (fonctionne bien avec des jeux comme GTA)
	Nous avons 2 valeurs ajustables :
		- Hold Time qui est le temps pendant lequel le bouton de visée restera enfoncé
		- Release Time qui est le temps pendant lequel le bouton sera relâché

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Shot Mod :
	Il existe 3 types de Shot Mod :
	- Strafe Shot vous permet de faire des pas de côté (de droite à gauche)
	- Jump Shot vous permet de sauter lorsque vous tirez (vous devez régler le bouton JUMP dans le menu)
	- Crouch Shot vous permet de vous accroupir ou de vous allonger lorsque vous tirez (vous devez définir le bouton CROUCH dans le menu)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Shot Activator vous permet de définir quand et comment le Shot Mod que vous avez choisi va démarrer
	Il y a 3 options possibles :
	- ADS + FIRE : le Shot Mod choisi démarrera lorsque vous appuierez sur les deux gâchettes.
	- ADS Only   : le Shot Mod choisi démarrera lorsque vous appuyez sur ADS et s'arrête lorsque vous appuyez sur FIRE
	- FIRE Only  : le Shot Mod choisi démarrera lorsque vous appuyez sur FIRE et s'arrête lorsque vous appuyez sur ADS

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Hold Breath permet de retenir automatiquement son souffle avec les Sniper

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Turbo Melee permet de spammer le bouton de corps à corps lorsque vous restez appuyé dessus

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Auto ADS permet d'appuyer sur ADS lorsque vous appuyez sur FIRE

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Auto FIRE permet d'appuyer sur FIRE lorsque vous appuyez sur ADS

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Sensibilité : permet de modifier la sensibilité de votre stick droit.
	Il y a 2 choix possibles :
	- Custom Sens vous permet de définir votre sensibilité dans 4 situations différentes (donc 4 valeurs ajustables)
		- General modifie votre sensibilité générale, quand vous vous déplacez, sans appuyer sur ADS ou FIRE
		- ADS modifie votre sensibilité lorsque vous maintenez la touche ADS enfoncée
		- FIRE modifie votre sensibilité lorsque vous maintenez la touche FIRE enfoncée
		- ADS + FIRE modifie votre sensibilité lorsque vous maintenez ADS et FIRE en même temps

	- Dynamic Sens vous permet de créer une courbe de sensibilité comme celles disponibles avec les manettes Elite - ce mod est assez compliqué à régler, voir l'exemple ci-dessous

	"Initial Sens" est votre sensibilité initiale X et Y (plage de valeurs 0 - 100)
		Par exemple, lorsque je vise, je veux que ma sensibilité, qui est fixée à 100% dans mon jeu, soit réduite de moitié tant que la position de mon stick ne dépasse pas la valeur de "Increase Point"
		Donc "DS Ini Sens" = 50 sur l'écran OLED

	"Increase Point" est la valeur limite du stick à partir duquel la sensibilité augmente progressivement(plage de valeurs de 0 à 100)
		Par exemple, lorsque la position du stick dépasse 65 (ma valeur "Increase Point"), la sensibilité augmente progressivement et passe de 50 (ma valeur "Initial Sens") à 100 (ma valeur "Max Sens")
		Le taux d'augmentation progressive de la sensibilité est défini par "Increase Rate"

	"Restart Point" est la valeur limite du stick à laquelle la sensibilité sera réinitialisée à "Initial Sens" (plage de valeurs 0 - 100)
		Lorsque la position du stick descend en dessous de 30 (ma valeur "Restart Point"), la sensibilité du stick revient à 50 (ma valeur "Initial Sens")

	"Max Sens" est la valeur de sensibilité maximale que vous souhaitez
		100 signifie que la sensibilité maximale sera celle que vous avez définie dans votre jeu

	"Increase Rate" definit à quelle cadence la sensibilité augmente ou réduit
		1 = 10ms de délai entre les augmentations

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- AutoRun vous permet de courir automatiquement lorsque vous poussez le stick vers l'avant (ou sur les côtés)
	Le mod maintient L3 (ou LS sur XBOX) lorsque vous poussez le stick gauche à plus de 90% - si votre jeu à l'option "maintenez pour courir" activez la

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Bunny Hop permet de spammer le bouton de saut lorsque vous le maintenez enfoncé

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Slide Cancel permet d'arreter l'annimation de slide dans CoD
	Il y a 2 types
		- Modern Warfare
		- Cold War

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Hair Trigger vous permet d'augmenter la sensibilité de vos gâchette L2/LT et R2/RT pour une réactivité inégalée

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Block Rumble permet de bloquer les vibrations de la manette si vous n'aimez pas jouer avec des vibrations
	Laissez les vibrations activées dans les options du jeu car AntiRecoil On Rumble a besoin que les vibrations soient activées dans le jeu pour fonctionner

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

															MERCI D'AVOIR LU TOUT CA
															MERCI D'AVOIR LU TOUT CA
															MERCI D'AVOIR LU TOUT CA
											
◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺
———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// M A I N   M E N U   N A M E  

// Main Menu Name
	const string MENUNAME[] = {
			"Mod Menu"    ,   "Controller"   ,  "Profiles"     // add as many as you want
// menuName_idx = 0       |        1         |      2     
	};
	
// Text: _MM mean Main Menu
	define 	MODMENU_MM = 0 , CONTROLLER_MM = 1 ,   PROFILES_MM = 2; // add as many as there are MENUNAME[]
	
// Index
	int menuName_idx;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// M O D S   N A M E   A N D   T O G G L E S

// Mod Name
	const string MODNAME[] = {
			"AntiRecoil"     , "RapidFire"    , "BurstFire"   , "AIM Assist"  , "AIM Abuse" , "Shot Mod" , 
// modName_idx = 0           |      1         |       2       |       3       |      4      |     5
			"Shot Activator" , " Hold Breath" , "Turbo Melee" , "Auto ADS"    , "Auto FIRE" , "Sensitivity" ,  "AutoRun"   , "Bunny Hop" , "Slide Cancel"
// modName_idx = 6           |       7        |       8       |       9       |      10     |       11      |     12      |     13      |      14
	};        
	
// Text: _M mean Mod name
	define 	ANTIRECOIL_M = 0, RAPIDFIRE_M = 1   , BURSTFIRE_M = 2  , AIMASSIST_M = 3 , AIMABUSE_M = 4  , SHOTMOD_M = 5      ,
	        SHOTACTIV_M = 6 , HOLDBREATH_M = 7  , TURBOMELEE_M = 8 , AUTOADS_M = 9   , AUTOFIRE_M = 10 , SENSITIVITY_M = 11 , AUTORUN_M = 12 , BUNNYHOP_M = 13 , SLIDECANCEL_M = 14; // add as many as there are MODNAME[]
	
// Index
	int modName_idx;
	
// Text 	
	const string ANTIRECOIL[] = { "OFF", "Progressive", "Standard", "On Rumble" };
	define PROGRESSIVE = 1, STANDARD = 2, ONRUMBLE = 3;
	
	const string RAPIDFIRE[] = { "OFF", "Dynamic", "Rounds per min", "Rounds per sec" };
	define DYNAMIC = 1, RPM = 2, RPS = 3;

	const string SHAPES[] = { "OFF", "Sticky", "Circular", "Tall Oval", "Wide Oval", "Spiral", "Helix" };
	define STICKY = 1, CIRCULAR = 2, TALLOVAL = 3, WIDEOVAL = 4, SPIRAL = 5, HELIX = 6;
	
	const string SHOT_MOD[] = { "OFF", "Strafe Shot", "Jump Shot", "Crouch Shot" };
	define STRAFE = 1, JUMP = 2, CROUCH = 3;
	
	const string SHOT_ACTIVATOR[] = { "ADS + FIRE", "ADS Only", "FIRE Only" };
	define ADSFIRE = 0, ADSONLY = 1, FIREONLY = 2;
	
	const string SENSITIVITY[] = { "OFF", "Custom Sens", "Dynamic Sens" };
	define CUSTOMSENS = 1, DYNAMICSENS = 2;
	
	const string SLIDECANCEL[] = { "OFF", "ModernWarfare", "ColdWar" };
	define MW = 1, CW = 2;
	
// Toggles for [3] Profiles: [profile_idx] = 0, 1 and 2
	int toggle_antirecoil[3];    // #1
	int toggle_rapidfire[3];     // #2
	int toggle_burstfire[3];     // #3
	int toggle_aimassist[3];     // #4
	int toggle_aimabuse[3];      // #5
	int toggle_shotMod[3];       // #6
	int toggle_shotActivator[3]; // #7
	int toggle_holdBreath[3];    // #8
	int toggle_turboMelee[3];    // #9
	int toggle_autoADS[3];       // #10
	int toggle_autoFIRE[3];      // #11
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 11;

// Toggles
	int toggle_sensitivity;
	int toggle_autorun;
	int toggle_bunnyHop;
	int toggle_slideCancel;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// V A L U E S   N A M E   A N D   V A R I A B L E S   F O R   V A L U E S

// Value Name
	const string VALNAME [] = {
			"AR Start"     , "AR End"         , "AR Time"       , "AR Horiz" , "Rumble Power"  , "Rate of Fire" , 
// valName_idx = 0         |       1          |      2          |       3    |       4         |       5
 			"BF Hold"      , "BF Release"     , "Radius"        , "Steps"    , "Hold Time"     , "Release Time" , "Strafe Time",
// valName_idx = 6         |       7          |      8          |       9    |       10        |     11         |       12
 			"Initial Sens" , "Increase Point" , "Restart Point" , "Max Sens" , "Increase Rate" , "General"      , "ADS"        , "FIRE" , "ADS + FIRE" , "Cancel Time"
// valName_idx = 13        |      14          |      15         |      16    |      17         |       18       |      19      |   20   |      21      |    
	};	
	
// Text: _V mean VALNAME
	define 	START_V = 0      , END_V = 1        , TIME_V = 2       , HORIZ_V = 3     , RUMBLEPOWER_V = 4, RATE_V = 5        ,
	        BFHOLD_V = 6     , BFRELEASE_V = 7  , RADIUS_V = 8     , STEPS_V = 9     , HOLDTIME_V = 10  , RELEASETIME_V = 11,  
	        STRAFETIME_V = 12, DSINITIAL_V = 13 , DSINCREASE_V = 14, DSRESTART_V = 15, DSMAX_V = 16     , DSRATE_V = 17     , 
	        GENERAL_V = 18   , ADS_V = 19       , FIRE_V = 20      , ADSFIRE_V = 21  , CANCELTIME_V = 22; // add as many as there are VALNAME[]

// Index 
	int valName_idx;

// Adjustable values for [3] profiles: [profile_idx] = 0, 1 and 2 
	int antirecoil_start[3];
	int antirecoil_end[3];
	int antirecoil_time[3];
	int antirecoil_horizontal[3];
	int rumble_power[3];
	int rate_of_fire[3];

// Adjustable values
	// BurstFire values
	int burstfire_hold; // BurstFire has toggle for each profile BUT the same values for each profile
	int burstfire_release;
	
	// AIM Assist values
	int aimassist_radius; // AIM Assist has toggle for each profile BUT the same values for each profile
	int aimassist_angle;
	
	// AIM Abuse values
	int aimabuse_hold;
	int aimabuse_release;
	
	// Strafe Shot value
	int strafe_time; // StrafeShot has a toggle for each profile BUT the same value for each profile
	
  // Custom Sens values
	int genSens;
	int adsSens;
	int hipSens;
	int adsfireSens;
	int customsens;
	
  // Dynamic Sens values
	int dynasens_initial_sens;
	int dynasens_limit;
	int dynasens_restart;
	int dynasens_max_sens;
	int dynasens_increase_rate;
	
// Slide Cancel Time
	int cancel_time;
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// C O N T R O L L E R   M E N U   N A M E  

// Controller Menu Name
	const string CONTROLLERNAME[] = {
			        "ADS BTN"    , "Fire BTN"  , "Tactical BTN" , "Lethal BTN" , "Jump BTN"     , "Crouch BTN"    ,
// controllerName_idx = 0        |      1      |         2      |       3      |      4         |        5        |    
                    "Reload BTN" , "Melee BTN" , "Sprint BTN"   , "Weapon BTN" , "Hair Trigger" , "Block Rumble"    
// controllerName_idx =   6      |       7     |       8        |       9      |       10       |     11
	};

// Text: _C mean Controller menu
	define ADS_BTN_C = 0    , FIRE_BTN_C = 1 , TACTICAL_BTN_C = 2, LETHAL_BTN_C = 3, JUMP_BTN_C = 4    , CROUCH_BTN_C = 5, 
	       RELOAD_BTN_C =  6, MELEE_BTN_C = 7, SPRINT_BTN_C = 8  , WEAPON_BTN_C = 9, HAIRTRIGGER_C = 10, RUMBLE_C = 11 ; // add as many as there are CONTROLLERNAME[]
	
	int controllerName_idx;
	
	const string LAYOUT_BTN_PS[] = { "L2"  , "R2"  , "L1"  , "R1"  , "CROSS"   , "CIRCLE"  , "SQUARE"  , "R3"  , "L3"  , "TRIANGLE"   };
	const string LAYOUT_BTN_XB[] = { "LT"  , "RT"  , "LB"  , "RB"  , "A"       , "B"       , "X"       , "RS"  , "LS"  , "Y"          };
	const uint8 BTN[]            = { PS4_L2, PS4_R2, PS4_L1, PS4_R1, PS4_CROSS , PS4_CIRCLE, PS4_SQUARE, PS4_R3, PS4_L3, PS4_TRIANGLE };
	
	int toggle_ads_btn;
	int toggle_fire_btn;
	int toggle_tactical_btn;
	int toggle_lethal_btn;
	int toggle_jump_btn;
	int toggle_crouch_btn;
	int toggle_reload_btn;
	int toggle_melee_btn;
	int toggle_sprint_btn;
	int toggle_weapon_btn;
	int toggle_hairTrigger;
	int toggle_rumble;	

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// P R O F I L E S   M E N U   N A M E 

// Profiles Menu Name
	const string PROFILESNAME[] = {
			        "Prim/Sec BTN" ,   "Custom Profile" ,   "Resync BTNs"}; // add as many as you want
// controllerName_idx = 0          |        1           |           2

// Text: _P mean Profile menu
	define 	       PRIM_SEC_P = 0  ,    CUSTOM_P = 1    ,    RESYNC_P = 2 ; // add as many as there are PROFILESNAME[]	
	
	int profilesName_idx;

	const string PROFILEBTN_PS[] = { "" ,  "L2" , "R2"  , "L1"  , "R1"  , "CROSS"  , "CIRCLE"  , "SQUARE"  , "TRIANGLE"  , "R3"  , "L3"  , "Dpad UP", "Dpad DOWN", "Dpad LEFT", "Dpad RIGHT"};
	const string PROFILEBTN_XB[] = { "" ,  "LT" , "RT"  , "LB"  , "RB"  , "A"      , "B"       , "X"       , "Y"         , "RS"  , "LS"  , "Dpad UP", "Dpad DOWN", "Dpad LEFT", "Dpad RIGHT"};
	//         toggle_xxxxxBTN[] =   0  |    1  |   2   |   3   |   4   |    5     |     6     |     7     |      8      |   9   |   10  |     11   |      12    |      13    |      14
	const int8 PROFILE_BTN[]   = { -1  , PS4_L2, PS4_R2, PS4_L1, PS4_R1, PS4_CROSS, PS4_CIRCLE, PS4_SQUARE, PS4_TRIANGLE, PS4_R3, PS4_L3, PS4_UP   , PS4_DOWN   , PS4_LEFT   , PS4_RIGHT   };
	
	int toggle_pressBTN[3];
	int toggle_holdBTN[3];  

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// M I S C   V A R I A B L E S

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for functions 
	int i;

data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_info;
	int display_black;
	int screensaver;

// ModMenu / ModEdit / KillSwitch ...
	int MainMenu;
	int ModMenu;	
	int ModEdit;
	int ControllerMenu;
	int ProfilesMenu;
	int KillSwitch;

// Anti Recoil  
	//int rumble;
	int rumble_recoil;
	int antirecoil_boost;
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter / Timer
	int count_black; 
	int info_timer;
	
// Profiles
	int custom_profile;
	int profile_idx; 
 	
//Misc
	int currentSlot;
	int current_info;
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// I N I T   S E C T I O N 

init{
					// Load default/stored values
// Toggles
	pmemValue = get_pvar(SPVAR_1, 1, 32767, 0);
	toggle_burstfire[0]    = get_15var(pmemValue,  0);	toggle_burstfire[1]  = get_15var(pmemValue,  1);	toggle_burstfire[2]  = get_15var(pmemValue,  2);	
	toggle_aimabuse[0]     = get_15var(pmemValue,  3);	toggle_aimabuse[1]   = get_15var(pmemValue,  4);	toggle_aimabuse[2]   = get_15var(pmemValue,  5);	
	toggle_autoADS[0]      = get_15var(pmemValue,  6);	toggle_autoADS[1]    = get_15var(pmemValue,  7);	toggle_autoADS[2]    = get_15var(pmemValue,  8);	
	toggle_autoFIRE[0]     = get_15var(pmemValue,  9);	toggle_autoFIRE[1]   = get_15var(pmemValue, 10);	toggle_autoFIRE[2]   = get_15var(pmemValue, 11);	
	toggle_holdBreath[0]   = get_15var(pmemValue, 12);	toggle_holdBreath[1] = get_15var(pmemValue, 13);	toggle_holdBreath[2] = get_15var(pmemValue, 14);
	
	pmemValue = get_pvar(SPVAR_2, 1, 32767, 0);
	toggle_turboMelee[0]   = get_15var(pmemValue,  0);	toggle_turboMelee[1] = get_15var(pmemValue,  1);	toggle_turboMelee[2] = get_15var(pmemValue,  2);	
	toggle_autorun         = get_15var(pmemValue,  3);  toggle_bunnyHop      = get_15var(pmemValue,  4);    toggle_hairTrigger   = get_15var(pmemValue,  5);  
	toggle_rumble          = get_15var(pmemValue,  6);
	
	pmemValue = get_pvar(SPVAR_3, -32768, 32767, 0);
	toggle_antirecoil[0] = get_4var(pmemValue, 3);		toggle_antirecoil[1] = get_4var(pmemValue, 2);		toggle_antirecoil[2] = get_4var(pmemValue, 1)     toggle_slideCancel = get_4var(pmemValue, 0);
	
	pmemValue = get_pvar(SPVAR_4, -32768, 32767, 0);
	toggle_rapidfire[0] = get_4var(pmemValue, 3);		toggle_rapidfire[1] = get_4var(pmemValue, 2);		toggle_rapidfire[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_5, -32768, 32767, 0);
	toggle_aimassist[0] = get_4var(pmemValue, 3);		toggle_aimassist[1] = get_4var(pmemValue, 2);		toggle_aimassist[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_6, -32768, 32767, 0);
	toggle_shotMod[0] = get_4var(pmemValue, 3);		    toggle_shotMod[1] = get_4var(pmemValue, 2);		    toggle_shotMod[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_7, -32768, 32767, 0);
	toggle_shotActivator[0] = get_4var(pmemValue, 3);   toggle_shotActivator[1] = get_4var(pmemValue, 2);	toggle_shotActivator[2] = get_4var(pmemValue, 1);    toggle_sensitivity = get_4var(pmemValue, 0);

	// Controller BTNs	
	pmemValue = get_pvar(SPVAR_8, 1, 32767, set_2var(0, 1));
	toggle_ads_btn = get_2var(pmemValue, 0);		toggle_fire_btn = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_9, 1, 32767, set_2var(2, 3));
	toggle_tactical_btn = get_2var(pmemValue, 0);		toggle_lethal_btn = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_10, 1, 32767, set_2var(4, 5));
	toggle_jump_btn = get_2var(pmemValue, 0);		toggle_crouch_btn = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_11, 1, 32767, set_2var(6, 7));
	toggle_reload_btn = get_2var(pmemValue, 0);		toggle_melee_btn = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_12, 1, 32767, set_2var(8, 9));
	toggle_sprint_btn = get_2var(pmemValue, 0);		toggle_weapon_btn = get_2var(pmemValue, 1);
	
	// Profile Hold/Press BTNs	
	pmemValue = get_pvar(SPVAR_13, -32768, 32767, 0);
	toggle_pressBTN[0] = get_4var(pmemValue, 3);   toggle_pressBTN[1] = get_4var(pmemValue, 2);	toggle_pressBTN[2] = get_4var(pmemValue, 1);   
	
	pmemValue = get_pvar(SPVAR_14, -32768, 32767, 0);
	toggle_holdBTN[0] = get_4var(pmemValue, 3);   toggle_holdBTN[1] = get_4var(pmemValue, 2);	toggle_holdBTN[2] = get_4var(pmemValue, 1); 
	
// Values		
	// Antirecoil vertical values
	pmemValue = get_pvar(SPVAR_15, -32768, 32767, 0);
	antirecoil_start[0] = get_2var(pmemValue, 0);		antirecoil_end[0] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_16, -32768, 32767, 0);
	antirecoil_start[1] = get_2var(pmemValue, 0);		antirecoil_end[1] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_17, -32768, 32767, 0);
	antirecoil_start[2] = get_2var(pmemValue, 0);		antirecoil_end[2] = get_2var(pmemValue, 1);
	
	antirecoil_time[0] = get_pvar(SPVAR_18, -32768, 32767, 0);
	antirecoil_time[1] = get_pvar(SPVAR_19, -32768, 32767, 0);
	antirecoil_time[2] = get_pvar(SPVAR_20, -32768, 32767, 0);

	// Antirecoil horizontal & rumble recoil values
	pmemValue = get_pvar(SPVAR_21, -32768, 32767, 0);
	antirecoil_horizontal[0] = get_2var(pmemValue, 0);		rumble_power[0] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_22, -32768, 32767, 0);
	antirecoil_horizontal[1] = get_2var(pmemValue, 0);		rumble_power[1] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_23, -32768, 32767, 0);
	antirecoil_horizontal[2] = get_2var(pmemValue, 0);		rumble_power[2] = get_2var(pmemValue, 1);	
	
	// Rate of fire values
	rate_of_fire[0] = get_pvar(SPVAR_24, -32768, 32767, 0);
	rate_of_fire[1] = get_pvar(SPVAR_25, -32768, 32767, 0);
	rate_of_fire[2] = get_pvar(SPVAR_26, -32768, 32767, 0);
	
	// BurstFire values
	burstfire_hold     = get_pvar(SPVAR_27, 1,  1000, 120);
	burstfire_release  = get_pvar(SPVAR_28, 1,  1000, 120);
	
	// AIM Assist values
	pmemValue = get_pvar(SPVAR_29, 1, 32767, set_2var(20, 15));
	aimassist_radius = get_2var(pmemValue, 0);		aimassist_angle = get_2var(pmemValue, 1);
	
	// AIM Abuse values
	aimabuse_hold     = get_pvar(SPVAR_30, 1, 500, 100);
	aimabuse_release  = get_pvar(SPVAR_31, 1, 500,  50);
	
	// StrafeShot value
	strafe_time = get_pvar(SPVAR_32, 1, 10000, 500);
	
	// Custom Sens values
	genSens     = get_pvar(SPVAR_33, 1, 327, 100);
	adsSens     = get_pvar(SPVAR_34, 1, 327, 100);
	hipSens     = get_pvar(SPVAR_35, 1, 327, 100);
	adsfireSens = get_pvar(SPVAR_36, 1, 327, 100);
	
	// Dynamic Sens values
	dynasens_initial_sens = get_pvar(SPVAR_37, 1, 327, 60 );
	
	pmemValue = get_pvar(SPVAR_38, 1, 32767, set_2var(80, 30));
	dynasens_limit   = get_2var(pmemValue, 0);		dynasens_restart = get_2var(pmemValue, 1);
	
	dynasens_max_sens      = get_pvar(SPVAR_39, 1, 327, 100);
	dynasens_increase_rate = get_pvar(SPVAR_40, 1, 50 , 1  );
	
	// Slide Cancel Time
	cancel_time     = get_pvar(SPVAR_41, 1, 300, 80);
	
	
// Get current slot
	currentSlot = get_slot();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// M A I N   S E C T I O N   S T A R T   
main { // main section start
////////////////////////////////////////////////////////////////////////////////////////////////////////// D E B U G   

	set_val(TRACE_1, toggle_antirecoil[profile_idx]);
	set_val(TRACE_2, speed_toggle_UP[profile_idx]);
	set_val(TRACE_3, toggle_rapidfire[profile_idx]);
	set_val(TRACE_4, speed_toggle_RIGHT[profile_idx]);

////////////////////////////////////////////////////////////////////////////////////////////////////////// C R O S S O V E R   P S 4  /  X B O X

    // If PS4 console:
    if(get_console() == PIO_PS4)
    {
    	if(get_controller() != PIO_PS4) // If not PS4 controller:
    	{
        	if(get_ival(PS4_SHARE)) // View
        	{
        		if(get_ival(PS4_R3)) // RS + View =  ScreenShot
        		{
					set_val(PS4_SHARE,100);
                	set_val(PS4_TOUCH,0);
                	set_val(PS4_R3,0);
        		}
        		else // View only = Touch Pad
        		{
        			set_val(PS4_TOUCH, 100);
        			set_val(PS4_SHARE, 0);
        		}
        	}
    	}
    }
    // If XBOX console:
    else if(get_console() == PIO_XB360)
	{
		if(get_controller() == PIO_PS4) // If PS4 controller:
			swap(PS4_TOUCH, PS4_SHARE);
	}
	
////////////////////////////////////////////////////////////////////////////////////////////////////////// K I L L S W I T C H   T O G G L E 

	if(!MainMenu && !ModMenu && !ModEdit && !ControllerMenu && !ProfilesMenu)
	{
	// KillSwitch ON or OFF method
		if( (get_ival(PS4_L2) && event_press(PS4_SHARE)) || (!get_ival(PS4_L2) && event_press(PS4_PS)) )
		{			
			KillSwitch = !KillSwitch;
			
			if(KillSwitch) 
				combo_run(RUMBLE_OFF);	
				
			else
			{
				combo_run(RUMBLE_ON);
				display_title = TRUE;	
			}
		}
		
	// KillSwitch - exit method (FALSE, script is actived)
		if(KillSwitch) 
		{
    		screensaver= FALSE;
			count_black = 0;
	
			if(event_press(PS4_CIRCLE) && get_brtime(PS4_CIRCLE) < 200) // Double tap CIRCLE/B  to exit
			{
				KillSwitch = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE; 
			}
			combo_run(KILLSWITCH);
		}
		else 
			combo_stop(KILLSWITCH);
			
	// Block button	
		if(get_ival(PS4_L2))
		{
			if(get_controller() != PIO_PS4) 
				set_val(PS4_TOUCH, 0);
			else
				set_val(PS4_SHARE, 0);
		}
	}
	
////////////////////////////////////////////////////////////////////////////////////////////////////////// S C R I P T   A C T I V E 

	if(!KillSwitch)
	{
/////////////////////////////////////////////////////////////////////////////////////////// M A I N   M E N U   T O G G L E

		if(get_ival(PS4_L2))
		{	
			if(event_release(PS4_OPTIONS))
			{
				cls_oled(OLED_BLACK);
    			
				if(ModEdit)
				{
					ModEdit = FALSE;
					display_title = TRUE;   
				}
				else if(ModMenu)
				{
					ModMenu = FALSE;
					display_title = TRUE; 
				}
				else if(ControllerMenu)
				{
					ControllerMenu = FALSE;
					display_title = TRUE; 
				}
				else if(ProfilesMenu)
				{
					ProfilesMenu = FALSE;
					display_title = TRUE; 
				}
				else 
					MainMenu = !MainMenu;
					
				if(!MainMenu)
				{
					combo_run(RUMBLE_OFF); 
					display_title = TRUE;  
				}
				else if(MainMenu)
				{
					menuName_idx = MODMENU_MM;        
					current_info = 0;		
					combo_run(RUMBLE_ON);
					draw_main_menu();
					display_new = TRUE;
					display_info = TRUE;
				}
			}
			set_val(PS4_OPTIONS, 0);
		} // L2/LT section end

/////////////////////////////////////////////////////////////////////////////////////////// A N Y   M E N U   A C T I V E

		if(ModMenu || ModEdit || MainMenu || ControllerMenu || ProfilesMenu)  
		{		
		// Buttons animation / Menus Navigation
			button_animation(); 
			
		//Stop screen Saver
    		screensaver = FALSE;
			count_black = 0;
			
		// Timer to display user infos
			info_timer += get_rtime();
	
			if(info_timer > 2000)
			{
				current_info ++;
				display_info = TRUE;
			}
			
		// Save everything and EXIT
			if(!get_ival(PS4_L2) && event_release(PS4_PS))
				save();
				
		// block ALL inputs 
			block_btn(); // user function
		}
		
/////////////////////////////////////////////////////////////////////////////////////////// M A I N   M E N U   A C T I V E

		/*if(MainMenu){}*/
		
/////////////////////////////////////////////////////////////////////////////////////////// M O D S   M E N U   A C T I V E

		if(ModMenu) 
		{
////////////////////////////////////////////////////////// TOGGLE FOR MODS

		// Tap UP or DOWN to turn ON/OFF
	   		// Mods that may have different ON/OFF status depending on the active Profile
			toggle_antirecoil[profile_idx]    = toggle( modName_idx, ANTIRECOIL_M , ANTIRECOIL_TXT     , toggle_antirecoil[profile_idx]    );
			toggle_rapidfire[profile_idx]     = toggle( modName_idx, RAPIDFIRE_M  , RAPIDFIRE_TXT      , toggle_rapidfire[profile_idx]     );
			toggle_burstfire[profile_idx]     = toggle( modName_idx, BURSTFIRE_M  , ONOFF_TXT          , toggle_burstfire[profile_idx]     );
			toggle_aimassist[profile_idx]     = toggle( modName_idx, AIMASSIST_M  , SHAPES_TXT         , toggle_aimassist[profile_idx]     );
			toggle_aimabuse[profile_idx]      = toggle( modName_idx, AIMABUSE_M   , ONOFF_TXT          , toggle_aimabuse[profile_idx]      );
			toggle_shotMod[profile_idx]       = toggle( modName_idx, SHOTMOD_M    , SHOT_MOD_TXT       , toggle_shotMod[profile_idx]       );
			toggle_shotActivator[profile_idx] = toggle( modName_idx, SHOTACTIV_M  , SHOT_ACTIVATOR_TXT , toggle_shotActivator[profile_idx] );
			toggle_holdBreath[profile_idx]    = toggle( modName_idx, HOLDBREATH_M , ONOFF_TXT          , toggle_holdBreath[profile_idx]    );
			toggle_turboMelee[profile_idx]    = toggle( modName_idx, TURBOMELEE_M , ONOFF_TXT          , toggle_turboMelee[profile_idx]    );
			toggle_autoADS[profile_idx]       = toggle( modName_idx, AUTOADS_M    , ONOFF_TXT          , toggle_autoADS[profile_idx]       );
			toggle_autoFIRE[profile_idx]      = toggle( modName_idx, AUTOFIRE_M   , ONOFF_TXT          , toggle_autoFIRE[profile_idx]      );
		
		// Mods that have same ON/OFF status on every Profiles
			toggle_sensitivity = toggle( modName_idx, SENSITIVITY_M , SENSITIVITY_TXT , toggle_sensitivity );
			toggle_autorun     = toggle( modName_idx, AUTORUN_M     , ONOFF_TXT       , toggle_autorun     );
			toggle_bunnyHop    = toggle( modName_idx, BUNNYHOP_M    , ONOFF_TXT       , toggle_bunnyHop    );
			toggle_slideCancel = toggle( modName_idx, SLIDECANCEL_M , SLIDECANCEL_TXT , toggle_slideCancel );
		} // ModMenu section end
		
/////////////////////////////////////////////////////////////////////////////////////////// E D I T   M E N U   A C T I V E

		if(ModEdit) 
		{
////////////////////////////////////////////////////////// EDIT ADJUSTABLE VALUES

		// Edit value: hold CROSS/A + UP (+1 or +10) or DOWN (-1 or -10) or RIGHT (+10 or +100) or LEFT (-10 or -100)	
			if(get_ival(PS4_CROSS)) 
			{
			// Mods that may have different values depending on the active Profile                                 val min, val max, inc/dec R/L, increase/decrease UP/DOWN 
				antirecoil_start[profile_idx]      = edit_val( START_V       , antirecoil_start[profile_idx]     ,    -99 ,     99 ,          1 ,          10               ); 
				antirecoil_end[profile_idx]        = edit_val( END_V         , antirecoil_end[profile_idx]       ,    -99 ,     99 ,          1 ,          10               ); 
				antirecoil_time[profile_idx]       = edit_val( TIME_V        , antirecoil_time[profile_idx]      ,      0 ,  10000 ,        100 ,        1000               );  
				antirecoil_horizontal[profile_idx] = edit_val( HORIZ_V       , antirecoil_horizontal[profile_idx],    -99 ,     99 ,          1 ,          10               ); 
				rumble_power[profile_idx]          = edit_val( RUMBLEPOWER_V , rumble_power[profile_idx]         ,    -60 ,     60 ,          1 ,          10               );
				if(toggle_rapidfire[profile_idx] == RPM)
					rate_of_fire[profile_idx]      = edit_val( RATE_V        , rate_of_fire[profile_idx]         ,     60 ,    750 ,          1 ,          10               );
				else if(toggle_rapidfire[profile_idx] == RPS)
					rate_of_fire[profile_idx]      = edit_val( RATE_V        , rate_of_fire[profile_idx]         ,      1 ,     25 ,          1 ,          10               );
				
			// Mods that have same value on every Profiles
				burstfire_hold         = edit_val( BFHOLD_V      , burstfire_hold         , 0 ,  1000 , 10 , 100 );
				burstfire_release      = edit_val( BFRELEASE_V   , burstfire_release      , 0 ,  1000 , 10 , 100 );
				aimassist_radius       = edit_val( RADIUS_V      , aimassist_radius       , 0 ,    50 ,  1 ,  10 );
				aimassist_angle        = edit_val( STEPS_V       , aimassist_angle        , 0 ,   500 ,  1 ,  10 );  
				aimabuse_hold          = edit_val( HOLDTIME_V    , aimabuse_hold          , 0 ,   500 , 10 , 100 );
				aimabuse_release       = edit_val( RELEASETIME_V , aimabuse_release       , 0 ,   500 , 10 , 100 );
				dynasens_initial_sens  = edit_val( DSINITIAL_V   , dynasens_initial_sens  , 0 ,   327 , 1  , 10  );
				dynasens_limit         = edit_val( DSINCREASE_V  , dynasens_limit         , 0 ,   100 , 1  , 10  );
				dynasens_restart       = edit_val( DSRESTART_V   , dynasens_restart       , 0 ,   100 , 1  , 10  );
				dynasens_max_sens      = edit_val( DSMAX_V       , dynasens_max_sens      , 0 ,   327 , 1  , 10  );
				dynasens_increase_rate = edit_val( DSRATE_V      , dynasens_increase_rate , 1 ,    50 , 1  , 10  );
				genSens                = edit_val( GENERAL_V     , genSens                , 1 ,   327 , 1  , 10  );
				adsSens                = edit_val( ADS_V         , adsSens                , 1 ,   327 , 1  , 10  );
				hipSens                = edit_val( FIRE_V        , hipSens                , 1 ,   327 , 1  , 10  );
				adsfireSens            = edit_val( ADSFIRE_V     , adsfireSens            , 1 ,   327 , 1  , 10  );
				cancel_time            = edit_val( CANCELTIME_V  , cancel_time            , 1 ,   200 , 1  , 10  );
			} // CROSS/A section end	
			
////////////////////////////////////////////////////////// FINDS THE VALUES AVAILABLE FOR EACH OF THE MODS

			else // if NOT CROSS/A
			{	
				if(modName_idx == ANTIRECOIL_M)  
				{
				// AntiRecoil On Rumble
					if(toggle_antirecoil[profile_idx] == ONRUMBLE) 
						valName_idx = cycle(valName_idx, HORIZ_V, RUMBLEPOWER_V );   // from HORIZ_V to RUMBLEPOWER_V
				// AntiRecoil Standard
					else if(toggle_antirecoil[profile_idx] == STANDARD)
						valName_idx = cycle(valName_idx, END_V , HORIZ_V  ); // END_V and HORIZ_V only
				// AntiRecoil Progressive
					else 
						valName_idx = cycle(valName_idx, START_V  , HORIZ_V     ); // from START_V to HORIZ_V
				}
				if(modName_idx == RAPIDFIRE_M)   valName_idx = cycle(valName_idx, RATE_V      , RATE_V        ); // RATE_V only
				if(modName_idx == BURSTFIRE_M)   valName_idx = cycle(valName_idx, BFHOLD_V    , BFRELEASE_V   ); // from BFHOLD_V to BFRELEASE_V
				if(modName_idx == AIMASSIST_M)   valName_idx = cycle(valName_idx, RADIUS_V    , STEPS_V       ); // from RADIUS_V to STEPS_V
				if(modName_idx == AIMABUSE_M )   valName_idx = cycle(valName_idx, HOLDTIME_V  , RELEASETIME_V ); // HOLDTIME_V and  RELEASETIME_V
				if(modName_idx == SHOTMOD_M  )   valName_idx = cycle(valName_idx, STRAFETIME_V, STRAFETIME_V  ); // STRAFETIME_V only
				
				if(modName_idx == SENSITIVITY_M) // Sensitivity
				{
				// Custom Sens
					if(toggle_sensitivity == CUSTOMSENS)
						valName_idx = cycle(valName_idx, GENERAL_V, ADSFIRE_V ); // from GENERAL_V to ADSFIRE_V
				// DynaSens
					else if(toggle_sensitivity == DYNAMICSENS)
						valName_idx = cycle(valName_idx, DSINITIAL_V, DSRATE_V ); // from DSINITIAL_V to DSRATE_V
				}
				
				if(modName_idx == SLIDECANCEL_M  )   valName_idx = cycle(valName_idx, CANCELTIME_V, CANCELTIME_V  ); // CANCELTIME_V only
			} // NOT EDIT_BTN section end
			
		} // ModEdit section end	
		
/////////////////////////////////////////////////////////////////////////////////////////// C O N T R O L L E R   M E N U   A C T I V E

		if(ControllerMenu)
		{
////////////////////////////////////////////////////////// CHOOSE THE LAYOUT OF THE BUTTONS / TOGGLE HAIR TRIGGER AND BLOCK RUMBLE

			toggle_ads_btn      = toggle( controllerName_idx, ADS_BTN_C      , LAYOUT_BTN_PS_TXT, toggle_ads_btn      );
			toggle_fire_btn     = toggle( controllerName_idx, FIRE_BTN_C     , LAYOUT_BTN_PS_TXT, toggle_fire_btn     );
			toggle_tactical_btn = toggle( controllerName_idx, TACTICAL_BTN_C , LAYOUT_BTN_PS_TXT, toggle_tactical_btn );
			toggle_lethal_btn   = toggle( controllerName_idx, LETHAL_BTN_C   , LAYOUT_BTN_PS_TXT, toggle_lethal_btn   );
			toggle_jump_btn     = toggle( controllerName_idx, JUMP_BTN_C     , LAYOUT_BTN_PS_TXT, toggle_jump_btn     );
			toggle_crouch_btn   = toggle( controllerName_idx, CROUCH_BTN_C   , LAYOUT_BTN_PS_TXT, toggle_crouch_btn   );
			toggle_reload_btn   = toggle( controllerName_idx, RELOAD_BTN_C   , LAYOUT_BTN_PS_TXT, toggle_reload_btn   );
			toggle_melee_btn    = toggle( controllerName_idx, MELEE_BTN_C    , LAYOUT_BTN_PS_TXT, toggle_melee_btn    );
			toggle_sprint_btn   = toggle( controllerName_idx, SPRINT_BTN_C   , LAYOUT_BTN_PS_TXT, toggle_sprint_btn   );
			toggle_weapon_btn   = toggle( controllerName_idx, WEAPON_BTN_C   , LAYOUT_BTN_PS_TXT, toggle_weapon_btn   );
			toggle_hairTrigger  = toggle( controllerName_idx, HAIRTRIGGER_C  , ONOFF_TXT        , toggle_hairTrigger  );
			toggle_rumble       = toggle( controllerName_idx, RUMBLE_C       , ONOFF_TXT        , toggle_rumble       );
		}
		
/////////////////////////////////////////////////////////////////////////////////////////// P R O F I L E   M E N U   A C T I V E

		/*if(ProfilesMenu){}*/
		
/////////////////////////////////////////////////////////////////////////////////////////// M O D S   S E C T I O N
		if(!MainMenu && !ModMenu && !ControllerMenu && !ProfilesMenu) 
		{
		
////////////////////////////////////////////////////////// MODS THAT ONLY WORK OUTSIDE ALL MENUS

			if(!ModEdit)
			{
			// Hair Trigger
				if(toggle_hairTrigger)
					deadzone(PS4_L2, PS4_R2, 99, 99);
					
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// Auto ADS / Auto FIRE
				if(toggle_autoADS[profile_idx])
				{
					if(get_val(BTN[toggle_fire_btn]))
						set_val(BTN[toggle_ads_btn], 100);
				}
				
				if(toggle_autoFIRE[profile_idx])
				{
					if(get_val(BTN[toggle_ads_btn]))
						set_val(BTN[toggle_fire_btn], 100);
				}
				
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// Block controller rumbles
				if(toggle_rumble)
					block_rumble();
					
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// Switch profile
				// ReSync
				if(get_val(PROFILE_BTN[toggle_holdBTN[RESYNC_P]]) )
				{
					if(event_press(PROFILE_BTN[toggle_pressBTN[RESYNC_P]]) )
					{
						if(PROFILE_BTN[toggle_holdBTN[CUSTOM_P]] == 0 || PROFILE_BTN[toggle_pressBTN[CUSTOM_P]] == 0)
							profile_idx = cycle(profile_idx++, 0, 1);
						else
							profile_idx = cycle(profile_idx++, 0, 2);
							
						display_title = TRUE;
					}
					set_val(PROFILE_BTN[toggle_pressBTN[RESYNC_P]], 0)
				}
				
				// Custom
				else if(get_val(PROFILE_BTN[toggle_holdBTN[CUSTOM_P]]) )
				{
					
					if(event_press(PROFILE_BTN[toggle_pressBTN[CUSTOM_P]]) )
					{
						if(custom_profile == 0)
							custom_profile = 2;
						else
							custom_profile = 0;
							
						profile_idx = custom_profile;
						display_title = TRUE;
					}
					set_val(PROFILE_BTN[toggle_pressBTN[CUSTOM_P]], 0)
					
				}
				
				// Primary / Secondary
				else if(event_press(PROFILE_BTN[toggle_pressBTN[PRIM_SEC_P]]) )
				{
					if(custom_profile < 2)
						profile_idx = !profile_idx;
						
					display_title = TRUE;
				}
				if(profile_idx < 2)
					custom_profile = 0;
				else 
					custom_profile = 2;
					
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// Hold Breath
				if(toggle_holdBreath[profile_idx])
				{
					if(isqrt(pow(abs(get_ival(PS4_LX)),2) + pow(abs(get_ival(PS4_LY)),2)) <= 50)
					{
						if(get_val(BTN[toggle_ads_btn]))
							set_val(BTN[toggle_sprint_btn], 100);
							
						if(event_press(BTN[toggle_ads_btn]))
							combo_run(HOLD_BREATH);
					}
				}
					
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// Turbo Melee
				if(toggle_turboMelee[profile_idx])
				{
					if(get_val(BTN[toggle_melee_btn]) && get_ptime(BTN[toggle_jump_btn]) > 200)
					{
						combo_btn = BTN[toggle_melee_btn];
						combo_wait = 40;
						combo_run(SPAM);
					}
				}
					
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
				
			// Custom Sensitivity
		    	if(toggle_sensitivity == 1)
		    	{	
		    		if(isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 8)
		    		{
			    		if(!get_val(BTN[toggle_ads_btn]) && !get_val(BTN[toggle_fire_btn]))
							customsens = genSens;
						else if(get_val(BTN[toggle_ads_btn]) && !get_val(BTN[toggle_fire_btn]))
							customsens = adsSens;
						else if(!get_val(BTN[toggle_ads_btn]) && get_val(BTN[toggle_fire_btn]))
							customsens = hipSens;
						if(get_val(BTN[toggle_ads_btn]) && get_val(BTN[toggle_fire_btn]))
							customsens = adsfireSens;
				
						sensitivity(PS4_RY,NOT_USE,customsens);
						sensitivity(PS4_RX,NOT_USE,customsens);
					}
		    	}
		    	
			// Dynamic Sensitivity
		    	else if(toggle_sensitivity == 2)
		    	{	
		    		if((get_val(BTN[toggle_ads_btn]) || get_val(BTN[toggle_fire_btn])) && isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 20)
		    			set_sens();
		    	}
		    	
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
				
			/* AutoRun 
			   push the left stick 90% forward or to the sides to run - hold to sprint must be enable */
				if(toggle_autorun)
				{
					if((isqrt(pow(abs(get_ival(PS4_LX)),2) + pow(abs(get_ival(PS4_LY)),2)) >= 90) && get_ival(PS4_LY) < 20 && !get_val(BTN[toggle_ads_btn]) && !get_val(BTN[toggle_fire_btn]))
						set_val(BTN[toggle_sprint_btn], 100);
				}
				
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
			// Shot Mods
				if(toggle_shotMod[profile_idx])
				{
		 			// If Strafe Shot is enable for the curent profile
					if(toggle_shotMod[profile_idx] == 1)
					{
						if(check_shotActivator())
							combo_run(STRAFESHOT);
						else
							combo_stop(STRAFESHOT);
					}
			
					// If Jump Shot is enable for the curent profile
					else if(toggle_shotMod[profile_idx] == 2)
					{
						if(check_shotActivator())
							combo_run(JUMPSHOT);
					}
			
					// If Crouch Shot is enable for the curent profile
					else if(toggle_shotMod[profile_idx] == 3)
					{
						if(check_shotActivator())
							set_val(BTN[toggle_crouch_btn], 100);
					}
				}
				
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
			// Bunny Hop
				if(toggle_bunnyHop)
				{
					if(get_val(BTN[toggle_jump_btn]) && get_ptime(BTN[toggle_jump_btn]) > 200)
					{
						combo_btn = BTN[toggle_jump_btn];
						combo_wait = 30;
						combo_run(SPAM);
					}
				}
			
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
				
				if(toggle_slideCancel)
				{
					
					if(isqrt(pow(abs(get_ival(PS4_LX)),2) + pow(abs(get_ival(PS4_LY)),2)) >= 80 && !get_val(BTN[toggle_ads_btn]))
					{
						if(event_release(BTN[toggle_crouch_btn]))
						{
							if(toggle_slideCancel == MW)
								combo_run(SLIDE_CANCEL_MW);
							if(toggle_slideCancel == CW)
								combo_run(SLIDE_CANCEL_CW);
						}
					}
					else
					{
						combo_stop(SLIDE_CANCEL_MW);
						combo_stop(SLIDE_CANCEL_CW);
					}
				}
				
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
			// Speed Toggles
				toggle_antirecoil[profile_idx] = speed_toggle( PS4_L2, PS4_UP    , toggle_antirecoil[profile_idx] , ANTIRECOIL_M , ANTIRECOIL_TXT , speed_toggle_UP[profile_idx]    );
				toggle_rapidfire[profile_idx]  = speed_toggle( PS4_L2, PS4_RIGHT , toggle_rapidfire[profile_idx]  , RAPIDFIRE_M  , RAPIDFIRE_TXT  , speed_toggle_RIGHT[profile_idx] );
				toggle_aimassist[profile_idx]  = speed_toggle( PS4_L2, PS4_DOWN  , toggle_aimassist[profile_idx]  , AIMASSIST_M  , SHAPES_TXT     , speed_toggle_DOWN[profile_idx]  );
				toggle_shotMod[profile_idx]    = speed_toggle( PS4_L2, PS4_LEFT  , toggle_shotMod[profile_idx]    , SHOTMOD_M    , SHOT_MOD_TXT   , speed_toggle_LEFT[profile_idx] );
				
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
			// DoGz Screen Saver
			    if(display_black)
			    {
			    	count_black += get_rtime();
			    	if(count_black >= 5000)
			    	{
			    		cls_oled(0);
			    		count_black = 0;
			    		screensaver = TRUE;
			    		display_black = FALSE;
			    	}
			    }
			    
			    if(screensaver)
			    {
			    	DGT += get_rtime();
			    	
					if(DGT >= 100) 
					{
						SD1 += 2;	TP1 += 1;	TP2 -= 1;	DGT  = 0;
					}
					DGR += get_rtime();
					
					if(DGR >= 30) 
					{
						Y_1 += 1;	Y_2 += 2;	Y_3 += 3;	Y_4 += 4;
						Y_5 += 5;	Y_6 += 6;	Y_7 += 7;	Y_8 += 8;
						DGR  = 0;
					}
					
					name();
					MSC += get_rtime();
					
					if(MSC >= 1000) 
					{
						MSC = 0;	
						RT += 1;
					}
					
					if(RT == 30) 
					{
						screensaver = 0;
						RT = 0;
						cls_oled(0);
					}
			    }
			} // NOT in Edit Menu
			
////////////////////////////////////////////////////////// MODS THAT ALSO WORK IN MODEDIT

		// AIM Abuse
			if(toggle_aimabuse[profile_idx])
			{
				if(get_val(BTN[toggle_ads_btn]))
					combo_run(AIM_ABUSE);
				else
					combo_stop(AIM_ABUSE);
			}
			
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
		// AIM Assist
			if(toggle_aimassist[profile_idx])
			{
				if(toggle_aimassist[profile_idx] == 1) // Batts Sticky
				{	
					if(get_val(BTN[toggle_ads_btn]) || get_val(BTN[toggle_fire_btn]) && (isqrt(pow(abs(get_ival(PS4_RY)),2) + pow(abs(get_ival(PS4_RX)),2)) < 100) )
					    combo_run(STICKY);
				}
				else // Polar Shapes
				{
					if(toggle_antirecoil[profile_idx] && get_val(BTN[toggle_fire_btn]))
					{
						RX = SmartSens(antirecoil_horizontal[profile_idx], PS4_RX);
						RY = SmartSens(ar_y, PS4_RY);
					}
					else
					{
						RX = get_val(PS4_RX);
						RY = get_val(PS4_RY);
					}
					
					actual_Magnitude = isqrt(pow(RX, 2) + pow(RY, 2));	
					max_Magnitude = (actual_Magnitude < 100);
				
					if(!(time++ % 1))
						angle += aimassist_angle;
						
					angle = angle % 360;
					sin_angle = Polar_Array[angle % 360];
					cos_angle = Polar_Array[(angle + 270) % 360];
					
				  
				  	if(get_val(BTN[toggle_fire_btn]) || get_val(BTN[toggle_ads_btn]))
				  	{
				    	if(actual_Magnitude <= aimassist_radius) 
				    	{
							sin_angle -= RY;
				      		cos_angle -= RX;
				    	}
					    else 
					    {
							sin_angle = (sin_angle * (200 - ((abs(RY) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
							cos_angle = (cos_angle * (200 - ((abs(RX) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
					    }
					    
					    GetShapesV1(aimassist_radius);
					    
					    if((!get_val(BTN[toggle_fire_btn]) && toggle_antirecoil[profile_idx]) || !toggle_antirecoil[profile_idx])
					    {
							set_val(PS4_RX, clamp(get_val(PS4_RX) + cos_angle, -100, 100));
							set_val(PS4_RY, clamp(get_val(PS4_RY) + sin_angle, -100, 100));
				  		}
					}
				}
			}
			
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
		// AntiRecoil
			if(toggle_antirecoil[profile_idx])
			{
			// Antirecoil Standard final value
				if(toggle_antirecoil[profile_idx] == 2)
					antirecoil_start[profile_idx] = antirecoil_end[profile_idx];
					
			// Progressive AntiRecoil vertical		
	    		if(antirecoil_start[profile_idx] < antirecoil_end[profile_idx])
	    	   		i_val = 1; 
	    		else
	    	    	i_val = -1;
	    		i_pnt = (antirecoil_time[profile_idx] / 10) / (abs(antirecoil_start[profile_idx] - antirecoil_end[profile_idx])); 
	    		
	    	// Reset
	    		if(!get_val(BTN[toggle_fire_btn])) 
	    		{
					ar_y = antirecoil_start[profile_idx];
	    	    	i_cnt = 0;
	    	    	i_num = 0;
	    	    	//rumble = 0;
	    	    	rumble_recoil = 0;
	    	    	antirecoil_boost = 0;
	    		}     
	    					
	    		if(get_val(BTN[toggle_fire_btn]))
				{
				// Rumble AntiRecoil Boost
					antirecoil_boost += random(1, 5);
					if(antirecoil_boost > 10)
						antirecoil_boost = 0;
						
/*				// SmartStop
					if(get_ptime(BTN[toggle_fire_btn]) < 500 || get_rumble(RUMBLE_A))
						rumble = 1;
					else if(get_rumble(RUMBLE_A) == 0)
						rumble = 0;
*/						
				// Progression Calculation
			        if(!p_complete())  
						ar_y = p_val();
			        else
			            ar_y = antirecoil_end[profile_idx];
			 
				// Run Rumble Antirecoil
					if(toggle_antirecoil[profile_idx] == 3) 
					{	
						rumble_recoil = max(get_rumble(RUMBLE_A),get_rumble(RUMBLE_B));
					                 				
						if(rumble_recoil > 10 && rumble_recoil < 90) 
						{
							if(!toggle_aimassist[profile_idx])
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY), -100, 100));
								set_val(PS4_RX, clamp(SmartSens(antirecoil_horizontal[profile_idx], PS4_RX), -100, 100));
							}
							else if(toggle_aimassist[profile_idx] > 1)
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY) + sin_angle, -100, 100));
								set_val(PS4_RX, clamp(SmartSens(antirecoil_horizontal[profile_idx], PS4_RX) + cos_angle, -100, 100));
							}
							else if(toggle_aimassist[profile_idx] == 1)
							{
								recoilAssist = rumble_recoil + rumble_power[profile_idx] + antirecoil_boost;
								combo_run(STICKY);
							}
						}
						else if(rumble_recoil < 10)
						{
							ar_y = antirecoil_end[profile_idx];
							antirecoil();
						}
					}
				// Run Progressive or Standard AntiRecoil
					else
					{	
				    // If BurstFire
				    	if(toggle_burstfire[profile_idx] == 1 && get_ptime(BTN[toggle_fire_btn]) <= hold_time)
				    	{
							antirecoil();
				    	}
				    // Full auto and RapidFire with smart stop
				        if(toggle_burstfire[profile_idx] == 0  || toggle_rapidfire[profile_idx] >= 1)
				        {
					        //if(rumble)
					        //{
								antirecoil();
					    	//}
				    	}
				    }
		    	}
			}
			
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
		// RapidFire
			if(toggle_rapidfire[profile_idx])
			{
				if(toggle_rapidfire[profile_idx] == 1)
				{
				// Rate of Fire Calculation
					hold_time = 50;
					rest_time = 35 * 10 - (get_ival(XB1_RT) * 3);
		    	}
				else if(toggle_rapidfire[profile_idx] == 2)
				{
				// Rate of Fire Calculation
		    		rest_time = 5000 / ((rate_of_fire[profile_idx] * 10) / 60); 
		   			hold_time = rest_time;
		    		if(rest_time < 0) rest_time = 0;
		    	}
				else if(toggle_rapidfire[profile_idx] == 3)
				{
				// Rate of Fire Calculation
		    		rest_time = 500 / rate_of_fire[profile_idx]; 
		   			hold_time = rest_time;
		    		if(rest_time < 0) rest_time = 0;
		    	}
	    
	    	// Run combo
	    		if(get_val(BTN[toggle_fire_btn]))
	    			combo_run(RAPIDFIRE);
	    		else
	    			combo_stop(RAPIDFIRE);
	    		
	    		led_on = 150;
	    		led_off = 300;
	    		combo_run(BLINK);
			}
			
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
		//BurstFire
			if(toggle_burstfire[profile_idx]) 
			{
	    	// Hold and Release
				hold_time = burstfire_hold;
				rest_time = burstfire_release;
				
	    	// Run combo
	    		if(get_val(BTN[toggle_fire_btn]))	
	    			combo_run(BURSTFIRE);
				else
	    			combo_stop(BURSTFIRE);
	
	    		led_on = 200;
	    		led_off = 1000;
	    		combo_run(BLINK);
			}
			
		// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
		
		} // Mods end  
		
/////////////////////////////////////////////////////////////////////////////////////////// D I S P L A Y   M O D S   A N D   V A L U E S

		if(display_new) 
		{
			screensaver = FALSE;
			count_black = 0;
			
			if(ModEdit) // Display editable value 
			{
				display_edit_line1();
				display_values();
			}
			else if(ModMenu || ControllerMenu) // Display Profile, mod name, toggle
			{
				display_edit_line1();
				display_edit_line2();
				display_edit_line3();
			}
			else if(MainMenu) // Display Main Menu
			{
				display_mainMenu();
			}
			else if(ProfilesMenu)
			{
				display_edit_line1();
				display_edit_profiles();
			}
			else // Quick Toggle Display (outside any menus)
			{
				cls_oled(OLED_BLACK);
			// Display mod name
				printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));
			// Display toggle
				display_edit_line3();
				count_black = 2000;
			}
			
			display_black = TRUE;
	        display_new = FALSE;
	       
	    } // display_new section end
	    
/////////////////////////////////////////////////////////////////////////////////////////// D I S P L A Y   U S E R   I N F O  	

		if(display_info) // display navigation infos
		{
			info_timer = 0;
			rect_oled(1, 50, 126, 13, OLED_WHITE, OLED_BLACK); // bottom rectangle (clear)
			current_info = cycle(current_info, 0, entry_count(get_controller_infoTXT()));
			printf(center_x(get_string_length(get_string(get_controller_infoTXT(), current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(get_controller_infoTXT(), current_info));
			display_info = FALSE;
		}
		
	} // !KillSwitch section end
	
////////////////////////////////////////////////////////////////////////////////////////////////////////// D I S P L A Y   T I T L E   S C R E E N  /  S C R E E N   S A V E R

    if(display_title)
    {
    	screensaver= FALSE;
    	count_black = 0;	
    	
    // Display logo
    	cls_oled(OLED_BLACK);
   		draw_logo();
   			
   	// Display current slot
   		number_to_string(currentSlot, find_digits(currentSlot)); 

   	// Display profile name
		display_profile();
		
   		display_black = TRUE;	
    	display_title = FALSE;
    }
    
////////////////////////////////////////////////////////////////////////////////////////////////////////// L E D S   C O L O R 

	if(KillSwitch)
		led(7);
	else
		led(profile_idx);
		
	if(toggle_rapidfire[profile_idx])
		combo_run(BLINK);		
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// M A I N   S E C T I O N   E N D

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// C O M B O S

combo RACE {
	X_1 = random(0,127);
	wait(SAVER1);
	X_2 = random(0,127);
	wait(SAVER1);
	X_3 = random(0,127);
	wait(SAVER1);
	X_4 = random(0,127);
	wait(SAVER1); 
	X_5 = random(0,127);
	wait(SAVER1);
	X_6 = random(0,127);
	wait(SAVER1); 
	X_7 = random(0,127);
	wait(SAVER1); 
	X_8 = random(0,127);
	wait(SAVER1);
}

combo RUMBLE_ON {					
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

combo RUMBLE_OFF {						
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

combo KILLSWITCH {
	cls_oled(OLED_BLACK);
    printf(center_x(sizeof(MUTE) - 1, OLED_FONT_MEDIUM_WIDTH),8,OLED_FONT_MEDIUM,OLED_WHITE,MUTE[0]);    
    wait(get_rtime());
    wait(250);
    printf(center_x(sizeof(HOLD) - 1, OLED_FONT_SMALL_WIDTH),38,OLED_FONT_SMALL,OLED_WHITE,HOLD[0]);     
    printf(center_x(sizeof(ACTIVE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,ACTIVE[0]); 
    wait(get_rtime());
    wait(5000);  
    cls_oled(OLED_BLACK);
    wait(get_rtime());
    wait(5000);  
}

combo SAVE { 
	call(RUMBLE_ON);
	wait(150);
	call(RUMBLE_ON);		
	wait(1000);
	display_title = TRUE;
}

combo RN {
	RN1 = random(65,90);
	RN2 = random(60,90);
	RN3 = random(65,90);
	RN4 = random(65,90); 
	RN5 = random(65,90);
	RN6 = random(65,90);
	RN7 = random(65,90);
	RN8 = random(65,90);
	wait(SAVER);
}

combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
}

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(BTN[toggle_fire_btn], 0);
    wait(rest_time - get_rtime());
    set_val(BTN[toggle_fire_btn], 0);
}  

combo STRAFESHOT { 
    set_val(PS4_LX, 100);
    wait(strafe_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafe_time);
    wait(50);
}

combo JUMPSHOT {
 	set_val(BTN[toggle_jump_btn], 100);
 	wait(50);
 	wait(100);
 }	
 
combo AIM_ABUSE {
    wait(aimabuse_hold);
    set_val(BTN[toggle_ads_btn], 0);
    wait(aimabuse_release - get_rtime());
    set_val(BTN[toggle_ads_btn], 0);
}

int recoilAssist;

combo STICKY {
	if(toggle_antirecoil[profile_idx] && get_val(BTN[toggle_fire_btn]))
    	set_val(PS4_RY, SmartSens(recoilAssist + aimassist_radius, PS4_RY));
    else 
    	set_val(PS4_RY, SmartSens(aimassist_radius, PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(BTN[toggle_fire_btn]))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(aimassist_radius, PS4_RX));
    set_val(PS4_LX, SmartSens(aimassist_radius, PS4_LX));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(BTN[toggle_fire_btn]))
    	set_val(PS4_RY, SmartSens(recoilAssist + inv(aimassist_radius), PS4_RY));
    else
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius), PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(BTN[toggle_fire_btn]))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(inv(aimassist_radius), PS4_RX));
    set_val(PS4_LX, SmartSens(inv(aimassist_radius), PS4_LX));
    wait(aimassist_angle - get_rtime());
    
	if(get_val(PS4_R2))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(inv(aimassist_radius), PS4_RX));
    set_val(PS4_LX, SmartSens(inv(aimassist_radius), PS4_LX));
}

int combo_btn, combo_wait;

combo SPAM {
	wait(combo_wait);
	set_val(combo_btn, 0);
	wait(combo_wait - get_rtime());
	set_val(combo_btn, 0);
}

combo HOLD_BREATH {
	set_val(BTN[toggle_sprint_btn],0);
	wait(60);
	set_val(BTN[toggle_sprint_btn],100);
	wait(110);
	set_val(BTN[toggle_sprint_btn],0);
	wait(110);
}

combo SLIDE_CANCEL_MW {              
	set_val(BTN[toggle_crouch_btn], 100);          
	wait(cancel_time);                         
	set_val(BTN[toggle_crouch_btn], 0);            
	wait(60);                          
	set_val(BTN[toggle_crouch_btn], 100);          
	wait(50);                          
	set_val(BTN[toggle_crouch_btn], 100);          
	set_val(BTN[toggle_jump_btn], 100);           
	wait(60);                          
	set_val(BTN[toggle_crouch_btn], 0);            
	set_val(BTN[toggle_jump_btn], 100);          
	wait(10);                        
	set_val(BTN[toggle_jump_btn], 0);
}

combo SLIDE_CANCEL_CW { 
	set_val(BTN[toggle_crouch_btn], 100);
	wait(cancel_time);
	set_val(BTN[toggle_crouch_btn], 0);
	wait(20);
	set_val(BTN[toggle_sprint_btn], 0);
	set_val(BTN[toggle_crouch_btn], 100);
	set_val(BTN[toggle_sprint_btn], 100);
	wait(20);
	set_val(BTN[toggle_crouch_btn], 0);
	set_val(BTN[toggle_sprint_btn], 0);
	wait(20);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// F U N C T I O N S 

/////////////////////////////////////////////////////////////////////////////////////////// A N T I R E C O I L

int i_cnt;  

function p_complete() { 

    i_cnt++;
    if(i_cnt > antirecoil_time[profile_idx] / 10) 
    {
        i_cnt = antirecoil_time[profile_idx] / 10;
        return 1;
    }    
    return 0;
}  

int i_num;
int i_pnt;
int ar_y;	
int i_val;

function p_val() { 

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
} 

int SmartVal;	

function SmartSens(f_val, f_axis) { 

	SmartVal = ( (f_val * ( 100 - abs( get_val(f_axis) ) ) ) / 100); 
    return clamp(get_val(f_axis) + SmartVal, -100, 100);
}

function antirecoil() {

	if(!toggle_aimassist[profile_idx])
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY), -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(antirecoil_horizontal[profile_idx], PS4_RX), -100, 100));
	}
	else if(toggle_aimassist[profile_idx] > 1)
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY) + sin_angle, -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(antirecoil_horizontal[profile_idx], PS4_RX) + cos_angle, -100, 100));
	}
	else if(toggle_aimassist[profile_idx] == 1)
	{
		recoilAssist = ar_y;
		combo_run(STICKY);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////// A I M   A S S I S T

int time;
int RX, RY;
int angle, cos_angle, sin_angle;
int SpiralPosition1,SpiralPosition2,InnerSpiral,OuterSpiral;
int actual_Magnitude, max_Magnitude, Position;

const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,    
80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7, 
6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,  
-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95, 
-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,   
-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61, 
-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,
9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,
82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; 

int timer;

function GetShapesV1(f_var) {     
   
    if(!SpiralPosition1)                                
	{
		InnerSpiral -= 1;
		if(InnerSpiral < 1)
			SpiralPosition1 = TRUE;
	}
	else
	{
	    InnerSpiral += 1;
		if(InnerSpiral > f_var)
			SpiralPosition1 = FALSE;
	}
	if(!SpiralPosition2)
	{
		OuterSpiral -= 1;
		if(OuterSpiral < 1)
			SpiralPosition2 = TRUE;
	}
	else
	{
		OuterSpiral += 1;
		if(OuterSpiral >  f_var)
			SpiralPosition2 = FALSE;
	} 
	if(toggle_aimassist[profile_idx] == 2)                    
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 3)        
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * (f_var / 2)) /100; 
	}
	if(toggle_aimassist[profile_idx] == 4)                     
	{ 
        RY = (sin_angle * (f_var / 2)) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 5)                  
	{
        RY = (sin_angle * InnerSpiral) /100;
        RX = (cos_angle * OuterSpiral) /100;  
	}
    if(toggle_aimassist[profile_idx] == 6)
	{
		RX = (cos_angle * Position) /100;
		RY = (sin_angle * Position) /100;
	
		if(Position == 0)
		    RX = (cos_angle * f_var) /100;
		    
		if(Position == 1)
			RY = (sin_angle * f_var) /100;
			
		if(Position == 2) 
			RX = (cos_angle * f_var) /100 * -1;
			
		if(Position == 3)
			RY = (sin_angle * f_var) /100 * -1;
			
		timer++;
		if(timer >= aimassist_angle)
		{
			Position++;
			timer = 0;
		}
				
		if(Position == 4)
			Position = 0;
    }
    
	cos_angle = RX;
	sin_angle = RY;
}

/////////////////////////////////////////////////////////////////////////////////////////// D Y N A M I C   S E N S I T I V I T Y 

int sens_x;
int sens_y;
int sens_xcnt,sens_ycnt;

function set_sens () { // Dynamic Sens by Batts

    if(abs(get_lval(PS4_RX)) >= dynasens_limit) 
    {
	    sens_xcnt += 1;
	    
		if(sens_xcnt >= dynasens_increase_rate && sens_x < dynasens_max_sens) 
		{ 
		    sens_x += 1; 
		    sens_xcnt = 0; 
		} 
			else if(sens_x >= dynasens_max_sens) 
				sens_xcnt = 0;  
	}
	
    else if(abs(get_val(PS4_RX)) < dynasens_restart) 
    {
	    sens_xcnt = 0; 
	    sens_x = dynasens_initial_sens;
	} 
	
    if(abs(get_lval(PS4_RY)) >= dynasens_limit) 
    {
	    sens_ycnt += 1;
		if(sens_ycnt >= dynasens_increase_rate && sens_y < dynasens_max_sens) 
		{ 
		    sens_y += 1; 
		    sens_ycnt = 1; 
		} 
			else if(sens_y >= dynasens_max_sens) 
				sens_ycnt = 0; 
	}
	
    else if(abs(get_val(PS4_RY)) < dynasens_restart) 
    {
	    sens_y = dynasens_initial_sens; 
	    sens_ycnt = 0;
	}
	
	sensitivity(PS4_RX,NOT_USE,sens_x);
    sensitivity(PS4_RY,NOT_USE,sens_y);
}

/////////////////////////////////////////////////////////////////////////////////////////// C H E C K   A C T I V A T O R 

function check_shotActivator() {	

	if(toggle_shotActivator[profile_idx] == ADSFIRE)
	{
		if(get_val(BTN[toggle_ads_btn]) && get_val(BTN[toggle_fire_btn]))
			return TRUE;
	}
	else if(toggle_shotActivator[profile_idx] == ADSONLY)
	{
		if(get_val(BTN[toggle_ads_btn]) && !get_val(BTN[toggle_fire_btn]))
			return TRUE;
	}
	else if(toggle_shotActivator[profile_idx] == FIREONLY)
	{
		if(!get_val(BTN[toggle_ads_btn]) && get_val(BTN[toggle_fire_btn]))
			return TRUE;
	}	
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////// D I S P L A Y   F U N C T I O N S 

function display_mainMenu() {

// Clears text emplacement (emplacement for lines 1, 2, 3, without arrows)
	rect_oled(13, 1, 102, 47, OLED_WHITE, OLED_BLACK); 
// Drop-down menu
	PrintMenu(MODMENU_MM,CONTROLLER_MM,PROFILES_MM);
	PrintMenu(CONTROLLER_MM,PROFILES_MM,MODMENU_MM);
	PrintMenu(PROFILES_MM,MODMENU_MM,CONTROLLER_MM);
}

function PrintMenu(f_active,f_line3,f_line1){  
 
	if(menuName_idx == f_active) 
	{ 
		printf(center_x(get_string_length(get_string(MENUNAME_TXT, f_active)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MENUNAME_TXT,f_active));
		printf(center_x(get_string_length(get_string(MENUNAME_TXT, f_line3)) , OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MENUNAME_TXT,f_line3) ); 
		printf(center_x(get_string_length(get_string(MENUNAME_TXT, f_line1)) , OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MENUNAME_TXT,f_line1) );
	} 
}

function display_edit_line1() {

// Clears text emplacement line 1
	rect_oled(13, 1, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
	
	if(ModMenu)
	{				
	// Display Profile only on mods that may have different ON/OFF status depending on the active Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE) 
			display_profile ();
		else // Mods that have the same toggle on every profiles, display EVERY PROFILE
    		printf(center_x(sizeof(ALL) - 1, OLED_FONT_SMALL_WIDTH),4,OLED_FONT_SMALL,OLED_WHITE,ALL[0]);
	}
	
	else if(ModEdit) 
	{
	// Display Value Name
    	if(valName_idx == END_V && toggle_antirecoil[profile_idx] == STANDARD)
    		printf(center_x(sizeof(ANTIRECOIL_VERTICAL) - 1, OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,ANTIRECOIL_VERTICAL[0]);  
    	else
    		printf(center_x(get_string_length(get_string(VALNAME_TXT, valName_idx)), OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(VALNAME_TXT, valName_idx));  
	}
	else if(ControllerMenu)
	{
	// Display Value Name
    	printf(center_x(sizeof(CONTROLLER) - 1, OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,CONTROLLER[0]);  
	}
	else if(ProfilesMenu)
	{
	// Display Value Name
    	printf(center_x(get_string_length(get_string(PROFILESNAME_TXT, profilesName_idx)), OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(PROFILESNAME_TXT, profilesName_idx));
	}
}

function display_edit_line2() {
	
// Clears text emplacement line 2
	rect_oled(13, 17, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
		
	if(ModMenu)
	{
	// Display Mod Name
		printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));  // small size
	}
	else if(ControllerMenu)
	{
	// Display Controller Name
		printf(center_x(get_string_length(get_string(CONTROLLERNAME_TXT, controllerName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(CONTROLLERNAME_TXT, controllerName_idx));  // small size
	
	}
}

function display_edit_line3() {
	
// Clears text emplacement line 3
	rect_oled(13, 33, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
	
	if(ControllerMenu)
	{
		display_toggle( controllerName_idx, ADS_BTN_C      , get_controller_layoutBTN_TXT(), toggle_ads_btn      );
		display_toggle( controllerName_idx, FIRE_BTN_C     , get_controller_layoutBTN_TXT(), toggle_fire_btn     );
		display_toggle( controllerName_idx, TACTICAL_BTN_C , get_controller_layoutBTN_TXT(), toggle_tactical_btn );
		display_toggle( controllerName_idx, LETHAL_BTN_C   , get_controller_layoutBTN_TXT(), toggle_lethal_btn   );
		display_toggle( controllerName_idx, JUMP_BTN_C     , get_controller_layoutBTN_TXT(), toggle_jump_btn     );
		display_toggle( controllerName_idx, CROUCH_BTN_C   , get_controller_layoutBTN_TXT(), toggle_crouch_btn   );
		display_toggle( controllerName_idx, RELOAD_BTN_C   , get_controller_layoutBTN_TXT(), toggle_reload_btn   );
		display_toggle( controllerName_idx, MELEE_BTN_C    , get_controller_layoutBTN_TXT(), toggle_melee_btn    );
		display_toggle( controllerName_idx, SPRINT_BTN_C   , get_controller_layoutBTN_TXT(), toggle_sprint_btn   );
		display_toggle( controllerName_idx, WEAPON_BTN_C   , get_controller_layoutBTN_TXT(), toggle_weapon_btn   );
		display_toggle( controllerName_idx, HAIRTRIGGER_C  , ONOFF_TXT                     , toggle_hairTrigger  );
		display_toggle( controllerName_idx, RUMBLE_C       , ONOFF_TXT                     , toggle_rumble       );
	}
	else
	{
	// Display toggle ON/OFF status
	    // Mods that may have different ON/OFF status depending on the active Profile
		display_toggle( modName_idx, ANTIRECOIL_M , ANTIRECOIL_TXT     , toggle_antirecoil[profile_idx]    );
		display_toggle( modName_idx, RAPIDFIRE_M  , RAPIDFIRE_TXT      , toggle_rapidfire[profile_idx]     );
		display_toggle( modName_idx, BURSTFIRE_M  , ONOFF_TXT          , toggle_burstfire[profile_idx]     );
		display_toggle( modName_idx, AIMASSIST_M  , SHAPES_TXT         , toggle_aimassist[profile_idx]     );
		display_toggle( modName_idx, AIMABUSE_M   , ONOFF_TXT          , toggle_aimabuse[profile_idx]      );
		display_toggle( modName_idx, SHOTMOD_M    , SHOT_MOD_TXT       , toggle_shotMod[profile_idx]       );
		display_toggle( modName_idx, SHOTACTIV_M  , SHOT_ACTIVATOR_TXT , toggle_shotActivator[profile_idx] );
		display_toggle( modName_idx, HOLDBREATH_M , ONOFF_TXT          , toggle_holdBreath[profile_idx]    );
		display_toggle( modName_idx, TURBOMELEE_M , ONOFF_TXT          , toggle_turboMelee[profile_idx]    );
		display_toggle( modName_idx, AUTOADS_M     , ONOFF_TXT         , toggle_autoADS[profile_idx]       );
		display_toggle( modName_idx, AUTOFIRE_M    , ONOFF_TXT         , toggle_autoFIRE[profile_idx]      );
		
		// Mods that have same ON/OFF status on every Profile
		display_toggle( modName_idx, SENSITIVITY_M , SENSITIVITY_TXT , toggle_sensitivity );
		display_toggle( modName_idx, AUTORUN_M     , ONOFF_TXT       , toggle_autorun     );
		display_toggle( modName_idx, BUNNYHOP_M    , ONOFF_TXT       , toggle_bunnyHop    );
		display_toggle( modName_idx, SLIDECANCEL_M , SLIDECANCEL_TXT , toggle_slideCancel );
	}
}

function display_edit_profiles() {
	if(profilesName_idx == PRIM_SEC_P)
	{		
	// Clears  text emplacement line 2 and 3
		rect_oled(13, 18, 102, OLED_FONT_SMALL_HEIGHT + 19, OLED_WHITE , OLED_BLACK); //  rectangle left (line 2 and 3)
		
		if(toggle_pressBTN[profilesName_idx] == 0)
			printf(center_x(sizeof(PRESS_BTN) - 1, OLED_FONT_SMALL_WIDTH),LINE_2_3_Y,OLED_FONT_SMALL,OLED_WHITE,PRESS_BTN[0]);
		else
			printf(center_x(get_string_length(get_string(get_controller_profileBTN_TXT(), toggle_pressBTN[profilesName_idx])), OLED_FONT_SMALL_WIDTH),LINE_2_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(get_controller_profileBTN_TXT(), toggle_pressBTN[profilesName_idx]));
	}
	else
	{
	// Clears text emplacement line 2
		rect_oled(13, 17, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
	// Clears text emplacement line 3
		rect_oled(13, 33, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
		
		if(toggle_holdBTN[profilesName_idx] == 0)
			printf(center_x(sizeof(HOLD_BTN) - 1, OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,HOLD_BTN[0]);
		else
			printf(center_x(get_string_length(get_string(get_controller_profileBTN_TXT(), toggle_holdBTN[profilesName_idx])), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(get_controller_profileBTN_TXT(), toggle_holdBTN[profilesName_idx]));
		
		if(toggle_pressBTN[profilesName_idx] == 0)
			printf(center_x(sizeof(PRESS_BTN) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,PRESS_BTN[0]);
		else
			printf(center_x(get_string_length(get_string(get_controller_profileBTN_TXT(), toggle_pressBTN[profilesName_idx])), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(get_controller_profileBTN_TXT(), toggle_pressBTN[profilesName_idx]));			
	}
}

function display_values() {

// Clears value zone
	rect_oled(38, 18, 51 , OLED_FONT_SMALL_HEIGHT + 3 , OLED_WHITE , OLED_BLACK); // small rectangle center (line 2 value)
	rect_oled(27, 31, 74 , OLED_FONT_SMALL_HEIGHT + 6 , OLED_WHITE , OLED_BLACK); // small rectangle center (line 3 value)
	
	// Mods that may have different values depending on the active Profile
	display_edit( START_V       , antirecoil_start[profile_idx]      );
	display_edit( END_V         , antirecoil_end[profile_idx]        );
	display_edit( TIME_V        , antirecoil_time[profile_idx]       );
	display_edit( HORIZ_V       , antirecoil_horizontal[profile_idx] );
	display_edit( RUMBLEPOWER_V , rumble_power[profile_idx]          );
	display_edit( RATE_V        , rate_of_fire[profile_idx]          );
				
	// Mods that have same value on every Profile
	display_edit( BFHOLD_V      , burstfire_hold         );
	display_edit( BFRELEASE_V   , burstfire_release      );
	display_edit( RADIUS_V      , aimassist_radius       );
	display_edit( STEPS_V       , aimassist_angle        );
	display_edit( HOLDTIME_V    , aimabuse_hold          );
	display_edit( RELEASETIME_V , aimabuse_release       );
	display_edit( STRAFETIME_V  , strafe_time            );
	display_edit( DSINITIAL_V   , dynasens_initial_sens  );
	display_edit( DSINCREASE_V  , dynasens_limit         );
	display_edit( DSRESTART_V   , dynasens_restart       );
	display_edit( DSMAX_V       , dynasens_max_sens      );
	display_edit( DSRATE_V      , dynasens_increase_rate );
	display_edit( GENERAL_V     , genSens                );
	display_edit( ADS_V         , adsSens                );
	display_edit( FIRE_V        , hipSens                );
	display_edit( ADSFIRE_V     , adsfireSens            );
	display_edit( CANCELTIME_V  , cancel_time            );
}

int profile_y;

function display_profile() {

	if(display_title)
		profile_y = 50; // Title screen
	else
		profile_y = 4; // Menus
	
    printf(center_x(get_string_length(get_string(PROFILE_TXT, profile_idx)), OLED_FONT_SMALL_WIDTH),profile_y,OLED_FONT_SMALL,OLED_WHITE,get_string(PROFILE_TXT, profile_idx));
}

function display_edit(f_idx, f_val) { 
	
    if(valName_idx == f_idx)
    		number_to_string(f_val, find_digits(f_val));
}

function display_toggle(f_idx, f_name, f_txt, f_toggle) { 

    if(f_idx == f_name)
    	printf(center_x(get_string_length(get_string(f_txt, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(f_txt, f_toggle));
}

/////////////////////////////////////////////////////////////////////////////////////////// E D I T   V A L U E S   F U N C T I O N S 

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  
	
	if(valName_idx == f_idx)
	{
    // +1 or -1															 
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); 
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); 
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); 
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); 
	}		
	return f_val;
}

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
	// Substract    
	  	if(f_val < f_rng_min) 
	  		f_val = f_rng_min; 
	// Add   
	  	if(f_val > f_rng_max) 
	  		f_val = f_rng_max; 
    		
        display_new = TRUE; 
    }
    return f_val; 
} 

/////////////////////////////////////////////////////////////////////////////////////////// T O G G L E S   F U N C T I O N S 

function toggle(f_idx, f_name, f_txt, f_val) { // toggle_antirecoil[profile_idx]    = toggle( modName_idx, ANTIRECOIL_M , ANTIRECOIL_TXT     , toggle_antirecoil[profile_idx]    );
	
	if(f_idx == f_name)
	{
		if(event_press(PS4_UP))
		{
			f_val = cycle(f_val + 1, 0, entry_count(f_txt));	
			Set_Rumble(f_val);
		}

		if(event_press(PS4_DOWN))
		{
			f_val = cycle(f_val - 1, 0, entry_count(f_txt));
			Set_Rumble(f_val);
		}
		
		if(modName_idx == ANTIRECOIL_M) 
			speed_toggle_UP[profile_idx] = f_val;
		else if(modName_idx == RAPIDFIRE_M) 
		{
			if(f_val >= 1) // disable BurstFire if RapidFire is ON
				toggle_burstfire[profile_idx] = 0;
			
			speed_toggle_RIGHT[profile_idx] = f_val;
		}		
		else if(modName_idx == AIMASSIST_M) 
		{
			if(f_val >= 1 && toggle_sensitivity == 2) // disable dynasens if AIM Assist is ON
				toggle_sensitivity = 0;
			
			speed_toggle_DOWN[profile_idx] = f_val;
		}
		else if(modName_idx == SHOTMOD_M)
			speed_toggle_LEFT[profile_idx] = f_val;
		else if(modName_idx == BURSTFIRE_M)
		{
			if(f_val == 1) // disable RapidFire if BurstFire is ON
				toggle_rapidfire[profile_idx] = 0;
		}
		else if(modName_idx == SENSITIVITY_M) // toggle 0 or 1 or 2 or 3 to select Custom or Dynamic Sens
		{
			if(f_val == 2) // disable AIM Assist if dynasens in ON
			{
				toggle_aimassist[0] = 0;
				toggle_aimassist[1] = 0;
				toggle_aimassist[2] = 0;
			}
		}
	}
	return f_val;
}

int speed_toggle_UP[3], speed_toggle_RIGHT[3], speed_toggle_DOWN[3], speed_toggle_LEFT[3];

function speed_toggle(f_hold, f_press, f_val, f_idx, f_txt, f_st) { // toggle_antirecoil[profile_idx] = speed_toggle(PS4_L2, PS4_UP, toggle_antirecoil[profile_idx], ANTIRECOIL_M, ANTIRECOIL_TXT, speed_toggle_UP[profile_idx]);
	
	if(get_val(f_hold))
	{
		if(get_val(f_press) && get_ptime(f_press) == 500) 
		{
			modName_idx = f_idx;
			
			if(f_val)
				f_val = 0;
			else
			{
				f_val = set_toggle_val(f_st, f_val, f_txt, f_press, 0); 
			}
			Set_Rumble(f_val);
		} 
		
		if(event_press(f_press) && get_brtime(f_press) <= 200) 
		{		
			modName_idx = f_idx;
			if(f_val)
			{
				f_val = cycle(f_val++, 1, entry_count(f_txt));
				set_speed_toggle_val(f_press, f_val);
			}
			else
			{
				f_val = set_toggle_val(f_st, f_val, f_txt, f_press, 1); 
			}
			Set_Rumble(f_val);
		}
		set_val(f_press, 0)
	}
	return f_val;
}

function set_toggle_val(f_st, f_val, f_txt, f_press, f_min) { 

	if(!f_st)
	{
		f_val = cycle(f_val++, f_min, entry_count(f_txt));
		set_speed_toggle_val(f_press, f_val);
	}
	else
	{
		f_val = f_st;
	}
	
	if(modName_idx == AIMASSIST_M)
	{
		if(f_val >= 1 && toggle_sensitivity == 2) // disable dynasens if AIM Assist in ON
			toggle_sensitivity = 0;
	}
	return f_val;
}

function set_speed_toggle_val(f_press, f_val) {
	if(f_press == PS4_UP)
		speed_toggle_UP[profile_idx] = f_val;
	if(f_press == PS4_RIGHT)
		speed_toggle_RIGHT[profile_idx] =  f_val;
	if(f_press == PS4_DOWN)
		speed_toggle_DOWN[profile_idx] =  f_val;
	if(f_press == PS4_LEFT)
		speed_toggle_LEFT[profile_idx] =  f_val;
}

function Set_Rumble(f_val){
	if(f_val == 0) combo_run(RUMBLE_OFF);
	else combo_run(RUMBLE_ON);
	display_new = TRUE; 
}

function check_toggle() {
	if(modName_idx == ANTIRECOIL_M  && toggle_antirecoil[profile_idx])      return TRUE;
	if(modName_idx == RAPIDFIRE_M   && toggle_rapidfire[profile_idx] > 1)   return TRUE;
	if(modName_idx == BURSTFIRE_M   && toggle_burstfire[profile_idx])       return TRUE;
	if(modName_idx == AIMASSIST_M   && toggle_aimassist[profile_idx])       return TRUE;
	if(modName_idx == AIMABUSE_M    && toggle_aimabuse[profile_idx])        return TRUE;
	if(modName_idx == SHOTMOD_M     && toggle_shotMod[profile_idx] == 1)    return TRUE;
	if(modName_idx == SENSITIVITY_M && toggle_sensitivity)                  return TRUE;
	if(modName_idx == SLIDECANCEL_M  && toggle_slideCancel)                  return TRUE;
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////// A R R A Y S   F U N C T I O N S 

define MODNAME_TXT = 0      , VALNAME_TXT = 1         , INFO_TOGGLE_PS_TXT = 2  , INFO_EDIT_PS_TXT = 3  , INFO_TOGGLE_XB_TXT = 4  , INFO_EDIT_XB_TXT = 5     , PROFILE_TXT = 6      ,
       MENUNAME_TXT = 7     , CONTROLLERNAME_TXT = 8  , ONOFF_TXT = 9           , PROFILESNAME_TXT = 10 , PROFILEBTN_PS_TXT = 11  , PROFILEBTN_XB_TXT = 12   , INFO_MAIN_PS_TXT = 13, 
       INFO_MAIN_XB_TXT = 14, INFO_CONTROL_PS_TXT = 15, INFO_CONTROL_XB_TXT = 16, LAYOUT_BTN_PS_TXT = 17, LAYOUT_BTN_XB_TXT = 18  , ANTIRECOIL_TXT = 19      , RAPIDFIRE_TXT = 20   , 
       SHAPES_TXT = 21      , SHOT_MOD_TXT = 22       , SHOT_ACTIVATOR_TXT = 23 , SENSITIVITY_TXT = 24  , INFO_PROFILE_PS_TXT = 25, INFO_PROFILE_XB_TXT = 26 , SLIDECANCEL_TXT = 27;
       
function entry_count(f_array_idx) { // by Swizzy

    i = 0;
    if (f_array_idx == MODNAME_TXT) {              while (MODNAME[i] != -1) { i++; } }
    else if (f_array_idx == VALNAME_TXT) {         while (VALNAME[i] != -1) { i++; } }
    else if (f_array_idx == INFO_TOGGLE_PS_TXT) {  while (INFO_TOGGLE_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_PS_TXT) {    while (INFO_EDIT_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_TOGGLE_XB_TXT) {  while (INFO_TOGGLE_XB[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_XB_TXT) {    while (INFO_EDIT_XB[i] != -1) { i++; } }
    else if (f_array_idx == PROFILE_TXT) {         while (PROFILE[i] != -1) { i++; } }
    else if (f_array_idx == MENUNAME_TXT) {        while (MENUNAME[i] != -1) { i++; } }
    else if (f_array_idx == CONTROLLERNAME_TXT) {  while (CONTROLLERNAME[i] != -1) { i++; } }
    else if (f_array_idx == ONOFF_TXT) {           while (ONOFF[i] != -1) { i++; } }
    else if (f_array_idx == PROFILESNAME_TXT) {    while (PROFILESNAME[i] != -1) { i++; } }
    else if (f_array_idx == PROFILEBTN_PS_TXT) {   while (PROFILEBTN_PS[i] != -1) { i++; } }
    else if (f_array_idx == PROFILEBTN_XB_TXT) {   while (PROFILEBTN_XB[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MAIN_PS_TXT) {    while (INFO_MAIN_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MAIN_XB_TXT) {    while (INFO_MAIN_XB[i] != -1) { i++; } }
    else if (f_array_idx == INFO_CONTROL_PS_TXT) { while (INFO_CONTROL_PS[i] != -1) { i++; } }
    else if (f_array_idx == LAYOUT_BTN_PS_TXT) {   while (LAYOUT_BTN_PS[i] != -1) { i++; } }
    else if (f_array_idx == LAYOUT_BTN_XB_TXT) {   while (LAYOUT_BTN_XB[i] != -1) { i++; } }
    else if (f_array_idx == ANTIRECOIL_TXT) {      while (ANTIRECOIL[i] != -1) { i++; } }
    else if (f_array_idx == RAPIDFIRE_TXT) {       while (RAPIDFIRE[i] != -1) { i++; } }
    else if (f_array_idx == SHAPES_TXT) {          while (SHAPES[i] != -1) { i++; } }
    else if (f_array_idx == SHOT_MOD_TXT) {        while (SHOT_MOD[i] != -1) { i++; } }
    else if (f_array_idx == SHOT_ACTIVATOR_TXT) {  while (SHOT_ACTIVATOR[i] != -1) { i++; } }
    else if (f_array_idx == SENSITIVITY_TXT) {     while (SENSITIVITY[i] != -1) { i++; } }
    else if (f_array_idx == INFO_PROFILE_PS_TXT) { while (INFO_PROFILE_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_PROFILE_XB_TXT) { while (INFO_PROFILE_XB[i] != -1) { i++; } }
    else if (f_array_idx == SLIDECANCEL_TXT) {     while (SLIDECANCEL[i] != -1) { i++; } }
    return i - 1;
}

function get_string(f_array_idx, f_idx) { 

	if(f_array_idx == MODNAME_TXT)            return MODNAME[f_idx];
	if(f_array_idx == VALNAME_TXT)            return VALNAME[f_idx];
	if(f_array_idx == INFO_TOGGLE_PS_TXT)     return INFO_TOGGLE_PS[f_idx];
	if(f_array_idx == INFO_EDIT_PS_TXT)       return INFO_EDIT_PS[f_idx];
	if(f_array_idx == INFO_TOGGLE_XB_TXT)     return INFO_TOGGLE_XB[f_idx];
	if(f_array_idx == INFO_EDIT_XB_TXT)       return INFO_EDIT_XB[f_idx];
	if(f_array_idx == PROFILE_TXT)            return PROFILE[f_idx];
	if(f_array_idx == MENUNAME_TXT)           return MENUNAME[f_idx];
	if(f_array_idx == CONTROLLERNAME_TXT)     return CONTROLLERNAME[f_idx];
	if(f_array_idx == ONOFF_TXT)              return ONOFF[f_idx];
	if(f_array_idx == PROFILESNAME_TXT)       return PROFILESNAME[f_idx];
	if(f_array_idx == PROFILEBTN_PS_TXT)      return PROFILEBTN_PS[f_idx];
	if(f_array_idx == PROFILEBTN_XB_TXT)      return PROFILEBTN_XB[f_idx];
	if(f_array_idx == INFO_MAIN_PS_TXT)       return INFO_MAIN_PS[f_idx];
	if(f_array_idx == INFO_MAIN_XB_TXT)       return INFO_MAIN_XB[f_idx];
	if(f_array_idx == INFO_CONTROL_PS_TXT)    return INFO_CONTROL_PS[f_idx];
	if(f_array_idx == INFO_CONTROL_XB_TXT)    return INFO_CONTROL_XB[f_idx];
	if(f_array_idx == LAYOUT_BTN_PS_TXT)      return LAYOUT_BTN_PS[f_idx];
	if(f_array_idx == LAYOUT_BTN_XB_TXT)      return LAYOUT_BTN_XB[f_idx];
	if(f_array_idx == ANTIRECOIL_TXT)         return ANTIRECOIL[f_idx];
	if(f_array_idx == RAPIDFIRE_TXT)          return RAPIDFIRE[f_idx];
	if(f_array_idx == SHAPES_TXT)             return SHAPES[f_idx];
	if(f_array_idx == SHOT_MOD_TXT)           return SHOT_MOD[f_idx];
	if(f_array_idx == SHOT_ACTIVATOR_TXT)     return SHOT_ACTIVATOR[f_idx];
	if(f_array_idx == SENSITIVITY_TXT)        return SENSITIVITY[f_idx];
	if(f_array_idx == INFO_PROFILE_PS_TXT)    return INFO_PROFILE_PS[f_idx];
	if(f_array_idx == INFO_PROFILE_XB_TXT)    return INFO_PROFILE_XB[f_idx];
	if(f_array_idx == SLIDECANCEL_TXT)        return SLIDECANCEL[f_idx];
	return -1;
}

int stringLength;

function get_string_length(offset) { // by Swizzy

    stringLength = 0;
    while (duint8(offset++)) { stringLength++; }
    return stringLength + 1;
}

/////////////////////////////////////////////////////////////////////////////////////////// D R A W   M E N U S / A R R O W S   F U N C T I O N S 

function draw_base_menu() {
	rect_oled(0, 0, 128, 49, OLED_BLACK, OLED_WHITE); // white contour 
	line_oled(1, 16, 126, 16, 1, OLED_WHITE); // draw line 1
	
// Filled rectangle white (emplacement for the chars line 1)
	if(!ControllerMenu)
	{
		rect_oled(2, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 1)
		rect_oled(115, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 1)
	}
}

function draw_modMenu() {
// Clears text emplacement line 2 and 3 (value zone while in ModEdit)
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Separate ex value zone
	line_oled(1, 32, 126, 32, 1, OLED_WHITE); // line 2 
	
// Filled rectangle white (emplacement for the chars line 2, 3)
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
}

function draw_modEdit() {
// Clears line 2 and 3
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Filled rectangle white 
	// Emplacement for the chars line 2, 3)	
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
	// Emplacement for + / -
	rect_oled(14, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE , OLED_WHITE); // rectangle left (line 2 + 3)
	rect_oled(102, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE, OLED_WHITE); // rectangle right (line 2 + 3)

// Display - / +
	line_oled(16, 31, 23, 31, 2, OLED_BLACK); // left -
	putc_oled(1, 43); // +
	puts_oled(103, 24, OLED_FONT_MEDIUM, 1, OLED_BLACK); // right + 	    

}

function draw_profilesMenu() {
// Clears line 2 and 3
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Filled rectangle white
	// Emplacement for the chars line 2, 3)
	rect_oled(2, 18, OLED_FONT_MEDIUM_WIDTH , OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE , OLED_WHITE); // rectangle left (line 2 + 3)
	rect_oled(115, 18, OLED_FONT_MEDIUM_WIDTH , OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE, OLED_WHITE); // rectangle right (line 2 + 3)
}	

function draw_main_menu() {
	rect_oled(0, 0, 128, 49, OLED_BLACK, OLED_WHITE); // white contour
	rect_oled(1, 1, 126, 47, OLED_WHITE, OLED_BLACK); // Filled rectangle white (emplacement for lines 1, 2, 3)
	btn_left = RIGHT;
	btn_right = LEFT;
	// Display arrows	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X + 2, LINE_2_Y, OLED_FONT_SMALL, 1, OLED_WHITE); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X - 2, LINE_2_Y, OLED_FONT_SMALL, 1, OLED_WHITE);
	
}

define UP = 131, DOWN = 132, LEFT = 133, RIGHT = 134, TRIANGLE = 130, Y = 89, CROSS = 127, A = 65;
define LEFT_X = 4, RIGHT_X = 117;
define LINE_1_Y = 4, LINE_2_Y = 20, LINE_3_Y = 36, LINE_4_Y = 53, LINE_2_3_Y = 28;  
int btn_left;
int btn_right;

function draw_chars_line1() {
// Define button
	if(ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}
	else
	{		
		if(get_controller() == PIO_PS4)
		{
			btn_left = TRIANGLE;
			btn_right = TRIANGLE;
		}
		else
		{
			btn_left = Y;
			btn_right = Y;
		}
	}
	
	if(!ControllerMenu)
	{
	// Clears/fill rectangle
		rect_oled(3, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 1)
		rect_oled(116, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 1)
	// Display chars	
		putc_oled(1,btn_left); 
		puts_oled(LEFT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_left); 	
		putc_oled(1,btn_right); 
		puts_oled(RIGHT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_right); 
	}
}

function draw_chars_line2() {
// Define button
	btn_left = LEFT;
	btn_right = RIGHT;

// Clears/fill rectangle
	rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); //  rectangle left (line 2)
	rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); //  rectangle right (line 2)

// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_right); 
	
}

function draw_chars_line3() { 
// Define button
	btn_left = DOWN;
	btn_right = UP;
		
// Clears/fill rectangle
	rect_oled(3, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 3)
	rect_oled(116, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); // rectangle right (line 3)	

// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_left); 
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_right);  
}

function draw_hold_to_edit() { 
// Display chars	
	if(get_controller() == PIO_PS4)
	{
	// Clears/fill the inside of the "hold button" rectangle
		rect_oled(28, 19, OLED_FONT_SMALL_WIDTH + 1 , OLED_FONT_SMALL_HEIGHT , OLED_WHITE , col_rec_left); 
		rect_oled(91, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT  , OLED_WHITE, col_rec_right);
		
		putc_oled(1, CROSS);
		puts_oled(92, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, CROSS);
		puts_oled(28, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_right);
		
	// Contour for chars X / A (must be after display chars)
		rect_oled(27, 18, OLED_FONT_SMALL_WIDTH + 3 , OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK , OLED_WHITE); // small rectangle left (line 2)
		rect_oled(91, 18, OLED_FONT_SMALL_WIDTH + 3, OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK, OLED_WHITE); // small rectangle right (line 2)
	}
	else
	{
	// Clears/fill the inside of the "hold button" rectangle
		rect_oled(28, 19, OLED_FONT_SMALL_WIDTH + 2 , OLED_FONT_SMALL_HEIGHT , OLED_WHITE , col_rec_left); 
		rect_oled(91, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT  , OLED_WHITE, col_rec_right);
		
		putc_oled(1, A);
		puts_oled(92, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, A);
		puts_oled(29, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_right);
		
	// Contour for chars X / A (must be after display chars)
		rect_oled(27, 18, OLED_FONT_SMALL_WIDTH + 4 , OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK , OLED_WHITE); // small rectangle left (line 2)
		rect_oled(90, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK, OLED_WHITE); // small rectangle right (line 2)
	}
}

function draw_char_profiles() {
// Define button
	btn_left = LEFT;
	btn_right = RIGHT;

// Clears/fill rectangle
	rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 17, OLED_WHITE , col_rec_left); //  rectangle left (line 2)
	rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 17, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
		
// Display chars

	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, 28, OLED_FONT_SMALL, 1, col_char_left); 
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, 28, OLED_FONT_SMALL, 1, col_char_right); 
}

int col_char_left; 
int col_char_right;
int col_rec_left = 1;
int col_rec_right = 1;

function button_animation() {
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_TRIANGLE))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(!ModEdit && !MainMenu)
			draw_chars_line1();
	}
	else if(event_release(PS4_TRIANGLE))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
		{
			profile_idx = cycle(profile_idx + 1, 0, entry_count(PROFILE_TXT));
			display_new = TRUE; 
		}
		else if(ProfilesMenu)
		{
			profilesName_idx = cycle(profilesName_idx + 1, 0, entry_count(PROFILESNAME_TXT));
			
			if(profilesName_idx == PRIM_SEC_P)
			{
				draw_base_menu();
				draw_profilesMenu();	
				draw_chars_line1();	
				draw_char_profiles();
			}
			else
			{
				draw_base_menu();		
				draw_modMenu();		
				draw_chars_line1();		
				draw_chars_line2(); 
				draw_chars_line3();	
			}
			
			display_new = TRUE; 
		}
		if(!ModEdit && !MainMenu)
			draw_chars_line1();
	}	
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_LEFT))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
			{
				draw_chars_line2();
			}
			else
			{
				valName_idx -= 1;
			// Limits for Standard Anti-Recoil 
				if(modName_idx == ANTIRECOIL_M && toggle_antirecoil[profile_idx] == STANDARD)
				{	
					if(valName_idx == TIME_V)
						valName_idx = END_V;
					if(valName_idx < END_V)
						valName_idx = HORIZ_V;
				}
				draw_chars_line1();
				display_new = TRUE; 
			}
		}
		else if(ModMenu)
		{
			modName_idx = cycle(modName_idx - 1, 0, entry_count(MODNAME_TXT));  // create a loop in the values
			draw_chars_line2();
			display_new = TRUE; 
		}
		else if(ControllerMenu)
		{
			controllerName_idx = cycle(controllerName_idx - 1, 0, entry_count(CONTROLLERNAME_TXT)); // create a loop in the values
			draw_chars_line2();
			display_new = TRUE;
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx == PRIM_SEC_P)
			{
				toggle_pressBTN[profilesName_idx] = cycle(toggle_pressBTN[profilesName_idx] - 1, 0, entry_count(PROFILEBTN_PS_TXT));
				draw_char_profiles();
			}
			else
			{
				toggle_holdBTN[profilesName_idx] = cycle(toggle_holdBTN[profilesName_idx] - 1, 0, entry_count(PROFILEBTN_PS_TXT));  // create a loop in the values
				draw_chars_line2();
			}	
			display_new = TRUE; 
		}		
	}
	if(event_release(PS4_LEFT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx == PRIM_SEC_P)
				draw_char_profiles();
			else
				draw_chars_line2();
		}	
		else if(!MainMenu)
			draw_chars_line2();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_RIGHT))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;	
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
			{
				valName_idx += 1;				
			// Limits for Standard Anti-Recoil	
				if(modName_idx == ANTIRECOIL_M && toggle_antirecoil[profile_idx] == STANDARD)
				{								
					if(valName_idx == TIME_V)
						valName_idx = HORIZ_V;
					if(valName_idx > HORIZ_V)
						valName_idx = END_V;
				}
				draw_chars_line1();
				display_new = TRUE; 
			}
		}
		else if(ModMenu)
		{
			modName_idx = cycle(modName_idx + 1, 0, entry_count(MODNAME_TXT));  // create a loop in the values
			draw_chars_line2();
			display_new = TRUE; 
		}
		else if(ControllerMenu)
		{
			controllerName_idx = cycle(controllerName_idx + 1, 0, entry_count(CONTROLLERNAME_TXT)); // create a loop in the values
			draw_chars_line2();
			display_new = TRUE;
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx == PRIM_SEC_P)
			{
				toggle_pressBTN[profilesName_idx] = cycle(toggle_pressBTN[profilesName_idx] + 1, 0, entry_count(PROFILEBTN_PS_TXT));
				draw_char_profiles();
			}
			else
			{
				toggle_holdBTN[profilesName_idx] = cycle(toggle_holdBTN[profilesName_idx] + 1, 0, entry_count(PROFILEBTN_PS_TXT));  // create a loop in the values
				draw_chars_line2();
			}	
			display_new = TRUE; 
		}	
	}
	if(event_release(PS4_RIGHT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx == PRIM_SEC_P)
				draw_char_profiles();
			else
				draw_chars_line2();
		}	
		else if(!MainMenu)
			draw_chars_line2();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_UP))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;
		
		if(MainMenu)
		{
			menuName_idx = cycle(menuName_idx - 1, 0, entry_count(MENUNAME_TXT)); // create a loop in the values
			display_new = TRUE;
		}
		else if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx != PRIM_SEC_P)
			{
				toggle_pressBTN[profilesName_idx] = cycle(toggle_pressBTN[profilesName_idx] + 1, 0, entry_count(PROFILEBTN_PS_TXT)); // create a loop in the values
				draw_chars_line3();
				display_new = TRUE; 
			}
		}
		else if(!MainMenu)
			draw_chars_line3();
	}
	if(event_release(PS4_UP))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx != PRIM_SEC_P)
				draw_chars_line3();
		}
		else if(!MainMenu)
			draw_chars_line3();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_DOWN))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(MainMenu)
		{
			menuName_idx = cycle(menuName_idx + 1, 0, entry_count(MENUNAME_TXT)); // create a loop in the values
			display_new = TRUE;
		}
		else if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx != PRIM_SEC_P)
			{
				toggle_pressBTN[profilesName_idx] = cycle(toggle_pressBTN[profilesName_idx] - 1, 0, entry_count(PROFILEBTN_PS_TXT));  // create a loop in the values
				draw_chars_line3();
				display_new = TRUE;
			}
		}
		else if(!MainMenu)
			draw_chars_line3();
	}
	if(event_release(PS4_DOWN))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
		else if(ProfilesMenu)
		{
			if(profilesName_idx != PRIM_SEC_P)
				draw_chars_line3();
		}
		else if(!MainMenu)
			draw_chars_line3();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_CROSS))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
	if(event_release(PS4_CROSS))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(MainMenu)
		{
			if(menuName_idx == MODMENU_MM)
			{
				modName_idx = 0;
				ModMenu = TRUE;
				MainMenu = FALSE;			
				draw_modMenu();				
				draw_chars_line2(); 
				draw_chars_line3();	
			}
			
			else if(menuName_idx == CONTROLLER_MM)
			{
				controllerName_idx = 0;
				ControllerMenu = TRUE;
				MainMenu = FALSE;		
				draw_modMenu();				
				draw_chars_line2(); 
				draw_chars_line3();	
			}
			
			else if(menuName_idx == PROFILES_MM)
			{
				profilesName_idx = 0;
				ProfilesMenu = TRUE;
				MainMenu = FALSE;	
				draw_profilesMenu();	
				draw_char_profiles();
			}
			current_info = 0;
			draw_base_menu();
			draw_chars_line1();
			display_new = TRUE;
			display_info = TRUE;
		}
		else if(ModMenu) 
		{
			if(check_toggle()) // From ModMenu to ModEdit - if toggle is TRUE, I can enter Edit Menu	 
			{
				if(toggle_antirecoil[profile_idx] == 3)
					valName_idx = RUMBLEPOWER_V; // Display rumble power first
				else
					valName_idx = entry_count(VALNAME_TXT) + 1; // always display first val names available when enter in edition mod
						
				if(modName_idx == RAPIDFIRE_M) // RapidFire defaut values
				{
					if(toggle_rapidfire[profile_idx] == 2 && rate_of_fire[profile_idx] < 60)
						rate_of_fire[profile_idx] = 240;
					if(toggle_rapidfire[profile_idx] == 3 && rate_of_fire[profile_idx] > 25)
						rate_of_fire[profile_idx] = 4;
				}
					
				current_info = 0;		
				ModEdit = TRUE;
				ModMenu = FALSE;
				draw_modEdit();			
				draw_chars_line1();		
				draw_chars_line2();		
				draw_hold_to_edit();
				draw_chars_line3();	
				display_new = TRUE;
				display_info = TRUE;
			}
		}
		else if(ModEdit)	
			draw_hold_to_edit();
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_CIRCLE))
	{
		if(ModMenu) //From ModMenu to Main Menu
		{
			MainMenu = TRUE;
			ModMenu = FALSE;
			draw_main_menu();
		}
		if(ModEdit) // From ModEdit to ModMenu
		{
			ModMenu = TRUE;
			ModEdit = FALSE;
			draw_modMenu();		
			draw_chars_line1();	
			draw_chars_line2();	
			draw_chars_line3();
		}
		if(ControllerMenu) //From Controller Menu to Main Menu
		{
			MainMenu = TRUE;
			ControllerMenu = FALSE;
			draw_main_menu();
		}
		if(ProfilesMenu) //From Profiles Menu to Main Menu
		{
			MainMenu = TRUE;
			ProfilesMenu = FALSE;
			draw_main_menu();
		}
		current_info = 0;
		display_new = TRUE;
		display_info = TRUE;
	}
}

function draw_logo() {
	printf(center_x(sizeof(TITLE1) - 1,OLED_FONT_MEDIUM_WIDTH),1,OLED_FONT_MEDIUM,OLED_WHITE,TITLE1[0]);
	printf(center_x(sizeof(TITLE2) - 1,OLED_FONT_MEDIUM_WIDTH),22,OLED_FONT_MEDIUM,OLED_WHITE,TITLE2[0]);
}

/////////////////////////////////////////////////////////////////////////////////////////// C O N T R O L L E R  F U N C T I O N S 

function get_controller_profileBTN_TXT() {
	
	if(get_controller() == PIO_PS4) return PROFILEBTN_PS_TXT;
	else                            return PROFILEBTN_XB_TXT;
	
	return -1;
}

function get_controller_layoutBTN_TXT() {
	
	if(get_controller() == PIO_PS4) return LAYOUT_BTN_PS_TXT;
	else                            return LAYOUT_BTN_XB_TXT;
	
	return -1;
}

function get_controller_infoTXT() {

	if(get_controller() == PIO_PS4)
	{
		if(MainMenu)            return INFO_MAIN_PS_TXT;
		else if(ModMenu)        return INFO_TOGGLE_PS_TXT;
		else if(ModEdit)        return INFO_EDIT_PS_TXT;
		else if(ControllerMenu) return INFO_CONTROL_PS_TXT;
		else if(ProfilesMenu)   return INFO_PROFILE_PS_TXT;
	}
	else
	{
		if(MainMenu)            return INFO_MAIN_XB_TXT;
		else if(ModMenu)        return INFO_TOGGLE_XB_TXT;
		else if(ModEdit)        return INFO_EDIT_XB_TXT;
		else if(ControllerMenu) return INFO_CONTROL_XB_TXT;
		else if(ProfilesMenu)   return INFO_PROFILE_XB_TXT;
	}
	return -1;
}

/////////////////////////////////////////////////////////////////////////////////////////// M I S C   F U N C T I O N S 

int c,c_val;

function number_to_string(f_val,f_digits) {

    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            /*if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }*/
        }
        c_val /= 10;
    }
    if(display_title)
    	puts_oled(120, 54, OLED_FONT_SMALL, i - 1, OLED_WHITE); // display current # slot
    else
    	puts_oled(center_x(i - 1,OLED_FONT_MEDIUM_WIDTH),28,OLED_FONT_MEDIUM,i - 1,OLED_WHITE); // adjustable value centered in X - medium size
}

function cycle(f_val, f_lo, f_hi) {
	if(f_val > f_hi) return f_lo;
	if(f_val < f_lo) return f_hi;
	return f_val;
}

function find_digits(f_num) {

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}

function center_x(f_chars,f_font) {

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
}

function center_y(f_size) {

    return (OLED_HEIGHT  / 2) - (f_size / 2);
}

function press_hold(f_btn) { 

	return event_press(f_btn) || get_ival(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

function led(f_color) {

   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
/*set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);*/
}

/////////////////////////////////////////////////////////////////////////////////////////// S C R E E N   S A V E R   F U N C T I O N S 

int RT,MSC,SD1,DGT,DGR,TP1,TP2;
int X_1,Y_1,X_2,Y_2,X_3,Y_3, X_4,Y_4,X_5,Y_5,X_6,Y_6,X_7,Y_7,X_8,Y_8,RN1,RN2,RN3,RN4,RN5,RN6,RN7,RN8;
int SSMU1 = 1,SSMU2 = 8,SSMU3 = 15,SSMU4 = 22,SSMU5 = 29,SSMU6 = 36,SSMU7 = 43;
define SSA1 = 78,SSA2 = 79,SSA3 = 90,SSA4 = 66,SSA5 = 65,SSA6 = 82,SSA7 = 68,SSA8 = 82,SSA9 = 73,SSA10 = 70,SSA11 = 82,SSA13 = 50,SSA14 = 49,SAVER = 5000,SAVER1 = 10;

function name(){
	cls_oled(0);
	combo_run(RACE);
	combo_run(RN);
if (Y_1 > 64)  Y_1 =   0;
if (Y_2 > 64)  Y_2 =   0;
if (Y_3 > 64)  Y_3 =   0;
if (Y_4 > 64)  Y_4 =   0;
if (Y_5 > 64)  Y_5 =   0;
if (Y_6 > 64)  Y_6 =   0;
if (Y_7 > 64)  Y_7 =   0;
if (Y_8 > 64)  Y_8 =   0;
if (SD1 > 105) SD1 = -50;
if (TP1 > 45)  TP1 =   0;
if (TP2 < 0)   TP2 =  55;
	putc_oled(1,RN1);
	puts_oled(X_1,Y_1,0,1,1);
	putc_oled(1,RN2);
	puts_oled(X_2,Y_2,0,1,1);
	putc_oled(1,RN3);
	puts_oled(X_3,Y_3,0,1,1);
	putc_oled(1,RN4);
	puts_oled(X_4,Y_4,0,1,1);
	putc_oled(1,RN5);
	puts_oled(X_5,Y_5,0,1,1);
	putc_oled(1,RN6);
	puts_oled(X_6,Y_6,0,1,1);
	putc_oled(1,RN7);
	puts_oled(X_7,Y_7,0,1,1);
	putc_oled(1,RN8);
	puts_oled(X_8,Y_8,0,1,1);
	putc_oled(1,SSA1);
	puts_oled(SSMU1 + SD1,TP1 + 2,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU2 + SD1,TP2 + 4,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU3 + SD1,TP1 + 6,0,1,1);
	putc_oled(1,SSA3);
	puts_oled(SSMU4 + SD1,TP2 + 8,0,1,1);
	putc_oled(1,SSA4);
	puts_oled(SSMU5 + SD1,TP1 + 10,0,1,1);
	putc_oled(1,SSA5);
	puts_oled(SSMU6 + SD1,TP2 + 12,0,1,1);
	putc_oled(1,SSA6);
	puts_oled(SSMU7 + SD1,TP1 + 14,0,1,1);
}

/////////////////////////////////////////////////////////////////////////////////////////// S A V E   F U N C T I O N S

int mask;
int ret;
int pmemValue;

function set_15var(pvar, ret, position) { // values range = 0 ~ 1
	for(i = position; i < (1 + position); i++)
	{
		pvar = pvar & (~(1 << i));
	}
	pvar = pvar | (ret << position);
	
	return pvar;
}

function get_15var(pvar, position){
	mask = 0;
	ret = 0;
	for(i = 0; i < 1 ; i++)
	{
		mask = mask | (1 << i);
	}
	mask = mask << position
	ret = (pvar & mask) >> position
return ret;
}

function set_4var(_1, _2, _3, _4) { // values range = 0 ~ 15
	return 0xff00 & ((0xf0 & (_1 << 4) | _2) << 8) | (0xf0 & (_3 << 4) | _4); 
}

function get_4var(f_PMemory, f_dec_pos) { 
	return  (f_PMemory >> (4 * f_dec_pos)) & 0x0F; 
}

function set_2var(var1, var2) { // values range = -127 ~ 127
	ret = 0;
	
	if(var1 < 0)
   		var1 = abs(var1) | 0x80;

	ret = (abs(var2) << 8)|var1;
	
	if(var2 < 0)
		ret *= -1;
	
	return ret;
}

function get_2var(pvar, var) {
	ret = 0;
	
	if(var == 0)
	{	 
		ret = 0x80 & abs(pvar) ;
		ret = ret >> 7;
		ret = ((-2) * ret) + 1;
		ret = (abs(pvar) & 0x7F) * ret;
	}
	else
	{
		ret = pvar >> 8;

	    if(pvar < 0)
			ret += 1;
	}
	
	return ret;
}

function save() {
	MainMenu = FALSE;
	ModMenu = FALSE;
	ModEdit = FALSE;
	ControllerMenu = FALSE;
	ProfilesMenu = FALSE;
	cls_oled(OLED_BLACK);
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 	// display SAVED... centered in X Y 
	combo_run(SAVE);
// Toggles
	pmemValue = set_15var(pmemValue, toggle_burstfire[0]  ,  0);		pmemValue = set_15var(pmemValue, toggle_burstfire[1]  ,  1);		pmemValue = set_15var(pmemValue, toggle_burstfire[2]  ,  2);
	pmemValue = set_15var(pmemValue, toggle_aimabuse[0]   ,  3);		pmemValue = set_15var(pmemValue, toggle_aimabuse[1]   ,  4);		pmemValue = set_15var(pmemValue, toggle_aimabuse[2]   ,  5);
	pmemValue = set_15var(pmemValue, toggle_autoADS[0]    ,  6);		pmemValue = set_15var(pmemValue, toggle_autoADS[1]    ,  7);		pmemValue = set_15var(pmemValue, toggle_autoADS[2]    ,  8);
	pmemValue = set_15var(pmemValue, toggle_autoFIRE[0]   ,  9);		pmemValue = set_15var(pmemValue, toggle_autoFIRE[1]   , 10);		pmemValue = set_15var(pmemValue, toggle_autoFIRE[2]   , 11);
	pmemValue = set_15var(pmemValue, toggle_holdBreath[0] , 12);		pmemValue = set_15var(pmemValue, toggle_holdBreath[1] , 13);		pmemValue = set_15var(pmemValue, toggle_holdBreath[2] , 14);
	set_pvar(SPVAR_1,pmemValue); 
	
	
	pmemValue = set_15var(pmemValue, toggle_turboMelee[0] ,  0);		pmemValue = set_15var(pmemValue, toggle_turboMelee[1] ,  1);		pmemValue = set_15var(pmemValue, toggle_turboMelee[2] ,  2);
	pmemValue = set_15var(pmemValue, toggle_autorun       ,  3);	 	pmemValue = set_15var(pmemValue, toggle_bunnyHop      ,  4);	 	pmemValue = set_15var(pmemValue, toggle_hairTrigger   ,  5); 		
	pmemValue = set_15var(pmemValue, toggle_rumble        ,  6);	
	set_pvar(SPVAR_2,pmemValue);
	
	pmemValue = set_4var(toggle_antirecoil[0], toggle_antirecoil[1], toggle_antirecoil[2], toggle_slideCancel);
	set_pvar(SPVAR_3,pmemValue);
	
	pmemValue = set_4var(toggle_rapidfire[0], toggle_rapidfire[1], toggle_rapidfire[2], NOT_USE);
	set_pvar(SPVAR_4,pmemValue);
	
	pmemValue = set_4var(toggle_aimassist[0], toggle_aimassist[1], toggle_aimassist[2], NOT_USE);
	set_pvar(SPVAR_5,pmemValue);
	
	pmemValue = set_4var(toggle_shotMod[0], toggle_shotMod[1], toggle_shotMod[2], NOT_USE);
	set_pvar(SPVAR_6,pmemValue);
	
	pmemValue = set_4var(toggle_shotActivator[0], toggle_shotActivator[1], toggle_shotActivator[2], toggle_sensitivity);
	set_pvar(SPVAR_7,pmemValue);
	
	// Controller BTNs	
	pmemValue = set_2var(toggle_ads_btn, toggle_fire_btn);
	set_pvar(SPVAR_8,pmemValue);
	
	pmemValue = set_2var(toggle_tactical_btn, toggle_lethal_btn);
	set_pvar(SPVAR_9,pmemValue);
	
	pmemValue = set_2var(toggle_jump_btn, toggle_crouch_btn);
	set_pvar(SPVAR_10,pmemValue);
	
	pmemValue = set_2var(toggle_reload_btn, toggle_melee_btn);
	set_pvar(SPVAR_11,pmemValue);
	
	pmemValue = set_2var(toggle_sprint_btn, toggle_weapon_btn);
	set_pvar(SPVAR_12,pmemValue);
	
	// Profile Hold/Press BTNs
	pmemValue = set_4var(toggle_pressBTN[0], toggle_pressBTN[1], toggle_pressBTN[2], NOT_USE);
	set_pvar(SPVAR_13,pmemValue);
	
	pmemValue = set_4var(toggle_holdBTN[0], toggle_holdBTN[1], toggle_holdBTN[2], NOT_USE);
	set_pvar(SPVAR_14,pmemValue);

//Values
	// Antirecoil vertical values
	pmemValue = set_2var(antirecoil_start[0], antirecoil_end[0]);
	set_pvar(SPVAR_15,pmemValue);
	
	pmemValue = set_2var(antirecoil_start[1], antirecoil_end[1]);
	set_pvar(SPVAR_16,pmemValue);
	
	pmemValue = set_2var(antirecoil_start[2], antirecoil_end[2]);
	set_pvar(SPVAR_17,pmemValue);
	
	set_pvar(SPVAR_18,antirecoil_time[0]);
	set_pvar(SPVAR_19,antirecoil_time[1]);
	set_pvar(SPVAR_20,antirecoil_time[2]);
	
	// Antirecoil horizontal & rumble recoil values
	pmemValue = set_2var(antirecoil_horizontal[0], rumble_power[0]);
	set_pvar(SPVAR_21,pmemValue);
	
	pmemValue = set_2var(antirecoil_horizontal[1], rumble_power[1]);
	set_pvar(SPVAR_22,pmemValue);
	
	pmemValue = set_2var(antirecoil_horizontal[2], rumble_power[2]);
	set_pvar(SPVAR_23,pmemValue);
	
	// Rate of fire values
	set_pvar(SPVAR_24,rate_of_fire[0]);
	set_pvar(SPVAR_25,rate_of_fire[1]);
	set_pvar(SPVAR_26,rate_of_fire[2]);
	
	// BurstFire values
	set_pvar(SPVAR_27, burstfire_hold   );
	set_pvar(SPVAR_28, burstfire_release);
	
	// AIM Assist values
	pmemValue = set_2var(aimassist_radius, aimassist_angle);
	set_pvar(SPVAR_29,pmemValue);

	// AIM Abuse values
	set_pvar(SPVAR_30,aimabuse_hold);
	set_pvar(SPVAR_31,aimabuse_release);
	
	// StrafeShot values
	set_pvar(SPVAR_32,strafe_time);
	
	// Custom Sens values
	set_pvar(SPVAR_33,genSens);
	set_pvar(SPVAR_34,adsSens);
	set_pvar(SPVAR_35,hipSens);
	set_pvar(SPVAR_36,adsfireSens);
	
	// Dynamic Sens	values
	set_pvar(SPVAR_37,dynasens_initial_sens);
	
	pmemValue = set_2var(dynasens_limit, dynasens_restart);
	set_pvar(SPVAR_38,pmemValue);
	
	set_pvar(SPVAR_39,dynasens_max_sens);
	set_pvar(SPVAR_40,dynasens_increase_rate);
	
	// Slide Cancel Time
	set_pvar(SPVAR_41,cancel_time);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// M I S C   T E X T   T O   D I S P L A Y

	const string TITLE1 = "The French";
	const string TITLE2 = "Connection";
	const string SAVE = "SAVED";
	const string ALL = "Every Profiles";
	const string MUTE = "Script OFF";
	const string HOLD = "Dbl-Tap CIRCLE/B";
	const string ACTIVE = "to turn ON"
	const string CONTROLLER = "Controller"
	const string ANTIRECOIL_VERTICAL = "AR Vertical";
	const string PRESS_BTN = "Press BTN";
	const string HOLD_BTN = "Hold BTN";
	
	const string ONOFF[] = { 
	"OFF", "ON" }; 
	
	const string PROFILE[] = {
	"Primary", "Secondary", "Custom" };
	
	const string INFO_MAIN_PS[] = {
	"Switch menus:", "tap UP or DOWN", "Enter a menu:", "tap CROSS", "Close OLED Menus:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"};
	
	const string INFO_TOGGLE_PS[] = {
	"Switch Profile:", "tap TRIANGLE", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", 
	"Edit Menu:", "tap CROSS", "MainMenu:", "tap CIRCLE", "Close OLED Menus:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_EDIT_PS[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold CROSS + tap", "UP DOWN LEFT RIGHT", 
	"ModMenu:", "tap CIRCLE", "Close OLED Menus:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_CONTROL_PS[] = {
	"Navigate options:", "tap LEFT or RIGHT", "Edit options:", "tap UP or DOWN", 
	"MainMenu:", "tap CIRCLE", "Close OLED Menus:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_PROFILE_PS[] = {
	"Navigate options:", "tap TRIANGLE", "Edit options:", "tap" , "UP DOWN LEFT RIGHT",
	"MainMenu:", "tap CIRCLE", "Close OLED Menus:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"};

	const string INFO_MAIN_XB[] = {
	"Switch menus:", "tap UP or DOWN", "Enter a menu:", "tap A", "Close OLED Menus:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 
	
	const string INFO_TOGGLE_XB[] = {
	"Switch Profile:", "tap Y", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", 
	"Edit Menu:", "tap A", "MainMenu:", "tap B", "Close OLED Menus:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 
	
	const string INFO_EDIT_XB[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold A + tap", "UP DOWN LEFT RIGHT", 
	"ModMenu:", "tap B", "Close OLED Menus:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 
	
	const string INFO_CONTROL_XB[] = {
	"Navigate options:", "tap LEFT or RIGHT", "Edit options:", "tap UP or DOWN",  
	"MainMenu:", "tap B", "Close OLED Menus:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 
	
	const string INFO_PROFILE_XB[] = {
	"Navigate options:", "tap Y", "Edit options:", "tap" , "UP DOWN LEFT RIGHT",
	"MainMenu:", "tap B", "Close OLED Menus:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 