/*———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Game: Every Shooter (FPS / TPS)
Version: 1.2
Device: CronusZEN ONLY
Controller tested: DS4 - Elite 2
Console tested: PS4 (XBOX and PC compatible)
Author: noozbar

———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

This script has most of the mods that are essential to most shooter games (FPS or TPS)

It is not plug and play, the user will have to activate the mods he is interested in and also define which are the JUMP and CROUCH buttons from the OLED menu

Compatible with PS4 and XBOX controllers, this script will replace your View button on XBOX controller with the TOUCHPAD button when playing on PlayStation

To capture (SHARE button on PS controllers), press RS + View


This script is smart, it will disable RapidFire if you activate BurstFire on the same profile (or vice versa),

It will disable Dynamic Sens if you activate AIM Assist on one of the 3 profiles or disable AIM Assist on all profiles if you activate Dynamic Sens (because these mods are not compatible)

It will display the PS buttons in the menu if your controller is a PS controller, otherwise it will display the XBOX buttons

It will allow you to enter Mod Edit only if the displayed mod is activated and if it has one or more adjustable values

The AntiRecoil + AIM Assist combination has been reworked for maximum compatibility between these two mods

In short, a lot of work has been put into this script and I think I've managed to counter most of the possible manipulation errors... have fun

———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸	
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
											INSTRUCTIONS - IMPORTANT, PLEASE READ CAREFULLY
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸ ◹◺◿◸											

How to use the ModMenu:

	Open ModMenu (L2/LT + OPTIONS/MENU to open or exit)
	
		Choose which profile you want to modify (Primary, Secondary or SideArm) 
			- Tap TRIANGLE/Y 
			
		Navigate between the different MODS with LEFT or RIGHT (D pad)
			- tap UP or DOWN to turn ON or OFF or switch mod Type
		
		Activate the mods you want on each profile...
		
	If the mod displayed id active and has one or more editable value(s): 
		- Tap CROSS/A to close ModMenu and go to ModEdit
			
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	

How to use the ModEdit: (while in ModMenu, tap CROSS/A to close ModMenu and go to ModEdit - if the mod displayed is active and has one or more editable value(s))

		Navigate between the different value name with LEFT or RIGHT
		Change/edit the value:
			- Hold CROSS/A and 
				- tap UP or RIGHT to increase value 
				- tap DOWN or LEFT to decrease value
		
		To exit ModEdit and go back to ModMenu, tap CIRCLE/B
		
		Hold L2/LT and tap PS/XBOX to close every Menu
	
〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
				           
	Save every values and exit(only available if you are in ModMenu or ModEdit)		
		- Tap PS/XBOX to save EVERY values, toggles independently for EACH profiles 

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Speed toggles for the active profile (outside Mod Menu/Edit)
		- Hold aiming button and hold 300ms
			- UP for	AntiRecoil 
			- DOWN for	AIM Assist
			- RIGHT for	RapidFire
			- LEFT for	BurstFire
			
		- Hold aiming button and
			- DOUBLE TAP UP to switch between every AntiRecoil Type
			- DOUBLE TAP DOWN to switch between every AIM Assist Shapes
			- DOUBLE TAP RIGHT to switch between every RapidFire Type

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
	
	Switch profiles
		- In Game:
			- Tap TRIANGLE/Y to switch profile 1 and 2 (primary and secondary)
			- Double tap to switch to profile 3 (sidearm) (tap again to go back to the previous profile)
		- In Mod Menu/Edit/Weapon
			- Tap TRIANGLE/Y to loop profile 1, 2, 3, 1, 2, 3 ...
			
	Resync profiles
		- Hold L3/LS and tap TRIANGLE/Y

〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜	
		
	Kill Switch (disable everything)
		- Turn ON to OFF or OFF to ON
			- Hold aiming button and tap SHARE/VIEW 
			- Tap PS/XBOX 
			
		- Turn ON (disable everything)
			- Tap OPTIONS/MENU
			
		- Turn OFF (enable everything)
			- Double tap CIRCLE/B
			- Hold CIRCLE/B more than 600ms
		
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

														M O D S   D E S C R I P T I O N
														
AntiRecoil: allows to control the recoil of a weapon

	There are 3 types of Vertical AntiRecoil:
	- Progressive: the most precise but also the most difficult to adjust. It is composed of 3 adjustable values:
		- AR Start is the value that will allow you to counter the kick of your weapon on the first 5 bullets, on the first burst
		- AR End is the value that allows you to stabilize the weapon when you hold the fire button to empty your magazine on the enemy
		- AR Time is a time value and defines the duration of the progression, the time you will take to progressively increase or decrease your AntiRecoil

For example Start = 48, End = 25 and Time = 1000
When you fire, your AntiRecoil will compensate your recoil at 48 to counter the kick and then it will start to progressively go down to 25 and reach 25 in 1 second (1000ms)
This is exactly what you do with your finger on the stick when you don't have ZEN, you pull back hard to counter the kick and then release progressively (in a few seconds) the pressure on the stick to stabilize the weapon

	- Standard: less precise but easier to adjust. It has only one adjustable value:
		- AR Vertical is the value that allows you to stabilize the weapon when you hold the fire button to empty your magazine on the enemy
	
	- On Rumble: quite precise and very simple to set, it is based on the vibrations sent to the controller by the game. It has only one adjustable value:
		- Rumble Power is a value (coefficient) that allows you to finely adjust the recoil of the weapon if the default value is too high or too low

Each of these 3 types of AntiRecoil Vertical also has an AntiRecoil Horizontal value which is composed of a single value:
		- AR Horiz is a value that allows you to correct the horizontal recoil of your weapon, if it goes left or right when you shoot


Each weapon is different and will have different AntiRecoil values
AntiRecoil On Rumble is the one that will work best for most weapons without you having to change the mod value

You need to increase the value if your weapon keeps going up to the sky, and decrease the value if you shoot into your feet

If you play with the right stick reversed, set your Vertical AntiRecoil to negative values

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

RapidFire: turns a single shot weapon into an automatic weapon by spamming the trigger for you when you hold it down
	There are 3 types of RapidFire
	- Dynamic: no adjustment to make, the more you pull the trigger, the more the rate increases
	- Rounds per min: has only one adjustable value:
		- Rate of Fire defines the number of rounds fired in one minute (RPM or BPM of your weapon)
	- Rounds per sec: has only one adjustable value:
		- Rate of Fire defines the number of rounds fired in one second (RPS or BPS of your weapon)

Do not use RapidFire with a full automatic weapon, you will slow down the rate!

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

BurstFire: turns a full auto weapon into a burst weapon by firing in short bursts as you hold the trigger down - allows you to have less recoil and save bullets - It has 2 adjustable values
	- BF Hold is the length of time the trigger is held down
	- BF Release is the length of time the trigger is released

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

AIM Assist draws a small circle (or other shape) with the right stick to make it easier for your sight to stay in the virtual bubble around your enemy
	There are 6 different types of AIM Assist
	- Sticky (non-polar)
	- Circular 
	- Tall Oval
	- Wide Oval
	- Spiral
	- Helix
	
These different types have 2 adjustable values:
	- Radius which defines the radius or size of the drawn shape
	
The bigger the Radius, the more you will have a shaking screen sensation, but the stronger the assist will be
The smaller it is, the more the shaking sensation will disappear, but the assist will be less strong

	- Steps is the rate at which shapes are drawn
	
With Sticky, the higher the value, the slower the rate
With other shapes, the higher the value, the faster the rate
A too fast rate can create slowdowns in the character's movements/moves.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

AIM Abuse will spam the aim button to try to abuse the autosnap present in the game (works well with games like GTA)
	We have 2 adjustable values:
		- Hold Time is the time the button will remain pressed
		- Release Time is the time the button will be released

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Shot Mod:
	There are 3 types of Shot Mod:
	- Strafe Shot allows you to step sideways (from right to left)
	- Jump Shot allows you to jump when you shoot (you have to set the JUMP button in the menu)
	- Crouch Shot allows you to crouch or lie down when you shoot (you must set the CROUCH button in the menu)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Shot Activator allows you to define when and how the Shot Mod you have chosen will start up
	There are 3 possible options:
	- ADS + FIRE: the chosen Shot Mod will start when you press both triggers
	- ADS Only: the chosen Shot Mod will start when you press ADS and stop when you press FIRE
	- FIRE Only: the chosen Shot Mod will start when you press FIRE and stop when you press ADS

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Sensitivity: allows you to modify the sensitivity of your right stick
	There are 2 possible choices:
	- Custom Sens allows you to define your sensitivity in 4 different situations (so 4 adjustable values)
		- General changes your general sensitivity, without holding down ADS or FIRE
		- ADS changes your sensitivity when you hold down ADS
		- FIRE changes your sensitivity when you hold down FIRE
		- ADS + FIRE changes your sensitivity when you hold down ADS and FIRE at the same time

	- Dynamic Sens allows you to create a sensitivity curve like the ones available with the Elite controllers - this mod is complicated to set, see the example below

	DYNASENS_INITIAL_SENS displayed on OLED screen "DS Ini Sens" is your initial X and Y sensitivity (value range 0 - 100)
		While aiming, I want my sensitivity which is set to 100% in my game to be reduced by half as long as the stick input does not exceed DYNASENS_LIMIT
		So "DS Ini Sens" = 50 on the OLED screen

	DYNASENS_LIMIT displayed on OLED screen "DS Limit" is the stick input point from which the sensitivity increases (value range 0 - 100)
		When the stick input exceeds 65 (my DYNASENS_LIMIT value), it gradually increases the sensitivity from 50 (my DYNASENS_INITIAL_SENS value) to 100 (my DYNASENS_MAX_SENS value)
		The sensitivity increase rate is defined by DYNASENS_INCREASE_RATE

	DYNASENS_RESTART displayed on OLED screen "DS Restart" stick input point where sensitivity will reset back to initial sens (value range 0 - 100)
		When stick input goes down below 30 (my DYNASENS_RESTART value), stick sensitivity return to 50 (my DYNASENS_INITIAL_SENS value)

	DYNASENS_MAX_SENS displayed on OLED screen "DS Max Sens" is the maximum sensitivity value you want
		100 means that your maximum "DynaSens" sensitivity will be the one you set in your game

	DYNASENS_INCREASE_RATE displayed on OLED screen "DS Inc Rate" sensitivity increase rate
		1 = 10ms delay between increase

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Hair Trigger allows you to increase the sensitivity of your trigger for unparalleled responsiveness

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- AutoRun allows you to run automatically when you push the stick forward (or to the sides)
	The mod maintains R3 (or RS on XBOX) when you push the left stick more than 90%.

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Auto ADS allows to press ADS when you press FIRE

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Auto FIRE allows you to press FIRE when you press ADS

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Jump BTN matches your in-game Jump button to the Jump button in the script for the Jump Shot Mod

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Crouch BTN matches your in-game Crouch button to the Crouch button in the script for the Shot Mod Crouch Shot

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Trigger/Bumper allows you to reverse the buttons and triggers
	If you play with the triggers reversed in the game options, then enable this mod

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Rumble FeedBack allows you to block the vibrations of the controller if you don't like playing with vibrations
	Leave the vibrations enabled in the game options as AntiRecoil On Rumble needs the vibrations to be enabled in the game

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

															THANK YOU FOR READING
															THANK YOU FOR READING
															THANK YOU FOR READING
											
											
◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺ ◿◸◹◺
———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*/

// Text to display 
	const string OFF = "OFF"; 
	const string ON = "ON"; 
	const string SAVE = "SAVED";
	const string ALL = "Every Profiles";
	const string MUTE = "Script OFF";
	const string HOLD = "Dbl-Tap CIRCLE/B";
	const string ACTIVE = "to turn ON"
	const string ANTIRECOIL_VERTICAL = "AR Vertical";
	
	const string PROFILE[] = {
	"Primary", "Secondary", "SideArm" };
	
	const string ANTIRECOIL[] = {
	"OFF", "Progressive", "Standard", "On Rumble" };
	
	const string RAPIDFIRE[] = {
	"OFF", "Dynamic", "Rounds per min", "Rounds per sec" };
	
	const string SHAPES[] = {
	"OFF", "Sticky", "Circular", "Tall Oval", "Wide Oval", "Spiral", "Helix" };
	
	const string SHOT_MOD[] = {
	"OFF", "Strafe Shot", "Jump Shot", "Crouch Shot" };
	
	const string SHOT_ACTIVATOR[] = {
	"ADS + FIRE", "ADS Only", "FIRE Only" };
	
	const string SENSITIVITY[] = {
	"OFF", "Custom Sens", "Dynamic Sens" };
	
	const string SWAP[] = {
	"Standard", "Swapped"};
	
	const string PS_BTN[] = {
	"CROSS", "CIRCLE", "R3", "L1" };
	
	const string XB_BTN[] = {
	"A", "B", "RS", "LB" };
	
	const uint8 BTN[] = {
	PS4_CROSS, PS4_CIRCLE, PS4_R3, PS4_L1 };
	
	const string INFO_MENU_PS[] = {
	"Switch Profile:", "tap TRIANGLE", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", 
	"Edit Menu:", "tap CROSS", "Close ModMenu:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_EDIT_PS[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold CROSS +", "UP DOWN LEFT RIGHT", 
	"Toggle Menu:", "tap CIRCLE", "Close ModMenu:", "hold L2 +", "tap OPTION", "Save and exit:", "tap PS"}; 
	
	const string INFO_MENU_XB[] = {
	"Switch Profile:", "tap Y", "Switch Mod:", "tap LEFT or RIGHT", "Toggle ON/OFF:", "tap UP or DOWN", 
	"Edit Menu:", "tap A", "Close ModMenu:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 
	
	const string INFO_EDIT_XB[] = {
	"Switch Value:", "tap LEFT or RIGHT", "Edit Value:", "hold A +", "UP DOWN LEFT RIGHT", 
	"Toggle Menu:", "tap B", "Close ModMenu:", "hold LT +", "tap MENU", "Save and exit:", "tap XBOX"}; 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

//                          M O D S   N A M E   A N D   T O G G L E S

// Mod Name
	const string MODNAME[] = {
			"AntiRecoil"    , "RapidFire"   , "BurstFire"     , "AIM Assist"    , "AIM Abuse" ,  "Shot Mod"  , 
// modName_idx = 0          |      1        |      2          |       3         |      4      |        5
			"Shot Acrivator","Sensitivity"  , "Hair Trigger"  , "AutoRun"       , "Auto ADS"  , "Auto FIRE"  ,  
// modName_idx = 6          |      7        |      8          |       9         |      10     |      11
			 "Jump BTN"     , "Crouch BTN"  , "Trigger/Bumper", "RumbleFeedBack"
// modName_idx = 12         |     13        |       14        |      15         |    
	};

// Index to find Mod Name string - switchable in game with left/right in ModMenu 
	int modName_idx;
	
	define 	ANTIRECOIL_M = 0, RAPIDFIRE_M = 1, BURSTFIRE_M = 2, AIMASSIST_M = 3, AIMABUSE_M = 4, SHOTMOD_M = 5, SHOTACTIVATOR_M = 6,
			SENSITIVITY_M = 7, HAIRTRIGGER_M = 8, AUTORUN_M = 9, AUTOADS = 10, AUTOFIRE = 11, 
			JUMPBTN_M = 12, CROUCH_BTN = 13, TRIGGERBUMPER_M = 14, RUMBLEFEEDBACK_M = 15;
			
// Toggles for [3] Profiles: [profile_idx] = 0, 1 and 2
	int toggle_antirecoil[3];  
	int toggle_rapidfire[3];  
	int toggle_burstfire[3];
	int toggle_aimassist[3];
	int toggle_aimabuse[3];
	int toggle_shotMod[3]; 
	int toggle_shotActivator[3];
	
// Amount of multi toggle - Used for display profiles
	define AMOUNT_OF_MULTI_TOGGLE = 7;

// Toggles
	int sensitivity_on;
	int hairTrigger_on;
	int autorun_on;
	int autoADS_on;
	int autoFIRE_on;
	int jump_btn;
	int crouch_btn;
	int swap_on;
	int rumble_on;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Value Name
	const string VALNAME [] = {
			"AR Start"   , "AR End"   , "AR Time"   , "AR Horiz"   , "Rumble Power", "Rate of Fire" , 
// valName_idx = 0       |      1     |      2      |       3      |       4       |       5
 			"BF Hold"    ,"BF Release", "Radius"    , "Steps"      ,  "Hold Time"  , "Release Time" , "Strafe Time",
// valName_idx = 6       |      7     |      8      |       9      |       10      |     11         |       12
 			"DS Ini Sens", "DS Limit" , "DS Restart", "DS Max Sens", "DS Inc Rate" , "General"      , "ADS" , "FIRE" , "ADS + FIRE" 
// valName_idx = 13      |     14     |      15     |      16      |      17       |       18       |   19  |   20   |      21      |    
	};

// Index to find Value Name string - switchable in game with left/right in ModEdit 
	int valName_idx;
	
// Adjustable values for [3] profiles: [profile_idx] = 0, 1 and 2 
	int antirecoil_start[3]; // antirecoil start value for 3 profiles: profile_idx = 0, 1 and 2 - add this value to the corresponding value in the array to find your final value
	int antirecoil_end[3];
	int antirecoil_time[3];
	int antirecoil_horizontal[3];
	int rate_of_fire[3];
	int rumble_power[3];
	
// Adjustable values
  // BurstFire values
	int burstfire_hold; // BurstFire have toggle for each profiles BUT the same values for each
	int burstfire_release;
  // AIM Assist values
	int aimassist_radius; // AIM Assist have toggle for each profiles BUT the same values for each
	int aimassist_angle;
// AIM Abuse values
	int aimabuse_hold;
	int aimabuse_release;
	// Strafe Shot value
	int strafe_time; // StrafeShot have toggle for each profiles BUT the same value for each
  // Custom Sens values
	int genSens;
	int adsSens;
	int hipSens;
	int adsfireSens;
	int customsens;
  // Dynamic Sens values
	int dynasens_initial_sens;    // initial RX/RY sentitivity
	int dynasens_limit;           // stick input point where RX/RY sens increases
	int dynasens_restart;         // stick input point where RX/RY sens will reset back to initial value dynasens_initial_sens
	int dynasens_max_sens;        // maximum sensitivity value 
	int dynasens_increase_rate;   // rate sensitivity increased (8 = 80ms delay between increase)
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

	const int16 ANTIRECOIL_VAL[][] = { 
//               ar start, ar end, ar time, ar horiz
/* Primary   */ {  50    ,   30  ,   1000  ,    0   }, 
/* Secondary */	{  35    ,   25  ,   1000  ,    0   },
/* SideArm   */	{  40    ,   20  ,   1000  ,    0   }
	};

// Adjustable value + array value = final value
	int final_antirecoil_start;
	int final_antirecoil_end;
	int final_antirecoil_time;
	int final_antirecoil_horizontal;
	int final_rate_of_fire;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Constant bytes - Convert numbers array - ASCII_NUM[column number]
	const uint8 ASCII_NUM[] = 
//	  0  1  2  3  4  5  6  7  8  9  (column numbers)
  	{48,49,50,51,52,53,54,55,56,57};
	
// Variables for functions 
	int i;

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

data(
//  0 Blue    1 Pink   2 SkyBlue  3 Green         
    1,0,0,0,  0,0,0,1,  1,0,1,0,  0,0,1,0,
//  4 Yellow  5 White   6 Red      7 OFF         
    0,1,1,0,  1,1,1,0,  0,1,0,0,  0,0,0,0 );     
     
// Refresh OLED
	int display_title = TRUE;
	int display_new; 
	int display_info;
	int display_black;
	int screensaver;

// ModMenu / ModEdit / KillSwitch
	int ModMenu;	
	int ModEdit;
	int KillSwitch;
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

// Anti Recoil  
	//int rumble;
	int rumble_recoil;
	int antirecoil_boost;
	
// RapidFire / BurstFire
	int hold_time;                                                    
	int rest_time;
	int led_on;
	int led_off;
	
// Counter
	int count_black; 
	int info_timer;
	
// Profiles
	int switch_ref;
	int profile_idx; // Used to define Profiles and also define # of profile to find, edit, and display the right index
 	
//Misc
	int ads_btn;
	int fire_btn;
	int currentSlot;
	int current_info;
	int logo_on; // check if logo is displayed or not to refresh display
	
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

init{
					// Load default/stored values
// Toggles
	pmemValue = get_pvar(SPVAR_1, 1, 32767, 0);
	toggle_burstfire[0]    = get_15var(pmemValue, 0);	toggle_burstfire[1]  = get_15var(pmemValue,  1);	toggle_burstfire[2]  = get_15var(pmemValue,  2);
	hairTrigger_on         = get_15var(pmemValue, 3);	autorun_on           = get_15var(pmemValue,  4);	autoADS_on           = get_15var(pmemValue,  5);
	autoFIRE_on            = get_15var(pmemValue, 6);	swap_on              = get_15var(pmemValue,  7);	rumble_on            = get_15var(pmemValue,  8);	
	toggle_aimabuse[0]     = get_15var(pmemValue, 9);	toggle_aimabuse[1]   = get_15var(pmemValue, 10);	toggle_aimabuse[2]   = get_15var(pmemValue, 11);
	
	
	pmemValue = get_pvar(SPVAR_2, -32768, 32767, 0);
	toggle_antirecoil[0] = get_4var(pmemValue, 3);		toggle_antirecoil[1] = get_4var(pmemValue, 2);		toggle_antirecoil[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_3, -32768, 32767, 0);
	toggle_rapidfire[0] = get_4var(pmemValue, 3);		toggle_rapidfire[1] = get_4var(pmemValue, 2);		toggle_rapidfire[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_4, -32768, 32767, 0);
	toggle_aimassist[0] = get_4var(pmemValue, 3);		toggle_aimassist[1] = get_4var(pmemValue, 2);		toggle_aimassist[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_5, -32768, 32767, 0);
	toggle_shotMod[0] = get_4var(pmemValue, 3);		toggle_shotMod[1] = get_4var(pmemValue, 2);		toggle_shotMod[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_6, -32768, 32767, 0);
	toggle_shotActivator[0] = get_4var(pmemValue, 3);		toggle_shotActivator[1] = get_4var(pmemValue, 2);		toggle_shotActivator[2] = get_4var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_7, -32768, 32767, 0);
	sensitivity_on = get_4var(pmemValue, 3);		jump_btn = get_4var(pmemValue, 2);		crouch_btn = get_4var(pmemValue, 1);
	
// Antirecoil vertical values
	pmemValue = get_pvar(SPVAR_8, -32768, 32767, 0);
	antirecoil_start[0] = get_2var(pmemValue, 0);		antirecoil_end[0] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_9, -32768, 32767, 0);
	antirecoil_start[1] = get_2var(pmemValue, 0);		antirecoil_end[1] = get_2var(pmemValue, 1);

	pmemValue = get_pvar(SPVAR_10, -32768, 32767, 0);
	antirecoil_start[2] = get_2var(pmemValue, 0);		antirecoil_end[2] = get_2var(pmemValue, 1);
	
	antirecoil_time[0] = get_pvar(SPVAR_11, -32768, 32767, 0);
	antirecoil_time[1] = get_pvar(SPVAR_12, -32768, 32767, 0);
	antirecoil_time[2] = get_pvar(SPVAR_13, -32768, 32767, 0);
	
// Antirecoil horizontal & rumble recoil values
	pmemValue = get_pvar(SPVAR_14, -32768, 32767, 0);
	antirecoil_horizontal[0] = get_2var(pmemValue, 0);		rumble_power[0] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_15, -32768, 32767, 0);
	antirecoil_horizontal[1] = get_2var(pmemValue, 0);		rumble_power[1] = get_2var(pmemValue, 1);
	
	pmemValue = get_pvar(SPVAR_16, -32768, 32767, 0);
	antirecoil_horizontal[2] = get_2var(pmemValue, 0);		rumble_power[2] = get_2var(pmemValue, 1);
	
// Rate of fire values
	rate_of_fire[0] = get_pvar(SPVAR_17, -32768, 32767, 0);
	rate_of_fire[1] = get_pvar(SPVAR_18, -32768, 32767, 0);
	rate_of_fire[2] = get_pvar(SPVAR_19, -32768, 32767, 0);
	
// BurstFire values
	burstfire_hold     = get_pvar(SPVAR_20, 1,  1000, 120);
	burstfire_release  = get_pvar(SPVAR_21, 1,  1000, 120);
	
// AIM Assist values
	pmemValue = get_pvar(SPVAR_22, 1, 32767, set_2var(20, 15));
	aimassist_radius = get_2var(pmemValue, 0);		aimassist_angle = get_2var(pmemValue, 1);
	
// StrafeShot value
	strafe_time = get_pvar(SPVAR_23, 1, 10000, 500);
	
// Custom Sens values
	genSens     = get_pvar(SPVAR_24, 1, 327, 100);
	adsSens     = get_pvar(SPVAR_25, 1, 327, 100);
	hipSens     = get_pvar(SPVAR_26, 1, 327, 100);
	adsfireSens = get_pvar(SPVAR_27, 1, 327, 100);
	
// Dynamic Sens values
	dynasens_initial_sens = get_pvar(SPVAR_28, 1, 327, 60 );
	
	pmemValue = get_pvar(SPVAR_29, 1, 32767, set_2var(80, 30));
	dynasens_limit   = get_2var(pmemValue, 0);		dynasens_restart = get_2var(pmemValue, 1);
	
	dynasens_max_sens      = get_pvar(SPVAR_30, 1, 327, 100);
	dynasens_increase_rate = get_pvar(SPVAR_31, 1, 50 , 1  );
	
// AIM Abuse values
	aimabuse_hold     = get_pvar(SPVAR_32, 1, 500, 100);
	aimabuse_release  = get_pvar(SPVAR_33, 1, 500,  50);
	
// Get current slot
	currentSlot = get_slot();
}

main { // main section start
/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                         DEBUG                                                         |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	

	set_val(TRACE_1, profile_idx);
	set_val(TRACE_2, modName_idx);
	set_val(TRACE_2, valName_idx);

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                       CROSSOVER                                                       |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
    if(get_controller() != PIO_PS4) // If not PS4 controller:
    {
    	// If PS4 console:
        if(get_console() == PIO_PS4)
        { 
        	if(get_ival(PS4_SHARE))
        	{
        		if(get_ival(PS4_R3)) // RS + View =  ScreenShot
        		{
					set_val(PS4_SHARE,100);
                	set_val(PS4_TOUCH,0);
                	set_val(PS4_R3,0);
        		}
        		else // View only = PS4_TOUCH
        		{
        			set_val(PS4_TOUCH, 100);
        			set_val(PS4_SHARE, 0);
        		}
        	}
        }
	}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                   TOGGLE KILLSWITCH                                                   |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	 
	if(!ModMenu && !ModEdit)
	{
	// KillSwitch ON or OFF method
		if( (get_ival(PS4_L2) && event_press(PS4_SHARE)) || (!get_ival(PS4_L2) && event_press(PS4_PS)) )
		{			
			KillSwitch = !KillSwitch;
			
			if(KillSwitch) 
				combo_run(RUMBLE_OFF);	// rumble and LED blink
				
			else
			{
				combo_run(RUMBLE_ON);	// rumble and LED blink
				display_title = TRUE;	// display Title screen, profile, Weapon Name, active slot and killswitch
			}
		}

	// KillSwitch - activation method (TRUE, script is muted)
		if(!KillSwitch)
		{
			combo_stop(KILLSWITCH);
			
			if(!get_ival(PS4_L2) && event_press(PS4_OPTIONS))
			{
				KillSwitch = TRUE;
				combo_run(RUMBLE_OFF);	// rumble and LED blink
			}
		}
		
	// KillSwitch - exit method (FALSE, script is actived)
		if(KillSwitch) 
		{
    		screensaver= FALSE;
			count_black = 0;
			logo_on = FALSE;
	
			if( (get_ival(PS4_CIRCLE) && get_ptime(PS4_CIRCLE) > 600) || (event_press(PS4_CIRCLE) && get_brtime(PS4_CIRCLE) < 200) ) // Hold CIRCLE/B 600ms or double tap to exit
			{
				KillSwitch = FALSE;
				combo_run(RUMBLE_ON);
				display_title = TRUE; 
			}
			
			combo_run(KILLSWITCH);
		}
	// Block button	
		if(get_ival(PS4_L2))
		{
			if(get_controller() != PIO_PS4) 
				set_val(PS4_TOUCH, 0);
			else
				set_val(PS4_SHARE, 0);
		}
	}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                        IF KILLSWITCH IS OFF (SCRIPT IS ACTIVE)                                        |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/	
	if(!KillSwitch)
	{
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                     TOGGLE MOD MENU                                   |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(get_ival(PS4_L2))
		{	
			if(event_release(PS4_OPTIONS))
			{
				cls_oled(OLED_BLACK);
    			logo_on = FALSE;
    			
				if(ModEdit)
				{
					ModEdit = FALSE;
					display_title = TRUE;   
				}
				else 
					ModMenu = !ModMenu;
				
				if(!ModMenu)
				{
					combo_run(RUMBLE_OFF); 
					display_title = TRUE;  
				}
				if(ModMenu)
				{
					modName_idx = ANTIRECOIL_M;        
					current_info = 0;		
					combo_run(RUMBLE_ON);	
					draw_base_menu();		
					draw_modMenu();		
					draw_chars_line1();		
					draw_chars_line2(); 
					draw_chars_line3();		
					display_new = TRUE;
					display_info = TRUE;
				}
			}
		// Block button	   
			set_val(PS4_OPTIONS, 0);
		} // L2/LT section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                   MOD MENU IS ACTIVE                                  |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(ModMenu) 
		{
		// Buttons animation
			button_animation(); 
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                           TOGGLE FOR MODS                             |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		// From ModMenu to ModEdit
			if(check_toggle()) 	 
			{
				if(event_release(PS4_CROSS))
				{
					if(toggle_antirecoil[profile_idx] == 3)
						valName_idx = 4; // Display rumble power first
					else
						valName_idx = entry_count(VALNAME_TXT) + 1; // always display first val names available when enter in edition mod
						
					if(modName_idx == RAPIDFIRE_M) // RapidFire defaut values
					{
						if(toggle_rapidfire[profile_idx] == 2 && rate_of_fire[profile_idx] < 60)
							rate_of_fire[profile_idx] = 240;
						if(toggle_rapidfire[profile_idx] == 3 && rate_of_fire[profile_idx] > 25)
							rate_of_fire[profile_idx] = 4;
					}
					
					current_info = 0;		
					ModEdit = TRUE;
					ModMenu = FALSE;
					draw_modEdit();			
					draw_chars_line1();		
					draw_chars_line2();		
					draw_hold_to_edit();
					draw_chars_line3();	
					display_new = TRUE;
					display_info = TRUE;
				}
			}
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                  MOD NAME NAVIGATION                  |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Navigate mods name
			if(event_press(PS4_RIGHT))
			{
				modName_idx = cycle(modName_idx + 1, 0, entry_count(MODNAME_TXT)); // create a loop in the values
				display_new = TRUE; 
			}
			
			if(event_press(PS4_LEFT))
			{
				modName_idx = cycle(modName_idx - 1, 0, entry_count(MODNAME_TXT));  // create a loop in the values
				display_new = TRUE; 
			}
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                    TOGGLE FOR MODS                    |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Tap UP or DOWN to turn ON/OFF
	   		// Mods that may have different ON/OFF status depending on the active Profile
			toggle_antirecoil[profile_idx]    = toggle( ANTIRECOIL_M   , toggle_antirecoil[profile_idx]    );
			toggle_rapidfire[profile_idx]     = toggle( RAPIDFIRE_M    , toggle_rapidfire[profile_idx]     );
			toggle_burstfire[profile_idx]     = toggle( BURSTFIRE_M    , toggle_burstfire[profile_idx]     );
			toggle_aimassist[profile_idx]     = toggle( AIMASSIST_M    , toggle_aimassist[profile_idx]     );
			toggle_aimabuse[profile_idx]      = toggle( AIMABUSE_M     , toggle_aimabuse[profile_idx]      );
			toggle_shotMod[profile_idx]       = toggle( SHOTMOD_M      , toggle_shotMod[profile_idx]       );
			toggle_shotActivator[profile_idx] = toggle( SHOTACTIVATOR_M, toggle_shotActivator[profile_idx] );
		
		// Mods that have same ON/OFF status on every Profiles
			sensitivity_on = toggle( SENSITIVITY_M   , sensitivity_on );
			hairTrigger_on = toggle( HAIRTRIGGER_M   , hairTrigger_on );
			autorun_on     = toggle( AUTORUN_M       , autorun_on     );
			autoADS_on     = toggle( AUTOADS         , autoADS_on     );
			autoFIRE_on    = toggle( AUTOFIRE        , autoFIRE_on    );
			jump_btn       = toggle( JUMPBTN_M       , jump_btn       );
			crouch_btn     = toggle( CROUCH_BTN      , crouch_btn     );
			swap_on        = toggle( TRIGGERBUMPER_M , swap_on        );
			rumble_on      = toggle( RUMBLEFEEDBACK_M, rumble_on      );
		} // ModMenu section end
	
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                                   MOD EDIT IS ACTIVE                                  |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/	
		if(ModEdit) 
		{
		// Buttons animation
			button_animation(); // define if the rectangle behind the arrow must be clear or fill, and define if the arrow must be black or white
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|                EDIT ADJUSTABLE VALUES                 |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
		// Edit value: hold CROSS/A + UP (+1 or +10) or DOWN (-1 or -10) or RIGHT (+10 or +100) or LEFT (-10 or -100)	
			if(get_ival(PS4_CROSS)) 
			{
			// Mods that may have different values depending on the active Profile
				antirecoil_start[profile_idx]      = edit_val( 0 , antirecoil_start[profile_idx]     , -99 ,    99 ,   1 , 10   ); 
				antirecoil_end[profile_idx]        = edit_val( 1 , antirecoil_end[profile_idx]       , -99 ,    99 ,   1 , 10   ); 
				antirecoil_time[profile_idx]       = edit_val( 2 , antirecoil_time[profile_idx]      ,  0  , 10000 , 100 , 1000 );  
				antirecoil_horizontal[profile_idx] = edit_val( 3 , antirecoil_horizontal[profile_idx], -99 ,    99 ,   1 , 10   ); 
				rumble_power[profile_idx]          = edit_val( 4 , rumble_power[profile_idx]         , -60 ,    60 ,   1 , 10   );
				if(toggle_rapidfire[profile_idx] == 2)
					rate_of_fire[profile_idx]      = edit_val( 5 , rate_of_fire[profile_idx]         ,  60 ,   750 ,   1 , 10   );
				else if(toggle_rapidfire[profile_idx] == 3)
					rate_of_fire[profile_idx]      = edit_val( 5 , rate_of_fire[profile_idx]         ,  1  ,    25 ,   1 , 10   );
				
			// Mods that have same value on every Profiles
				burstfire_hold         = edit_val( 6 , burstfire_hold         , 0 ,  1000 , 10 , 100 );
				burstfire_release      = edit_val( 7 , burstfire_release      , 0 ,  1000 , 10 , 100 );
				aimassist_radius       = edit_val( 8 , aimassist_radius       , 0 ,    50 , 1  , 10  );
				aimassist_angle        = edit_val( 9 , aimassist_angle        , 0 ,    50 , 1  , 10  ); 
				aimabuse_hold          = edit_val( 10, aimabuse_hold          , 0 ,   500 , 10 , 100 );
				aimabuse_release       = edit_val( 11, aimabuse_release       , 0 ,   500 , 10 , 100 ); 
				strafe_time            = edit_val( 12, strafe_time            , 0 , 10000 , 10 , 100 );
				dynasens_initial_sens  = edit_val( 13, dynasens_initial_sens  , 0 ,   327 , 1  , 10  );
				dynasens_limit         = edit_val( 14, dynasens_limit         , 0 ,   100 , 1  , 10  );
				dynasens_restart       = edit_val( 15, dynasens_restart       , 0 ,   100 , 1  , 10  );
				dynasens_max_sens      = edit_val( 16, dynasens_max_sens      , 0 ,   327 , 1  , 10  );
				dynasens_increase_rate = edit_val( 17, dynasens_increase_rate , 1 ,    50 , 1  , 10  );
				genSens                = edit_val( 18, genSens                , 1 ,   327 , 1  , 10  );
				adsSens                = edit_val( 19, adsSens                , 1 ,   327 , 1  , 10  );
				hipSens                = edit_val( 20, hipSens                , 1 ,   327 , 1  , 10  );
				adsfireSens            = edit_val( 21, adsfireSens            , 1 ,   327 , 1  , 10  );
			} // CROSS/A section end
			
		/*— ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — °
		|  FIND AVAILABLE VALUES AND NAVIGATION BETWEEN VALUES  |
		° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° — ° —*/
			else // if NOT EDIT_BTN
			{	
			// From ModEdit to ModMenu	
				if(event_press(PS4_CIRCLE))
				{
					current_info = 0;	
					ModMenu = TRUE;
					ModEdit = FALSE;
					draw_modMenu();		
					draw_chars_line1();	
					draw_chars_line2();	
					draw_chars_line3();
					display_new = TRUE;
					display_info = TRUE;
				}
				
			// Navigate value name
				if(event_press(PS4_RIGHT))
				{
					valName_idx += 1;
				// Limits for Standard Anti-Recoil	
					if(modName_idx == ANTIRECOIL_M && toggle_antirecoil[profile_idx] == 2)
					{								
						if(valName_idx == 2)
							valName_idx = 3;
						if(valName_idx > 3)
							valName_idx = 1;
					}
					display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
				}
				if(event_press(PS4_LEFT))
				{
					valName_idx -= 1;
				// Limits for Standard Anti-Recoil 
					if(modName_idx == ANTIRECOIL_M && toggle_antirecoil[profile_idx] == 2)
					{	
						if(valName_idx == 2)
							valName_idx = 1;
						if(valName_idx < 1)
							valName_idx = 3;
					}
					display_new = TRUE; // display ModName, ModEdit, ModWeapon, profile, ON/OFF and value
				}
					
			// Available values for each of the mods 
				if(modName_idx == ANTIRECOIL_M) // AntiRecoil
				{
					if(toggle_antirecoil[profile_idx] == 3)
						valName_idx = cycle(valName_idx, 3, 4 );   // Rumble AR
					else if(toggle_antirecoil[profile_idx] == 2)
						valName_idx = cycle(valName_idx, 1 , 3  ); // AntiRecoil Standard
					else
						valName_idx = cycle(valName_idx, 0 , 3  ); // AntiRecoil Progressive
				}
				
				if(modName_idx == RAPIDFIRE_M) valName_idx = cycle(valName_idx, 5 , 5  );// RapidFire
				if(modName_idx == BURSTFIRE_M) valName_idx = cycle(valName_idx, 6 , 7  );// BurstFire
				if(modName_idx == AIMASSIST_M) valName_idx = cycle(valName_idx, 8 , 9  );// AIM Assist
				if(modName_idx == AIMABUSE_M ) valName_idx = cycle(valName_idx, 10, 11 );// AIM Abuse
				if(modName_idx == SHOTMOD_M  ) valName_idx = cycle(valName_idx, 12, 12 );// StrafeShot
				
				if(modName_idx == SENSITIVITY_M) // Sensitivity
				{
					if(sensitivity_on == 1)
						valName_idx = cycle(valName_idx, 18, 21 );// Custom Sens
					else if(sensitivity_on == 2)
						valName_idx = cycle(valName_idx, 13, 17 );// DynaSens
				}
			} // NOT EDIT_BTN section end
		} // ModEdit section end	

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                             MOD MENU OR MOD EDIT IS ACTIVE                            |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(ModMenu || ModEdit) 
		{
		//Stop screen Saver
    		screensaver = FALSE;
			count_black = 0;
			
		// Timer to display user infos
			info_timer += get_rtime();
	
			if(info_timer > 2000)
			{
				current_info ++;
				display_info = TRUE;
			}
			
		// Save everything and EXIT
			if(!get_ival(PS4_L2) && event_release(PS4_PS))
				save();
				
		// block ALL inputs 
			block_btn(); // user function
			
		// Switch Profiles (not in ModEdit)
			if(event_release(PS4_TRIANGLE) && !ModEdit)
			{	
				profile_idx = cycle(profile_idx + 1, 0, entry_count(PROFILE_TXT));
				display_new = TRUE; 
			}
		}

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                      FIND FINAL ANTIRECOIL AND RAPIDFIRE VALUES                       |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
	
	// Find final values in relation to Weapon Category and Weapon Name arrays		
		final_antirecoil_start       = ANTIRECOIL_VAL[profile_idx][0] + antirecoil_start[profile_idx];
		final_antirecoil_end         = ANTIRECOIL_VAL[profile_idx][1] + antirecoil_end[profile_idx];
		final_antirecoil_time        = ANTIRECOIL_VAL[profile_idx][2] + antirecoil_time[profile_idx];
		final_antirecoil_horizontal  = ANTIRECOIL_VAL[profile_idx][3] + antirecoil_horizontal[profile_idx];
		final_rate_of_fire           = rate_of_fire[profile_idx];
				
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                             FEATURES ACTIVE IN GAME ONLY                              |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(!ModMenu && !ModEdit)
		{
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                               FEATURES                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		// Swap triggers and bumpers 
			if(swap_on) 
			{
				ads_btn = PS4_L1;
				fire_btn = PS4_R1;
			}
			else
			{
				ads_btn = PS4_L2;
				fire_btn = PS4_R2;
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
		
		// Hair Trigger
			if(hairTrigger_on)
	   	 		deadzone(PS4_L2,PS4_R2,99,99);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
	
		// Switch Profiles - tap TRIANGLE/Y to switch profile 1 or 2 - double tap for profile 3 - hold L3/LS + tap TRIANGLE/Y for sync color
			if( (!get_val(PS4_DOWN) || get_val(PS4_L3)) && event_press(PS4_TRIANGLE) )
			{
				if(get_brtime(PS4_TRIANGLE) < 250) 
					profile_idx = 2;
				else
				{
				    if(switch_ref != 2) 
						switch_ref = !switch_ref;  
				                	
					profile_idx = switch_ref;
				}	
				
				display_title = TRUE;
		   	}
		    	
			if(get_lval(PS4_L3))
				set_val(PS4_TRIANGLE, 0);
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Custom Sensitivity
	    	if(sensitivity_on == 1)
	    	{	
	    		if(isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 8)
	    		{
		    		if(!get_val(ads_btn) && !get_val(fire_btn))
						customsens = genSens;
					else if(get_val(ads_btn) && !get_val(fire_btn))
						customsens = adsSens;
					else if(!get_val(ads_btn) && get_val(fire_btn))
						customsens = hipSens;
					if(get_val(ads_btn) && get_val(fire_btn))
						customsens = adsfireSens;
			
					sensitivity(PS4_RY,NOT_USE,customsens);
					sensitivity(PS4_RX,NOT_USE,customsens);
				}
	    	}
	    	
		// Dynamic Sensitivity
	    	else if(sensitivity_on == 2)
	    	{	
	    		if((get_val(ads_btn) || get_val(fire_btn)) && isqrt(pow(abs(get_ival(PS4_RX)),2) + pow(abs(get_ival(PS4_RY)),2)) >= 20)
	    			set_sens();
	    	}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		/* AutoRun 
		   push the left stick 90% forward or to the sides to run - hold to sprint must be enable */
			if(autorun_on)
			{
				if((isqrt(pow(abs(get_ival(PS4_LX)),2) + pow(abs(get_ival(PS4_LY)),2)) >= 90) && get_ival(PS4_LY) < 20 && !get_val(ads_btn) && !get_val(fire_btn))
					set_val(PS4_L3, 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

		// In game rumbles block
			if(!rumble_on)
				block_rumble();
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// If Strafe Shot is enable for the curent profile
			if(toggle_shotMod[profile_idx] == 1)
			{
				if(check_activator())
					combo_run(STRAFESHOT);
				else
					combo_stop(STRAFESHOT);
			}
	
		// If Jump Shot is enable for the curent profile
			else if(toggle_shotMod[profile_idx] == 2)
			{
				if(check_activator())
					combo_run(JUMPSHOT);
			}
	
		// If Crouch Shot is enable for the curent profile
			else if(toggle_shotMod[profile_idx] == 3)
			{
				if(check_activator())
					set_val(BTN[crouch_btn], 100);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
		// Speed Toggles
			toggle_antirecoil[profile_idx] = speed_toggle( ads_btn, PS4_UP   , 500 , toggle_antirecoil[profile_idx], ANTIRECOIL_M );
			toggle_rapidfire[profile_idx]  = speed_toggle( ads_btn, PS4_RIGHT, 500 , toggle_rapidfire[profile_idx] , RAPIDFIRE_M  );
			toggle_burstfire[profile_idx]  = speed_toggle( ads_btn, PS4_LEFT , 500 , toggle_burstfire[profile_idx] , BURSTFIRE_M  );
			toggle_aimassist[profile_idx]  = speed_toggle( ads_btn, PS4_DOWN , 500 , toggle_aimassist[profile_idx] , AIMASSIST_M  );
		
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

	/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
	|                          SCREEN SAVER BY DoGz                         |
	¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		    if(display_black)
		    {
		    	count_black += get_rtime();
		    	if(count_black >= 5000)
		    	{
		    		cls_oled(0);
		    		count_black = 0;
		    		screensaver = TRUE;
		    		logo_on = FALSE;
		    		display_black = FALSE;
		    	}
		    }
		    
		    if(screensaver)
		    {
		    	DGT += get_rtime();
				if(DGT >= 100) 
				{
					SD1 += 2;	TP1 += 1;
					TP2 -= 1;	DGT  = 0;
				}
				DGR += get_rtime();
				
				if(DGR >= 30) 
				{
					Y_1 += 1;	Y_2 += 2;	Y_3 += 3;	Y_4 += 4;
					Y_5 += 5;	Y_6 += 6;	Y_7 += 7;	Y_8 += 8;
					DGR  = 0;
				}
				
				name();
				MSC += get_rtime();
				
				if(MSC >= 1000) 
				{
					MSC = 0;
					RT += 1;
				}
				
				if(RT == 30) 
				{
					screensaver = 0;
					RT = 0;
					cls_oled(0);
				}
		    }
		} // NOT ModMenu and NOT ModEdit section end
		
	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|                         FEATURES ACTIVE IN GAME AND IN MOD EDIT                       |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(!ModMenu)
		{
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             AIM Abuse                                 |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
			
			
			if(toggle_aimabuse[profile_idx])
			{
				if(get_val(ads_btn))
					combo_run(AIM_ABUSE);
				else
					combo_stop(AIM_ABUSE);
			}
		
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             AIM Assist                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/

			if(toggle_aimassist[profile_idx])
			{
				if(toggle_aimassist[profile_idx] == 1) // Batts Sticky
				{	
					if(get_val(ads_btn) || get_val(fire_btn))
					    combo_run(STICKY);
				}
				else // Polar Shapes
				{
					if(toggle_antirecoil[profile_idx] && get_val(fire_btn))
					{
						RX = SmartSens(final_antirecoil_horizontal, PS4_RX);
						RY = SmartSens(ar_y, PS4_RY);
					}
					else
					{
						RX = get_val(PS4_RX);
						RY = get_val(PS4_RY);
					}
					
					actual_Magnitude = isqrt(pow(RX, 2) + pow(RY, 2));	
					max_Magnitude = (actual_Magnitude < 100);
				
					if(!(time++ % 1))
						angle += aimassist_angle;
						
					angle = angle % 360;
					sin_angle = Polar_Array[angle % 360];
					cos_angle = Polar_Array[(angle + 270) % 360];
					
				  
				  	if(get_val(fire_btn) || get_val(ads_btn))
				  	{
				    	if(actual_Magnitude <= aimassist_radius) 
				    	{
							sin_angle -= RY;
				      		cos_angle -= RX;
				    	}
					    else 
					    {
							sin_angle = (sin_angle * (200 - ((abs(RY) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
							cos_angle = (cos_angle * (200 - ((abs(RX) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude;
					    }
					    
					    GetShapesV1(aimassist_radius);
					    
					    if((!get_val(fire_btn) && toggle_antirecoil[profile_idx]) || !toggle_antirecoil[profile_idx])
					    {
							set_val(PS4_RX, clamp(get_val(PS4_RX) + cos_angle, -100, 100));
							set_val(PS4_RY, clamp(get_val(PS4_RY) + sin_angle, -100, 100));
				  		}
					}
				}
			}

		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             AntiRecoil                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/

			if(toggle_antirecoil[profile_idx])
			{
				check_trigger();
				
			// Antirecoil Standard final value
				if(toggle_antirecoil[profile_idx] == 2)
					final_antirecoil_start = final_antirecoil_end;
					
			// Progressive AntiRecoil vertical		
	    		if(final_antirecoil_start < final_antirecoil_end)
	    	   		i_val = 1; 
	    		else
	    	    	i_val = -1;
	    		i_pnt = (final_antirecoil_time / 10) / (abs(final_antirecoil_start - final_antirecoil_end)); 
	    		
	    	// Reset
	    		if(!get_val(trigger)) 
	    		{
					ar_y = final_antirecoil_start;
	    	    	i_cnt = 0;
	    	    	i_num = 0;
	    	    	//rumble = 0;
	    	    	rumble_recoil = 0;
	    	    	antirecoil_boost = 0;
	    		}     
	    					
	    		if(get_lval(trigger))
				{
				
				// Rumble AntiRecoil Boost
					antirecoil_boost += random(1, 5);
					if(antirecoil_boost > 10)
						antirecoil_boost = 0;
						
/*				// SmartStop
					if(get_ptime(trigger) < 500 || get_rumble(RUMBLE_A))
						rumble = 1;
					else if(get_rumble(RUMBLE_A) == 0)
						rumble = 0;
*/						
				// Progression Calculation
			        if(!p_complete())  
						ar_y = p_val();
			        else
			            ar_y = final_antirecoil_end;
			 
				// Run Rumble Antirecoil
					if(toggle_antirecoil[profile_idx] == 3) 
					{	
						rumble_recoil = max(get_rumble(RUMBLE_A),get_rumble(RUMBLE_B));
					                 				
						if(rumble_recoil > 10 && rumble_recoil < 90) 
						{
							if(!toggle_aimassist[profile_idx])
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY), -100, 100));
								set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX), -100, 100));
							}
							else if(toggle_aimassist[profile_idx] > 1)
							{
								set_val(PS4_RY, clamp(SmartSens(rumble_recoil + rumble_power[profile_idx] + antirecoil_boost, PS4_RY) + sin_angle, -100, 100));
								set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX) + cos_angle, -100, 100));
							}
							else if(toggle_aimassist[profile_idx] == 1)
							{
								recoilAssist = rumble_recoil + rumble_power[profile_idx] + antirecoil_boost;
								combo_run(STICKY);
							}
						}
						else if(rumble_recoil < 10)
						{
							ar_y = final_antirecoil_end;
							antirecoil();
						}
					}
				// Run Progressive or Standard AntiRecoil
					else
					{	
				    // If BurstFire
				    	if(toggle_burstfire[profile_idx] == 1 && get_ptime(trigger) <= hold_time)
				    	{
							antirecoil();
				    	}
				    // Full auto and RapidFire with smart stop
				        if(toggle_burstfire[profile_idx] == 0  || toggle_rapidfire[profile_idx] >= 1)
				        {
					        //if(rumble)
					        //{
								antirecoil();
					    	//}
				    	}
				    }
		    	}
			}
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                             RapidFire                                 |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
		
		// RapidFire
			if(toggle_rapidfire[profile_idx])
			{
				if(toggle_rapidfire[profile_idx] == 1)
				{
				// Rate of Fire Calculation
					hold_time = 50;
					rest_time = 35 * 10 - (get_ival(XB1_RT) * 3);
		    	}
				else if(toggle_rapidfire[profile_idx] == 2)
				{
				// Rate of Fire Calculation
		    		rest_time = 5000 / ((final_rate_of_fire * 10) / 60); 
		   			hold_time = rest_time;
		    		if(rest_time < 0) rest_time = 0;
		    	}
				else if(toggle_rapidfire[profile_idx] == 3)
				{
				// Rate of Fire Calculation
		    		rest_time = 500 / final_rate_of_fire; 
		   			hold_time = rest_time;
		    		if(rest_time < 0) rest_time = 0;
		    	}
	    
	    	// Run combo
	    		if(get_val(fire_btn))
	    			combo_run(RAPIDFIRE);
	    		else
	    			combo_stop(RAPIDFIRE);
	    		
	    		led_on = 150;
	    		led_off = 300;
	    		combo_run(BLINK);
			}
		/*— ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤
		|                              BurstFire                                |
		¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ — ¤ —*/
	
		//BurstFire
			if(toggle_burstfire[profile_idx] == 1) 
			{
	    	// Hold and Release
				hold_time = burstfire_hold;
				rest_time = burstfire_release;
				
	    	// Run combo
	    		if(get_val(fire_btn))	
	    			combo_run(BURSTFIRE);
	    		
				if(event_release(fire_btn))
	    			combo_stop(BURSTFIRE);
	
	    		led_on = 200;
	    		led_off = 1000;
	    		combo_run(BLINK);
			}
	// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
			
		}// NOT ModMenu but ModEdit

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|            DISPLAY TEXT AND VALUES IN MOD MENU, MOD EDIT AND MOD WEAPON               |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
		if(display_new) 
		{
			screensaver = FALSE;
			count_black = 0;
			
			if(ModEdit) // Display editable value 
			{
				display_edit_line1();
			// Clears value zone
				rect_oled(38, 18, 51 , OLED_FONT_SMALL_HEIGHT + 3 , OLED_WHITE , OLED_BLACK); // small rectangle left (line 2 value)
				rect_oled(27, 31, 74 , OLED_FONT_SMALL_HEIGHT + 6 , OLED_WHITE , OLED_BLACK); // small rectangle left (line 3 value)
			
			// Display editable value
				display_values();
			}
			else if(ModMenu) // Display Profile, mod name, toggle
			{
				display_edit_line1();
				display_edit_line2();
				display_edit_line3();
			}
			else // Speed Toggle Display
			{
				cls_oled(OLED_BLACK);
			// Display mod name
				printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));
			// Display toggle
				display_edit_line3();
				count_black = 2000;
			}
			
			display_black = TRUE;
	        display_new = FALSE;
	       
	    } // display_new section end

	/*— x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x
	|               DISPLAY USER INFOS IN MOD MENU, MOD EDIT AND MOD WEAPON                 |
	x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x — x —*/
	
		if(display_info) // display navigation infos
		{
			info_timer = 0;
			rect_oled(1, 50, 126, 13, OLED_WHITE, OLED_BLACK); // bottom rectangle (clear)
			if(ModMenu)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_MENU_PS_TXT));
				
				if(get_controller() == PIO_PS4)
					printf(center_x(get_string_length(get_string(INFO_MENU_PS_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_MENU_PS_TXT, current_info));
				else
					printf(center_x(get_string_length(get_string(INFO_MENU_XB_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_MENU_XB_TXT, current_info));
			}
			if(ModEdit)
			{
				current_info = cycle(current_info, 0, entry_count(INFO_EDIT_PS_TXT));
				
				if(get_controller() == PIO_PS4)
					printf(center_x(get_string_length(get_string(INFO_EDIT_PS_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_EDIT_PS_TXT, current_info));
				else
					printf(center_x(get_string_length(get_string(INFO_EDIT_XB_TXT, current_info)), OLED_FONT_SMALL_WIDTH),LINE_4_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(INFO_EDIT_XB_TXT, current_info));
			}
			display_info = FALSE;
		}
	} // !KillSwitch section end

// back to main section

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                           DISPLAY TITLE - KILLSWITCH - PROFILE - WEAPON NAME - # SLOT                                 |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
// Display Script Title    
    if(display_title)
    {
    	screensaver= FALSE;
    	count_black = 0;	
    	
    // Display logo
    	if(!logo_on)
    	{
    		cls_oled(0);
   			draw_logo();
   		}
   		else
   			rect_oled(0, 45, 128, 31, OLED_WHITE, OLED_BLACK); // clear profile and #slot
   			
   	// Display current slot
   		number_to_string(currentSlot, find_digits(currentSlot)); 

   	// Display profile name
		display_profile();
		
		logo_on = TRUE;
   		display_black = TRUE;	
    	display_title = FALSE;
    }

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                      COLOR LED                                                        |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
	if(KillSwitch)
		led(7);
	else
		led(profile_idx);
		
} // main section end
/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                  MAIN SECTION END                                                     |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                   COMBO SECTION                                                       |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/
combo RACE {
	X_1 = random(0,127);
	wait(SAVER1);
	X_2 = random(0,127);
	wait(SAVER1);
	X_3 = random(0,127);
	wait(SAVER1);
	X_4 = random(0,127);
	wait(SAVER1); 
	X_5 = random(0,127);
	wait(SAVER1);
	X_6 = random(0,127);
	wait(SAVER1); 
	X_7 = random(0,127);
	wait(SAVER1); 
	X_8 = random(0,127);
	wait(SAVER1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_ON {					
	set_ledx(2, 2);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
	wait(100);
	set_rumble(RUMBLE_B, 50);
	wait(150);
	reset_rumble();
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RUMBLE_OFF {						
	set_ledx(1, 1);
	set_rumble(RUMBLE_A, 50);
	wait(300);
	reset_rumble();
	wait(400);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜
	
combo KILLSWITCH {
	cls_oled(OLED_BLACK);
    printf(center_x(sizeof(MUTE) - 1, OLED_FONT_MEDIUM_WIDTH),8,OLED_FONT_MEDIUM,OLED_WHITE,MUTE[0]);    
    wait(get_rtime());
    wait(250);
    printf(center_x(sizeof(HOLD) - 1, OLED_FONT_SMALL_WIDTH),38,OLED_FONT_SMALL,OLED_WHITE,HOLD[0]);     
    printf(center_x(sizeof(ACTIVE) - 1, OLED_FONT_SMALL_WIDTH),50,OLED_FONT_SMALL,OLED_WHITE,ACTIVE[0]); 
    wait(get_rtime());
    wait(5000);  
    cls_oled(OLED_BLACK);
    wait(get_rtime());
    wait(5000);  
}
    
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

combo SAVE { 
	call(RUMBLE_ON);
	wait(150);
	call(RUMBLE_ON);		
	wait(1000);
	display_title = TRUE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo RN {
	RN1 = random(65,90);
	RN2 = random(60,90);
	RN3 = random(65,90);
	RN4 = random(65,90); 
	RN5 = random(65,90);
	RN6 = random(65,90);
	RN7 = random(65,90);
	RN8 = random(65,90);
	wait(SAVER);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BLINK {
	led(profile_idx);
    wait(led_on);
    led(7);
    wait(led_off);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo BURSTFIRE { 
    wait(hold_time);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
	call(RAPIDFIRE);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜  

combo RAPIDFIRE { 
    wait(hold_time);
    set_val(fire_btn, 0);
    wait(rest_time - get_rtime());
    set_val(fire_btn, 0);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo STRAFESHOT { 
    set_val(PS4_LX, 100);
    wait(strafe_time);
    wait(50);
    set_val(PS4_LX, -100);
    wait(strafe_time);
    wait(50);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
 
 combo JUMPSHOT {
 	set_val(BTN[jump_btn], 100);
 	wait(50);
 	wait(100);
 }
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int recoilAssist;

combo STICKY {
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
	{
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    	set_val(PS4_RY, SmartSens(aimassist_radius + recoilAssist, PS4_RY));
    }
    else 
    	set_val(PS4_RY, SmartSens(aimassist_radius, PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(aimassist_radius, PS4_RX));
    set_val(PS4_LX, SmartSens(aimassist_radius, PS4_LX));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
	{
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius) + recoilAssist, PS4_RY));
    }
    else
    	set_val(PS4_RY, SmartSens(inv(aimassist_radius), PS4_RY));
    wait(aimassist_angle);
    
	if(toggle_antirecoil[profile_idx] && get_val(trigger))
    	set_val(PS4_RY, SmartSens(recoilAssist, PS4_RY));
    set_val(PS4_RX, SmartSens(inv(aimassist_radius), PS4_RX));
    set_val(PS4_LX, SmartSens(inv(aimassist_radius), PS4_LX));
    wait(aimassist_angle);
}
 
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

combo AIM_ABUSE {
    wait(aimabuse_hold);
    set_val(ads_btn, 0);
    wait(aimabuse_release - get_rtime());
    set_val(ads_btn, 0);
}

/*— ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌
|                                                 FUNCTION SECTION                                                      |
◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ — ◌ —*/

function display_edit_line1() {

// Clears text emplacement line 1
	rect_oled(13, 1, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
	
	if(ModMenu)
	{				
	// Display Profile only on mods that may have different ON/OFF status depending on the active Profile
		if(modName_idx < AMOUNT_OF_MULTI_TOGGLE) 
			display_profile ();
		else // Mods that have the same toggle on every profiles, display EVERY PROFILE
    		printf(center_x(sizeof(ALL) - 1, OLED_FONT_SMALL_WIDTH),4,OLED_FONT_SMALL,OLED_WHITE,ALL[0]);
	}
	
	if(ModEdit) 
	{
	// Display Value Name
    	if(valName_idx == 1 && toggle_antirecoil[profile_idx] == 2)
    		printf(center_x(sizeof(ANTIRECOIL_VERTICAL) - 1, OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,ANTIRECOIL_VERTICAL[0]);  
    	else
    		printf(center_x(get_string_length(get_string(VALNAME_TXT, valName_idx)), OLED_FONT_SMALL_WIDTH),LINE_1_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(VALNAME_TXT, valName_idx));  
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit_line2() {
	
// Clears text emplacement line 2
	rect_oled(13, 17, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);
		
	if(ModMenu)
	{
	// Display Mod Name
		printf(center_x(get_string_length(get_string(MODNAME_TXT, modName_idx)), OLED_FONT_SMALL_WIDTH),LINE_2_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(MODNAME_TXT, modName_idx));  // small size
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_edit_line3() {
	
// Clears text emplacement line 3
	rect_oled(13, 33, 102, OLED_FONT_SMALL_HEIGHT + 5, OLED_WHITE , OLED_BLACK);

// Display toggle ON/OFF status
    // Mods that may have different ON/OFF status depending on the active Profile
	display_toggle( ANTIRECOIL_M    , toggle_antirecoil[profile_idx]   ); // display_toggle( corresponding modName_idx , toggle_I_want_to_be_displayed[profile]);
	display_toggle( RAPIDFIRE_M     , toggle_rapidfire[profile_idx]    );
	display_toggle( BURSTFIRE_M     , toggle_burstfire[profile_idx]    );
	display_toggle( AIMASSIST_M     , toggle_aimassist[profile_idx]    );
	display_toggle( AIMABUSE_M      , toggle_aimabuse[profile_idx]     );
	display_toggle( SHOTMOD_M       , toggle_shotMod[profile_idx]      );
	display_toggle( SHOTACTIVATOR_M , toggle_shotActivator[profile_idx]);
	
	// Mods that have same ON/OFF status on every Profile
	display_toggle( SENSITIVITY_M    , sensitivity_on);
	display_toggle( HAIRTRIGGER_M    , hairTrigger_on);
	display_toggle( AUTORUN_M        , autorun_on    );
	display_toggle( AUTOADS          , autoADS_on    );
	display_toggle( AUTOFIRE         , autoFIRE_on   );
	display_toggle( JUMPBTN_M        , jump_btn      );
	display_toggle( CROUCH_BTN       , crouch_btn    );
	display_toggle( TRIGGERBUMPER_M  , swap_on       );
	display_toggle( RUMBLEFEEDBACK_M , rumble_on     );
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_values() {

	// Mods that may have different values depending on the active Profile
	display_edit( 0 , final_antirecoil_start      );// Display_edit( corresponding valName_idx , val_I_want_to_be_displayed[profile] );
	display_edit( 1 , final_antirecoil_end        );
	display_edit( 2 , final_antirecoil_time       );
	display_edit( 3 , final_antirecoil_horizontal );
	display_edit( 4 , rumble_power[profile_idx]   );
	display_edit( 5 , final_rate_of_fire          );
				
	// Mods that have same value on every Profile
	display_edit( 6 , burstfire_hold         );
	display_edit( 7 , burstfire_release      );
	display_edit( 8 , aimassist_radius       );
	display_edit( 9 , aimassist_angle        );
	display_edit( 10, aimabuse_hold          );
	display_edit( 11, aimabuse_release       );
	display_edit( 12, strafe_time            );
	display_edit( 13, dynasens_initial_sens  );
	display_edit( 14, dynasens_limit         );
	display_edit( 15, dynasens_restart       );
	display_edit( 16, dynasens_max_sens      );
	display_edit( 17, dynasens_increase_rate );
	display_edit( 18, genSens                );
	display_edit( 19, adsSens                );
	display_edit( 20, hipSens                );
	display_edit( 21, adsfireSens            );
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int profile_y;

function display_profile() {

	if(display_title)
		profile_y = 50; // Title screen
	else
		profile_y = 4; // Menus
	
    printf(center_x(get_string_length(get_string(PROFILE_TXT, profile_idx)), OLED_FONT_SMALL_WIDTH),profile_y,OLED_FONT_SMALL,OLED_WHITE,get_string(PROFILE_TXT, profile_idx));
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function display_edit(f_idx, f_val) { 
	
    if(valName_idx == f_idx)
    		number_to_string(f_val, find_digits(f_val));
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function display_toggle(f_idx, f_toggle) { 

    if(modName_idx == f_idx)
   	{
		if(f_idx == ANTIRECOIL_M) // if AntiRecoil MOD
    	// Display OFF or Progressive or Standard or On Rumble
    		printf(center_x(get_string_length(get_string(ANTIRECOIL_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(ANTIRECOIL_TXT, f_toggle));
    		
    	else if(f_idx == RAPIDFIRE_M) // if RapidFire MOD
    	// Display OFF or RPM/BPM or RPS/BPS
    		printf(center_x(get_string_length(get_string(RAPIDFIRE_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(RAPIDFIRE_TXT, f_toggle));
    		
		else if(f_idx == AIMASSIST_M) // if Polar Assist MOD
    	// Display AIM Assist shapes
    		printf(center_x(get_string_length(get_string(SHAPES_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHAPES_TXT, f_toggle));
    		
		else if(f_idx == SHOTMOD_M) // if Shot Mod
    	// Display Shot Mod
    		printf(center_x(get_string_length(get_string(SHOT_MOD_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHOT_MOD_TXT, f_toggle));
    		
		else if(f_idx == SHOTACTIVATOR_M) // if Shot Activator
    	// Display Shot Mod
    		printf(center_x(get_string_length(get_string(SHOT_ACTIVATOR_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SHOT_ACTIVATOR_TXT, f_toggle));
    		
		else if(f_idx == SENSITIVITY_M) // if Sensitivity MOD
    	// Display Custom Sens or Dynamic Sens
    		printf(center_x(get_string_length(get_string(SENSITIVITY_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SENSITIVITY_TXT, f_toggle));
    		
    	else if(f_idx == JUMPBTN_M || f_idx == CROUCH_BTN) // if Jump or Crouch btn
    	{	
    		if(get_controller() == PIO_PS4)
    			printf(center_x(get_string_length(get_string(PS_BTN_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(PS_BTN_TXT, f_toggle));
    		else
    			printf(center_x(get_string_length(get_string(XB_BTN_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(XB_BTN_TXT, f_toggle));
    	}
    	
		else if(f_idx == TRIGGERBUMPER_M) // if Trigger/Bumper MOD
    	// Display Standard or Swapped
    		printf(center_x(get_string_length(get_string(SWAP_TXT, f_toggle)), OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,get_string(SWAP_TXT, f_toggle));
    		
		else
		{
    	// Display ON OFF
    		if(f_toggle == 1)
    			printf(center_x(sizeof(ON) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,ON[0]);
    		else
    			printf(center_x(sizeof(OFF) - 1, OLED_FONT_SMALL_WIDTH),LINE_3_Y,OLED_FONT_SMALL,OLED_WHITE,OFF[0]);
   		}
   	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define SSA1 = 78,SSA2 = 79,SSA3 = 90,SSA4 = 66,SSA5 = 65,SSA6 = 82,SSA7 = 68,SSA8 = 82,SSA9 = 73,SSA10 = 70,SSA11 = 82,SSA13 = 50,SSA14 = 49,SAVER = 5000,SAVER1 = 10;

function edit_val(f_idx, f_val, f_min, f_max, f_inc1, f_inc2) {  
	
	if(valName_idx == f_idx)
	{
    // +1 or -1															 
    	f_val    = value_change( f_val ,PS4_LEFT , inv(f_inc1), f_min, f_max ); 
    	f_val    = value_change( f_val ,PS4_RIGHT, f_inc1     , f_min, f_max ); 
   	 // +10 or -10
   	   	f_val    = value_change( f_val ,PS4_DOWN , inv(f_inc2), f_min, f_max ); 
       	f_val    = value_change( f_val ,PS4_UP   , f_inc2     , f_min, f_max ); 
	}		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function value_change(f_val,f_btn,f_inc, f_rng_min, f_rng_max) { 

    if(press_hold(f_btn)) 
    {
        f_val += f_inc;
        
        if(modName_idx == ANTIRECOIL_M) // array value + temp value
        {
	    // Substract    
	        if((f_val + ANTIRECOIL_VAL[profile_idx][valName_idx]) < f_rng_min) 
	        	f_val = f_rng_min - ANTIRECOIL_VAL[profile_idx][valName_idx]; 
	    // Add   
	        if((f_val + ANTIRECOIL_VAL[profile_idx][valName_idx]) > f_rng_max) 
	        	f_val = f_rng_max - ANTIRECOIL_VAL[profile_idx][valName_idx]; 
        }
        
        else
        {
		// Substract    
	    	if(f_val < f_rng_min) 
	    		f_val = f_rng_min; 
		// Add   
	   		if(f_val > f_rng_max) 
	    		f_val = f_rng_max; 
    	}	
        display_new = TRUE; 
    }
    return f_val; 
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function toggle(f_idx, f_val) { 
	
	if(event_press(PS4_UP))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == ANTIRECOIL_M) // toggle 0 or 1 or 2 or 3 to select antirecoil type
				f_val = cycle(f_val + 1, 0, entry_count(ANTIRECOIL_TXT));
				
			else if(f_idx == RAPIDFIRE_M) // toggle 0 or 1 or 2 to select rapidfire type
			{
				f_val = cycle(f_val + 1, 0, entry_count(RAPIDFIRE_TXT));
				
				if(f_val >= 1) // disable BurstFire if RapidFire is ON
					toggle_burstfire[profile_idx] = 0;
			}
			
			else if(f_idx == BURSTFIRE_M) // toggle 0 or 1 to select BurstFire
			{
				f_val = cycle(f_val + 1, 0, 1);
				
				if(f_val == 1) // disable RapidFire if BurstFire is ON
					toggle_rapidfire[profile_idx] = 0;
			}
				
			else if(f_idx == AIMASSIST_M) // toggle 0 or 1 or 2 ... or 6 to select aim assist shape
			{
				f_val = cycle(f_val + 1, 0, entry_count(SHAPES_TXT));
				
				if(f_val >= 1 && sensitivity_on == 2) // if AIM Assist disable dynasens
					sensitivity_on = 0;
			}
				
			else if(f_idx == SHOTMOD_M) // toggle 0 or 1 or 2 or 3 to select Shot Mod
				f_val = cycle(f_val + 1, 0, entry_count(SHOT_MOD_TXT));
				
			else if(f_idx == SHOTACTIVATOR_M) // toggle 0 or 1 or 2 to select Shot Activator
				f_val = cycle(f_val + 1, 0, entry_count(SHOT_ACTIVATOR_TXT));
				
			else if(f_idx == SENSITIVITY_M) // toggle 0 or 1 or 2 or 3 to select Custom or Dynamic Sens
			{
				f_val = cycle(f_val + 1, 0, entry_count(SENSITIVITY_TXT));
				
				if(f_val == 2) // if dynasens disable AIM Assist
				{
					toggle_aimassist[0] = 0;
					toggle_aimassist[1] = 0;
					toggle_aimassist[2] = 0;
				}
			}
			
			else if(f_idx == JUMPBTN_M || f_idx == CROUCH_BTN) // toggle 0 or 1 or 2 or 3 to select Jump and Crouch btn
				f_val = cycle(f_val + 1, 0, entry_count(PS_BTN_TXT)); // or XB_BTN_TXT 
				
			else
				f_val = cycle(f_val + 1, 0, 1);
		
		// Rumble	
			if(f_val == 0) 
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);
		}
		display_new = TRUE; 
	}

	if(event_press(PS4_DOWN))
	{
		if(modName_idx == f_idx)
		{
			if(f_idx == ANTIRECOIL_M) // toggle 0 or 1 or 2 or 3 to select antirecoil type
				f_val = cycle(f_val - 1, 0, entry_count(ANTIRECOIL_TXT));
				
			else if(f_idx == RAPIDFIRE_M) // toggle 0 or 1 or 2 to select rapidfire type
			{
				f_val = cycle(f_val - 1, 0, entry_count(RAPIDFIRE_TXT));
				
				if(f_val >= 1) // disable BurstFire if RapidFire is ON
					toggle_burstfire[profile_idx] = 0;
			}
			
			else if(f_idx == BURSTFIRE_M) // toggle 0 or 1 to select BurstFire
			{
				f_val = cycle(f_val - 1, 0, 1);
				
				if(f_val == 1) // disable RapidFire if BurstFire is ON
					toggle_rapidfire[profile_idx] = 0;
			}
				
			else if(f_idx == AIMASSIST_M) // toggle 0 or 1 or 2 ... or 6 to select aim assist shape
			{
				f_val = cycle(f_val - 1, 0, entry_count(SHAPES_TXT));
				
				if(f_val >= 1 && sensitivity_on == 2) // if AIM Assist disable dynasens
					sensitivity_on = 0;
			}
				
			else if(f_idx == SHOTMOD_M) // toggle 0 or 1 or 2 or 3 to select Shot Mod
				f_val = cycle(f_val - 1, 0, entry_count(SHOT_MOD_TXT));
				
			else if(f_idx == SHOTACTIVATOR_M) // toggle 0 or 1 or 2 to select Shot Activator
				f_val = cycle(f_val - 1, 0, entry_count(SHOT_ACTIVATOR_TXT));
				
			else if(f_idx == SENSITIVITY_M) // toggle 0 or 1 or 2 or 3 to select Custom or Dynamic Sens
			{
				f_val = cycle(f_val - 1, 0, entry_count(SENSITIVITY_TXT));
				
				if(f_val == 2) // if dynasens disable AIM Assist
				{
					toggle_aimassist[0] = 0;
					toggle_aimassist[1] = 0;
					toggle_aimassist[2] = 0;
				}
			}
			
			else if(f_idx == JUMPBTN_M || f_idx == CROUCH_BTN) // toggle 0 or 1 or 2 or 3 to select Jump and Crouch btn
				f_val = cycle(f_val - 1, 0, entry_count(PS_BTN_TXT)); // or XB_BTN_TXT 
				
			else
				f_val = cycle(f_val - 1, 0, 1);
		
		// Rumble	
			if(f_val == 0) 
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);	
		}
		display_new = TRUE; 
	}
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function speed_toggle(f_hold, f_press, f_time, f_val, f_idx) {  
	
	if(get_val(f_hold))
	{
		if(event_press(f_press) && get_brtime(f_press) <= 200) 
		{		
			if(f_idx == ANTIRECOIL_M) // if AntiRecoil
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(ANTIRECOIL_TXT)) ; // Antirecoil type 
			}
			if(f_idx == RAPIDFIRE_M) // if RapidFire
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(RAPIDFIRE_TXT)) ; // RapidFire type 
			}
			if(f_idx == AIMASSIST_M) // if Polar Assist
			{
				modName_idx = f_idx;
				f_val = cycle(f_val + 1, 1, entry_count(SHAPES_TXT)) ;// switch shapes 
			}
			display_new = TRUE; 
		}
		
		if(get_val(f_press) && get_ptime(f_press) == f_time) // Hold second button 300ms or more
		{
			modName_idx = f_idx;
			f_val = !f_val;	
			
			if(f_idx == AIMASSIST_M) // polar assist
			{
				if(f_val >= 1 && sensitivity_on == 2) // if AIM Assist disable dynasens
					sensitivity_on = 0;
			}
			
			if(f_val == 0)
				combo_run(RUMBLE_OFF);
			else
				combo_run(RUMBLE_ON);
				
			display_new = TRUE; 
		} 
		
		set_val(f_press, 0)
	}
		
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function check_toggle() {
	if(modName_idx == ANTIRECOIL_M  && toggle_antirecoil[profile_idx])      return TRUE;
	if(modName_idx == RAPIDFIRE_M   && toggle_rapidfire[profile_idx] > 1)   return TRUE;
	if(modName_idx == BURSTFIRE_M   && toggle_burstfire[profile_idx])       return TRUE;
	if(modName_idx == AIMASSIST_M   && toggle_aimassist[profile_idx])       return TRUE;
	if(modName_idx == AIMABUSE_M    && toggle_aimabuse[profile_idx])        return TRUE;
	if(modName_idx == SHOTMOD_M     && toggle_shotMod[profile_idx] == 1)    return TRUE;
	if(modName_idx == SENSITIVITY_M && sensitivity_on)                      return TRUE;
	return FALSE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function check_activator() {	
	if(toggle_shotActivator[profile_idx] == 0)
	{
		if(get_val(ads_btn) && get_val(fire_btn))
			return TRUE;
	}
	else if(toggle_shotActivator[profile_idx] == 1)
	{
		if(get_val(ads_btn) && !get_val(fire_btn))
			return TRUE;
	}
	else if(toggle_shotActivator[profile_idx] == 2)
	{
		if(!get_val(ads_btn) && get_val(fire_btn))
			return TRUE;
	}	
	return FALSE;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int trigger;

function check_trigger() {		
	if(autoADS_on)
	{
		if(get_val(fire_btn))
		{	
			trigger = fire_btn;
			set_val(ads_btn, 100);
		}
	}
	else if(autoFIRE_on)
	{
		if(get_val(ads_btn))
		{
			trigger = ads_btn;
			set_val(fire_btn, 100);
		}
	}
	if(autoADS_on && autoFIRE_on)
	{
		if(get_val(fire_btn))
		{	
			trigger = fire_btn;
			set_val(ads_btn, 100);
		}
		else if(get_val(ads_btn))
		{
			trigger = ads_btn;
			set_val(fire_btn, 100);
		}
	}	
	else if(!autoADS_on && !autoFIRE_on)
	{
		if(get_val(fire_btn))
			trigger = fire_btn;
	}	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define MODNAME_TXT = 0;
define VALNAME_TXT = 1;
define INFO_MENU_PS_TXT = 2;
define INFO_EDIT_PS_TXT = 3;
define INFO_MENU_XB_TXT = 4;
define INFO_EDIT_XB_TXT = 5;
define SHAPES_TXT = 6;
define ANTIRECOIL_TXT = 7;
define PROFILE_TXT = 8;
define RAPIDFIRE_TXT = 9;
define SENSITIVITY_TXT = 10;
define SHOT_MOD_TXT = 11;
define SHOT_ACTIVATOR_TXT = 12;
define SWAP_TXT = 13;
define PS_BTN_TXT = 14;
define XB_BTN_TXT = 15;

function entry_count(f_array_idx) { // by Swizzy

    i = 0;
    if (f_array_idx == MODNAME_TXT) { while (MODNAME[i] != -1) { i++; } }
    else if (f_array_idx == VALNAME_TXT) { while (VALNAME[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MENU_PS_TXT) { while (INFO_MENU_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_PS_TXT) { while (INFO_EDIT_PS[i] != -1) { i++; } }
    else if (f_array_idx == INFO_MENU_XB_TXT) { while (INFO_MENU_XB[i] != -1) { i++; } }
    else if (f_array_idx == INFO_EDIT_XB_TXT) { while (INFO_EDIT_XB[i] != -1) { i++; } }
    else if (f_array_idx == SHAPES_TXT) { while (SHAPES[i] != -1) { i++; } }
    else if (f_array_idx == ANTIRECOIL_TXT) { while (ANTIRECOIL[i] != -1) { i++; } }
    else if (f_array_idx == PROFILE_TXT) { while (PROFILE[i] != -1) { i++; } }
    else if (f_array_idx == RAPIDFIRE_TXT) { while (RAPIDFIRE[i] != -1) { i++; } }
    else if (f_array_idx == SENSITIVITY_TXT) { while (SENSITIVITY[i] != -1) { i++; } }
    else if (f_array_idx == SHOT_MOD_TXT) { while (SHOT_MOD[i] != -1) { i++; } }
    else if (f_array_idx == SHOT_ACTIVATOR_TXT) { while (SHOT_ACTIVATOR[i] != -1) { i++; } }
    else if (f_array_idx == SWAP_TXT) { while (SWAP[i] != -1) { i++; } }
    else if (f_array_idx == PS_BTN_TXT) { while (PS_BTN[i] != -1) { i++; } }
    else if (f_array_idx == XB_BTN_TXT) { while (XB_BTN[i] != -1) { i++; } }
    return i - 1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function get_string(f_array_idx, f_idx) { 

	if(f_array_idx == MODNAME_TXT)
		return MODNAME[f_idx];
		
	if(f_array_idx == VALNAME_TXT)
		return VALNAME[f_idx];
			
	if(f_array_idx == INFO_MENU_PS_TXT)
		return INFO_MENU_PS[f_idx];
		
	if(f_array_idx == INFO_EDIT_PS_TXT)
		return INFO_EDIT_PS[f_idx];
			
	if(f_array_idx == INFO_MENU_XB_TXT)
		return INFO_MENU_XB[f_idx];
		
	if(f_array_idx == INFO_EDIT_XB_TXT)
		return INFO_EDIT_XB[f_idx];
		
	if(f_array_idx == SHAPES_TXT)
		return SHAPES[f_idx];
		
	if(f_array_idx == ANTIRECOIL_TXT)
		return ANTIRECOIL[f_idx];
		
	if(f_array_idx == PROFILE_TXT)
		return PROFILE[f_idx];
		
	if(f_array_idx == RAPIDFIRE_TXT)
		return RAPIDFIRE[f_idx];
		
	if(f_array_idx == SENSITIVITY_TXT)
		return SENSITIVITY[f_idx];
		
	if(f_array_idx == SHOT_MOD_TXT)
		return SHOT_MOD[f_idx];
		
	if(f_array_idx == SHOT_ACTIVATOR_TXT)
		return SHOT_ACTIVATOR[f_idx];
		
	if(f_array_idx == SWAP_TXT)
		return SWAP[f_idx];
		
	if(f_array_idx == PS_BTN_TXT)
		return PS_BTN[f_idx];
		
	if(f_array_idx == XB_BTN_TXT)
		return XB_BTN[f_idx];
		
	return -1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int stringLength;
function get_string_length(offset) { // by Swizzy

    stringLength = 0;
    while (duint8(offset++)) { stringLength++; }
    return stringLength + 1;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int sens_x;
int sens_y;
int sens_xcnt,sens_ycnt;

function set_sens () { // Dynamic Sens by Batts

    if(abs(get_lval(PS4_RX)) >= dynasens_limit) 
    {
	    sens_xcnt += 1;
	    
		if(sens_xcnt >= dynasens_increase_rate && sens_x < dynasens_max_sens) 
		{ 
		    sens_x += 1; 
		    sens_xcnt = 0; 
		} 
			else if(sens_x >= dynasens_max_sens) 
				sens_xcnt = 0;  
	}
	
    else if(abs(get_val(PS4_RX)) < dynasens_restart) 
    {
	    sens_xcnt = 0; 
	    sens_x = dynasens_initial_sens;
	} 
	
    if(abs(get_val(PS4_RY)) >= dynasens_limit) 
    {
	    sens_ycnt += 1;
		if(sens_ycnt >= dynasens_increase_rate && sens_y < dynasens_max_sens) 
		{ 
		    sens_y += 1; 
		    sens_ycnt = 1; 
		} 
			else if(sens_y >= dynasens_max_sens) 
				sens_ycnt = 0; 
	}
	
    else if(abs(get_val(PS4_RY)) < dynasens_restart) 
    {
	    sens_y = dynasens_initial_sens; 
	    sens_ycnt = 0;
	}
	
	sensitivity(PS4_RX,NOT_USE,sens_x);
    sensitivity(PS4_RY,NOT_USE,sens_y);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 
                                          
int i_cnt;    

function p_complete() { 

    i_cnt++;
    if(i_cnt > final_antirecoil_time / 10) 
    {
        i_cnt = final_antirecoil_time / 10;
        return 1;
    }    
    return 0;
}  

int i_num;
int i_pnt;
int ar_y;	
int i_val;

function p_val() { 

    i_num++;
    if(i_num == i_pnt) 
    {
        i_num = 0;
        ar_y += i_val;
    }
    return ar_y;
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int SmartSens_side;
int SmartSens;
	
function SmartSens(f_val, f_axis) { 

	if(f_val < 0)
		SmartSens_side = -1; 
	else 
		SmartSens_side = 1; 

	if(SmartSens_side == -1) 
	{
	    if(get_ival(f_axis) > 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 - f_val)) / 100); 
	    
	    else if(get_ival(f_axis) <= 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 + f_val)) / 100);
	}
	
	if(SmartSens_side == 1) 
	{
	    if(get_ival(f_axis) < 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 + f_val)) / 100); 
	    	
	    else if(get_ival(f_axis) >= 0) 
	    	SmartSens = ((get_ival(f_axis) * (100 - f_val)) / 100);
	}
	
	if(SmartSens_side == -1 && get_ival(f_axis) >= f_val + SmartSens || SmartSens_side == 1 && get_ival(f_axis) <= f_val + SmartSens)
	    return clamp(f_val + SmartSens, -100, 100);
	    
	return 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function antirecoil() {

	if(!toggle_aimassist[profile_idx])
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY), -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX), -100, 100));
	}
	else if(toggle_aimassist[profile_idx] > 1)
	{
		set_val(PS4_RY, clamp(SmartSens(ar_y, PS4_RY) + sin_angle, -100, 100));   
		set_val(PS4_RX, clamp(SmartSens(final_antirecoil_horizontal, PS4_RX) + cos_angle, -100, 100));
	}
	else if(toggle_aimassist[profile_idx] == 1)
	{
		recoilAssist = ar_y;
		combo_run(STICKY);
	}
}
// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int c,c_val;

function number_to_string(f_val,f_digits) {

    i = 1;  c_val = 10000;
    
	if(f_val < 0) //--neg numbers
	{          
         putc_oled(i,45);    //--add leading "-"
         i += 1;
         f_val = abs(f_val);
	} 
	
	for(c = 5; c >= 1; c--) 
	{
	    if(f_digits >= c) 
	    {
            putc_oled(i,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;
            i +=  1; 
            /*if(c == 4) 
            {
                putc_oled(i,44);   //--add ","
                i += 1;
            }*/
        }
        c_val /= 10;
    }
    if(display_title)
    	puts_oled(120, 54, OLED_FONT_SMALL, i - 1, OLED_WHITE); // display current # slot
    else
    	puts_oled(center_x(i - 1,OLED_FONT_MEDIUM_WIDTH),28,OLED_FONT_MEDIUM,i - 1,OLED_WHITE); // adjustable value centered in X - medium size
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_base_menu() {
	rect_oled(0, 0, 128, 49, OLED_BLACK, OLED_WHITE); // white contour 
	line_oled(1, 16, 126, 16, 1, OLED_WHITE); // draw line 1
	
// Filled rectangle white (emplacement for the chars line 1)	
	rect_oled(2, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 1)
	rect_oled(115, 2, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 1)
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_modMenu() {
// Clears text emplacement line 2 and 3 (value zone while in ModEdit)
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Separate ex value zone
	line_oled(1, 32, 126, 32, 1, OLED_WHITE); // line 2 
	
// Filled rectangle white (emplacement for the chars line 2, 3)
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 34, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 3, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_modEdit() {
// Clears line 2 and 3
	rect_oled(1, 17, 126, 31, OLED_WHITE, OLED_BLACK);
	
// Filled rectangle white 
	// Emplacement for the chars line 2, 3)	
	rect_oled(2, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 2)
	rect_oled(115, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 2)
	rect_oled(2, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE , OLED_WHITE); // rectangle left (line 3)
	rect_oled(115, 33, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 4, OLED_WHITE, OLED_WHITE); // rectangle right (line 3)
	// Emplacement for + / -
	rect_oled(14, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE , OLED_WHITE); // rectangle left (line 2 + 3)
	rect_oled(102, 18, OLED_FONT_MEDIUM_WIDTH + 1, OLED_FONT_MEDIUM_HEIGHT + 11, OLED_WHITE, OLED_WHITE); // rectangle right (line 2 + 3)

// Display - / +
	line_oled(16, 31, 23, 31, 2, OLED_BLACK); // left -
	putc_oled(1, 43); // +
	puts_oled(103, 24, OLED_FONT_MEDIUM, 1, OLED_BLACK); // right + 	    

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

define UP = 131; define DOWN = 132; define LEFT = 133; define RIGHT = 134; define TRIANGLE = 130; define Y = 89; define CROSS = 127; define A = 65;
define LEFT_X = 4; define RIGHT_X = 117;
define LINE_1_Y = 4; define LINE_2_Y = 20;  define LINE_3_Y = 36; define LINE_4_Y = 53;  
int btn_left;
int btn_right;

function draw_chars_line1() {
// Define button
	if(ModMenu)
	{		
		if(get_controller() == PIO_PS4)
		{
			btn_left = TRIANGLE;
			btn_right = TRIANGLE;
		}
		else
		{
			btn_left = Y;
			btn_right = Y;
		}
	}
	if(ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}

// Clears/fill rectangle
	rect_oled(3, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 1)
	rect_oled(116, 3, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 1)
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_1_Y, OLED_FONT_SMALL, 1, col_char_right); 

}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_chars_line2() {
// Define button
	if (ModMenu || ModEdit)
	{
		btn_left = LEFT;
		btn_right = RIGHT;
	}
	if(ModEdit)
	{
	// Clears/fill rectangle
		rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 2)
		rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
	}
	else
	{
	// Clears/fill rectangle
		rect_oled(3, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); //  rectangle left (line 2)
		rect_oled(116, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); //  rectangle right (line 2)
	}
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_left); 	
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_2_Y, OLED_FONT_SMALL, 1, col_char_right); 
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_chars_line3() { 
// Define button
	if (ModMenu)
	{
		btn_left = DOWN;
		btn_right = UP;
	}
	if(ModEdit)
	{
		btn_left = DOWN;
		btn_right = UP;
		
	// Clears/fill rectangle
		rect_oled(3, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE , col_rec_left); // rectangle left (line 3)
		rect_oled(116, 34, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 2, OLED_WHITE, col_rec_right); // rectangle right (line 3)	
	}
	else
	{
	// Clears/fill rectangle
		rect_oled(3, 35, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE , col_rec_left); // rectangle left (line 3)
		rect_oled(116, 35, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT + 1, OLED_WHITE, col_rec_right); // rectangle right (line 3)
	}
// Display chars	
	putc_oled(1,btn_left); 
	puts_oled(LEFT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_left); 
	putc_oled(1,btn_right); 
	puts_oled(RIGHT_X, LINE_3_Y, OLED_FONT_SMALL, 1, col_char_right);  
	
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function draw_hold_to_edit() { 
// Clears/fill the inside of the "hold button" rectangle
	rect_oled(28, 19, OLED_FONT_SMALL_WIDTH + 1 , OLED_FONT_SMALL_HEIGHT , OLED_WHITE , col_rec_left); 
	rect_oled(91, 19, OLED_FONT_SMALL_WIDTH + 2, OLED_FONT_SMALL_HEIGHT  , OLED_WHITE, col_rec_right); 
// Display chars	
	if(get_controller() == PIO_PS4)
	{	
		putc_oled(1, CROSS);
		puts_oled(92, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, CROSS);
		puts_oled(28, LINE_2_Y - 1, OLED_FONT_SMALL, 1, col_char_right);
	}
	else
	{
		putc_oled(1, A);
		puts_oled(92, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_left);
		putc_oled(1, A);
		puts_oled(29, LINE_2_Y , OLED_FONT_SMALL, 1, col_char_right);
	}
// Contour for chars X / A (must be after display chars)
	rect_oled(27, 18, OLED_FONT_SMALL_WIDTH + 3 , OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK , OLED_WHITE); // small rectangle left (line 2)
	rect_oled(90, 18, OLED_FONT_SMALL_WIDTH + 4, OLED_FONT_SMALL_HEIGHT + 2 , OLED_BLACK, OLED_WHITE); // small rectangle right (line 2)
}	

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int col_char_left; 
int col_char_right;
int col_rec_left = 1;
int col_rec_right = 1;

function button_animation() {
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_TRIANGLE))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModMenu)
			draw_chars_line1();
	}
	else if(event_release(PS4_TRIANGLE))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
			
		if(ModMenu)
			draw_chars_line1();
	}	
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	if(event_press(PS4_LEFT))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
	if(event_release(PS4_LEFT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_RIGHT))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;	
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
	if(event_release(PS4_RIGHT))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line2();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line2();
			else
				draw_chars_line1();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_UP))
	{
		col_char_left = 0;
		col_char_right = 1;
		col_rec_left = 1;
		col_rec_right = 0;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
	if(event_release(PS4_UP))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_DOWN))
	{
		col_char_left = 1;
		col_char_right = 0;
		col_rec_left = 0;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
	if(event_release(PS4_DOWN))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModMenu)
			draw_chars_line3();
			
		if(ModEdit)
		{
			if(get_val(PS4_CROSS))
				draw_chars_line3();
		}
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if(event_press(PS4_CROSS))
	{
		col_char_left = 1;
		col_char_right = 1;
		col_rec_left = 0;
		col_rec_right = 0;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
	if(event_release(PS4_CROSS))//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		col_char_left = 0;
		col_char_right = 0;
		col_rec_left = 1;
		col_rec_right = 1;
		
		if(ModEdit)	
			draw_hold_to_edit();
	}
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int SSMU1 = 1,SSMU2 = 8,SSMU3 = 15,SSMU4 = 22,SSMU5 = 29,SSMU6 = 36,SSMU7 = 43;

function cycle(f_val, f_lo, f_hi) {
	if(f_val > f_hi) return f_lo;
	if(f_val < f_lo) return f_hi;
	return f_val;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int X_1,Y_1,X_2,Y_2,X_3,Y_3, X_4,Y_4,X_5,Y_5,X_6,Y_6,X_7,Y_7,X_8,Y_8,RN1,RN2,RN3,RN4,RN5,RN6,RN7,RN8;

function find_digits(f_num) {

    f_num = abs(f_num);
    if(f_num / 10000 > 0) return 5;
    if(f_num /  1000 > 0) return 4;
    if(f_num /   100 > 0) return 3;
    if(f_num /    10 > 0) return 2;
                          return 1;
}     

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_x(f_chars,f_font) {

    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function center_y(f_size) {

    return (OLED_HEIGHT  / 2) - (f_size / 2);
} 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

int RT,MSC,SD1,DGT,DGR,TP1,TP2;

function press_hold(f_btn) { 

	return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function led(f_color) {

   for(i = 0; i <= 3; i++) 
   {
     set_led(i,duint8((f_color * 4) + i));
   }
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

function save() {
	ModMenu = FALSE;
	ModEdit = FALSE;
	cls_oled(OLED_BLACK);
	printf(center_x(sizeof(SAVE) - 1,OLED_FONT_LARGE_WIDTH),center_y(OLED_FONT_LARGE_HEIGHT),OLED_FONT_LARGE,OLED_WHITE,SAVE[0]); 
	combo_run(SAVE);
	
// Toggles
	pmemValue = set_15var(pmemValue, toggle_burstfire[0] , 0);		pmemValue = set_15var(pmemValue, toggle_burstfire[1] ,  1);		pmemValue = set_15var(pmemValue, toggle_burstfire[2] ,  2);
	pmemValue = set_15var(pmemValue, hairTrigger_on      , 3);	 	pmemValue = set_15var(pmemValue, autorun_on          ,  4);	 	pmemValue = set_15var(pmemValue, autoADS_on          ,  5);
	pmemValue = set_15var(pmemValue, autoFIRE_on         , 6); 		pmemValue = set_15var(pmemValue, swap_on             ,  7);		pmemValue = set_15var(pmemValue, rumble_on           ,  8);
	pmemValue = set_15var(pmemValue, toggle_aimabuse[0]  , 9);		pmemValue = set_15var(pmemValue, toggle_aimabuse[1]  , 10);		pmemValue = set_15var(pmemValue, toggle_aimabuse[2]  , 11);
	set_pvar(SPVAR_1,pmemValue);
	
	pmemValue = set_4var(toggle_antirecoil[0], toggle_antirecoil[1], toggle_antirecoil[2], NOT_USE);
	set_pvar(SPVAR_2,pmemValue);
	
	pmemValue = set_4var(toggle_rapidfire[0], toggle_rapidfire[1], toggle_rapidfire[2], NOT_USE);
	set_pvar(SPVAR_3,pmemValue);
	
	pmemValue = set_4var(toggle_aimassist[0], toggle_aimassist[1], toggle_aimassist[2], NOT_USE);
	set_pvar(SPVAR_4,pmemValue);
	
	pmemValue = set_4var(toggle_shotMod[0], toggle_shotMod[1], toggle_shotMod[2], NOT_USE);
	set_pvar(SPVAR_5,pmemValue);
	
	pmemValue = set_4var(toggle_shotActivator[0], toggle_shotActivator[1], toggle_shotActivator[2], NOT_USE);
	set_pvar(SPVAR_6,pmemValue);
	
	pmemValue = set_4var(sensitivity_on, jump_btn, crouch_btn, NOT_USE);
	set_pvar(SPVAR_7,pmemValue);
	
// Antirecoil vertical values
	pmemValue = set_2var(antirecoil_start[0], antirecoil_end[0]);
	set_pvar(SPVAR_8,pmemValue);
	pmemValue = set_2var(antirecoil_start[1], antirecoil_end[1]);
	set_pvar(SPVAR_9,pmemValue);
	pmemValue = set_2var(antirecoil_start[2], antirecoil_end[2]);
	set_pvar(SPVAR_10,pmemValue);
	set_pvar(SPVAR_11,antirecoil_time[0]);
	set_pvar(SPVAR_12,antirecoil_time[1]);
	set_pvar(SPVAR_13,antirecoil_time[2]);

// Antirecoil horizontal & rumble recoil values
	pmemValue = set_2var(antirecoil_horizontal[0], rumble_power[0]);
	set_pvar(SPVAR_14,pmemValue);
	pmemValue = set_2var(antirecoil_horizontal[1], rumble_power[1]);
	set_pvar(SPVAR_15,pmemValue);
	pmemValue = set_2var(antirecoil_horizontal[2], rumble_power[2]);
	set_pvar(SPVAR_16,pmemValue);
	
// Rate of fire values
	set_pvar(SPVAR_17,rate_of_fire[0]);
	set_pvar(SPVAR_18,rate_of_fire[1]);
	set_pvar(SPVAR_19,rate_of_fire[2]);
	
// BurstFire values
	set_pvar(SPVAR_20, burstfire_hold   );
	set_pvar(SPVAR_21, burstfire_release);

// AIM Assist values
	pmemValue = set_2var(aimassist_radius, aimassist_angle);
	set_pvar(SPVAR_22,pmemValue);
	
// StrafeShot values
	set_pvar(SPVAR_23,strafe_time);

// Custom Sens values
	set_pvar(SPVAR_24,genSens);
	set_pvar(SPVAR_25,adsSens);
	set_pvar(SPVAR_26,hipSens);
	set_pvar(SPVAR_27,adsfireSens);

// Dynamic Sens	values
	set_pvar(SPVAR_28,dynasens_initial_sens);
	pmemValue = set_2var(dynasens_limit, dynasens_restart);
	set_pvar(SPVAR_29,pmemValue);
	set_pvar(SPVAR_30,dynasens_max_sens);
	set_pvar(SPVAR_31,dynasens_increase_rate);
	
// AIM Abuse values
	set_pvar(SPVAR_32,aimabuse_hold);
	set_pvar(SPVAR_33,aimabuse_release);

}

int mask;
int ret;
int pmemValue;

function set_15var(pvar, ret, position) { // values range = 0 ~ 1
	for(i = position; i < (1 + position); i++)
	{
		pvar = pvar & (~(1 << i));
	}
	pvar = pvar | (ret << position);
	
	return pvar;
}
function get_15var(pvar, position){
	mask = 0;
	ret = 0;
	for(i = 0; i < 1 ; i++)
	{
		mask = mask | (1 << i);
	}
	mask = mask << position
	ret = (pvar & mask) >> position
return ret;
}
//----

function set_4var(_1, _2, _3, _4) { // values range = 0 ~ 15
	return 0xff00 & ((0xf0 & (_1 << 4) | _2) << 8) | (0xf0 & (_3 << 4) | _4); 
}
function get_4var(f_PMemory, f_dec_pos) { 
	return  (f_PMemory >> (4 * f_dec_pos)) & 0x0F; 
}
//----

function set_2var(var1, var2) { // values range = -127 ~ 127
	ret = 0;
	
	if(var1 < 0)
   		var1 = abs(var1) | 0x80;

	ret = (abs(var2) << 8)|var1;
	
	if(var2 < 0)
		ret *= -1;
	
	return ret;
}
function get_2var(pvar, var) {
	ret = 0;
	
	if(var == 0)
	{	 
		ret = 0x80 & abs(pvar) ;
		ret = ret >> 7;
		ret = ((-2) * ret) + 1;
		ret = (abs(pvar) & 0x7F) * ret;
	}
	else
	{
		ret = pvar >> 8;

	    if(pvar < 0)
			ret += 1;
	}
	
	return ret;
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function name(){
	cls_oled(0);
	combo_run(RACE);
	combo_run(RN);
if (Y_1 > 64)  Y_1 =   0;
if (Y_2 > 64)  Y_2 =   0;
if (Y_3 > 64)  Y_3 =   0;
if (Y_4 > 64)  Y_4 =   0;
if (Y_5 > 64)  Y_5 =   0;
if (Y_6 > 64)  Y_6 =   0;
if (Y_7 > 64)  Y_7 =   0;
if (Y_8 > 64)  Y_8 =   0;
if (SD1 > 105) SD1 = -50;
if (TP1 > 45)  TP1 =   0;
if (TP2 < 0)   TP2 =  55;
	putc_oled(1,RN1);
	puts_oled(X_1,Y_1,0,1,1);
	putc_oled(1,RN2);
	puts_oled(X_2,Y_2,0,1,1);
	putc_oled(1,RN3);
	puts_oled(X_3,Y_3,0,1,1);
	putc_oled(1,RN4);
	puts_oled(X_4,Y_4,0,1,1);
	putc_oled(1,RN5);
	puts_oled(X_5,Y_5,0,1,1);
	putc_oled(1,RN6);
	puts_oled(X_6,Y_6,0,1,1);
	putc_oled(1,RN7);
	puts_oled(X_7,Y_7,0,1,1);
	putc_oled(1,RN8);
	puts_oled(X_8,Y_8,0,1,1);
	putc_oled(1,SSA1);
	puts_oled(SSMU1 + SD1,TP1 + 2,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU2 + SD1,TP2 + 4,0,1,1);
	putc_oled(1,SSA2);
	puts_oled(SSMU3 + SD1,TP1 + 6,0,1,1);
	putc_oled(1,SSA3);
	puts_oled(SSMU4 + SD1,TP2 + 8,0,1,1);
	putc_oled(1,SSA4);
	puts_oled(SSMU5 + SD1,TP1 + 10,0,1,1);
	putc_oled(1,SSA5);
	puts_oled(SSMU6 + SD1,TP2 + 12,0,1,1);
	putc_oled(1,SSA6);
	puts_oled(SSMU7 + SD1,TP1 + 14,0,1,1);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

function block_btn() {

set_val(PS4_UP     , 0 ); 	set_val(PS4_DOWN  , 0 ); 	set_val(PS4_LEFT  , 0 );	set_val(PS4_RIGHT   , 0);
set_val(PS4_CROSS  , 0 ); 	set_val(PS4_CIRCLE, 0 ); 	set_val(PS4_SQUARE, 0 ); 	set_val(PS4_TRIANGLE, 0);
set_val(PS4_L1     , 0 ); 	set_val(PS4_R1    , 0 ); 	set_val(PS4_L3    , 0 ); 	set_val(PS4_R3      , 0);
set_val(PS4_OPTIONS, 0 ); 	set_val(PS4_SHARE , 0 );	set_val(PS4_TOUCH , 0 );	set_val(PS4_PS      , 0);
set_val(XB1_PL1    , 0 ); 	set_val(XB1_PL2   , 0 );	set_val(XB1_PR1   , 0 );	set_val(XB1_PR2     , 0);
/*set_val(PS4_LX, 0); 		set_val(PS4_LY, 0); 		set_val(PS4_RX, 0); 		set_val(PS4_RY, 0);
set_val(PS4_L2, 0); 		set_val(PS4_R2, 0);*/
}  

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 

const string TITLE1 = "SHOOTER"
const string TITLE2 = "MASTER"

function draw_logo() {
	printf(center_x(sizeof(TITLE1) - 1,OLED_FONT_LARGE_WIDTH),1,OLED_FONT_LARGE,OLED_WHITE,TITLE1[0]);
	printf(center_x(sizeof(TITLE2) - 1,OLED_FONT_LARGE_WIDTH),22,OLED_FONT_LARGE,OLED_WHITE,TITLE2[0]);
}

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int time;
int RX, RY;
int angle, cos_angle, sin_angle;
int SpiralPosition1,SpiralPosition2,InnerSpiral,OuterSpiral;
int actual_Magnitude, max_Magnitude, Position;

const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,    
80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7, 
6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,  
-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95, 
-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,   
-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61, 
-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,
9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,
82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100}; 

// 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜 〜

int timer;

function GetShapesV1(f_var) {     
   
    if(!SpiralPosition1)                                
	{
		InnerSpiral -= 1;
		if(InnerSpiral < 1)
			SpiralPosition1 = TRUE;
	}
	else
	{
	    InnerSpiral += 1;
		if(InnerSpiral > f_var)
			SpiralPosition1 = FALSE;
	}
	if(!SpiralPosition2)
	{
		OuterSpiral -= 1;
		if(OuterSpiral < 1)
			SpiralPosition2 = TRUE;
	}
	else
	{
		OuterSpiral += 1;
		if(OuterSpiral >  f_var)
			SpiralPosition2 = FALSE;
	} 
	if(toggle_aimassist[profile_idx] == 2)                    
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 3)        
	{ 
        RY = (sin_angle * f_var) /100;
        RX = (cos_angle * (f_var / 2)) /100; 
	}
	if(toggle_aimassist[profile_idx] == 4)                     
	{ 
        RY = (sin_angle * (f_var / 2)) /100;
        RX = (cos_angle * f_var) /100;  
	} 
	if(toggle_aimassist[profile_idx] == 5)                  
	{
        RY = (sin_angle * InnerSpiral) /100;
        RX = (cos_angle * OuterSpiral) /100;  
	}
    if(toggle_aimassist[profile_idx] == 6)
	{
		RX = (cos_angle * Position) /100;
		RY = (sin_angle * Position) /100;
	
		if(Position == 0)
		    RX = (cos_angle * f_var) /100;
		    
		if(Position == 1)
			RY = (sin_angle * f_var) /100;
			
		if(Position == 2) 
			RX = (cos_angle * f_var) /100 * -1;
			
		if(Position == 3)
			RY = (sin_angle * f_var) /100 * -1;
			
		timer++;
		if(timer >= aimassist_angle)
		{
			Position++;
			timer = 0;
		}
				
		if(Position == 4)
			Position = 0;
    }
    
	cos_angle = RX;
	sin_angle = RY;
}